<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《阿里巴巴Java开发手册》详解</title>
      <link href="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/"/>
      <url>/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="《阿里巴巴Java开发手册》详解"><a href="#《阿里巴巴Java开发手册》详解" class="headerlink" title="《阿里巴巴Java开发手册》详解"></a>《阿里巴巴Java开发手册》详解</h1><h2 id="1-编码"><a href="#1-编码" class="headerlink" title="1-编码"></a>1-编码</h2><h3 id="1-1-Integer缓存问题分析"><a href="#1-1-Integer缓存问题分析" class="headerlink" title="1.1-Integer缓存问题分析"></a>1.1-Integer缓存问题分析</h3><h4 id="1-1-1-前言"><a href="#1-1-1-前言" class="headerlink" title="1.1.1-前言"></a>1.1.1-前言</h4><p>《手册》第 7 页有一段关于包装对象之间值的比较问题的规约 <a href="https://www.imooc.com/read/55/article/1139#fn1" target="_blank" rel="noopener">1</a>：</p><blockquote><p>【强制】所有整型包装类对象之间值的比较，全部使用 equals 方法比较。<br>说明：对于 Integer var = ? 在 - 128 至 127 范围内的赋值，Integer 对象是在 IntegerCache.cache 产 生，会复用已有对象，这个区间内的 Integer 值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。</p></blockquote><p>这条建议非常值得大家关注， 而且该问题在 Java 面试中十分常见。</p><p>我们还需要思考以下几个问题：</p><ul><li>如果不看《手册》，我们如何知道 <code>Integer var = ?</code> 会缓存 -128 到 127 之间的赋值？</li><li>为什么会缓存这个范围的赋值？</li><li>我们如何学习和分析类似的问题？</li></ul><h4 id="1-1-2-Integer-缓存问题分析"><a href="#1-1-2-Integer-缓存问题分析" class="headerlink" title="1.1.2-Integer 缓存问题分析"></a>1.1.2-Integer 缓存问题分析</h4><p>我们先看下面的示例代码，并思考该段代码的输出结果：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IntTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Integer a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">,</span> d <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过运行代码可以得到答案，程序输出的结果分别为： <code>true</code> , <code>false</code>。</p><p><strong>那么为什么答案是这样？</strong></p><p>结合《手册》的描述很多人可能会颇有自信地回答：<strong>因为缓存了 -128 到 127 之间的数值</strong>，就没有然后了。</p><p>那么为什么会缓存这一段区间的数值？缓存的区间可以修改吗？其它的包装类型有没有类似缓存？</p><p><strong>what? 咋还有这么多问题？这谁知道啊</strong>！</p><p>莫急，且看下面的分析。</p><h5 id="1-源码分析法"><a href="#1-源码分析法" class="headerlink" title="1. 源码分析法"></a>1. 源码分析法</h5><p>首先我们可以通过源码对该问题进行分析。</p><p>我们知道，<code>Integer var = ?</code> 形式声明变量，会通过 <code>java.lang.Integer#valueOf(int)</code> 来构造 <code>Integer</code> 对象。</p><p>很多人可能会说：“你咋能知道这个呢”？</p><p>如果不信大家可以打断点，运行程序后会调到这里，总该信了吧？（后面还会再作解释）。</p><p>我们先看该函数源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Returns an {@code Integer} instance representing the specified * {@code int} value.  If a new {@code Integer} instance is not * required, this method should generally be used in preference to * the constructor {@link #Integer(int)}, as this method is likely * to yield significantly better space and time performance by * caching frequently requested values. * * This method will always cache values in the range -128 to 127, * inclusive, and may cache other values outside of this range. * * @param  i an {@code int} value. * @return an {@code Integer} instance representing {@code i}. * @since  1.5 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>        <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过源码可以看出，如果用 <code>Ineger.valueOf(int)</code> 来创建整数对象，参数大于等于整数缓存的最小值（ <code>IntegerCache.low</code> ）并小于等于整数缓存的最大值（ <code>IntegerCache.high</code>）, 会直接从缓存数组 (<code>java.lang.Integer.IntegerCache#cache</code>) 中提取整数对象；否则会 <code>new</code> 一个整数对象。</p><p><strong>那么这里的缓存最大和最小值分别是多少呢？</strong></p><p>从上述注释中我们可以看出，最小值是 -128, 最大值是 127。</p><p><strong>那么为什么会缓存这一段区间的整数对象呢？</strong></p><p>通过注释我们可以得知：<strong>如果不要求必须新建一个整型对象，缓存最常用的值（提前构造缓存范围内的整型对象），会更省空间，速度也更快。</strong></p><p>这给我们一个非常重要的启发：</p><blockquote><p>如果想减少内存占用，提高程序运行的效率，可以将常用的对象提前缓存起来，需要时直接从缓存中提取。</p></blockquote><p>那么我们再思考下一个问题： <strong><code>Integer</code> 缓存的区间可以修改吗？</strong></p><p>通过上述源码和注释我们还无法回答这个问题，接下来，我们继续看 <code>java.lang.Integer.IntegerCache</code> 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Cache to support the object identity semantics of autoboxing for values between * -128 and 127 (inclusive) as required by JLS. * * The cache is initialized on first usage.  The size of the cache * may be controlled by the {@code -XX:AutoBoxCacheMax=&lt;size>} option. * During VM initialization, java.lang.Integer.IntegerCache.high property * may be set and saved in the private system properties in the * sun.misc.VM class. */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// high value may be configured by property</span>            <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>            String integerCacheHighPropValue <span class="token operator">=</span>                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>VM<span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 省略其它代码</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 省略其它代码</span><span class="token punctuation">}</span></code></pre><p>通过 <code>IntegerCache</code> 代码和注释我们可以看到，最小值是固定值 -128， 最大值并不是固定值，缓存的最大值是可以通过虚拟机参数 <code>-XX:AutoBoxCacheMax=}</code> 或 <code>-Djava.lang.Integer.IntegerCache.high=</code> 来设置的，未指定则为 127。</p><p>因此可以通过修改这两个参数其中之一，让缓存的最大值大于等于 150。</p><p>如果作出这种修改，示例的输出结果便会是： <code>true</code>,<code>true</code>。</p><p><strong>学到这里是不是发现，对此问题的理解和最初的想法有些不同呢？</strong></p><p>这段注释也解答了为什么要缓存这个范围的数据：</p><blockquote><p><strong>是为了自动装箱时可以复用这些对象</strong> ，这也是 JLS<a href="https://www.imooc.com/read/55/article/1139#fn2" target="_blank" rel="noopener">2</a> 的要求。</p></blockquote><p>我们可以参考 JLS 的 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7" target="_blank" rel="noopener">Boxing Conversion 部分</a>的相关描述。</p><blockquote><p>If the value<code>p</code>being boxed is an integer literal of type <code>int</code>between <code>-128</code>and <code>127</code>inclusive (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.1" target="_blank" rel="noopener">§3.10.1</a>), or the boolean literal <code>true</code>or<code>false</code>(<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.3" target="_blank" rel="noopener">§3.10.3</a>), or a character literal between <code>&#39;\u0000&#39;</code>and <code>&#39;\u007f&#39;</code>inclusive (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.4" target="_blank" rel="noopener">§3.10.4</a>), then let <code>a</code>and <code>b</code>be the results of any two boxing conversions of <code>p</code>. It is always the case that <code>a</code>==<code>b</code>.</p><p>在 -128 到 127 （含）之间的 int 类型的值，或者 boolean 类型的 true 或 false， 以及范围在’\u0000’和’\u007f’ （含）之间的 char 类型的数值 p， 自动包装成 a 和 b 两个对象时， 可以使用 a == b 判断 a 和 b 的值是否相等。</p></blockquote><h5 id="2-反汇编法"><a href="#2-反汇编法" class="headerlink" title="2. 反汇编法"></a>2. 反汇编法</h5><p>那么究竟 <code>Integer var = ?</code> 形式声明变量，是不是通过 <code>java.lang.Integer#valueOf(int)</code> 来构造 <code>Integer</code> 对象呢？ 总不能都是猜测 N 个可能的函数，然后断点调试吧？</p><p><strong>如果遇到其它类似的问题，没人告诉我底层调用了哪个方法，该怎么办？</strong> 囧…</p><p>这类问题有个杀手锏，可以通过对编译后的 class 文件进行反汇编来查看。</p><p>首先编译源代码：<code>javac IntTest.java</code></p><p>然后需要对代码进行反汇编，执行：<code>javap -c IntTest</code></p><blockquote><p>如果想了解 <code>javap</code> 的用法，直接输入 <code>javap -help</code> 查看用法提示（很多命令行工具都支持 <code>-help</code> 或 <code>--help</code> 给出用法提示）。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/javap.jpeg" alt="javap"></p></blockquote><p>反编译后，我们得到以下代码：</p><pre class=" language-java"><code class="language-java">Compiled from <span class="token string">"IntTest.java"</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">com<span class="token punctuation">.</span>chujianyun<span class="token punctuation">.</span>common<span class="token punctuation">.</span>int_test<span class="token punctuation">.</span>IntTest</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> com<span class="token punctuation">.</span>chujianyun<span class="token punctuation">.</span>common<span class="token punctuation">.</span>int_test<span class="token punctuation">.</span><span class="token function">IntTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> aload_0       <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Object."&lt;init>":()V</span>       <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> bipush        <span class="token number">100</span>       <span class="token number">2</span><span class="token operator">:</span> invokestatic  #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span>       <span class="token number">5</span><span class="token operator">:</span> astore_1       <span class="token number">6</span><span class="token operator">:</span> bipush        <span class="token number">100</span>       <span class="token number">8</span><span class="token operator">:</span> invokestatic  #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span>      <span class="token number">11</span><span class="token operator">:</span> astore_2      <span class="token number">12</span><span class="token operator">:</span> sipush        <span class="token number">150</span>      <span class="token number">15</span><span class="token operator">:</span> invokestatic  #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span>      <span class="token number">18</span><span class="token operator">:</span> astore_3      <span class="token number">19</span><span class="token operator">:</span> sipush        <span class="token number">150</span>      <span class="token number">22</span><span class="token operator">:</span> invokestatic  #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span>      <span class="token number">25</span><span class="token operator">:</span> astore        <span class="token number">4</span>      <span class="token number">27</span><span class="token operator">:</span> getstatic     #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>      <span class="token number">30</span><span class="token operator">:</span> aload_1      <span class="token number">31</span><span class="token operator">:</span> aload_2      <span class="token number">32</span><span class="token operator">:</span> if_acmpne     <span class="token number">39</span>      <span class="token number">35</span><span class="token operator">:</span> iconst_1      <span class="token number">36</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">40</span>      <span class="token number">39</span><span class="token operator">:</span> iconst_0      <span class="token number">40</span><span class="token operator">:</span> invokevirtual #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Z)V</span>      <span class="token number">43</span><span class="token operator">:</span> getstatic     #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>      <span class="token number">46</span><span class="token operator">:</span> aload_3      <span class="token number">47</span><span class="token operator">:</span> aload         <span class="token number">4</span>      <span class="token number">49</span><span class="token operator">:</span> if_acmpne     <span class="token number">56</span>      <span class="token number">52</span><span class="token operator">:</span> iconst_1      <span class="token number">53</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">57</span>      <span class="token number">56</span><span class="token operator">:</span> iconst_0      <span class="token number">57</span><span class="token operator">:</span> invokevirtual #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Z)V</span>      <span class="token number">60</span><span class="token operator">:</span> <span class="token keyword">return</span><span class="token punctuation">}</span></code></pre><p>可以明确得 “看到” 这四个 ``Integer var = ? <code>形式声明的变量的确是通过</code> java.lang.Integer#valueOf(int) <code>来构造</code> Integer` 对象的。</p><p><strong>接下来对汇编后的代码进行详细分析，如果看不懂可略过</strong>：</p><p>根据<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">《Java Virtual Machine Specification : Java SE 8 Edition》</a><a href="https://www.imooc.com/read/55/article/1139#fn3" target="_blank" rel="noopener">3</a>，后缩写为 JVMS , 第 6 章 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">虚拟机指令集</a>的相关描述以及《深入理解 Java 虚拟机》<a href="https://www.imooc.com/read/55/article/1139#fn4" target="_blank" rel="noopener">4</a> 414-149 页的 附录 B “虚拟机字节码指令表”。 我们对上述指令进行解读：</p><p>偏移为 0 的指令为：<code>bipush 100</code> ，其含义是将单字节整型常量 100 推入操作数栈的栈顶；</p><p>偏移为 2 的指令为：<code>invokestatic #2 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</code> 表示调用一个 <code>static</code> 函数，即 <code>java.lang.Integer#valueOf(int)</code>；</p><p>偏移为 5 的指令为：<code>astore_1</code> ，其含义是从操作数栈中弹出对象引用，然后将其存到第 1 个局部变量 Slot 中；</p><p>偏移 6 到 25 的指令和上面类似；</p><p>偏移为 30 的指令为 <code>aload_1</code> ，其含义是从第 1 个局部变量 Slot 取出对象引用（即 a），并将其压入栈；</p><p>偏移为 31 的指令为 <code>aload_2</code> ，其含义是从第 2 个局部变量 Slot 取出对象引用（即 b），并将其压入栈；</p><p>偏移为 32 的指令为 <code>if_acmpn</code>，该指令为条件跳转指令，<code>if_</code> 后以 a 开头表示对象的引用比较。</p><p>由于该指令有以下特性：</p><blockquote><ul><li><code>if_acmpeq</code> 比较栈两个引用类型数值，相等则跳转</li><li><code>if_acmpne</code> 比较栈两个引用类型数值，不相等则跳转</li></ul></blockquote><p>由于 <code>Integer</code> 的缓存问题，所以 a 和 b 引用指向同一个地址，因此此条件不成立（成立则跳转到偏移为 39 的指令处），执行偏移为 35 的指令。</p><p>偏移为 35 的指令: <code>iconst_1</code>，其含义为将常量 1 压栈（ Java 虚拟机中 boolean 类型的运算类型为 int ，其中 true 用 1 表示，详见 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.1" target="_blank" rel="noopener">2.11.1 数据类型和 Java 虚拟机</a>。</p><p>然后执行偏移为 36 的 <code>goto</code> 指令，跳转到偏移为 40 的指令。</p><p>偏移为 40 的指令：<code>invokevirtual #4 // Method java/io/PrintStream.println:(Z)V</code>。</p><p>可知参数描述符为 <code>Z</code> ，返回值描述符为 <code>V</code>。</p><p>根据 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2" target="_blank" rel="noopener">4.3.2 字段描述符</a> ，可知 <code>FieldType</code> 的字符为 <code>Z</code> 表示 <code>boolean</code> 类型， 值为 <code>true</code> 或 <code>false</code>。<br>根据 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3" target="_blank" rel="noopener">4.3.3 字段描述符</a> ，可知返回值为 <code>void</code>。</p><p>因此可以知，最终调用了 <code>java.io.PrintStream#println(boolean)</code> 函数打印栈顶常量即 <code>true</code>。</p><p>然后比较执行偏移 43 到 57 之间的指令，比较 c 和 d， 打印 <code>false</code> 。</p><p>执行偏移为 60 的指令，即 <code>retrun</code> ，程序结束。</p><p>可能有些朋友会对反汇编的代码有些抵触和恐惧，这都是非常正常的现象。</p><p>我们分析和研究问题的时候，<strong>看懂核心逻辑即可</strong>，不要纠结于细节，而失去了重点。</p><p>一回生两回熟，随着遇到的例子越来越多，遇到类似的问题时，会喜欢上 <code>javap</code> 来分析和解决问题。</p><p>如果想深入学习 java 反汇编，强烈建议结合官方的 JVMS 或其中文版:《Java 虚拟机规范》这本书进行拓展学习。</p><p>如果大家不喜欢命令行的方式进行 Java 的反汇编，这里推荐一个简单易用的可视化工具：<a href="https://github.com/zxh0/classpy" target="_blank" rel="noopener">classpy</a> ，大家可以自行了解学习。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/classpy.jpeg" alt="classpy"></p><h4 id="1-1-3-Long-的缓存问题分析"><a href="#1-1-3-Long-的缓存问题分析" class="headerlink" title="1.1.3-Long 的缓存问题分析"></a>1.1.3-Long 的缓存问题分析</h4><p>我们学习的目的之一就是要学会举一反三。因此我们对 <code>Long</code> 也进行类似的研究，探究两者之间有何异同。</p><h5 id="1-源码分析"><a href="#1-源码分析" class="headerlink" title="1. 源码分析"></a>1. 源码分析</h5><p>类似的，我们接下来分析 <code>java.lang.Long#valueOf(long)</code> 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Returns a {@code Long} instance representing the specified * {@code long} value. * If a new {@code Long} instance is not required, this method * should generally be used in preference to the constructor * {@link #Long(long)}, as this method is likely to yield * significantly better space and time performance by caching * frequently requested values. * * Note that unlike the {@linkplain Integer#valueOf(int) * corresponding method} in the {@code Integer} class, this method * is &lt;em>not&lt;/em> required to cache values within a particular * range. * * @param  l a long value. * @return a {@code Long} instance representing {@code l}. * @since  1.5 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> Long <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">long</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> offset <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">>=</span> <span class="token operator">-</span><span class="token number">128</span> <span class="token operator">&amp;&amp;</span> l <span class="token operator">&lt;=</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// will cache</span>        <span class="token keyword">return</span> LongCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>l <span class="token operator">+</span> offset<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>发现该函数的写法和 <code>Ineger.valueOf(int)</code> 非常相似。</p><p>我们同样也看到， <code>Long</code> 也用到了缓存。 使用 <code>java.lang.Long#valueOf(long)</code> 构造 <code>Long</code> 对象时，值在 <strong>[-128, 127]</strong> 之间的 <code>Long</code> 对象直接从缓存对象数组中提取。</p><p>而且注释同样也提到了：<strong>缓存的目的是为了提高性能</strong>。</p><p>但是通过注释我们发现这么一段提示：</p><blockquote><p>Note that unlike the {@linkplain Integer#valueOf(int) corresponding method} in the {@code Integer} class, this method is <em>not</em> required to cache values within a particular range.</p><p>注意：和 <code>Ineger.valueOf(int)</code> 不同的是，此方法并没有被要求缓存特定范围的值。</p></blockquote><p>这也正是上面源码中缓存范围判断的注释为何用 <code>// will cache</code> 的原因（可以对比一下上面 <code>Integer</code> 的缓存的注释）。</p><p>因此我们可知，虽然此处采用了缓存，但应该不是 JLS 的要求。</p><p><strong>那么 <code>Long</code> 类型的缓存是如何构造的呢？</strong></p><p>我们查看缓存数组的构造：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LongCache</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">LongCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Long cache<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">127</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到，它是在静态代码块中填充缓存数组的。</p><h5 id="2-反编译"><a href="#2-反编译" class="headerlink" title="2. 反编译"></a>2. 反编译</h5><p>同样地我们也编写一个示例片段：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LongTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Long a <span class="token operator">=</span> <span class="token operator">-</span>128L<span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token operator">-</span>128L<span class="token punctuation">,</span> c <span class="token operator">=</span> 150L<span class="token punctuation">,</span> d <span class="token operator">=</span> 150L<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c <span class="token operator">==</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>编译源代码： <code>javac LongTest.java</code></p><p>对编译后的类文件进行反汇编: <code>javap -c LongTest</code></p><p>得到下面反编译的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_int<span class="token punctuation">.</span>LongTest</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_int<span class="token punctuation">.</span><span class="token function">LongTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> aload_0       <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Object."&lt;init>":()V</span>       <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> ldc2_w        #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// long -128l</span>       <span class="token number">3</span><span class="token operator">:</span> invokestatic  #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Long.valueOf:(J)Ljava/lang/Long;</span>       <span class="token number">6</span><span class="token operator">:</span> astore_1       <span class="token number">7</span><span class="token operator">:</span> ldc2_w        #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// long -128l</span>      <span class="token number">10</span><span class="token operator">:</span> invokestatic  #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Long.valueOf:(J)Ljava/lang/Long;</span>      <span class="token number">13</span><span class="token operator">:</span> astore_2      <span class="token number">14</span><span class="token operator">:</span> ldc2_w        #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// long 150l</span>      <span class="token number">17</span><span class="token operator">:</span> invokestatic  #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Long.valueOf:(J)Ljava/lang/Long;</span>      <span class="token number">20</span><span class="token operator">:</span> astore_3      <span class="token number">21</span><span class="token operator">:</span> ldc2_w        #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// long 150l</span>      <span class="token number">24</span><span class="token operator">:</span> invokestatic  #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Long.valueOf:(J)Ljava/lang/Long;</span>      <span class="token number">27</span><span class="token operator">:</span> astore        <span class="token number">4</span>      <span class="token number">29</span><span class="token operator">:</span> getstatic     #<span class="token number">7</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>      <span class="token number">32</span><span class="token operator">:</span> aload_1      <span class="token number">33</span><span class="token operator">:</span> aload_2      <span class="token number">34</span><span class="token operator">:</span> if_acmpne     <span class="token number">41</span>      <span class="token number">37</span><span class="token operator">:</span> iconst_1      <span class="token number">38</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">42</span>      <span class="token number">41</span><span class="token operator">:</span> iconst_0      <span class="token number">42</span><span class="token operator">:</span> invokevirtual #<span class="token number">8</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Z)V</span>      <span class="token number">45</span><span class="token operator">:</span> getstatic     #<span class="token number">7</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>      <span class="token number">48</span><span class="token operator">:</span> aload_3      <span class="token number">49</span><span class="token operator">:</span> aload         <span class="token number">4</span>      <span class="token number">51</span><span class="token operator">:</span> if_acmpne     <span class="token number">58</span>      <span class="token number">54</span><span class="token operator">:</span> iconst_1      <span class="token number">55</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">59</span>      <span class="token number">58</span><span class="token operator">:</span> iconst_0      <span class="token number">59</span><span class="token operator">:</span> invokevirtual #<span class="token number">8</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Z)V</span>      <span class="token number">62</span><span class="token operator">:</span> <span class="token keyword">return</span><span class="token punctuation">}</span></code></pre><p>我们从上述代码中发现 <code>Long var = ?</code> 的确是通过 <code>java.lang.Long#valueOf(long)</code> 来构造对象的。</p><h4 id="1-1-4-总结"><a href="#1-1-4-总结" class="headerlink" title="1.1.4-总结"></a>1.1.4-总结</h4><p>本小节通过源码分析法、阅读 JLS 和 JVMS、使用反汇编法，对 <code>Integer</code> 和 <code>Long</code> 缓存的目的和实现方式问题进行了深入分析。</p><p>让大家能够通过更丰富的手段来学习知识和分析问题，通过对缓存目的的思考来学到更通用和本质的东西。</p><p>本节使用的几种手段将是我们未来常用的方法，也是工作进阶的必备技能和一个程序员专业程度的体现，希望大家未来能够多动手实践。</p><p>下一节我们将介绍 Java 序列化相关问题，包括序列化的定义，序列化常见的方案，序列化的坑点等。</p><h3 id="1-2-Java序列化引发的血案"><a href="#1-2-Java序列化引发的血案" class="headerlink" title="1.2-Java序列化引发的血案"></a>1.2-Java序列化引发的血案</h3><h4 id="1-2-1-前言"><a href="#1-2-1-前言" class="headerlink" title="1.2.1-前言"></a>1.2.1-前言</h4><p>《手册》第 9 页 “OOP 规约” 部分有一段关于序列化的约定 <a href="https://www.imooc.com/read/55/article/1140#fn1" target="_blank" rel="noopener">1</a>：</p><blockquote><p>【强制】当序列化类新增属性时，请不要修改 serialVersionUID 字段，以避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。<br>说明：注意 serialVersionUID 值不一致会抛出序列化运行时异常。</p></blockquote><p>我们应该思考下面几个问题：</p><ul><li>序列化和反序列化到底是什么？</li><li>它的主要使用场景有哪些？</li><li>Java 序列化常见的方案有哪些？</li><li>各种常见序列化方案的区别有哪些？</li><li>实际的业务开发中有哪些坑点？</li></ul><p>接下来将从这几个角度去研究这个问题。</p><h4 id="1-2-2-序列化和反序列化是什么？为什么需要它？"><a href="#1-2-2-序列化和反序列化是什么？为什么需要它？" class="headerlink" title="1.2.2-序列化和反序列化是什么？为什么需要它？"></a>1.2.2-序列化和反序列化是什么？为什么需要它？</h4><p><strong>序列化</strong>是将内存中的对象信息转化成可以存储或者传输的数据到临时或永久存储的过程。而<strong>反序列化</strong>正好相反，是从临时或永久存储中读取序列化的数据并转化成内存对象的过程。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.jpeg" alt="序列化和反序列化"></p><p><strong>那么为什么需要序列化和反序列化呢？</strong></p><p>希望大家能够养成从本源上思考这个问题的思维方式，即思考它为什么会出现，而不是单纯记忆。</p><blockquote><p>大家可以回忆一下，平时都是如果将文字文件、图片文件、视频文件、软件安装包等传给小伙伴时，这些资源在计算机中存储的方式是怎样的。</p><p>进而再思考，Java 中的对象如果需要存储或者传输应该通过什么形式呢？</p></blockquote><p>我们都知道，一个文件通常是一个 m 个字节的序列：B0, B1, …, Bk, …, Bm-1。所有的 I/O 设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对应文件的读和写来执行。<a href="https://www.imooc.com/read/55/article/1140#fn2" target="_blank" rel="noopener">2</a></p><p>因此本质上讲，文本文件，图片、视频和安装包等文件底层都被转化为二进制字节流来传输的，对方得文件就需要对文件进行解析，因此就需要有能够根据不同的文件类型来解码出文件的内容的程序。</p><p>大家试想一个典型的场景：如果要实现 Java 远程方法调用，就需要将调用结果通过网路传输给调用方，如果调用方和服务提供方不在一台机器上就很难共享内存，就需要将 Java 对象进行传输。而想要将 Java 中的对象进行网络传输或存储到文件中，就需要将对象转化为二进制字节流，这就是所谓的序列化。存储或传输之后必然就需要将二进制流读取并解析成 Java 对象，这就是所谓的反序列化。</p><p>序列化的主要目的是：<strong>方便存储到文件系统、数据库系统或网络传输等</strong>。</p><p>实际开发中常用到序列化和反序列化的场景有：</p><ul><li>远程方法调用（RPC）的框架里会用到序列化。</li><li>将对象存储到文件中时，需要用到序列化。</li><li>将对象存储到缓存数据库（如 Redis）时需要用到序列化。</li><li>通过序列化和反序列化的方式实现对象的深拷贝。</li></ul><h4 id="1-2-3-常见的序列化方式"><a href="#1-2-3-常见的序列化方式" class="headerlink" title="1.2.3-常见的序列化方式"></a>1.2.3-常见的序列化方式</h4><p>常见的序列化方式包括 Java 原生序列化、Hessian 序列化、Kryo 序列化、JSON 序列化等。</p><h5 id="1-Java-原生序列化"><a href="#1-Java-原生序列化" class="headerlink" title="1. Java 原生序列化"></a>1. Java 原生序列化</h5><p>正如前面章节讲到的，对于 JDK 中有的类，最好的学习方式之一就是直接看其源码。</p><p><code>Serializable</code> 的源码非常简单，只有声明，没有属性和方法：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 注释太长，省略</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>在学习源码注释之前，希望大家可以站在设计者的角度，先思考一个问题：如果一个类序列化到文件之后，类的结构发生变化还能否保证正确地反序列化呢？</p><p>答案显然是不确定的。</p><p><strong>那么如何判断文件被修改过了呢？</strong> 通常可以通过加密算法对其进行签名，文件作出任何修改签名就会不一致。但是 Java 序列化的场景并不适合使用上述的方案，因为类文件的某些位置加个空格，换行等符号类的结构没有发生变化，这个签名就不应该发生变化。还有一个类新增一个属性，之前的属性都是有值的，之前都被序列化到对象文件中，有些场景下还希望反序列化时可以正常解析，怎么办呢？</p><p>那么是否可以通过约定一个唯一的 ID，通过 ID 对比，不一致就认为不可反序列化呢？</p><p><strong>实现序列化接口后，如果开发者不手动指定该版本号 ID 怎么办？</strong></p><p>既然 Java 序列化场景下的 “签名” 应该根据类的特点生成，我们是否可以不指定序列化版本号就默认根据类名、属性和函数等计算呢？</p><p>如果针对某个自己定义的类，想自定义序列化和反序列化机制该如何实现呢？支持吗？</p><p>带着这些问题我们继续看序列化接口的注释。</p><p><code>Serializable</code> 的源码注释特别长，其核心大致作了下面的说明：</p><p>Java 原生序列化需要实现 <code>Serializable</code> 接口。序列化接口不包含任何方法和属性等，它只起到序列化标识作用。</p><p>一个类实现序列化接口则其子类型也会继承序列化能力，但是实现序列化接口的类中有其他对象的引用，则其他对象也要实现序列化接口。序列化时如果抛出 <code>NotSerializableException</code> 异常，说明该对象没有实现 <code>Serializable</code> 接口。</p><p>每个序列化类都有一个叫 <code>serialVersionUID</code> 的版本号，反序列化时会校验待反射的类的序列化版本号和加载的序列化字节流中的版本号是否一致，如果序列化号不一致则会抛出 <code>InvalidClassException</code> 异常。</p><p>强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的序列化号，因为这个默认的序列化号和类的特征以及编译器的实现都有关系，很容易在反序列化时抛出 <code>InvalidClassException</code> 异常。建议将这个序列化版本号声明为私有，以避免运行时被修改。</p><p>实现序列化接口的类可以提供自定义的函数修改默认的序列化和反序列化行为。</p><p>自定义序列化方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">writeObject</span><span class="token punctuation">(</span>ObjectOutputStream out<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">;</span></code></pre><p>自定义反序列化方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">readObject</span><span class="token punctuation">(</span>ObjectInputStream in<span class="token punctuation">)</span>   <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException<span class="token punctuation">;</span></code></pre><p>通过自定义这两个函数，可以实现序列化和反序列化不可序列化的属性，也可以对序列化的数据进行数据的加密和解密处理。</p><h5 id="2-Hessian-序列化"><a href="#2-Hessian-序列化" class="headerlink" title="2. Hessian 序列化"></a>2. Hessian 序列化</h5><p>Hessian 是一个动态类型，二进制序列化，也是一个基于对象传输的网络协议。Hessian 是一种跨语言的序列化方案，序列化后的字节数更少，效率更高。Hessian 序列化会把复杂对象的属性映射到 <code>Map</code> 中再进行序列化。</p><h5 id="3-Kryo-序列化"><a href="#3-Kryo-序列化" class="headerlink" title="3. Kryo 序列化"></a>3. Kryo 序列化</h5><p>Kryo 是一个快速高效的 Java 序列化和克隆工具。Kryo 的目标是快速、字节少和易用。Kryo 还可以自动进行深拷贝或者浅拷贝。Kryo 的拷贝是对象到对象的拷贝而不是对象到字节，再从字节到对象的恢复。Kryo 为了保证序列化的高效率，会提前加载需要的类，这会带一些消耗，但是这是序列化后文件较小且反序列化非常快的重要原因。</p><h5 id="4-JSON-序列化"><a href="#4-JSON-序列化" class="headerlink" title="4. JSON 序列化"></a>4. JSON 序列化</h5><p>JSON (JavaScript Object Notation) 是一种轻量级的数据交换方式。JSON 序列化是基于 JSON 这种结构来实现的。JSON 序列化将对象转化成 JSON 字符串，JSON 反序列化则是将 JSON 字符串转回对象的过程。常用的 JSON 序列化和反序列化的库有 Jackson、GSON、Fastjson 等。</p><h4 id="1-2-4-Java-常见的序列化方案对比"><a href="#1-2-4-Java-常见的序列化方案对比" class="headerlink" title="1.2.4-Java 常见的序列化方案对比"></a>1.2.4-Java 常见的序列化方案对比</h4><p>我们想要对比各种序列化方案的优劣无外乎两点，一点是查资料，一点是自己写代码验证。</p><h5 id="1-Java-原生序列化-1"><a href="#1-Java-原生序列化-1" class="headerlink" title="1. Java 原生序列化"></a>1. Java 原生序列化</h5><p>Java 序列化的优点是：对对象的结构描述清晰，反序列化更安全。主要缺点是：效率低，序列化后的二进制流较大。</p><h5 id="2-Hessian-序列化-1"><a href="#2-Hessian-序列化-1" class="headerlink" title="2. Hessian 序列化"></a>2. Hessian 序列化</h5><p>Hession 序列化二进制流较 Java 序列化更小，且序列化和反序列化耗时更短。但是父类和子类有相同类型属性时，由于先序列化子类再序列化父类，因此反序列化时子类的同名属性会被父类的值覆盖掉，开发时要特别注意这种情况。</p><blockquote><p>Hession2.0 序列化二进制流大小是 Java 序列化的 50%，序列化耗时是 Java 序列化的 30%，反序列化的耗时是 Java 序列化的 20%。 <a href="https://www.imooc.com/read/55/article/1140#fn3" target="_blank" rel="noopener">3</a></p></blockquote><p>编写待测试的类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PersonHessian</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> Boolean male<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Male</span> <span class="token keyword">extends</span> <span class="token class-name">PersonHessian</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>编写单测来模拟序列化继承覆盖问题：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 验证Hessian序列化继承覆盖问题 */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testHessianSerial</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    HessianSerialUtil<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> male<span class="token punctuation">)</span><span class="token punctuation">;</span>    Male maleGet <span class="token operator">=</span> HessianSerialUtil<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 相等</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>male<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> maleGet<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// male.getId()结果是1，maleGet.getId()结果是null</span>    Assert<span class="token punctuation">.</span><span class="token function">assertNull</span><span class="token punctuation">(</span>maleGet<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertNotEquals</span><span class="token punctuation">(</span>male<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> maleGet<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述单测示例验证了：反序列化时子类的同名属性会被父类的值覆盖掉的问题。</p><h5 id="3-Kryo-序列化-1"><a href="#3-Kryo-序列化-1" class="headerlink" title="3. Kryo 序列化"></a>3. Kryo 序列化</h5><p>Kryo 优点是：速度快、序列化后二进制流体积小、反序列化超快。但是缺点是：跨语言支持复杂。注册模式序列化更快，但是编程更加复杂。</p><h5 id="4-JSON-序列化-1"><a href="#4-JSON-序列化-1" class="headerlink" title="4. JSON 序列化"></a>4. JSON 序列化</h5><p>JSON 序列化的优势在于可读性更强。主要缺点是：没有携带类型信息，只有提供了准确的类型信息才能准确地进行反序列化，这点也特别容易引发线上问题。</p><p>下面给出使用 Gson 框架模拟 JSON 序列化时遇到的反序列化问题的示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 验证GSON序列化类型错误 */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testGSON</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> String name <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> String id <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> 20L<span class="token punctuation">)</span><span class="token punctuation">;</span>    String jsonString <span class="token operator">=</span> GSONSerialUtil<span class="token punctuation">.</span><span class="token function">getJsonString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> mapGSON <span class="token operator">=</span> GSONSerialUtil<span class="token punctuation">.</span><span class="token function">parseJson</span><span class="token punctuation">(</span>jsonString<span class="token punctuation">,</span> Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> mapGSON<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 不等  map.get(id)为Long类型 mapGSON.get(id)为Double类型</span>    Assert<span class="token punctuation">.</span><span class="token function">assertNotEquals</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mapGSON<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertNotEquals</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> mapGSON<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>下面给出使用 fastjson 模拟 JSON 反序列化问题的示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 验证FatJson序列化类型错误 */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFastJson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> String name <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> String id <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> 20L<span class="token punctuation">)</span><span class="token punctuation">;</span>    String fastJsonString <span class="token operator">=</span> FastJsonUtil<span class="token punctuation">.</span><span class="token function">getJsonString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> mapFastJson <span class="token operator">=</span> FastJsonUtil<span class="token punctuation">.</span><span class="token function">parseJson</span><span class="token punctuation">(</span>fastJsonString<span class="token punctuation">,</span> Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> mapFastJson<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 错误  map.get(id)为Long类型 mapFastJson.get(id)为Integer类型</span>    Assert<span class="token punctuation">.</span><span class="token function">assertNotEquals</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mapFastJson<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertNotEquals</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> mapFastJson<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>大家还可以通过单元测试构造大量复杂对象对比各种序列化方式或框架的效率。</p><p>如定义下列测试类为 User，包括以下多种类型的属性：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token keyword">private</span> Boolean sex<span class="token punctuation">;</span>    <span class="token keyword">private</span> String nickName<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthDay<span class="token punctuation">;</span>    <span class="token keyword">private</span> Double salary<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="5-各种常见的序列化性能排序"><a href="#5-各种常见的序列化性能排序" class="headerlink" title="5. 各种常见的序列化性能排序"></a>5. 各种常见的序列化性能排序</h5><p>实验的版本：kryo-shaded 使用 4.0.2 版本，gson 使用 2.8.5 版本，hessian 用 4.0.62 版本。</p><p>实验的数据：构造 50 万 User 对象运行多次。</p><p>大致得出一个结论：</p><ul><li>从二进制流大小来讲：JSON 序列化 &gt; Java 序列化 &gt; Hessian2 序列化 &gt; Kryo 序列化 &gt; Kryo 序列化注册模式；</li><li>从序列化耗时而言来讲：GSON 序列化 &gt; Java 序列化 &gt; Kryo 序列化 &gt; Hessian2 序列化 &gt; Kryo 序列化注册模式；</li><li>从反序列化耗时而言来讲：GSON 序列化 &gt; Java 序列化 &gt; Hessian2 序列化 &gt; Kryo 序列化注册模式 &gt; Kryo 序列化；</li><li>从总耗时而言：Kryo 序列化注册模式耗时最短。</li></ul><blockquote><p>注：由于所用的序列化框架版本不同，对象的复杂程度不同，环境和计算机性能差异等原因结果可能会有出入。</p></blockquote><h4 id="1-2-5-序列化引发的一个血案"><a href="#1-2-5-序列化引发的一个血案" class="headerlink" title="1.2.5-序列化引发的一个血案"></a>1.2.5-序列化引发的一个血案</h4><p>接下来我们看下面的一个案例：</p><blockquote><p>前端调用服务 A，服务 A 调用服务 B，服务 B 首次接到请求会查 DB，然后缓存到 Redis（缓存 1 个小时）。服务 A 根据服务 B 返回的数据后执行一些处理逻辑，处理后形成新的对象存到 Redis（缓存 2 个小时）。</p><p>服务 A 通过 Dubbo 来调用服务 B，A 和 B 之间数据通过 <code>Map</code> 类型传输，服务 B 使用 Fastjson 来实现 JSON 的序列化和反序列化。</p><p>服务 B 的接口返回的 <code>Map</code> 值中存在一个 <code>Long</code> 类型的 <code>id</code> 字段，服务 A 获取到 <code>Map</code> ，取出 <code>id</code> 字段并强转为 <code>Long</code> 类型使用。</p></blockquote><p>执行的流程如下：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%88%E4%BE%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.jpeg" alt="序列化案例执行流程"></p><p>通过分析我们发现，服务 A 和服务 B 的 RPC 调用使用 Java 序列化，因此类型信息不会丢失。</p><p>但是由于服务 B 采用 JSON 序列化进行缓存，第一次访问没啥问题，其执行流程如下：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%88%E4%BE%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B1.jpeg" alt="序列化案例执行流程1"></p><p><strong>如果服务 A 开启了缓存</strong>，服务 A 在第一次请求服务 B 后，缓存了运算结果，且服务 A 缓存时间比服务 B 长，因此不会出现错误。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%88%E4%BE%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B2.jpeg" alt="序列化案例执行流程2"></p><p><strong>如果服务 A 不开启缓存</strong>，服务 A 会请求服务 B ，由于首次请求时，服务 B 已经缓存了数据，服务 B 从 Redis（B）中反序列化得到 <code>Map</code>。流程如下图所示：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E5%BA%8F%E5%88%97%E5%8C%96%E6%A1%88%E4%BE%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B3.jpeg" alt="序列化案例执行流程3"></p><p>然而问题来了： 服务 A 从 Map 取出此 <code>Id</code> 字段，强转为 <code>Long</code> 时会出现类型转换异常。</p><p>最后定位到原因是 Json 反序列化 Map 时如果原始值小于 Int 最大值，反序列化后原本为 Long 类型的字段，变为了 Integer 类型，服务 B 的同学紧急修复。</p><p>服务 A 开启缓存时， 虽然采用了 JSON 序列化存入缓存，但是采用 DTO 对象而不是 Map 来存放属性，所以 JSON 反序列化没有问题。</p><p><strong>因此大家使用二方或者三方服务时，当对方返回的是 <code>Map</code> 类型的数据时要特别注意这个问题</strong>。</p><blockquote><p>作为服务提供方，可以采用 JDK 或者 Hessian 等序列化方式；</p><p>作为服务的使用方，我们不要从 Map 中一个字段一个字段获取和转换，可以使用 JSON 库直接将 Map 映射成所需的对象，这样做不仅代码更简洁还可以避免强转失败。</p></blockquote><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFastJsonObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> String name <span class="token operator">=</span> <span class="token string">"name"</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> String id <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> 20L<span class="token punctuation">)</span><span class="token punctuation">;</span>    String fastJsonString <span class="token operator">=</span> FastJsonUtil<span class="token punctuation">.</span><span class="token function">getJsonString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 模拟拿到服务B的数据</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> mapFastJson <span class="token operator">=</span> FastJsonUtil<span class="token punctuation">.</span><span class="token function">parseJson</span><span class="token punctuation">(</span>fastJsonString<span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 转成强类型属性的对象而不是使用map 单个取值</span>    User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span>mapFastJson<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toJavaObject</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 正确</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="1-2-6-总结"><a href="#1-2-6-总结" class="headerlink" title="1.2.6-总结"></a>1.2.6-总结</h4><p>本节的主要讲解了序列化的主要概念、主要实现方式，以及序列化和反序列化的几个坑点，希望大家在实际业务开发中能够注意这些细节，避免趟坑。</p><p>下一节将讲述浅拷贝和深拷贝的相关知识。</p><h3 id="1-3-学习浅拷贝和深拷贝的正确方式"><a href="#1-3-学习浅拷贝和深拷贝的正确方式" class="headerlink" title="1.3-学习浅拷贝和深拷贝的正确方式"></a>1.3-学习浅拷贝和深拷贝的正确方式</h3><h4 id="1-3-1-前言"><a href="#1-3-1-前言" class="headerlink" title="1.3.1-前言"></a>1.3.1-前言</h4><p>《手册》第 10 页有关于 <code>Object</code> 的 <code>clone</code> 问题的描述 <a href="https://www.imooc.com/read/55/article/1141#fn1" target="_blank" rel="noopener">1</a>：</p><blockquote><p>【推荐】慎用 Object 的 clone 方法来拷贝对象。<br>说明：对象 clone 方法默认是浅拷贝，若想实现深拷贝需覆写 clone 方法实现域对象的深度遍历式拷贝。</p></blockquote><p>那么我们要思考几个问题：</p><ol><li>什么是浅拷贝？</li><li>浅拷贝和深拷贝的区别是什么？</li><li>拷贝的目的是什么？</li><li>拷贝的使用场景是什么？</li><li>如何实现深拷贝？</li></ol><p>网上也有很多介绍浅拷贝和深拷贝的文章，但文章质量参差不齐，有些文章读完仍然对概念得理解非常含糊。读完这些文章对拷贝的使用场景，对深拷贝的实现方式等都无法有全面和深刻的理解。</p><p>为此本节将带着大家系统地研究这上述问题，以便大家未来遇到类似问题时可以举一反三，灵活迁移。</p><h4 id="1-3-2-概念介绍"><a href="#1-3-2-概念介绍" class="headerlink" title="1.3.2-概念介绍"></a>1.3.2-概念介绍</h4><h5 id="1-拷贝-克隆的概念"><a href="#1-拷贝-克隆的概念" class="headerlink" title="1. 拷贝 / 克隆的概念"></a>1. 拷贝 / 克隆的概念</h5><p>我们先研究第 1 个问题：<strong>什么是拷贝？</strong></p><p>维基百科对 “克隆” 的描述如下 <a href="https://www.imooc.com/read/55/article/1141#fn2" target="_blank" rel="noopener">2</a>：</p><blockquote><p>克隆 (英语： Clone) 在广义上是指利用生物技术由无性生殖产生与原原个体有完全相同基因组之后代的过程。</p><p>在园艺学上，克隆指通过营养繁殖产生的单一植株的后代，很多植物都是通过克隆这样的无性繁殖方式从单一植株获得大量的子代个体。</p><p>在生物学上，是指选择性地复制出一段 DNA 序列（分子克隆）、细胞（细胞克隆）或个体（个体克隆）。</p><p>克隆一个生物体意味着创造一个与原先的生物体具有完全一样的遗传信息的新生物体。</p></blockquote><p>计算机中的拷贝或克隆和上述概念很类似，可以类比理解。</p><p>对象的拷贝，就是根据原来的对象 “复制” 一份属性、状态一致的新的对象。</p><h5 id="2-为什么需要拷贝方法？"><a href="#2-为什么需要拷贝方法？" class="headerlink" title="2. 为什么需要拷贝方法？"></a>2. 为什么需要拷贝方法？</h5><p>我们思考第 2 个问题：<strong>为什么需要拷贝呢？</strong></p><p>我们来看下面的订单类和商品类。</p><p>订单类（ <code>Order</code> ）：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String orderNo<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Item<span class="token operator">></span> itemList<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>商品类（ Item` ）：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Item</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> Long itemId<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String desc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 省略其他</span><span class="token punctuation">}</span></code></pre><p>如果我们查询得到 1 个订单对象，该对象包括 6 个商品对象。</p><p>如果我们还需要构造多个新的订单对象，属性和上述订单对象非常相似，只是订单号不同或者商品略有区别。</p><p>这时如果有一个 “复制” 方法，可以将订单复制一个副本，而且修改副本中的订单号和商品列表 ( <code>itemList</code> ) 不影响原始对象，是不是很方便？</p><p>另外一个非常典型的场景是在多线程中。如果只用一个主线程，在主线程中修改订单号分别调用 <code>doSomeThing</code> 函数，想分别打印 first 和 second 两个订单编号字符串。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CloneDemo</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Order order <span class="token operator">=</span> OrderMocker<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        order<span class="token punctuation">.</span><span class="token function">setOrderNo</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">doSomeThing</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>        order<span class="token punctuation">.</span><span class="token function">setOrderNo</span><span class="token punctuation">(</span><span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">doSomeThing</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span>Order order<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getOrderNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行程序后输出的结果的确是: <code>first</code>、<code>second</code>。</p><p>但在多线程环境中，如果我们不通过克隆构造新的对象，线程池中两个线程会公用同一个对象，后面对订单号的修改将影响到其它线程。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CloneDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Order order <span class="token operator">=</span> OrderMocker<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        order<span class="token punctuation">.</span><span class="token function">setOrderNo</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        order<span class="token punctuation">.</span><span class="token function">setOrderNo</span><span class="token punctuation">(</span><span class="token string">"second"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSomeThing</span><span class="token punctuation">(</span>Order order<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getOrderNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出的结果是: <code>second</code>、<code>second</code>。</p><p>因此如果能够克隆一个新的对象，并且对新对象的修改不影响原始对象，就能实现我们期待的效果。</p><h5 id="3-什么是浅拷贝？浅拷贝和深拷贝的区别是什么？"><a href="#3-什么是浅拷贝？浅拷贝和深拷贝的区别是什么？" class="headerlink" title="3. 什么是浅拷贝？浅拷贝和深拷贝的区别是什么？"></a>3. 什么是浅拷贝？浅拷贝和深拷贝的区别是什么？</h5><p>通过前言部分的介绍，我们知道 <code>Object</code> 的 <code>clone</code> 函数默认是浅拷贝。</p><p>按照惯例我们进入源码，看看是否能够得到我们想要的答案：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Creates and returns a copy of this object.  The precise meaning * of "copy" may depend on the class of the object. The general * intent is that, for any object {@code x}, the expression: * &lt;blockquote> * &lt;pre> * x.clone() != x&lt;/pre>&lt;/blockquote> * will be true, and that the expression: * &lt;blockquote> * &lt;pre> * x.clone().getClass() == x.getClass()&lt;/pre>&lt;/blockquote> * will be {@code true}, but these are not absolute requirements. * While it is typically the case that: * &lt;blockquote> * &lt;pre> * x.clone().equals(x)&lt;/pre>&lt;/blockquote> * will be {@code true}, this is not an absolute requirement. * &lt;p> * By convention, the returned object should be obtained by calling * {@code super.clone}.  If a class and all of its superclasses (except * {@code Object}) obey this convention, it will be the case that * {@code x.clone().getClass() == x.getClass()}. * &lt;p> * By convention, the object returned by this method should be independent * of this object (which is being cloned).  To achieve this independence, * it may be necessary to modify one or more fields of the object returned * by {@code super.clone} before returning it.  Typically, this means * copying any mutable objects that comprise the internal "deep structure" * of the object being cloned and replacing the references to these * objects with references to the copies.  If a class contains only * primitive fields or references to immutable objects, then it is usually * the case that no fields in the object returned by {@code super.clone} * need to be modified. * &lt;p> * The method {@code clone} for class {@code Object} performs a * specific cloning operation. First, if the class of this object does * not implement the interface {@code Cloneable}, then a * {@code CloneNotSupportedException} is thrown. Note that all arrays * are considered to implement the interface {@code Cloneable} and that * the return type of the {@code clone} method of an array type {@code T[]} * is {@code T[]} where T is any reference or primitive type. * Otherwise, this method creates a new instance of the class of this * object and initializes all its fields with exactly the contents of * the corresponding fields of this object, as if by assignment; the * contents of the fields are not themselves cloned. Thus, this method * performs a "shallow copy" of this object, not a "deep copy" operation. * &lt;p> * The class {@code Object} does not itself implement the interface * {@code Cloneable}, so calling the {@code clone} method on an object * whose class is {@code Object} will result in throwing an * exception at run time. * * @return     a clone of this instance. * @throws  CloneNotSupportedException  if the object's class does not *               support the {@code Cloneable} interface. Subclasses *               that override the {@code clone} method can also *               throw this exception to indicate that an instance cannot *               be cloned. * @see java.lang.Cloneable */</span><span class="token keyword">protected</span> <span class="token keyword">native</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException<span class="token punctuation">;</span></code></pre><p>该函数给出了非常详尽的介绍。下面给出一些要点的翻译：</p><blockquote><p>该方法是创建对象的副本。这就意味着 “副本” 依赖于该对象的类型。</p><p>对于任何对象而言，一般来说下面的表达式成立：</p><p><code>x.clone() != x</code> 的结果为 <code>true</code> 。</p><p><code>x.clone().getClass() == x.getClass()</code> 的结果为 <code>true</code> 。</p><p>但是这些也不是强制的要求。</p><p><code>x.clone().equals(x)</code> 的结果也是 <code>true</code>。这也不是强制要求。</p><p>按照惯例，返回对象应该通过调用 <code>super.clone</code> 函数来构造。如果一个类和它的所有父类（除了 <code>Object</code> ）都遵循这个约定，那么 <code>x.clone().getClass() == x.getClass()</code> 将成立。</p><p>按照惯例，返回的对象应该和原始对象是独立的。</p><p>为了实现这种独立性，后续应该在调用 <code>super.clone</code> 得到拷贝对象并返回之前，应该对内部深层次的可变对象创建副本并指向克隆对象的对应属性的引用。</p><p>如果一个类只包含基本类型的属性或者指向不可变对象的引用，这种情况下，<code>super.clone</code> 返回的对象不需要被修改。</p><p>如果调用 <code>clone</code> 函数的类没有实现 <code>Cloneable</code> 接口将会抛出 <code>CloneNotSupportedException</code>。</p><p>注意所有的数组对象都默认实现了 <code>Cloneable</code> 接口。</p><p>该函数会创建该类的新实例，并初始化所有属性对象。属性对象本身并不会自动调用 <code>clone</code>。</p><p>因此此方法实现的是浅拷贝而不是深拷贝。</p></blockquote><p>因此我们可以了解到，浅拷贝将返回该类的新的实例，该实例的引用类型对象共享。<br>深拷贝也会返回该类的新的实例，但是该实例的引用类型属性也是拷贝的新对象。</p><p>如果用一句话来描述，<strong>浅拷贝和深拷贝的主要区别在于对于引用类型是否共享。</strong></p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB.jpeg" alt="浅拷贝和深拷贝的区别"></p><p>为了更好地理解浅拷贝，我们给出一个示例：</p><p>改造订单对象：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String orderNo<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Item<span class="token operator">></span> itemList<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Order <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>Order<span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 不会调到这里</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过 <code>Object</code> 类的 <code>clone</code> 函数的注释我们了解到：如果调用 <code>clone</code> 函数的类没有实现 <code>Cloneable</code> 接口将会抛出 <code>CloneNotSupportedException</code> 。</p><p>因此要实现 <code>Cloneable</code> 接口。</p><p>重写 <code>clone</code> 函数是为了供外部使用，因此定义为 <code>public</code> 。</p><p>返回值类型定义为客户端直接需要的对象类型（本类）。</p><p>这体现了《Effective Java》的 Item 11 中所提到的 <a href="https://www.imooc.com/read/55/article/1141#fn3" target="_blank" rel="noopener">3</a>：</p><blockquote><p>Never make the client do anything the library can do for the client.</p><p>不要让客户端去做任何类库可以替它完成的事。</p></blockquote><p>我们为上述浅拷贝编写测试代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderMocker</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Order <span class="token function">mock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Order order <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Order</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        order<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span>        order<span class="token punctuation">.</span><span class="token function">setOrderNo</span><span class="token punctuation">(</span><span class="token string">"abcdefg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Item<span class="token operator">></span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Item item <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        item<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>0L<span class="token punctuation">)</span><span class="token punctuation">;</span>        item<span class="token punctuation">.</span><span class="token function">setItemId</span><span class="token punctuation">(</span>0L<span class="token punctuation">)</span><span class="token punctuation">;</span>        item<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"《阿里巴巴Java开发手册》详解慕课专栏"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        item<span class="token punctuation">.</span><span class="token function">setDesc</span><span class="token punctuation">(</span><span class="token string">"精品推荐"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        items<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        order<span class="token punctuation">.</span><span class="token function">setItemList</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> order<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shallowClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Order order <span class="token operator">=</span> OrderMocker<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Order cloneOrder <span class="token operator">=</span> order<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">assertFalse</span><span class="token punctuation">(</span>order <span class="token operator">==</span> cloneOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">assertTrue</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getItemList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> cloneOrder<span class="token punctuation">.</span><span class="token function">getItemList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>该单元测试可以通过，从而证实了 <code>clone</code> 函数的注释，证实了浅拷贝的表现。</p><p>即浅拷贝后，原对象的订单列表和克隆对象的订单列表地址相同。</p><p><strong>因此如果使用浅拷贝，修改拷贝订单的商品列表，那么原始订单对象的商品列表也会受到影响。</strong></p><p>为了更形象地理解浅拷贝和深拷贝的概念，我们以文件夹进行类比：</p><blockquote><p>浅拷贝：同一个文件夹的两个快捷方式，虽然是两个不同的快捷方式，但是指向的文件夹是同一个，不管是通过哪个快捷方式进入，对该文件夹下的文件修改，相互影响。</p><p>深拷贝：我们复制某个文件夹（含里面的内容）在另外一个目录进行粘贴，就可得到具有相同内容的新目录，对新文件夹修改不影响原始文件夹。</p></blockquote><h4 id="1-3-3-深拷贝的实现方式"><a href="#1-3-3-深拷贝的实现方式" class="headerlink" title="1.3.3-深拷贝的实现方式"></a>1.3.3-深拷贝的实现方式</h4><p>虽然浅拷贝能够实现拷贝的功能，但是浅拷贝的引用类型成员变量是共享的，修改极可能导致相互影响。</p><p>业务开发中使用深拷贝更多一些，<strong>那么实现深拷贝有哪些方式呢？</strong></p><h5 id="1-手动深拷贝"><a href="#1-手动深拷贝" class="headerlink" title="1. 手动深拷贝"></a>1. 手动深拷贝</h5><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String orderNo<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Item<span class="token operator">></span> itemList<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Order <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Order order <span class="token operator">=</span> <span class="token punctuation">(</span>Order<span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                order<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>orderNo <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                order<span class="token punctuation">.</span>orderNo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>orderNo<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>itemList <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                List<span class="token operator">&lt;</span>Item<span class="token operator">></span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Item each <span class="token operator">:</span> itemList<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Item item <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    Long id <span class="token operator">=</span> each<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>id <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                        item<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    Long itemId <span class="token operator">=</span> each<span class="token punctuation">.</span><span class="token function">getItemId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>itemId <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                        item<span class="token punctuation">.</span><span class="token function">setItemId</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">(</span>itemId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    String name <span class="token operator">=</span> each<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>name <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                        item<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    String desc <span class="token operator">=</span> each<span class="token punctuation">.</span><span class="token function">getDesc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>desc <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                        item<span class="token punctuation">.</span><span class="token function">setDesc</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>desc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    items<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                order<span class="token punctuation">.</span><span class="token function">setItemList</span><span class="token punctuation">(</span>items<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> order<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>深拷贝也调用 <code>super.clone</code> 是为了支撑 <code>x.clone().getClass() == x.getClass()</code> 。</p><p>写好代码后，通过调用 <code>Order</code> 类的 <code>clone</code> 函数即可实现深拷贝。</p><p>由于克隆的对象和内部的引用类型的属性全部都是依据原始对象新建的对象，因此如果修改拷贝对象的商品列表，原始订单对象的商品列表并不会受到影响。</p><p>通过下面的单元测试来验证：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Order order <span class="token operator">=</span> OrderMocker<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Order cloneOrder <span class="token operator">=</span> <span class="token punctuation">(</span>Order<span class="token punctuation">)</span> order<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertFalse</span><span class="token punctuation">(</span>order <span class="token operator">==</span> cloneOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertFalse</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getItemList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> cloneOrder<span class="token punctuation">.</span><span class="token function">getItemList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>该单测可顺利通过。</p><h5 id="2-序列化方式"><a href="#2-序列化方式" class="headerlink" title="2. 序列化方式"></a>2. 序列化方式</h5><p>前面章节我们讲到了序列化和反序列化的知识，讲到了序列化的主要使用场景包括深拷贝。</p><p>序列化通过将原始对象转化为字节流，再从字节流重建新的 Java 对象，因此原始对象和反序列化后的对象修改互不影响。</p><p>因此可以使用之前讲到的序列化和反序列化方式来实现深拷贝。</p><h6 id="2-1-自定义序列化工具函数"><a href="#2-1-自定义序列化工具函数" class="headerlink" title="2.1 自定义序列化工具函数"></a>2.1 自定义序列化工具函数</h6><p>如果我们不想为了深拷贝这一项功能就依赖新的 jar 包，可以在自己项目中借助对象输入和输出流编写拷贝工具函数。</p><p>示例代码如下：</p><pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">/**     * JDK序列化方式深拷贝     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">deepClone</span><span class="token punctuation">(</span>T origin<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException <span class="token punctuation">{</span>        ByteArrayOutputStream outputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span>ObjectOutputStream objectOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            objectOutputStream<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span>            objectOutputStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> outputStream<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">(</span>ByteArrayInputStream inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> JdkSerialUtil<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>我们可通过调试查看克隆对象和原始对象。</p><p>从下图中我们可以清晰地看到，通过此方法克隆得到的新的对象是一个全新的对象。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0.jpeg" alt="自定义序列化工具函数"></p><p>需要注意的是：正如前面章节所讲，Java 序列化需要实现 <code>Serializable</code> 接口，而且效率不是特别高。</p><h6 id="2-2-commons-lang3-的序列化工具类"><a href="#2-2-commons-lang3-的序列化工具类" class="headerlink" title="2.2 commons-lang3 的序列化工具类"></a>2.2 commons-lang3 的序列化工具类</h6><p>我们可以利用项目中引用的常见工具包的工具类实现深拷贝，避免重复造轮子。</p><p>可以使用 commons-lang3 （3.7 版本）的序列化工具类： <code>org.apache.commons.lang3.SerializationUtils#clone</code>。</p><p>用法非常简单：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">serialUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Order order <span class="token operator">=</span> OrderMocker<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 使用方式</span>    Order cloneOrder <span class="token operator">=</span> SerializationUtils<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertFalse</span><span class="token punctuation">(</span>order <span class="token operator">==</span> cloneOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertFalse</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getItemList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> cloneOrder<span class="token punctuation">.</span><span class="token function">getItemList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>前面反复提到过，我们学习知识不仅要知其然，而且要知其所以然。</p><p><strong>那么它是如何实现深拷贝的呢？</strong></p><p>按照惯例我们打开源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * &lt;p>Deep clone an {@code Object} using serialization.&lt;/p> * * &lt;p>This is many times slower than writing clone methods by hand * on all objects in your object graph. However, for complex object * graphs, or for those that don't support deep cloning this can * be a simple alternative implementation. Of course all the objects * must be {@code Serializable}.&lt;/p> * * @param &lt;T> the type of the object involved * @param object  the {@code Serializable} object to clone * @return the cloned object * @throws SerializationException (runtime) if the serialization fails */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Serializable</span><span class="token operator">></span> T <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">final</span> T object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objectData <span class="token operator">=</span> <span class="token function">serialize</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ByteArrayInputStream bais <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>objectData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>ClassLoaderAwareObjectInputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassLoaderAwareObjectInputStream</span><span class="token punctuation">(</span>bais<span class="token punctuation">,</span>            object<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*         * when we serialize and deserialize an object,         * it is reasonable to assume the deserialized object         * is of the same type as the original serialized object         */</span>        <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// see above</span>        <span class="token keyword">final</span> T readObject <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> in<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> readObject<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">final</span> ClassNotFoundException ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SerializationException</span><span class="token punctuation">(</span><span class="token string">"ClassNotFoundException while reading cloned object data"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">final</span> IOException ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SerializationException</span><span class="token punctuation">(</span><span class="token string">"IOException while reading or closing cloned object data"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过其返回值的泛型描述 `` 可以断定参数对象需要实现序列化接口。</p><p>该函数注释也给出了性能说明，该深拷贝方法性能不如直接手动写 <code>clone</code> 方法效率高。</p><p>大家可以进到该方法的子函数中查看更多细节。</p><p>通过源码的分析我们发现，该克隆函数本质上也是通过 Java 序列化和反序列化方式实现。</p><h6 id="2-3-JSON-序列化"><a href="#2-3-JSON-序列化" class="headerlink" title="2.3 JSON 序列化"></a>2.3 JSON 序列化</h6><p>我们还可以通过 JSON 序列化方式实现深拷贝。</p><p>下面我们利用 Google 的 Gson 库（2.8.5 版本），实现基于 JSON 的深拷贝：</p><p>首先我们将深拷贝方法封装到拷贝工具类中：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Gson方式实现深拷贝 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">deepCloneByGson</span><span class="token punctuation">(</span>T origin<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span>T<span class="token operator">></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Gson gson <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Gson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> gson<span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>gson<span class="token punctuation">.</span><span class="token function">toJson</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">,</span> clazz<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用时直接调用封装的工具方法即可：</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Test</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">withGson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      Order order <span class="token operator">=</span> OrderMocker<span class="token punctuation">.</span><span class="token function">mock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// gson序列化方式</span>      Order cloneOrder <span class="token operator">=</span> CloneUtil<span class="token punctuation">.</span><span class="token function">deepCloneByGson</span><span class="token punctuation">(</span>order<span class="token punctuation">,</span> Order<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">assertFalse</span><span class="token punctuation">(</span>order <span class="token operator">==</span> cloneOrder<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">assertFalse</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getItemList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> cloneOrder<span class="token punctuation">.</span><span class="token function">getItemList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>使用 JSON 序列化方式实现深拷贝的好处是，性能比 Java 序列化方式更好，更重要的是不要求序列化对象以及成员属性（嵌套）都要实现序列化接口。</p><p>我们也可以使用前面讲到的 Hessian 和 Kryo 序列化来实现，请大家自行封装。</p><p>上面通过 Gson 实现的深拷贝工具方法封装，再次体现了 “不要让客户端去做任何类库可以替它完成的事” 的原则。</p><p>这点也和《重构 - 改善既有代码的设计》 第一版 10.13 封装向下转型的重构方案一致。</p><p>最后，建议<strong>不管采取哪种或者哪几种深拷贝方式，都尽量将其封装到项目的克隆工具类中，方便复用</strong>。</p><h4 id="1-3-4-总结"><a href="#1-3-4-总结" class="headerlink" title="1.3.4-总结"></a>1.3.4-总结</h4><p>本节重点讲述了浅拷贝和深拷贝的概念，它们的主要区别，以及浅拷贝和深拷贝的实现方式。</p><p>下一节将讲述开发常用既熟悉又陌生的几种分层领域模型，讲述它们之间的区别和实际开发中的使用。</p><h3 id="1-4-分层领域模型使用解读"><a href="#1-4-分层领域模型使用解读" class="headerlink" title="1.4-分层领域模型使用解读"></a>1.4-分层领域模型使用解读</h3><h4 id="1-4-1-前言"><a href="#1-4-1-前言" class="headerlink" title="1.4.1-前言"></a>1.4.1-前言</h4><p>《手册》关于分层模型部分的规约如下 <a href="https://www.imooc.com/read/55/article/1142#fn1" target="_blank" rel="noopener">1</a>：</p><blockquote><p>【参考】分层领域模型规约<br>DO (Data Object): 此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</p><p>DTO (Data Transfer Object): 数据传输对象，Service 或 Manager 向外传输的对象。</p><p>BO (Business Object): 业务对象，由 Service 层输出的封装业务逻辑的对象。</p><p>AO (Application Object): 应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴 近展示层，复用度不高。</p><p>VO (View Object): 显示层对象，通常是 Web 向模板渲染引擎层传输的对象。Query: 数据查询对象，各层接收上层的查询请求。</p><p>注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。</p></blockquote><p>那么我们需要思考以下几个问题：</p><ul><li>为什么需要这些分层领域模型？</li><li>实际开发中每种分层领域模型都会用到吗？</li></ul><p>本小节我们将重点分析和解答这些问题。</p><h4 id="1-4-2-分层模型"><a href="#1-4-2-分层模型" class="headerlink" title="1.4.2-分层模型"></a>1.4.2-分层模型</h4><h5 id="1-常见的分层模型有哪些？含义是什么？"><a href="#1-常见的分层模型有哪些？含义是什么？" class="headerlink" title="1. 常见的分层模型有哪些？含义是什么？"></a>1. 常见的分层模型有哪些？含义是什么？</h5><p>学习和工作经常会接触到分层领域模型，如 DO、BO、DTO、VO 等。其中 DO、BO、DTO、AO、Query 在《手册》给出了一些解释，这里给出一些补充。</p><p>DTO (Data Transger Object) 为数据传输对象，通常将底层的数据聚合传给外部系统，它通常用作 Service 和 Manager 层向上层返回的对象。需要注意的是：如果作为分布式服务的参数或返回对象，通常要实现序列化接口。</p><p>Param 为查询参数对象，适用于各层，通常用作接受前端参数对象。Param 和 Query 的出现是为了避免使用 <code>Map</code> 作为接收参数的对象。</p><p>BO (Bussiness Object) 即业务对象。该对象中通常包含业务逻辑。此对象在实际使用中有不同的理解，有的团队采用领域驱动设计，BO 含有属性和方法（具体可参考领域驱动设计的相关图书）；有的团队将 BO 当做 Service 返回给上层的 “专用 DTO” 使用；而有的团队则当做 Service 层内保存中间信息数据的 “DTO” 或者上下文对象来使用（本文采用这种理解）。</p><p>比如 BO 中可以保存中间状态，放一些逻辑等，这些并不适合放在 <code>DTO</code> 中：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ItemBO</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Boolean isOnSell<span class="token punctuation">;</span>    <span class="token keyword">private</span> Boolean hasStock<span class="token punctuation">;</span>    <span class="token keyword">private</span> Boolean hasSensitiveWords<span class="token punctuation">;</span>    <span class="token keyword">public</span> Boolean <span class="token function">isLegal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>isOnSell <span class="token operator">==</span> null <span class="token operator">||</span> hasStock <span class="token operator">==</span> null <span class="token operator">||</span> hasSensitiveWords <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> isOnSell <span class="token operator">&amp;&amp;</span> hasStock <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasSensitiveWords<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>VO (View Object) 为视图对象，通常作为控制层通过 JSON 返回给前端然后前端渲染或者加载页面模板在后端进行填充。</p><p>AO (Application Object) 应用对象。通常用在控制层和服务层之间。有些团队会将前端查询的属性和保存的属性几乎一致的对象封装为 AO，如读取用户属性传给前端，用户在前端编辑了用户属性后传回后端。这种用法将 AO 用作 Param 和 VO 或 Param 和 DTO 的组合。</p><h5 id="2-为什么要有分层领域模型？"><a href="#2-为什么要有分层领域模型？" class="headerlink" title="2. 为什么要有分层领域模型？"></a>2. 为什么要有分层领域模型？</h5><p>还有的朋友查询参数喜欢通过 <code>Map</code> 或者 <code>JSONObject</code> 来封装。有些朋友可能会认为这么多模型没有必要，因为通常各层模型的属性基本相同，而且各种类型的分层模型对象转换非常麻烦。</p><p>使用不同的分层领域模型能够让程序更加健壮、更容易拓展，可以降低系统各层的耦合度。</p><p>分层模型的优势只有在系统较大时才体现得更加明显。设想一下如果我们不想定义 DTO 和 VO，直接将 DO 用到数据访问层、服务层、控制层和外部访问接口上。此时该表删除或则修改一个字段，DO 必须同步修改，这种修改将会影响到各层，这并不符合高内聚低耦合的原则。通过定义不同的 DTO 可以控制对不同系统暴露不同的属性，通过属性映射还可以实现具体的字段名称的隐藏。不同业务使用不同的模型，当一个业务发生变更需要修改字段时，不需要考虑对其它业务的影响，如果使用同一个对象则可能因为 “不敢乱改” 而产生很多不优雅的兼容性行为。</p><p>如果我们不愿意定义 Param 对象，使用 Map 来接收前端的参数，获取时如果采用 JSON 反序列化，则可能出现上一节所讲到的反序列化类型丢失问题。如果我们不使用 Query 对象而是 <code>Map</code> 对象来封装 DAO 的参数，设置和获取的 <code>key</code> 很可能因为粗心导致设置和获取时的 key 不一致而出现 BUG。</p><h4 id="1-4-3-开发中的应用"><a href="#1-4-3-开发中的应用" class="headerlink" title="1.4.3-开发中的应用"></a>1.4.3-开发中的应用</h4><p>讲完了概念和优势，大家可能会认为文字描述有些抽象，接下来通过查询和返回两个视角为大家展示实际项目中的一种常见的用法（贫血模型）。</p><h5 id="1-查询视图"><a href="#1-查询视图" class="headerlink" title="1. 查询视图"></a>1. 查询视图</h5><p>我们先从请求访问的视角去了解不同分层数据模型在实际项目中一种常见用法。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E6%9F%A5%E8%AF%A2%E8%A7%86%E5%9B%BE.jpeg" alt="查询视图"></p><p>前端或者其它服务将 <code>Param</code> 对象作为参数传给控制层或者对外服务接口，然后调用内部的服务类，服务类内部的中间数据和这些数据相关的逻辑可以封装为 <code>BO</code> ，比如根据 <code>BO</code> 多个属性判断是否符合某个条件。</p><p>如果查询数据则封装为 <code>Query</code> 对象作为参数，如果需要查询其它依赖，则可以封装 <code>Param</code> 对象作为参数去查询。<code>DAO</code> 层一般插入和更新的参数对象使用 <code>DO</code> 或 <code>Param</code>, 查询参数一般使用 <code>Query</code>，删除参数一般使用 <code>Param</code>。</p><h5 id="2-返回视图"><a href="#2-返回视图" class="headerlink" title="2. 返回视图"></a>2. 返回视图</h5><p>接下来我们从数据返回的视角去了解分层领域模型在实际项目中的一种常见用法：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E8%BF%94%E5%9B%9E%E8%A7%86%E5%9B%BE.jpeg" alt="返回视图"></p><p>数据访问层通常将数据封装为 <code>DO</code> 对象传给 <code>Service</code> 层，<code>Manager</code> 或 <code>Client</code> 层往往将查询结果封装为 <code>DTO</code> 传给 <code>Service</code> 层。</p><p>通常内部服务层通过 <code>DTO</code> 往外传输数据。<code>Controller</code> 通常将 <code>DTO</code> 组装为前端需要的 <code>VO</code> 或者直接将 <code>DTO</code> 外传 。</p><p>RPC 服务接口将 <code>DTO</code> 直接返回或者重新封装为新的 <code>DTO</code> 返回给外部服务。</p><p>另外即使同一个接口，但是一个对内使用，一个对外暴露，尽量使用不同接口，定义不同的参数和返回值，从而避免因为修改内部或外部的数据结构而导致另外一个受到影响，这也是单一职责原则的要求。</p><blockquote><p><strong>单一职责原则</strong>：一个类应该有且只有一个改变的理由。</p></blockquote><p>也有部分团队 RPC 的请求和响应参数都通过 DTO 来承载，通过 <code>XXRequestDTO</code> 和 <code>XXResponseDTO</code> 来表示。</p><p>实践分层领域模型能够提高项目的健壮性、可拓展性和可维护性，降低了系统内部各层的耦合度。</p><p>上面只是给出一种参考，很多团队对部分分层模型的理解会有差异，实际的使用过程中根据自己团队的规模可以适当变通。比如有很多团队项目并不是特别大，为了降低复杂度，只用到了 <code>DTO</code> 、<code>VO</code> 、<code>DO</code> 三种分层领域模型。</p><p>最后对分层领域模型的规约这里进行补充：</p><p><strong>【参考】不提倡在 DTO 中写逻辑，强制不要在 RPC 返回对象的 DTO 中封装逻辑。</strong></p><p>有些团队的个别成员会将根据成员属性作判断的一些函数写到 DTO 中，最奇葩的是该逻辑还主要供内部系统业务层使用。</p><p>如:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">xxDTO</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 各种属性</span><span class="token comment" spellcheck="true">// 逻辑代码</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span>  <span class="token function">canXXX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 各种判断</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这样造成系统的耦合性非常强。</p><p>如果对方用到了这个函数，未来此函数的内部逻辑必须发生变化，未必能及时通知对方升级，容易造成 BUG。</p><p>即使耗费了成本找到了使用方，为了你的功能，让别人被迫升级版本重新上线也是非常不专业的事情。</p><p>显然这样做不合理。</p><blockquote><p>试想一下今天 A 部门告诉你他们因某个功能被迫修改了某个 RPC 返回值 DTO 的某个方法，你们用到没有？用到升级一下哈…</p><p>然后 B 部门的人明天告诉你同样的话，然后 C 部门，然后…</p><p>你会不会崩溃？</p></blockquote><p>建议如果需要在内部业务中写对实体相关的逻辑，可以考虑封装到工具类 / 帮助类中。</p><h4 id="1-4-4-总结"><a href="#1-4-4-总结" class="headerlink" title="1.4.4-总结"></a>1.4.4-总结</h4><p>本节主要讲分层模型的目的和优势以及在实际开发中的常见用法。给大家一个参考，让大家能够在开发时知道哪些模型应该放到哪一层。</p><p>下一节将讲述不同的分层领域模型之间的转换的正确姿势。</p><h3 id="1-5-Java属性映射的正确姿势"><a href="#1-5-Java属性映射的正确姿势" class="headerlink" title="1.5-Java属性映射的正确姿势"></a>1.5-Java属性映射的正确姿势</h3><h4 id="1-5-1-前言"><a href="#1-5-1-前言" class="headerlink" title="1.5.1-前言"></a>1.5.1-前言</h4><p>前一节讲到项目为了更容易维护，易于拓展等原因会使用各种分层领域模型。在多层应用中，常需要对各种不同的分层对象进行转换，这就会存在一个非常棘手的问题即：编写不同的模型之间相互转换的代码非常麻烦。其中最常见和最简单的方式是编写对象属性转换函数，即普通的 Getter/Setter 方法。除此之外各种各种属性映射工具。</p><ul><li>那么常见的 Java 属性映射工具有哪些？</li><li>它们的原理以及对其性能怎样？</li><li>实际开发中该如何选择？</li></ul><p>本节将给出解答。</p><h4 id="1-5-2-常见的-Java-属性映射的工具及其原理"><a href="#1-5-2-常见的-Java-属性映射的工具及其原理" class="headerlink" title="1.5.2-常见的 Java 属性映射的工具及其原理"></a>1.5.2-常见的 Java 属性映射的工具及其原理</h4><h5 id="1-常见的-Java-属性映射工具"><a href="#1-常见的-Java-属性映射工具" class="headerlink" title="1. 常见的 Java 属性映射工具"></a>1. 常见的 Java 属性映射工具</h5><p>常见的 Java 属性映射工具有以下几种：</p><ol><li><code>org.apache.commons.beanutils.BeanUtils#copyProperties</code></li><li><code>org.springframework.beans.BeanUtils#copyProperties(java.lang.Object, java.lang.Object)</code></li><li><code>org.dozer.Mapper#map(java.lang.Object, java.lang.Class)</code></li><li><code>net.sf.cglib.beans.BeanCopier#copy</code></li><li><code>ma.glasnost.orika.MapperFacade#map(S, D)</code></li><li><code>mapstruct</code></li></ol><h5 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h5><p>1、Getter/Setter 方式使用原生的语法，虽然简单但是手动编写非常耗时；</p><p>2、通过 <a href="https://mvnrepository.com/artifact/net.sf.dozer/dozer/5.5.1" target="_blank" rel="noopener">dozer 的 maven 依赖</a>可以看出，dozer 并没有使用字节码增强技术，因为并没有引用任何字节码增强技术的 jar 包；</p><p>我们再从其核心类 <code>org.dozer.MappingProcessor</code> 中寻找线索：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Array<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Modifier<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>我们可以断定，dozer 使用的是反射机制。</p><p>3、同样的 commons 和 Spring 的 <code>BeanUtil</code> 工具类也采用的是反射方式。优点是两个是非常常用的类库，不需要引用更多复杂的包；</p><p>4、cglib 的 <code>BeanCopier</code> 的原理是不是也是反射机制呢？</p><p>我们可以通过 <a href="https://mvnrepository.com/artifact/cglib/cglib/3.2.12" target="_blank" rel="noopener">cglib 的 maven 库</a>的编译依赖中找到线索：</p><p>![cglib 的 maven 库](cglib 的 maven 库.jpeg)</p><p>发现该库依赖了 asm ，我们去 <a href="https://asm.ow2.io/" target="_blank" rel="noopener">asm 官网</a>可以看到它的介绍：</p><blockquote><p>asm 库是一个 Java 字节码操作和分析框架，它可以用来修改已经存在的字节码或者直接二进制形式动态生成 class 文件。asm 的特点是小且快。</p></blockquote><p>同样的，我们可以通过 <a href="https://mvnrepository.com/artifact/ma.glasnost.orika/orika-core/1.5.4" target="_blank" rel="noopener">orika 的 maven 库</a>得到其实现依赖的核心技术：</p><p>![orika 的 maven 库](orika 的 maven 库.jpeg)</p><p>其中 javassist 我们知道它是一个字节码操作工具。</p><p>我们去<a href="https://asm.ow2.io/" target="_blank" rel="noopener">它的</a><a href="http://www.javassist.org/" target="_blank" rel="noopener">官网</a>看下介绍：</p><blockquote><p>javassist 让操作字节码非常容易。javassist 允许 java 程序运行时定义一个新的类，也可以实现在 JVM 加载类文件时修改它。javassist 提供两种级别的 API ，一种是源码级别；一种是字节码级别。使用源码级别的 API，无需对 java 字节码特定知识有深入的了解就可以轻松修改类文件。字节码级别的 API 则允许用户直接修改类文件。</p></blockquote><p>6、通过 <a href="https://mapstruct.org/" target="_blank" rel="noopener">MapStruct 的官网</a>的介绍我们可以看出，mapstruct 采用原生的方法调用，因此更快速，更安全也更容易理解。根据官网的介绍我们知道，使用时只需要使用它的注解，定义好转换接口，转换函数，编译时会自动生成转换工具的实现类、调用属性赋值和取值函数实现转换。mapstruct 还支持通过注解形式定义不同属性名的映射关系等，功能很强大。</p><p>转换代码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>    UserMapper INSTANCE <span class="token operator">=</span> <span class="token punctuation">(</span>UserMapper<span class="token punctuation">)</span>Mappers<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    UserDTO <span class="token function">userDo2Dto</span><span class="token punctuation">(</span>UserDO var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>编译后生成自动的转换接口的实现类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserMapperImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">UserMapperImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> UserDTO <span class="token function">userDo2Dto</span><span class="token punctuation">(</span>UserDO userDO<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>userDO <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            UserDTO userDTO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            userDTO<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>userDO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            userDTO<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>userDO<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            userDTO<span class="token punctuation">.</span><span class="token function">setNickName</span><span class="token punctuation">(</span>userDO<span class="token punctuation">.</span><span class="token function">getNickName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            userDTO<span class="token punctuation">.</span><span class="token function">setBirthDay</span><span class="token punctuation">(</span>userDO<span class="token punctuation">.</span><span class="token function">getBirthDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> userDTO<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>大大简化了代码。</p><p>官方还提供了非常详细的<a href="https://mapstruct.org/documentation/reference-guide/" target="_blank" rel="noopener">参考文档</a> 和使用范例，提供了很多高级用法。</p><h5 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a>3. 性能</h5><p>接下来按照惯例，我们对比一下它们的性能。</p><p>我们在 <code>com.imooc.basic.converter.UserConverterTest</code> 类中对上面的常见对象转换方式进行单测 <code>UserDO</code> 对象：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDO</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String nickName<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthDay<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>目标对象：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDTO</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token keyword">private</span> String nickName<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birthDay<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用 easyrandom（后面的单元测试环节会重点介绍）构造 10 万个 <code>UserDO</code> 随机对象进行性能对比。spring 版本为 5.1.8.RELEASE，dozer 版本为 5.5.1，orika-core 版本为 1.5.4，cglib 版本为 3.2.12，commons-lang3 包版本为 3.9，10 次运行取平均值，最终结果如下：</p><ol><li>普通 Getter/Setter 耗时 365ms；</li><li><code>org.apache.commons.beanutils.BeanUtils#copyPropertie</code> 耗时 9s273ms；</li><li><code>org.springframework.beans.BeanUtils#copyProperties(java.lang.Object, java.lang.Object)</code> 耗时 2s327ms；</li><li><code>org.dozer.Mapper#map(java.lang.Object, java.lang.Class)</code> 耗时 9s271ms；</li><li><code>ma.glasnost.orika.MapperFacade#map(S, D)</code> 耗时 837ms；</li><li><code>net.sf.cglib.beans.BeanCopier#copy</code> 耗时 409ms；</li><li>MapStruct 393ms。</li></ol><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.jpeg" alt="属性映射性能对比"></p><p>由于机器的性能不同结果会有偏差，本实验并没有将转换框架的功能发挥到到极致，也没有使用更复杂的对象进行对比，因此本实验的结果仅作为一个大致的参考。</p><p>我们仍然可以大致可以得出结论：采用字节码增强技术的 Java 属性转换工具和普通的 Getter/Setter 方法性能相差无几，甚至比 Getter/Setter 效率还高，反射的性能相对较差。</p><p>因此从性能来讲首推 Getter/Setter 方式（含 MapStruct），其次是 cglib。</p><h4 id="1-5-3-用哪个？为什么？怎么用？"><a href="#1-5-3-用哪个？为什么？怎么用？" class="headerlink" title="1.5.3-用哪个？为什么？怎么用？"></a>1.5.3-用哪个？为什么？怎么用？</h4><h5 id="1-用什么？为什么？"><a href="#1-用什么？为什么？" class="headerlink" title="1. 用什么？为什么？"></a>1. 用什么？为什么？</h5><p>通过以上的分析，我们对 Java 属性转换有了一个基本的了解。</p><p><strong>选择太多往往会比较纠结，实际开发中我们用哪种更好呢？</strong></p><p>我在业务代码中见到同事用的转换工具主要有 Getter/Setter 方式、 orika 和 commons/spring 的属性拷贝工具。</p><p><strong>属性转换工具的优势</strong>：用起来方便，往往一行行代码就实现多属性的转换，而且属性不对应可以通过注解或者修改配置方式自动适配，功能非常强大。</p><p><strong>属性转换工具的缺点</strong>：</p><ol><li>多次对象映射（从 A 映射到 B，再从 B 映射到 C）如果属性不完全一致容易出错；</li><li>有些转换工具，属性类型不一致自动转换容易出现意想不到的 BUG；</li><li>基于反射和字节码增强技术的映射工具实现的映射，对一个类属性的修改不容易感知到对其它转换类的影响。</li></ol><p><strong>我们可以想想这样一个场景</strong>：</p><blockquote><p>一个 <code>UserDO</code> 如果属性超多，转换到 <code>UserDTO</code> 再被转换成 <code>UserVO</code> 。如果你修改 <code>UserDTO</code> 的一个属性命名，其它类待映射的类新增的对应属性有一个字母写错了，编译期间不容易发现问题，造成 BUG。</p><p>如果使用原始的 Getter/Setter 方式转换，修改了 <code>UserDO</code> 的属性，那么转换代码就会报错，编译都不通过，这样就可以逆向提醒我们注意到属性的变动的影响。</p></blockquote><p><strong>因此强烈建议使用定义转换类和转换函数，使用插件实现转换，不需要引入其它库，降低了复杂性，可以支持更灵活的映射。</strong></p><p>大家可以想想这种场景：</p><blockquote><p>如果一个 A 映射到 B，B 有两个属性来自 C，一个属性来自于传参或者计算等。</p></blockquote><p>此时自定义转换函数就更方便。</p><p><strong>如果使用属性映射工具推荐使用 MapStruct，更安全一些，转换效率也很高。</strong></p><h5 id="2-怎么用？"><a href="#2-怎么用？" class="headerlink" title="2. 怎么用？"></a>2. 怎么用？</h5><p>每种对象属性映射工具的具体用法，大家可以参考官网文档或源码中的测试类，这里主要讲映射的工具类该如何定义。</p><p>为了避免转换函数散落到多个业务类中，不容易复用，我们可以在工具包或者对象包下定义一个专门的转换包（converter 或者 mapper 包），在转换的包下编写转换工具类。</p><p><strong>第一种方式</strong>：可以实现 <code>org.springframework.core.convert.converter.Converter</code> 接口。</p><p>代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>convert<span class="token punctuation">.</span>converter<span class="token punctuation">.</span>Converter<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDO2DTOConverter</span> <span class="token keyword">implements</span> <span class="token class-name">Converter</span><span class="token operator">&lt;</span>UserDO<span class="token punctuation">,</span> UserDTO<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> UserDTO <span class="token function">convert</span><span class="token punctuation">(</span>UserDO source<span class="token punctuation">)</span> <span class="token punctuation">{</span>        UserDTO userDTO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDTO<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDTO<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDTO<span class="token punctuation">.</span><span class="token function">setNickName</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getNickName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDTO<span class="token punctuation">.</span><span class="token function">setBirthDay</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getBirthDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> userDTO<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述只能实现单向转换，<strong>我们如果想双向转换该怎么做呢？</strong></p><p>这时候我们可以采用<strong>第二种方式</strong>，可以继承 <code>com.google.common.base.Converter</code> 接口实现双向转换。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>converter<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>UserDO<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>converter<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>UserDTO<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>common<span class="token punctuation">.</span>base<span class="token punctuation">.</span>Converter<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserDO2DTOConverter</span> <span class="token keyword">extends</span> <span class="token class-name">Converter</span><span class="token operator">&lt;</span>UserDO<span class="token punctuation">,</span> UserDTO<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> UserDTO <span class="token function">doForward</span><span class="token punctuation">(</span>UserDO userDO<span class="token punctuation">)</span> <span class="token punctuation">{</span>        UserDTO userDTO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDTO<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>userDO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDTO<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>userDO<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDTO<span class="token punctuation">.</span><span class="token function">setNickName</span><span class="token punctuation">(</span>userDO<span class="token punctuation">.</span><span class="token function">getNickName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDTO<span class="token punctuation">.</span><span class="token function">setBirthDay</span><span class="token punctuation">(</span>userDO<span class="token punctuation">.</span><span class="token function">getBirthDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> userDTO<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> UserDO <span class="token function">doBackward</span><span class="token punctuation">(</span>UserDTO userDTO<span class="token punctuation">)</span> <span class="token punctuation">{</span>        UserDO userDO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDO<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDO<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDO<span class="token punctuation">.</span><span class="token function">setNickName</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">.</span><span class="token function">getNickName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDO<span class="token punctuation">.</span><span class="token function">setBirthDay</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">.</span><span class="token function">getBirthDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> userDO<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>我更建议采用以下这种方式，因为上述方式只能实现单向或者双向转换，如果更多种对象类型的转换就无能为力。</p><p>此时可以自定义接口或者抽象类，支持更多种对象的转换。</p><p>更推荐大家直接定义某个对象的转换器类，在其内部编写该对象各层对象的转换函数：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserConverter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> UserDTO <span class="token function">convertToDTO</span><span class="token punctuation">(</span>UserDO source<span class="token punctuation">)</span> <span class="token punctuation">{</span>        UserDTO userDTO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDTO<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDTO<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDTO<span class="token punctuation">.</span><span class="token function">setNickName</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getNickName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDTO<span class="token punctuation">.</span><span class="token function">setBirthDay</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getBirthDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> userDTO<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> UserDO <span class="token function">convertToDO</span><span class="token punctuation">(</span>UserDO source<span class="token punctuation">)</span> <span class="token punctuation">{</span>        UserDO userDO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserDO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDO<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDO<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDO<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDO<span class="token punctuation">.</span><span class="token function">setNickName</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getNickName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userDO<span class="token punctuation">.</span><span class="token function">setBirthDay</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">getBirthDay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> userDO<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 转换成UserVO等</span><span class="token punctuation">}</span></code></pre><p>有些同学可能会抱怨，<strong>Getter/Setter 方式转换函数编写非常耗时而且容易漏，怎么办？</strong></p><p>这里推荐一个 IDEA 插件：<strong>GenerateAllSetter</strong> 或者 <strong>GenerateO2O</strong>。</p><p>定义好转换函数之后，鼠标放在 <code>convertToDTO</code> 上使用快捷键，选择 “generate setter getter converter” 即可实现根据目标对象的属性名适配同名源对象自动填充，注意如果有个别属性不对应，需手动转换。</p><p><strong>另外推荐使用 mapstruct 实现对象属性映射</strong>：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>    UserMapper INSTANCE <span class="token operator">=</span> Mappers<span class="token punctuation">.</span><span class="token function">getMapper</span><span class="token punctuation">(</span>UserMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    UserDTO  <span class="token function">userDo2Dto</span><span class="token punctuation">(</span>UserDO userDO<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用时一行代码即可搞定：</p><pre class=" language-java"><code class="language-java">UserDTO userDTO <span class="token operator">=</span> UserMapper<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">.</span><span class="token function">userDo2Dto</span><span class="token punctuation">(</span>userDO<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>相当于把 IDE 插件自动生成的这部分任务改为了使用注解，通过插件编译时自动生成。</p><h4 id="1-5-4-总结"><a href="#1-5-4-总结" class="headerlink" title="1.5.4-总结"></a>1.5.4-总结</h4><p>本节主要介绍了 Java 属性映射的各种方式，介绍了每种方式背后的原理，并简单对比了各种属性映射方式的耗时。本小节还给出了属性转换工具的推荐定义方式。希望大家在实际的开发中，除了考虑性能外，兼顾考虑安全性和可维护性。</p><p>下节将介绍过期代码的正确处理方式。</p><h3 id="1-6-过期类、属性、接口的正确处理姿势"><a href="#1-6-过期类、属性、接口的正确处理姿势" class="headerlink" title="1.6-过期类、属性、接口的正确处理姿势"></a>1.6-过期类、属性、接口的正确处理姿势</h3><h4 id="1-6-1-前言"><a href="#1-6-1-前言" class="headerlink" title="1.6.1-前言"></a>1.6.1-前言</h4><p>《手册》第 7 页对于过时类有这样一句描述 <a href="https://www.imooc.com/read/55/article/1144#fn1" target="_blank" rel="noopener">1</a>：</p><blockquote><p>接口过时必须加 @Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。<br>接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</p></blockquote><p>那么我们要思考为什么要这么做呢？这个指导原则如何更好地落地呢？</p><h4 id="1-6-2-为什么要这样做？"><a href="#1-6-2-为什么要这样做？" class="headerlink" title="1.6.2-为什么要这样做？"></a>1.6.2-为什么要这样做？</h4><p>如果有机会进入一个大一点的公司，而且你是一个有追求的人，你可能会遇到下面几种情况。</p><ul><li>当你接手一个服务，看到某个类、属性、函数被标注为 @Deprecated 但是没有注释的时候，内心是崩溃的；</li><li>当你对接二方服务，升级 jar 包后发现使用的接口被标记为废弃但是没注释时，内心也是崩溃的；</li><li>当你看到同事封装的一些工具类使用了一些被废弃的类时，你的内心同样同样是崩溃的。不改放在那看着难受，改又无故得耗费自己的时间，而且还怕改出 BUG。</li></ul><p>试想一下，如果你接手一个服务里面的类、属性和函数要被废弃了连 @Deprecated 都不加，是不是很容易 “放心” 使用进而被坑？</p><p>如果被标注为 <code>@Deprecated</code> ，给出注释说明为什么被废弃，新的接口是什么，心里会不会更踏实？</p><p>如果对接的二方服务 jar 包升级以后发现，使用的接口被废弃且给出详细的告诉你改用哪个新接口，是不是心里更有底？</p><p>试想一下如果我们每个人都能遵守这种规约，封装工具类时遇到过时的类，主动去学习并使用新的替换类，是不是就不会好很多？</p><h4 id="1-6-3-如何落实？"><a href="#1-6-3-如何落实？" class="headerlink" title="1.6.3-如何落实？"></a>1.6.3-如何落实？</h4><p>那么，说了这么多，究竟该如何落地呢？<br>我认为：最好的学习方式之一就是找一些优秀的源码相关的示例进行学习。</p><h5 id="1-JDK-的类或常见三方库"><a href="#1-JDK-的类或常见三方库" class="headerlink" title="1. JDK 的类或常见三方库"></a>1. JDK 的类或常见三方库</h5><p>我们以 JDK 中的 <code>URLEncoder</code> 和 <code>URLDecoder</code> 为例介绍如何写过期函数的注释和如何替换该过期函数：</p><pre class=" language-java"><code class="language-java">String url <span class="token operator">=</span> <span class="token string">"xxx"</span><span class="token punctuation">;</span>String encode <span class="token operator">=</span> URLEncoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"URL编码结果："</span> <span class="token operator">+</span> encode<span class="token punctuation">)</span><span class="token punctuation">;</span>String decode <span class="token operator">=</span> URLDecoder<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encode<span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"URL解码结果："</span> <span class="token operator">+</span> decode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在 IDEA 中编写如上代码时候，<code>java.net.URLEncoder#encode(java.lang.String)</code> 和 <code>java.net.URLDecoder#decode(java.lang.String)</code> 会有删除的标志，便表示该函数已经过期。</p><p>那么如何找到新函数和修改呢？</p><p>我们进到源码里查看:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Decodes a {@code x-www-form-urlencoded} string. * The platform's default encoding is used to determine what characters * are represented by any consecutive sequences of the form * "&lt;i>{@code %xy}&lt;/i>". * @param s the {@code String} to decode * @deprecated The resulting string may vary depending on the platform's *          default encoding. Instead, use the decode(String,String) method *          to specify the encoding. * @return the newly decoded {@code String} */</span><span class="token annotation punctuation">@Deprecated</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">decode</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    String str <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        str <span class="token operator">=</span> <span class="token function">decode</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> dfltEncName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsupportedEncodingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// The system should always have the platform default</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> str<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在 <code>@deprecated</code> 的注释里我们找到了答案：“The resulting string may vary depending on the platform’s default encoding.（解析结果的字符串和系统的默认字符编码强关联）”，并给出了替代函数的说明 “Instead, use the <code>decode(String,String)</code> method to specify the encoding.（使用 <code>decode(String,String)</code> 函数来指定字符串编码）”</p><p>因此我们提供新的接口，就得接口要废弃时也可以参考这里<strong>写上废弃的原因以及替代的新接口</strong>。</p><p>我们还可以通过 <a href="https://www.codota.com/code/query" target="_blank" rel="noopener">codota</a> 来搜索（建议在 IDEA 安装插件，使用更方便）看常见类库的常见函数的用法，甚至可以看到某些函数的使用概率：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/codota.jpeg" alt="codota"></p><p>搜索我们想要的类和方法：<a href="https://www.codota.com/code/query/java.net@URLEncoder@encode" target="_blank" rel="noopener">URLEncoder.encode</a>，即可得到 github 优秀的开源框架或 stackoverflow 中相关优秀范例。根据相关的优秀代码范例进行修改。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/URLEncoder.jpeg" alt="URLEncoder"></p><p>我们改用新的函数：</p><pre class=" language-java"><code class="language-java">    String url <span class="token operator">=</span> <span class="token string">"xxx"</span><span class="token punctuation">;</span>    String encode <span class="token operator">=</span> URLEncoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> Charsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"URL编码结果："</span> <span class="token operator">+</span> encode<span class="token punctuation">)</span><span class="token punctuation">;</span>    String decode <span class="token operator">=</span> URLDecoder<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encode<span class="token punctuation">,</span> Charsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"URL解码结果："</span> <span class="token operator">+</span> decode<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>对类似废弃的接口的改动，最好要使用单元测试进行验证：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 新旧两种接口对比 * * @throws UnsupportedEncodingException */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testURLUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> UnsupportedEncodingException <span class="token punctuation">{</span>    String url <span class="token operator">=</span> <span class="token string">"http://www.imooc.com/test?name=张三"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 旧的函数</span>    String encodeOrigin <span class="token operator">=</span> URLEncoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>    String decodeOrigin <span class="token operator">=</span> URLDecoder<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encodeOrigin<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新的函数</span>    String encodeNew <span class="token operator">=</span> URLEncoder<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> Charsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String decodeNew <span class="token operator">=</span> URLDecoder<span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encodeNew<span class="token punctuation">,</span> Charsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 结果对比</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>encodeOrigin<span class="token punctuation">,</span> encodeNew<span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>decodeOrigin<span class="token punctuation">,</span> decodeNew<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果是常见的<strong>三方库</strong>，也可以采用类似的步骤，一般都很快解决问题。</p><p>如我们发现下面的函数被废弃，进入到源码中查看：</p><pre><code>org.springframework.util.Assert#doesNotContain(java.lang.String, java.lang.String)/** * @deprecated as of 4.3.7, in favor of {@link #doesNotContain(String, String, String)} */@Deprecatedpublic static void doesNotContain(String textToSearch, String substring) {   doesNotContain(textToSearch, substring,         &quot;[Assertion failed] - this String argument must not contain the substring [&quot; + substring + &quot;]&quot;);}</code></pre><p>直接通过点击 <code>{@link #doesNotContain(String, String, String)</code> 可以快速进入新的替代函数去查看。</p><p>从这里例子我们还学到了一个新的技巧，如果是二方库或者三方库，废弃的属性、函数在注释中除了可以写原因和替代函数外，可以标注从哪个版本被标注为废弃。替代函数可以使用 <code>{@link}</code> 方式，更便捷和优雅。</p><p>再回顾上面 <code>java.net.URLDecoder#decode(java.lang.String)</code> 的注释就没有提供这种方式，跳转就不够方便。</p><p>另外大家还可以学习一下 <code>@see</code> 的用法，以及 <code>@see</code> 和 <code>{@link}</code> 的区别，后面专栏也会对注释做专门的讲解。</p><p>我们从这个例子还可以看到注释中并没有说明废弃的原因，作为读者你会发现有些摸不着头脑，心里嘀咕 “为啥被废弃？”。</p><p>通过替换函数以及注释我们可以猜测废弃的原因是：” 默认的提示文本不够优雅 “且即使断言通过，第三个参数字符串拼接仍然会执行，造成不必要字符串连接操作。这点有点类似于日志中不建议使用字符串拼接当做日志内容（可以采用占位符的方式）。</p><p>新的替换函数的注释除了给出功能介绍外，也给出了使用的范例：</p><pre class=" language-java"><code class="language-java">Assert<span class="token punctuation">.</span><span class="token function">doesNotContain</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"rod"</span><span class="token punctuation">,</span> <span class="token string">"Name must not contain 'rod'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里给我们带来的启发是，<strong>写工具类时如果能再注释上添加一些范例和结果，则会极大方便使用者</strong>。</p><p>这点在 <code>commons-lang3</code> 和 <code>guava</code> 等开源工具库中随处可见，值得我们学习。</p><p>随手选取一个例子，大家感受一下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * &lt;p>Strips whitespace from the start and end of a String  returning * {@code null} if the String is empty ("") after the strip.&lt;/p> * * &lt;p>This is similar to {@link #trimToNull(String)} but removes whitespace. * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p> * * &lt;pre> * StringUtils.stripToNull(null)     = null * StringUtils.stripToNull("")       = null * StringUtils.stripToNull("   ")    = null * StringUtils.stripToNull("abc")    = "abc" * StringUtils.stripToNull("  abc")  = "abc" * StringUtils.stripToNull("abc  ")  = "abc" * StringUtils.stripToNull(" abc ")  = "abc" * StringUtils.stripToNull(" ab c ") = "ab c" * &lt;/pre> * * @param str  the String to be stripped, may be null * @return the stripped String, *  {@code null} if whitespace, empty or null String input * @since 2.0 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">stripToNull</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    str <span class="token operator">=</span> <span class="token function">strip</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> null <span class="token operator">:</span> str<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对于常见的三方库，还有一个不错的技巧：我们可以从 github 上拉取其源代码，然后找到某个类对应的单元测试类中，在单元测试模块可以找到对应的参考用法。还可以在源码中打断点，进行深入研究。希望大家可以亲自实践，会有更加深刻的体会。</p><h5 id="2-二方库"><a href="#2-二方库" class="headerlink" title="2. 二方库"></a>2. 二方库</h5><p>作为接口的使用者，如果使用二方库，发现使用的功能被标注为废弃。</p><p>如果是 maven 项目可以通过 maven 命令拉取其源码和 javadoc。</p><pre><code>mvn dependency:sources -DdownloadSources=true -DdownloadJavadocs=true</code></pre><p>如果是 gradle 项目，也可以使用插件下载源码，查看其将被废弃的原因。</p><p>如果没有标注原因并给出替代方案，或给出的注释不够详细，建议直接和二方包的提供者联系，及早替换。</p><p>二方库的工具类替换成新的接口也必须要通过单测，并对涉及的功能进行回归。</p><h5 id="3-自己库"><a href="#3-自己库" class="headerlink" title="3. 自己库"></a>3. 自己库</h5><p>作为接口或对象的提供者，废弃的类、属性、函数加上废弃的原因和替代方案。</p><p>如 RPC 订单常见接口的 <code>OrderCreateParam</code> 参数类的 JSON 类型参数：<code>orderItemDetail</code> 要替换成列表 <code>orderItemParams</code> 下面的属性类型进行替换：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderCreateParam</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 对象详情     * 参考示例：'[{"count":22,"name":"商品1"},{"count":33,"name":"商品2"}]'     * &lt;p>     * 废弃原因：订单详情由JSON传参，改为对象传参。     * 替代方案： {@link com.imooc.basic.deprecated.OrderCreateParam#orderItemParams}     */</span>    <span class="token annotation punctuation">@Deprecated</span>    <span class="token keyword">private</span> String orderItemDetail<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>OrderItemParam<span class="token operator">></span> orderItemParams<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 其他属性</span><span class="token punctuation">}</span></code></pre><p>自己类的变动要通过单元测试进行验证：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testOriginAndNew</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    OrderCreateParam orderCreateParamOrigin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderCreateParam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 原始JSON属性</span>    orderCreateParamOrigin<span class="token punctuation">.</span><span class="token function">setOrderItemDetail</span><span class="token punctuation">(</span><span class="token string">"[{\"count\":22,\"name\":\"商品1\"},{\"count\":33,\"name\":\"商品2\"}]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    OrderCreateParam orderCreateParamNew <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderCreateParam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新的对象属性</span>    List<span class="token operator">&lt;</span>OrderItemParam<span class="token operator">></span> orderItemParamList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    OrderItemParam orderItemParam <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderItemParam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    orderItemParam<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"商品1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    orderItemParam<span class="token punctuation">.</span><span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    orderItemParamList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>orderItemParam<span class="token punctuation">)</span><span class="token punctuation">;</span>    OrderItemParam orderItemParam2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderItemParam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    orderItemParam2<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"商品2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    orderItemParam2<span class="token punctuation">.</span><span class="token function">setCount</span><span class="token punctuation">(</span><span class="token number">33</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    orderItemParamList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>orderItemParam2<span class="token punctuation">)</span><span class="token punctuation">;</span>    orderCreateParamNew<span class="token punctuation">.</span><span class="token function">setOrderItemParams</span><span class="token punctuation">(</span>orderItemParamList<span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>orderCreateParamNew<span class="token punctuation">.</span><span class="token function">getOrderItemParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> orderCreateParamOrigin<span class="token punctuation">.</span><span class="token function">getOrderItemDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里给出一个简单的模拟范例，实际业务代码中参数的接口还要进行 mock 单元测试（后续章节会有相关介绍），对应接口要根据变动传入不同的参数进行功能测试。</p><p>如如果实际开发中自己需要改动的功能涉及到废弃的类、属性、函数等，且没有详细地注释，无法获知废弃的原因和替代的方案。可以通过 IDEA 的 “annotate” 菜单，或者 “Git” - ”Show History for Selection“ 等来查看添加废弃注解的人员与之联系。避免自己错代码，如果搞明白问题且仍然不能废弃，最好能够主动将废弃的原因和替代的代码补充到注释中。</p><p>如果是三方或二方库，由于作者责任性不强或者职业素养不高，对某个接口标记废弃且没有任何注释时，我们优先在本类中寻找函数签名相似的函数。如果是开源项目或者公司内部可以拉取的项目，可以拉取该项目代码，找到该类查看提交记录，从中寻找线索。</p><p>不管是三方、二方还是自己的项目，对替换废弃的类、属性和方法等进行修改后，一定要通过单元测试去验证功能并且对接口使用的功能进行功能测试。</p><p>如果要删除废弃的属性或接口，一般先提供新的方案通知使用方修改，此时可以在将废弃的接口上加上日志，新旧接口同时运行一段时间后确认无调用再下一个版本中考虑删除接口。</p><p>如果我们能快速找到替代的方案，就可以节省很多时间；如果我们能够充分地测试，就可以平稳替换；如果我们能够介绍清楚废弃的原因，提供新的替代方案，并给出快捷的跳转方式，我们的专业程度就会提高。</p><h4 id="1-6-4-总结"><a href="#1-6-4-总结" class="headerlink" title="1.6.4-总结"></a>1.6.4-总结</h4><p>本节的主要介绍过期类、属性、接口的正确处理姿势，包括添加废弃注解，添加废弃的原因，添加新接口的跳转等方式，还要在替换后对新接口进行测试测试。本小节还介绍了通过查看相关的优秀开源代码、使用 codota 工具来学习相关知识的方法。</p><p>下节我们将学习开发中经常碰到的又爱又恨的空指针，了解其产生的主要原因，学习如何尽可能地避免。</p><h3 id="1-7-空指针引发的血案"><a href="#1-7-空指针引发的血案" class="headerlink" title="1.7-空指针引发的血案"></a>1.7-空指针引发的血案</h3><h4 id="1-7-1-前言"><a href="#1-7-1-前言" class="headerlink" title="1.7.1-前言"></a>1.7.1-前言</h4><p>《手册》的第 7 页和 25 页有两段关于空指针的描述 <a href="https://www.imooc.com/read/55/article/1145#fn1" target="_blank" rel="noopener">1</a>：</p><blockquote><p>【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals。</p><p>【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景:</p><ol><li>返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。</li></ol><p>反例:public int f () { return Integer 对象}， 如果为 null，自动解箱抛 NPE。</p><ol><li>数据库的查询结果可能为 null。</li><li>集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。</li><li>远程调用返回对象时，一律要求进行空指针判断，防止 NPE。</li><li>对于 Session 中获取的数据，建议进行 NPE 检查，避免空指针。</li><li>级联调用 obj.getA ().getB ().getC (); 一连串调用，易产生 NPE。</li></ol></blockquote><p>《手册》对空指针常见的原因和基本的避免空指针异常的方式给了介绍，非常有参考价值。</p><p>那么我们思考以下几个问题：</p><ul><li>如何学习 <code>NullPointerException</code>（简称为 NPE）？</li><li>哪些用法可能造 NPE 相关的 BUG？</li><li>在业务开发中作为接口提供者和使用者如何更有效地避免空指针呢？</li></ul><h4 id="1-7-2-了解空指针"><a href="#1-7-2-了解空指针" class="headerlink" title="1.7.2-了解空指针"></a>1.7.2-了解空指针</h4><h5 id="1-源码注释"><a href="#1-源码注释" class="headerlink" title="1. 源码注释"></a>1. 源码注释</h5><p>前面介绍过源码是学习的一个重要途径，我们一起看看 <code>NullPointerException</code> 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Thrown when an application attempts to use {@code null} in a * case where an object is required. These include: * &lt;ul> * &lt;li>Calling the instance method of a {@code null} object. * &lt;li>Accessing or modifying the field of a {@code null} object. * &lt;li>Taking the length of {@code null} as if it were an array. * &lt;li>Accessing or modifying the slots of {@code null} as if it *     were an array. * &lt;li>Throwing {@code null} as if it were a {@code Throwable} *     value. * &lt;/ul> * &lt;p> * Applications should throw instances of this class to indicate * other illegal uses of the {@code null} object. * * {@code NullPointerException} objects may be constructed by the * virtual machine as if {@linkplain Throwable#Throwable(String, * Throwable, boolean, boolean) suppression were disabled and/or the * stack trace was not writable}. * * @author  unascribed * @since   JDK1.0 */</span><span class="token keyword">public</span><span class="token keyword">class</span> <span class="token class-name">NullPointerException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeException</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 5162710183389028792L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Constructs a {@code NullPointerException} with no detail message.     */</span>    <span class="token keyword">public</span> <span class="token function">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Constructs a {@code NullPointerException} with the specified     * detail message.     *     * @param   s   the detail message.     */</span>    <span class="token keyword">public</span> <span class="token function">NullPointerException</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>源码注释给出了非常详尽地解释：</p><blockquote><p>空指针发生的原因是应用需要一个对象时却传入了 <code>null</code>，包含以下几种情况：</p><ol><li>调用 null 对象的实例方法。</li><li>访问或者修改 null 对象的属性。</li><li>获取值为 null 的数组的长度。</li><li>访问或者修改值为 null 的二维数组的列时。</li><li>把 null 当做 Throwable 对象抛出时。</li></ol></blockquote><p><strong>实际编写代码时，产生空指针的原因都是这些情况或者这些情况的变种。</strong></p><p>《手册》中的另外一处描述</p><blockquote><p>“集合里的元素即使 isNotEmpty，取出的数据元素也可能为 <code>null</code>。”</p></blockquote><p>和第 4 条非常类似。</p><p>如《手册》中的：</p><blockquote><p>“级联调用 obj.getA ().getB ().getC (); 一连串调用，易产生 NPE。”</p></blockquote><p>和第 1 条很类似，因为每一层都可能得到 <code>null</code> 。</p><p>当遇到《手册》中和源码注释中所描述的这些场景时，要注意预防空指针。</p><p>另外通过读源码注释我们还得到了 “意外发现”，JVM 也可能会通过 <code>Throwable#Throwable(String, Throwable, boolean, boolean)</code> 构造函数来构造 <code>NullPointerException</code> 对象。</p><h5 id="2-继承体系"><a href="#2-继承体系" class="headerlink" title="2. 继承体系"></a>2. 继承体系</h5><p>通过源码可以看到 NPE 继承自 <code>RuntimeException</code> 我们可以通过 IDEA 的 “Java Class Diagram” 来查看类的继承体系。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/NullPointerException%E7%9A%84%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB.jpeg" alt="NullPointerException的继承体系"></p><p>可以清晰地看到 NPE 继承自 <code>RuntimeException</code> ，另外我们选取 <code>NoSuchFieldException</code> 和 <code>NoSuchFieldError</code> 和 <code>NoClassDefFoundError</code> ，可以看到 <code>Throwable</code> 的子类型包括 <code>Error</code> 和 <code>Exception</code>, 其中 NPE 又是 <code>Exception</code> 的子类。</p><p>那么为什么 <code>Exception</code> 和 <code>Error</code> 有什么区别？ <code>Excption</code> 又分为哪些类型呢？</p><p>我们可以分别去 <code>java.lang.Exception</code> 和 <code>java.lang.Error</code> 的源码注释中寻找答案。</p><p>通过 <code>Exception</code> 的源码注释我们了解到， <code>Exception</code> 分为两类一种是非受检异常（uncheked exceptions）即 <code>java.lang.RuntimeException</code> 以及其子类；而受检异常（checked exceptions）的抛出需要再普通函数或构造方法上通过 <code>throws</code> 声明。</p><p>通过 <code>java.lang.Error</code> 的源码注释我们了解到，<code>Error</code> 代表严重的问题，不应该被程序 <code>try-catch</code>。编译时异常检测时， <code>Error</code> 也被视为不可检异常（uncheked exceptions）。</p><p>大家可以在 IDEA 中分别查看 <code>Exception</code> 和 <code>Error</code> 的子类，了解自己开发中常遇到的异常都属于哪个分类。</p><p>我们还可以通过《JLS》<a href="https://www.imooc.com/read/55/article/1145#fn2" target="_blank" rel="noopener">2</a> 第 11 章 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-11.html" target="_blank" rel="noopener">Exceptions</a> 对异常进行学习。</p><p>其中在异常的类型这里，讲到：</p><blockquote><p>不可检异常（ <strong>unchecked exception</strong>）包括运行时异常和 error 类。</p><p>可检异常（ <strong>checked exception</strong> ）不属于不可检异常的所有异常都是可检异常。除 RuntimeException 和其子类，以及 Error 类以及其子类外的其他 Throwable 的子类。</p></blockquote><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/Throwable.jpeg" alt="Throwable"></p><p>还有更多关于异常的详细描述，，包括异常的原因、异步异常、异常的编译时检查等，大家可以自己进一步学习。</p><h4 id="1-7-3-空指针引发的血案"><a href="#1-7-3-空指针引发的血案" class="headerlink" title="1.7.3-空指针引发的血案"></a>1.7.3-空指针引发的血案</h4><h5 id="1-最常见的错误姿势"><a href="#1-最常见的错误姿势" class="headerlink" title="1. 最常见的错误姿势"></a>1. 最常见的错误姿势</h5><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Assertions<span class="token punctuation">.</span><span class="token function">assertThrows</span><span class="token punctuation">(</span>NullPointerException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>UserDTO<span class="token operator">></span> users <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span>2L<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            users<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span>3L<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">send</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 第 1 处</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>UserDTO<span class="token operator">></span> users<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>UserDTO userDto <span class="token operator">:</span> users<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">doSend</span><span class="token punctuation">(</span>userDto<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer SOME_TYPE <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSend</span><span class="token punctuation">(</span>UserDTO userDTO<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String target <span class="token operator">=</span> <span class="token string">"default"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 第 2 处</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>userDTO<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>SOME_TYPE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            target <span class="token operator">=</span> <span class="token function">getTarget</span><span class="token punctuation">(</span>userDTO<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"userNo:%s, 发送到%s成功"</span><span class="token punctuation">,</span> userDTO<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> String <span class="token function">getTarget</span><span class="token punctuation">(</span>Integer type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> type <span class="token operator">+</span> <span class="token string">"号基地"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>在第 1 处，如果集合为 <code>null</code> 则会抛空指针；</p><p>在第 2 处，如果 <code>type</code> 属性为 <code>null</code> 则会抛空指针异常，导致后续都发送失败。</p><p>大家看这个例子觉得很简单，看到输入的参数有 <code>null</code> 本能地就会考虑空指针问题，但是自己写代码时你并不知道上游是否会有 <code>null</code>。</p><h5 id="2-无结果仍返回对象"><a href="#2-无结果仍返回对象" class="headerlink" title="2. 无结果仍返回对象"></a>2. 无结果仍返回对象</h5><p>实际开发中有些同学会有一些非常 “个性” 的写法。</p><p>为了避免空指针或避免检查到 null 参数抛异常，直接返回一个空参构造函数创建的对象。</p><p>类似下面的做法：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 根据订单编号查询订单 * * @param orderNo 订单编号 * @return 订单 */</span><span class="token keyword">public</span> Order <span class="token function">getByOrderNo</span><span class="token punctuation">(</span>String orderNo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>orderNo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Order</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 查询order</span>    <span class="token keyword">return</span> <span class="token function">doGetByOrderNo</span><span class="token punctuation">(</span>orderNo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>由于常见的单个数据的查询接口，参数检查不符时会抛异常或者返回 <code>null</code>。 极少有上述的写法，因此调用方的惯例是判断结果不为 <code>null</code> 就使用其中的属性。</p><p>这个哥们这么写之后，上层判断返回值不为 <code>null</code> , 上层就放心大胆得调用实例函数，导致线上报空指针，就造成了线上 BUG。</p><h5 id="3-新增-NonNull-属性反序列化的-BUG"><a href="#3-新增-NonNull-属性反序列化的-BUG" class="headerlink" title="3. 新增 @NonNull 属性反序列化的 BUG"></a>3. 新增 @NonNull 属性反序列化的 BUG</h5><p>假如有一个订单更新的 RPC 接口，该接口有一个 <code>OrderUpdateParam</code> 参数，之前有两个属性一个是 <code>id</code> 一个是 <code>name</code> 。在某个需求时，新增了一个 extra 属性，且该字段一定不能为 <code>null</code> 。</p><p>采用 lombok 的 <code>@NonNull</code> 注解来避免空指针：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>Data<span class="token punctuation">;</span><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>NonNull<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable<span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderUpdateParam</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 3240762365557530541L<span class="token punctuation">;</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 其它属性</span>    <span class="token comment" spellcheck="true">// 新增的属性</span>    <span class="token annotation punctuation">@NonNull</span>    <span class="token keyword">private</span> String extra<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上线后导致没有使用最新 jar 包的服务对该接口的 RPC 调用报错。</p><p>我们来分析一下原因，在 IDEA 的 target - classes 目录下找到 DEMO 编译后的 class 文件，IDEA 会自动帮我们反编译：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderUpdateParam</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 3240762365557530541L<span class="token punctuation">;</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@NonNull</span>    <span class="token keyword">private</span> String extra<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">OrderUpdateParam</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> <span class="token keyword">final</span> String extra<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>extra <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"extra is marked non-null but is null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>extra <span class="token operator">=</span> extra<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@NonNull</span>    <span class="token keyword">public</span> String <span class="token function">getExtra</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>extra<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setExtra</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> <span class="token keyword">final</span> String extra<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>extra <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"extra is marked non-null but is null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>extra <span class="token operator">=</span> extra<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 其他代码</span><span class="token punctuation">}</span></code></pre><p>我们还可以使用反编译工具：<a href="http://java-decompiler.github.io/" target="_blank" rel="noopener">JD-GUI</a> 对编译后的 class 文件进行反编译，查看源码。</p><p>由于调用方调用的是不含 <code>extra</code> 属性的 jar 包，并且序列化编号是一致的，反序列化时会抛出 NPE。</p><pre class=" language-java"><code class="language-java">Caused by<span class="token operator">:</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>NullPointerException<span class="token operator">:</span> extra        at com<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>OrderUpdateParam<span class="token punctuation">.</span>&lt;init<span class="token operator">></span><span class="token punctuation">(</span>OrderUpdateParam<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">21</span><span class="token punctuation">)</span></code></pre><p>RPC 参数新增 lombok 的 <code>@NonNull</code> 注解时，要考虑调用方是否及时更新 jar 包，避免出现空指针。</p><h5 id="4-自动拆箱导致空指针"><a href="#4-自动拆箱导致空指针" class="headerlink" title="4. 自动拆箱导致空指针"></a>4. 自动拆箱导致空指针</h5><p>前面章节讲到了对象转换，如果我们下面的 <code>GoodCreateDTO</code> 是我们自己服务的对象， 而 <code>GoodCreateParam</code> 是我们调用服务的参数对象。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GoodCreateDTO</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String title<span class="token punctuation">;</span>    <span class="token keyword">private</span> Long price<span class="token punctuation">;</span>    <span class="token keyword">private</span> Long count<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GoodCreateParam</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>560222124628416274L<span class="token punctuation">;</span>    <span class="token keyword">private</span> String title<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> price<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中 <code>GoodCreateDTO</code> 的 <code>count</code> 属性在我们系统中是非必传参数，本系统可能为 <code>null</code>。</p><p>如果我们没有拉取源码的习惯，直接通过前面的转换工具类去转换。</p><p>我们潜意识会认为外部接口的对象类型也都是包装类型，这时候很容易因为转换出现 NPE 而导致线上 BUG。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GoodCreateConverter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> GoodCreateParam <span class="token function">convertToParam</span><span class="token punctuation">(</span>GoodCreateDTO goodCreateDTO<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>goodCreateDTO <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        GoodCreateParam goodCreateParam <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GoodCreateParam</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        goodCreateParam<span class="token punctuation">.</span><span class="token function">setTitle</span><span class="token punctuation">(</span>goodCreateDTO<span class="token punctuation">.</span><span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        goodCreateParam<span class="token punctuation">.</span><span class="token function">setPrice</span><span class="token punctuation">(</span>goodCreateDTO<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        goodCreateParam<span class="token punctuation">.</span><span class="token function">setCount</span><span class="token punctuation">(</span>goodCreateDTO<span class="token punctuation">.</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> goodCreateParam<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当转换器执行到 <code>goodCreateParam.setCount(goodCreateDTO.getCount());</code> 会自动拆箱会报空指针。</p><p>当 <code>GoodCreateDTO</code> 的 <code>count</code> 属性为 <code>null</code> 时，自动拆箱将报空指针。</p><p><strong>再看一个花样踩坑的例子</strong>：</p><p>我们作为使用方调用如下的二方服务接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Boolean <span class="token function">someRemoteCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>然后自以为对方肯定会返回 <code>TRUE</code> 或 <code>FALSE</code>，然后直接拿来作为判断条件或者转为基本类型，如果返回的是 <code>null</code>，则会报空指针异常：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">someRemoteCall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// 业务代码</span> <span class="token punctuation">}</span></code></pre><p>大家看示例的时候可能认为这种情况很简单，自己开发的时候肯定会注意，但是往往事实并非如此。</p><p>希望大家可以掌握常见的可能发生空指针场景，在开发是注意预防。</p><h5 id="5-分批调用合并结果时空指针"><a href="#5-分批调用合并结果时空指针" class="headerlink" title="5. 分批调用合并结果时空指针"></a>5. 分批调用合并结果时空指针</h5><p>大家再看下面这个经典的例子。</p><p>因为某些批量查询的二方接口在数据较大时容易超时，因此可以分为小批次调用。</p><p>下面封装一个将 <code>List</code> 数据拆分成每 <code>size</code> 个一批数据，去调用 <code>function</code> RPC 接口，然后将结果合并。</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> V<span class="token operator">></span> List<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token function">partitionCallList</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> dataList<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">,</span> Function<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">,</span> List<span class="token operator">&lt;</span>V<span class="token operator">>></span> function<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>dataList<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Preconditions<span class="token punctuation">.</span><span class="token function">checkArgument</span><span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"size 必须大于0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> Lists<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>dataList<span class="token punctuation">,</span> size<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>function<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        <span class="token punctuation">(</span>resultList1<span class="token punctuation">,</span> resultList2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                            resultList1<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>resultList2<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">return</span> resultList1<span class="token punctuation">;</span>                        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>看着挺对，没啥问题，其实则不然。</p><p>设想一下，如果某一个批次请求无数据，不是返回空集合而是 null，会怎样？</p><p>很不幸，又一个空指针异常向你飞来 …</p><p>此时<strong>要根据具体业务场景来判断如何处理这里可能产生的空指针异常</strong>。</p><p>如果在某个场景中，返回值为 null 是一定不允许的行为，可以在 function 函数中对结果进行检查，如果结果为 null，可抛异常。</p><p>如果是允许的，在调用 map 后，可以过滤 null :</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 省略前面代码</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>function<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>Objects<span class="token operator">:</span><span class="token operator">:</span>nonNull<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 省略后续代码</span></code></pre><h4 id="1-7-4-预防空指针的一些方法"><a href="#1-7-4-预防空指针的一些方法" class="headerlink" title="1.7.4-预防空指针的一些方法"></a>1.7.4-预防空指针的一些方法</h4><p><code>NPE</code> 造成的线上 BUG 还有很多种形式，如何预防空指针很重要。</p><p>下面将介绍几种预防 NPE 的一些常见方法：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E9%A2%84%E9%98%B2%E7%A9%BA%E6%8C%87%E9%92%88.jpeg" alt="预防空指针"></p><h5 id="1-接口提供者角度"><a href="#1-接口提供者角度" class="headerlink" title="1. 接口提供者角度"></a>1. 接口提供者角度</h5><h6 id="1-1-返回空集合"><a href="#1-1-返回空集合" class="headerlink" title="1.1 返回空集合"></a>1.1 返回空集合</h6><p>如果参数不符合要求直接返回空集合，底层的函数也使用一致的方式：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> List<span class="token operator">&lt;</span>Order<span class="token operator">></span> <span class="token function">getByOrderName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">doGetByOrderName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Collections<span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="1-2-使用-Optional"><a href="#1-2-使用-Optional" class="headerlink" title="1.2 使用 Optional"></a>1.2 使用 Optional</h6><p><code>Optional</code> 是 Java 8 引入的特性，返回一个 <code>Optional</code> 则明确告诉使用者结果可能为空：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Optional<span class="token operator">&lt;</span>Order<span class="token operator">></span> <span class="token function">getByOrderId</span><span class="token punctuation">(</span>Long orderId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token function">doGetByOrderId</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果大家感兴趣可以进入 <code>Optional</code> 的源码，结合前面介绍的 <code>codota</code> 工具进行深入学习，也可以结合《Java 8 实战》的相关章节进行学习。</p><h6 id="1-3-使用空对象设计模式"><a href="#1-3-使用空对象设计模式" class="headerlink" title="1.3 使用空对象设计模式"></a>1.3 使用空对象设计模式</h6><p>该设计模式为了解决 NPE 产生原因的第 1 条 “调用 <code>null</code> 对象的实例方法”。</p><p>在编写业务代码时为了避免 <code>NPE</code> 经常需要先判空再执行实例方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomeOperation</span><span class="token punctuation">(</span>Operation operation<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>operation <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        operation<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>《设计模式之禅》（第二版）554 页在拓展篇讲述了 “空对象模式”。</p><p>可以构造一个 <code>NullXXX</code> 类拓展自某个接口， 这样这个接口需要为 <code>null</code> 时，直接返回该对象即可：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NullOperation</span> <span class="token keyword">implements</span> <span class="token class-name">Operation</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do nothing</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这样上面的判空操作就不再有必要， 因为我们在需要出现 <code>null</code> 的地方都统一返回 <code>NullOperation</code>，而且对应的对象方法都是有的：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomeOperation</span><span class="token punctuation">(</span>Operation operation<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    operation<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-接口使用者角度"><a href="#2-接口使用者角度" class="headerlink" title="2. 接口使用者角度"></a>2. 接口使用者角度</h5><p>讲完了接口的编写者该怎么做，我们讲讲接口的使用者该如何避免 <code>NPE</code> 。</p><h6 id="2-1-null-检查"><a href="#2-1-null-检查" class="headerlink" title="2.1 null 检查"></a>2.1 null 检查</h6><p>正如《代码简洁之道》第 7.8 节 “别传 null 值” 中所要表达的意义：</p><blockquote><p>可以进行参数检查，对不满足的条件抛出异常。</p></blockquote><p>直接在使用前对不能为 <code>null</code> 的和不满足业务要求的条件进行检查，是一种最简单最常见的做法。</p><p>通过防御性参数检测，可以极大降低出错的概率，提高程序的健壮性：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateOrder</span><span class="token punctuation">(</span>OrderUpdateParam orderUpdateParam<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkUpdateParam</span><span class="token punctuation">(</span>orderUpdateParam<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">doUpdate</span><span class="token punctuation">(</span>orderUpdateParam<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkUpdateParam</span><span class="token punctuation">(</span>OrderUpdateParam orderUpdateParam<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>orderUpdateParam <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"参数不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Long id <span class="token operator">=</span> orderUpdateParam<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String name <span class="token operator">=</span> orderUpdateParam<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"id不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"name不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>JDK 和各种开源框架中可以找到很多这种模式，<code>java.util.concurrent.ThreadPoolExecutor#execute</code> 就是采用这种模式。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 其他代码</span>     <span class="token punctuation">}</span></code></pre><p>以及 <code>org.springframework.context.support.AbstractApplicationContext#assertBeanFactoryActive</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">assertBeanFactoryActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>active<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>closed<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token function">getDisplayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" has been closed already"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token function">getDisplayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" has not been refreshed yet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h6 id="2-2-使用-Objects"><a href="#2-2-使用-Objects" class="headerlink" title="2.2 使用 Objects"></a>2.2 使用 Objects</h6><p>可以使用 Java 7 引入的 Objects 类，来简化判空抛出空指针的代码。</p><p>使用方法如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">checkUpdateParam2</span><span class="token punctuation">(</span>OrderUpdateParam orderUpdateParam<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>orderUpdateParam<span class="token punctuation">)</span><span class="token punctuation">;</span>    Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>orderUpdateParam<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>orderUpdateParam<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>原理很简单，我们看下源码；</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">requireNonNull</span><span class="token punctuation">(</span>T obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h6 id="2-3-使用-commons-包"><a href="#2-3-使用-commons-包" class="headerlink" title="2.3 使用 commons 包"></a>2.3 使用 commons 包</h6><p>我们可以使用 commons-lang3 或者 commons-collections4 等常用的工具类辅助我们判空。</p><ul><li><p><strong>使用字符串工具类：org.apache.commons.lang3.StringUtils</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>String param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用param参数</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p><strong>使用校验工具类：org.apache.commons.lang3.Validate</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>Object param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Validate<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>param<span class="token punctuation">,</span><span class="token string">"param must not null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSomething2</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> parms<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Validate<span class="token punctuation">.</span><span class="token function">notEmpty</span><span class="token punctuation">(</span>parms<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>该校验工具类支持多种类型的校验，支持自定义提示文本等。</p><p>前面已经介绍了读源码是最好的学习方式之一，这里我们看下底层的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> T <span class="token function">notEmpty</span><span class="token punctuation">(</span><span class="token keyword">final</span> T collection<span class="token punctuation">,</span> <span class="token keyword">final</span> String message<span class="token punctuation">,</span> <span class="token keyword">final</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>collection <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>collection<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> collection<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>该如果集合对象为 null 则会抛空 <code>NullPointerException</code> 如果集合为空则抛出 <code>IllegalArgumentException</code>。</p><p>通过源码我们还可以了解到更多的校验函数。</p></li></ul><h6 id="2-4-使用集合工具类：org-apache-commons-collections4-CollectionUtils"><a href="#2-4-使用集合工具类：org-apache-commons-collections4-CollectionUtils" class="headerlink" title="2.4 使用集合工具类：org.apache.commons.collections4.CollectionUtils"></a>2.4 使用集合工具类：<code>org.apache.commons.collections4.CollectionUtils</code></h6><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用params</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h6 id="2-5-使用-guava-包"><a href="#2-5-使用-guava-包" class="headerlink" title="2.5 使用 guava 包"></a>2.5 使用 guava 包</h6><p>可以使用 guava 包的 <code>com.google.common.base.Preconditions</code> 前置条件检测类。</p><p>同样看源码，源码给出了一个范例。原始代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token keyword">double</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"input is negative: "</span> <span class="token operator">+</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// calculate square root</span><span class="token punctuation">}</span></code></pre><p>使用 <code>Preconditions</code> 后，代码可以简化为：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token keyword">double</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">checkArgument</span><span class="token punctuation">(</span>value <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"input is negative: %s"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// calculate square root</span> <span class="token punctuation">}</span></code></pre><p>Spring 源码里很多地方可以找到类似的用法，下面是其中一个例子：</p><pre><code>org.springframework.context.annotation.AnnotationConfigApplicationContext#registerpublic void register(Class&lt;?&gt;... annotatedClasses) {    Assert.notEmpty(annotatedClasses, &quot;At least one annotated class must be specified&quot;);    this.reader.register(annotatedClasses);}org.springframework.util.Assert#notEmpty(java.lang.Object[], java.lang.String)public static void notEmpty(Object[] array, String message) {    if (ObjectUtils.isEmpty(array)) {        throw new IllegalArgumentException(message);    }}</code></pre><p>虽然使用的具体工具类不一样，核心的思想都是一致的。</p><h6 id="2-6-自动化-API"><a href="#2-6-自动化-API" class="headerlink" title="2.6 自动化 API"></a>2.6 自动化 API</h6><ul><li><p><strong>使用 lombok 的 <code>@Nonnull</code> 注解</strong></p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething5</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> String param<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 使用param</span>      <span class="token function">proccess</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>查看编译后的代码：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething5</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NonNull</span> String param<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>param <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"param is marked non-null but is null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">proccess</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre></li><li><p><strong>使用 IntelliJ IDEA 提供的 @NotNull 和 @Nullable 注解</strong></p><p>maven 依赖如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- https://mvnrepository.com/artifact/org.jetbrains/annotations --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.jetbrains<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>annotations<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>17.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>@NotNull 在参数上的用法和上面的例子非常相似。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token annotation punctuation">@NotNull</span> String param<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用param</span>    <span class="token function">proccess</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们可以去该注解的源码 <code>org.jetbrains.annotations.NotNull#exception</code> 里查看更多细节，大家也可以使用 IDEA 插件或者前面介绍的 JD-GUI 来查看编译后的 class 文件，去了解 @NotNull 注解的作用。</p></li></ul><h4 id="1-7-5-总结"><a href="#1-7-5-总结" class="headerlink" title="1.7.5-总结"></a>1.7.5-总结</h4><p>本节主要讲述空指针的含义，空指针常见的中枪姿势，以及如何避免空指针异常。下一节将为你揭秘 当 switch 遇到空指针，又会发生什么奇妙的事情。</p><h3 id="1-8-当switch遇到空指针"><a href="#1-8-当switch遇到空指针" class="headerlink" title="1.8-当switch遇到空指针"></a>1.8-当switch遇到空指针</h3><h4 id="1-8-1-前言"><a href="#1-8-1-前言" class="headerlink" title="1.8.1-前言"></a>1.8.1-前言</h4><p>《手册》的第 18 页有关于 <code>switch</code> 的规约：</p><blockquote><p>【强制】当 switch 括号内的变量类型为 String 并且此变量为外部参数时，必须先进行 null<br>判断。<a href="https://www.imooc.com/read/55/article/1146#fn1" target="_blank" rel="noopener">1</a></p></blockquote><p>在《手册》中，该规约下面还给出了一段反例（此处略）。</p><p>最近很火的一篇名为《悬赏征集！5 道题征集代码界前 3% 的超级王者》<a href="https://www.imooc.com/read/55/article/1146#fn2" target="_blank" rel="noopener">2</a> 的文章，也给出了类似的一段代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SwitchTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String param <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>param<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token string">"null"</span><span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>该文章给出的问题是：“上面这段程序输出的结果是什么？”。</p><p>其实，想知道答案很容易，运行一下程序答案就出来了。</p><p><strong>但是如果浅尝辄止，我们就丧失了一次难得的学习机会</strong>，不像是一名优秀程序猿的作风。</p><p>我们还需要思考下面几个问题：</p><ul><li><code>switch</code> 除了 <code>String</code> 还支持哪种类型？</li><li>为什么《手册》规定字符串类型参数要先进行 null 判断？</li><li>为什么可能会抛出异常？</li><li>该如何分析这类问题呢？</li></ul><p>本节将对上述问题进行分析。</p><h4 id="1-8-2-问题分析"><a href="#1-8-2-问题分析" class="headerlink" title="1.8.2-问题分析"></a>1.8.2-问题分析</h4><h5 id="1-源码大法"><a href="#1-源码大法" class="headerlink" title="1.  源码大法"></a>1.  源码大法</h5><p>按照我们一贯的风格，我们应该先上 “源码大法”，但是 <code>switch</code> 是关键字，无法进入 JDK 源码中查看学习，因此我们暂时放弃通过源码或源码注释来分析解决的手段。</p><h5 id="2-官方文档"><a href="#2-官方文档" class="headerlink" title="2. 官方文档"></a>2. 官方文档</h5><p>我们去官方文档 JLS<a href="https://www.imooc.com/read/55/article/1146#fn3" target="_blank" rel="noopener">3</a> 查看 <code>swtich</code> 语句<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-14.html#jls-14.11" target="_blank" rel="noopener">相关描述</a>。</p><blockquote><p>switch 的表达式必须是 char, byte, short, int, Character, Byte, Short, Integer, String, 或者 enum 类型，否则会发生编译错误</p><p>switch 语句必须满足以下条件，否则会出现编译错误：</p><ul><li>与 switch 语句关联的每个 case 都必须和 switch 的表达式的类型一致；</li><li>如果 switch 表达式是枚举类型，case 常量也必须是枚举类型；</li><li>不允许同一个 switch 的两个 case 常量的值相同；</li><li>和 switch 语句关联的常量不能为 null ；</li><li>一个 switch 语句最多有一个 default 标签。</li></ul></blockquote><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/Java8-Switch.jpeg" alt="Java8-Switch"></p><p>我们了解到 switch 语句支持的类型，以及会出现编译错误的原因。</p><p>我们看到关键的一句话：</p><blockquote><p>When the switch statement is executed, first the Expression is evaluated. If the Expression evaluates to null, a NullPointerException is thrown and the entire switch statement completes abruptly for that reason.</p><p>switch 语句执行的时候，首先将执行 switch 的表达式。如果表达式为 null, 则会抛出 NullPointerException，整个 switch 语句的执行将被中断。</p></blockquote><p>这里的表达式就是我们的参数，前言中该参数的值为 <code>null</code>, 因此答案就显而易见了：结果会抛出异常，而且是前面章节讲到的 <code>NullPointerException</code>。</p><p>另外从 JVM<a href="https://www.imooc.com/read/55/article/1146#fn4" target="_blank" rel="noopener">4</a> <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.10" target="_blank" rel="noopener">3.10 节 “Compiling Switches”</a> ，我们学习到：</p><blockquote><p>编译器使用 tableswitch 和 lookupswitch 指令生成 switch 语句的编译代码。tablesswtich 语句用于表示 swtich 结构的 case 语句块，它可以地从索引表中确定 case 语句块的分支偏移量。当 switch 语句的条件值不能对应索引表的任何一个 case 语句块的偏移量时就会用到 default 语句。</p><p>Java 虚拟机的 tableswitch 和 lookupswitch 指令只能支持 int 类型的条件值。如果 swich 中使用其他类型的值，那么就必须转化为 int 类型。</p><p>当 switch 语句中的 case 分支条件比较稀疏时， tableswtich 指令的空间利用率较低。 可以使用 lookupswitch 指令来取代。</p><p>lookupswitch 指令的索引表项由 int 类型的键（来自于 case 语句后的数值）和对应目标语句的偏移量构成。 当 lookcupswitch 指令执行时， switch 语句的条件值将和索引表中的键进行比对，如果某个键和条件的值相符，那么将转移到这个键对应的分支偏移量的代码行处开始执行，如果没有符合的键值，则执行 default 分支。</p></blockquote><p>因此我们可以推测出，表达式会将 String 的参数转成 int 类型的值和 case 进行比对。</p><p>我们去 <code>String</code> 源码中寻找可以将字符串转 int 的函数，发现 <code>hashCode()</code> 可能是最佳的选择之一（后面会印证）。</p><p>因此空指针出现的根源在于：<strong>虚拟机为了实现 switch 的语法，将参数表达式转换成 int。而这里的参数为 null， 从而造成了空指针异常</strong>。</p><p>通过官方文档的阅读，我们对 switch 有了一个相对深入的了解。</p><h5 id="3-Java-反汇编大法"><a href="#3-Java-反汇编大法" class="headerlink" title="3. Java 反汇编大法"></a>3. Java 反汇编大法</h5><p>如何印证官方文档的描述？如何进一步分析呢？</p><p>按照惯例我们用反汇编大法。</p><h6 id="3-1-switch-举例"><a href="#3-1-switch-举例" class="headerlink" title="3.1 switch 举例"></a>3.1 switch 举例</h6><p>我们先看一个正常的示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String param <span class="token operator">=</span> <span class="token string">"t"</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>param<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token string">"a"</span><span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"b"</span><span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token string">"c"</span><span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p>先进入到代码目录，对类文件进行编译：</p><pre><code>javac SwitchTest2.java</code></pre><p>然后反汇编的代码如下：</p><pre><code>javap -c SwitchTest2</code></pre><p>前方高能预警，先稳住，不要怕，不要方，后面会给出解释并给出简化版：</p><pre class=" language-java"><code class="language-java">Compiled from <span class="token string">"SwitchTest2.java"</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_switch<span class="token punctuation">.</span>SwitchTest2</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_switch<span class="token punctuation">.</span><span class="token function">SwitchTest2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> aload_0       <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Object."&lt;init>":()V</span>       <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> ldc           #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// String t</span>       <span class="token number">2</span><span class="token operator">:</span> astore_1       <span class="token number">3</span><span class="token operator">:</span> aload_1       <span class="token number">4</span><span class="token operator">:</span> astore_2       <span class="token number">5</span><span class="token operator">:</span> iconst_m1       <span class="token number">6</span><span class="token operator">:</span> istore_3       <span class="token number">7</span><span class="token operator">:</span> aload_2       <span class="token number">8</span><span class="token operator">:</span> invokevirtual #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// Method java/lang/String.hashCode:()I</span>      <span class="token number">11</span><span class="token operator">:</span> tableswitch   <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 97 to 99</span>                    <span class="token number">97</span><span class="token operator">:</span> <span class="token number">36</span>                    <span class="token number">98</span><span class="token operator">:</span> <span class="token number">50</span>                    <span class="token number">99</span><span class="token operator">:</span> <span class="token number">64</span>               <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">75</span>          <span class="token punctuation">}</span>      <span class="token number">36</span><span class="token operator">:</span> aload_2      <span class="token number">37</span><span class="token operator">:</span> ldc           #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// String a</span>      <span class="token number">39</span><span class="token operator">:</span> invokevirtual #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Method java/lang/String.equals:(Ljava/lang/Object;)Z</span>      <span class="token number">42</span><span class="token operator">:</span> ifeq          <span class="token number">75</span>      <span class="token number">45</span><span class="token operator">:</span> iconst_0      <span class="token number">46</span><span class="token operator">:</span> istore_3      <span class="token number">47</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">75</span>      <span class="token number">50</span><span class="token operator">:</span> aload_2      <span class="token number">51</span><span class="token operator">:</span> ldc           #<span class="token number">6</span>                  <span class="token comment" spellcheck="true">// String b</span>      <span class="token number">53</span><span class="token operator">:</span> invokevirtual #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Method java/lang/String.equals:(Ljava/lang/Object;)Z</span>      <span class="token number">56</span><span class="token operator">:</span> ifeq          <span class="token number">75</span>      <span class="token number">59</span><span class="token operator">:</span> iconst_1      <span class="token number">60</span><span class="token operator">:</span> istore_3      <span class="token number">61</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">75</span>      <span class="token number">64</span><span class="token operator">:</span> aload_2      <span class="token number">65</span><span class="token operator">:</span> ldc           #<span class="token number">7</span>                  <span class="token comment" spellcheck="true">// String c</span>      <span class="token number">67</span><span class="token operator">:</span> invokevirtual #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Method java/lang/String.equals:(Ljava/lang/Object;)Z</span>      <span class="token number">70</span><span class="token operator">:</span> ifeq          <span class="token number">75</span>      <span class="token number">73</span><span class="token operator">:</span> iconst_2      <span class="token number">74</span><span class="token operator">:</span> istore_3      <span class="token number">75</span><span class="token operator">:</span> iload_3      <span class="token number">76</span><span class="token operator">:</span> tableswitch   <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 0 to 2</span>                     <span class="token number">0</span><span class="token operator">:</span> <span class="token number">104</span>                     <span class="token number">1</span><span class="token operator">:</span> <span class="token number">115</span>                     <span class="token number">2</span><span class="token operator">:</span> <span class="token number">126</span>               <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">137</span>          <span class="token punctuation">}</span>     <span class="token number">104</span><span class="token operator">:</span> getstatic     #<span class="token number">8</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>     <span class="token number">107</span><span class="token operator">:</span> ldc           #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// String a</span>     <span class="token number">109</span><span class="token operator">:</span> invokevirtual #<span class="token number">9</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>     <span class="token number">112</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">145</span>     <span class="token number">115</span><span class="token operator">:</span> getstatic     #<span class="token number">8</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>     <span class="token number">118</span><span class="token operator">:</span> ldc           #<span class="token number">6</span>                  <span class="token comment" spellcheck="true">// String b</span>     <span class="token number">120</span><span class="token operator">:</span> invokevirtual #<span class="token number">9</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>     <span class="token number">123</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">145</span>     <span class="token number">126</span><span class="token operator">:</span> getstatic     #<span class="token number">8</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>     <span class="token number">129</span><span class="token operator">:</span> ldc           #<span class="token number">7</span>                  <span class="token comment" spellcheck="true">// String c</span>     <span class="token number">131</span><span class="token operator">:</span> invokevirtual #<span class="token number">9</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>     <span class="token number">134</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">145</span>     <span class="token number">137</span><span class="token operator">:</span> getstatic     #<span class="token number">8</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>     <span class="token number">140</span><span class="token operator">:</span> ldc           #<span class="token number">10</span>                 <span class="token comment" spellcheck="true">// String default</span>     <span class="token number">142</span><span class="token operator">:</span> invokevirtual #<span class="token number">9</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>     <span class="token number">145</span><span class="token operator">:</span> <span class="token keyword">return</span><span class="token punctuation">}</span></code></pre><p>首先介绍一个简单的背景知识：</p><blockquote><p>字符 a 的 ASCII 码为 97, b 为 98，c 为 99 （我们发现常见英文字母的哈希值为其 ASCII 码）。</p></blockquote><p>tableswitch 后面的注释显示 case 的哈希值的范围是 97 到 99。</p><p>我们讲解核心代码，先看偏移为 8 的指令，调用了参数的 <code>hashCode()</code> 函数来获取字符串 “t” 的哈希值。</p><pre class=" language-java"><code class="language-java">tableswitch   <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 97 to 99</span>           <span class="token number">97</span><span class="token operator">:</span> <span class="token number">36</span>           <span class="token number">98</span><span class="token operator">:</span> <span class="token number">50</span>           <span class="token number">99</span><span class="token operator">:</span> <span class="token number">64</span>           <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">75</span>      <span class="token punctuation">}</span></code></pre><p>接下来我们看偏移为 11 的指令处： tableswitch 是跳转引用列表， 如果值小于其中的最小值或者大于其中的最大值，跳转到 <code>default</code> 语句。</p><blockquote><p>其中 97 为键，36 为对应的目标语句偏移量。</p></blockquote><p>hashCode 和 tableswitch 的键相等，则跳转到对应的目标偏移量，t 的哈希值为 116，大于条件的最大值 99，因此跳转到 <code>default</code> 对应的语句行（即偏移量为 75 的指令处执行）。</p><p>从 36 到 74 行，根据哈希值相等跳转到判断是否相等的指令。</p><p>然后调用 <code>java.lang.String#equals</code> 判断 switch 的字符串是否和对应的 case 的字符串相等。</p><p>如果相等则分别根据第几个条件得到条件的索引，然后每个索引对应下一个指定的代码行数。</p><p>default 语句对应 137 行，打印 “default” 字符串，然后执行 145 行 <code>return</code> 命令返回。</p><p>然后再通过 tableswitch 判断执行哪一行打印语句。</p><p><strong>因此整个流程是先计算字符串参数的哈希值，判断哈希值的范围，然后哈希值相等再判断对象是否相等，然后执行对应的代码块。</strong></p><h6 id="3-2-分析问题"><a href="#3-2-分析问题" class="headerlink" title="3.2 分析问题"></a>3.2 分析问题</h6><p>经过前面的学习我们对 String 为参数的 switch 语句的执行流程有了初步认识。</p><p>我们反汇编开篇的示例，得到如下代码：</p><pre class=" language-java"><code class="language-java">Compiled from <span class="token string">"SwitchTest.java"</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_switch<span class="token punctuation">.</span>SwitchTest</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_switch<span class="token punctuation">.</span><span class="token function">SwitchTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> aload_0       <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Object."&lt;init>":()V</span>       <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> aconst_null       <span class="token number">1</span><span class="token operator">:</span> astore_1       <span class="token number">2</span><span class="token operator">:</span> aload_1       <span class="token number">3</span><span class="token operator">:</span> astore_2       <span class="token number">4</span><span class="token operator">:</span> iconst_m1       <span class="token number">5</span><span class="token operator">:</span> istore_3       <span class="token number">6</span><span class="token operator">:</span> aload_2       <span class="token number">7</span><span class="token operator">:</span> invokevirtual #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// Method java/lang/String.hashCode:()I</span>      <span class="token number">10</span><span class="token operator">:</span> lookupswitch  <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 1</span>               <span class="token number">3392903</span><span class="token operator">:</span> <span class="token number">28</span>               <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">39</span>          <span class="token punctuation">}</span>      <span class="token number">28</span><span class="token operator">:</span> aload_2      <span class="token number">29</span><span class="token operator">:</span> ldc           #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// String null</span>      <span class="token number">31</span><span class="token operator">:</span> invokevirtual #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/lang/String.equals:(Ljava/lang/Object;)Z</span>      <span class="token number">34</span><span class="token operator">:</span> ifeq          <span class="token number">39</span>      <span class="token number">37</span><span class="token operator">:</span> iconst_0      <span class="token number">38</span><span class="token operator">:</span> istore_3      <span class="token number">39</span><span class="token operator">:</span> iload_3      <span class="token number">40</span><span class="token operator">:</span> lookupswitch  <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 1</span>                     <span class="token number">0</span><span class="token operator">:</span> <span class="token number">60</span>               <span class="token keyword">default</span><span class="token operator">:</span> <span class="token number">71</span>          <span class="token punctuation">}</span>      <span class="token number">60</span><span class="token operator">:</span> getstatic     #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>      <span class="token number">63</span><span class="token operator">:</span> ldc           #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// String null</span>      <span class="token number">65</span><span class="token operator">:</span> invokevirtual #<span class="token number">6</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>      <span class="token number">68</span><span class="token operator">:</span> <span class="token keyword">goto</span>          <span class="token number">79</span>      <span class="token number">71</span><span class="token operator">:</span> getstatic     #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>      <span class="token number">74</span><span class="token operator">:</span> ldc           #<span class="token number">7</span>                  <span class="token comment" spellcheck="true">// String default</span>      <span class="token number">76</span><span class="token operator">:</span> invokevirtual #<span class="token number">6</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>      <span class="token number">79</span><span class="token operator">:</span> <span class="token keyword">return</span><span class="token punctuation">}</span></code></pre><p><strong>猜想和验证是学习的最佳方式之一</strong>，我们通过猜想来提取知识，通过验证来核实自己的猜想是否正确。</p><p><strong>猜想 1</strong>：根据上面的分析我们可以 “猜想”：3392903 应该是 “null” 字符串的哈希值。</p><p>我们可以打印其哈希值去印证：<code>System.out.println((&quot;null&quot;).hashCode());</code> ，也可以通过编写单元测试来断言，还可以通过调试来执行表达式等方式查看。</p><p>在调试模式下，在变量选项卡上右键，选择 “Evaluate Expression…” ，填写想执行想计算的表达式即可：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/Evaluate-Expression.jpeg" alt="Evaluate-Expression"></p><p>我们将上面的字节码的逻辑反向 “翻译” 成 java 代码大致如下：</p><pre class=" language-java"><code class="language-java">String param <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token keyword">int</span> hashCode <span class="token operator">=</span> param<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>hashCode <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> param<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对应流程图如下：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/Switch%E5%8F%8D%E6%B1%87%E7%BC%96%E6%B5%81%E7%A8%8B.jpeg" alt="Switch反汇编流程"></p><p>因此空指针的原因就一目了然了。</p><p>回忆一下空指针的小节讲到的：</p><blockquote><p>空指针异常发生的原因之一：“调用 null 对象的实例方法。”。</p><p>以及 “JVM 也可能会通过 <code>Throwable#Throwable(String, Throwable, boolean, boolean)</code> 构造函数来构造 <code>NullPointerException</code> 对象。”</p></blockquote><p>此处字节码执行时调用了 <code>null</code> 的 <code>hashCode</code> 方法，虚拟机可以通过上面的函数构造 NPE 并抛出。</p><p><strong>那么将字符串通过 hashCode 函数转为整型和 case 条件对比后，为什么还需要 equals 再次判断呢？</strong></p><p>这就要回到 hashCode 函数的本质，即将不同的对象（不定长）映射到整数范围（定长）, 而且 java 的 hashCode 函数和 equals 函数默认约定：同一个对象的 hashCode 一定相等， 即 hashCode 不等的对象一定不是同一个对象。</p><p>详情参见 <code>java.lang.Object#hashCode</code> 和 <code>java.lang.Object#equals</code> 的注释。</p><p>通过这一特性，可以快速判断对象是否有可能相当，避免不必要的比较。</p><p><strong>另外我们还可以猜想如何提高比较的效率？</strong></p><p><strong>猜想 2：</strong> 如果编译期能够将 lookupswitch 按照 hash 值升序排序，则运行时就可讲参数的 hash 值（最小）先和第一个和除 default 外的倒数第一个 hash 值（最大）比较，不在这个范围直接走 default 语句即可，在这个范围就可以使用使用二分查找法，将时间复杂度降低到 O (logn) ，从而大大提高效率。</p><p>大家可以通过读 jvms 甚至读虚拟机代码去核实和验证上述猜想。</p><p>另外，<strong>虽然有些哈希函数设计的比较优良，能够尽可能避免 hash 冲突，但是对象的数量是 “无限” 的，整数的范围是 “有限” 的，将无限的对象映射到有限的范围，必然会产生冲突。</strong></p><p>因此通过上述反汇编代码可以看出：</p><p>switch 表达式会先计算字符串的 hashCode （main 函数偏移为 7 处代码），然后根据 hashCode 是否相等快速判断是否要走到某个 case（见 lookupswith），如果不满足，直接执行到 default （main 函数偏移为 39 处代码）；如果满足，则跳转到对应 case 的代码（见 main 函数偏移为 28 之后的代码）再通过 equals 判断值是否相等，来避免 hash 冲突时 case 被误执行。</p><p><strong>这种先判断 hash 值是否相等（有可能是同一个对象 / 两个对象有可能相等）再通过 equals 比较 “对象是否相等” 的做法，在 Java 的很多 JDK 源码中和其他框架中非常常见</strong>。</p><h4 id="1-8-3-总结"><a href="#1-8-3-总结" class="headerlink" title="1.8.3-总结"></a>1.8.3-总结</h4><p>本节我们结合一个简单的案例 和 jvms， 学习了 switch 的基本原理，分析了示例代码产生空指针的原因。本节还介绍了一个简单的调试技巧，以及 “猜想和验证” 的学习方式，希望大家在后面的学习和工作中多加实践。</p><p>下一节我们将深入学习枚举并介绍其高级用法。</p><h3 id="1-9-枚举类的正确学习方式"><a href="#1-9-枚举类的正确学习方式" class="headerlink" title="1.9-枚举类的正确学习方式"></a>1.9-枚举类的正确学习方式</h3><h4 id="1-9-1-前言"><a href="#1-9-1-前言" class="headerlink" title="1.9.1-前言"></a>1.9.1-前言</h4><p>《手册》第 3 、4 、39 页中有几段关于枚举类型的描述<a href="https://www.imooc.com/read/55/article/1147#fn1" target="_blank" rel="noopener">1</a> ：</p><blockquote><p>【参考】枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。<br>说明: 枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。</p><p>【推荐】如果变量值仅在一个固定范围内变化用enum类型来定义。</p><p>【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用 枚举类型或者包含枚举类型的 POJO 对象。</p></blockquote><p>大多数 Java 程序员对枚举类型一知半解，大多数程序员对枚举的用法都非常简单。</p><p>本小节主要解决以下几个问题：</p><ul><li>那么枚举类究竟是怎样的？</li><li>默认的构造方法为何是私有的？</li><li>为什么接口不要返回枚举类型。</li><li>枚举类还有哪些高级用法？</li></ul><h4 id="1-9-2-学习枚举类"><a href="#1-9-2-学习枚举类" class="headerlink" title="1.9.2-学习枚举类"></a>1.9.2-学习枚举类</h4><h5 id="1-勿忘初心"><a href="#1-勿忘初心" class="headerlink" title="1. 勿忘初心"></a>1. 勿忘初心</h5><p>我们学习一个框架，学习一个语言特性时，可以思考一下这个框架和语言特性出现的原因。</p><p>枚举一般用来表示一组相同类型的常量，比如月份、星期、颜色等。</p><p>枚举的主要使用场景是，当需要一组固定的常量，并且编译时成员就已能确定时就应该使用枚举。<a href="https://www.imooc.com/read/55/article/1147#fn2" target="_blank" rel="noopener">2</a></p><p>因此枚举类型没必要多例，如果能够保证单例，则可以减少内存开销。</p><p>另外枚举为数值提供了命名，更容易理解，而且枚举更加安全，功能更加强大。</p><h5 id="2-官方文档法"><a href="#2-官方文档法" class="headerlink" title="2. 官方文档法"></a>2. 官方文档法</h5><p>前面介绍过，优先通过官方文档来学习 Java 的语言特性。</p><p>JLS <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9" target="_blank" rel="noopener">8.9 节Enum Types</a> 对枚举类型进行了详细地介绍<a href="https://www.imooc.com/read/55/article/1147#fn3" target="_blank" rel="noopener">3</a>。主要有以下几个要点：</p><blockquote><p>如果枚举类如果被 abstract 或 final 修饰，枚举如果常量重复，如果尝试实例化枚举类型都会有编译错误。</p><p>枚举类除声明的枚举常量没有其他实例。</p><p>枚举类型的 E 是Enum的直接子类。</p></blockquote><p>那么 Java 是如何保证除了定义的枚举常量外没有其他实例呢？</p><p>从手册中我们可以找到原因：</p><ul><li>Enum 的 clone 方法被 final 修饰，保证 enum 常量不会被克隆。</li><li>禁止对枚举类型的反射。</li><li>序列化机制保证反序列化时枚举类型不允许构造多个相同实例。</li></ul><p>通过这些提示，我们就明白为何枚举类的构造函数是私有的，</p><p>文档中还介绍了枚举的成员，枚举的迭代，枚举类型作为 switch 的条件，带抽象函数的枚举常量等。</p><h5 id="3-Java-反汇编"><a href="#3-Java-反汇编" class="headerlink" title="3. Java 反汇编"></a>3. Java 反汇编</h5><p>我们选取 JLS 中的一个代码片段：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> CoinEnum <span class="token punctuation">{</span>    <span class="token function">PENNY</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">NICKEL</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DIME</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">QUARTER</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">CoinEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>先编译： <code>javac CoinEnum.java</code></p><p>然后再反汇编：<code>javap -c CoinEnum</code></p><p>得到下面的反汇编后的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_enum<span class="token punctuation">.</span>CoinEnum</span> <span class="token keyword">extends</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Enum</span><span class="token operator">&lt;</span>com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_enum<span class="token punctuation">.</span>CoinEnum<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_enum<span class="token punctuation">.</span>CoinEnum PENNY<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_enum<span class="token punctuation">.</span>CoinEnum NICKEL<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_enum<span class="token punctuation">.</span>CoinEnum DIME<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_enum<span class="token punctuation">.</span>CoinEnum QUARTER<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 第 1 处代码</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_enum<span class="token punctuation">.</span>CoinEnum<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> getstatic     #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Field $VALUES:[Lcom/imooc/basic/learn_enum/CoinEnum;</span>       <span class="token number">3</span><span class="token operator">:</span> invokevirtual #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// Method "[Lcom/imooc/basic/learn_enum/CoinEnum;".clone:()Ljava/lang/Object;</span>       <span class="token number">6</span><span class="token operator">:</span> checkcast     #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// class "[Lcom/imooc/basic/learn_enum/CoinEnum;"</span>       <span class="token number">9</span><span class="token operator">:</span> areturn   <span class="token comment" spellcheck="true">// 第 2 处代码</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_enum<span class="token punctuation">.</span>CoinEnum <span class="token function">valueOf</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> ldc           #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class com/imooc/basic/learn_enum/CoinEnum</span>       <span class="token number">2</span><span class="token operator">:</span> aload_0       <span class="token number">3</span><span class="token operator">:</span> invokestatic  #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span>       <span class="token number">6</span><span class="token operator">:</span> checkcast     #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class com/imooc/basic/learn_enum/CoinEnum</span>       <span class="token number">9</span><span class="token operator">:</span> areturn  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> aload_0       <span class="token number">1</span><span class="token operator">:</span> getfield      #<span class="token number">7</span>                  <span class="token comment" spellcheck="true">// Field value:I</span>       <span class="token number">4</span><span class="token operator">:</span> ireturn  <span class="token keyword">static</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class com/imooc/basic/learn_enum/CoinEnum</span>       <span class="token number">3</span><span class="token operator">:</span> dup       <span class="token number">4</span><span class="token operator">:</span> ldc           #<span class="token number">8</span>                  <span class="token comment" spellcheck="true">// String PENNY</span>       <span class="token number">6</span><span class="token operator">:</span> iconst_0       <span class="token number">7</span><span class="token operator">:</span> iconst_1       <span class="token number">8</span><span class="token operator">:</span> invokespecial #<span class="token number">9</span>                  <span class="token comment" spellcheck="true">// Method "&lt;init>":(Ljava/lang/String;II)V</span>      <span class="token number">11</span><span class="token operator">:</span> putstatic     #<span class="token number">10</span>                 <span class="token comment" spellcheck="true">// Field PENNY:Lcom/imooc/basic/learn_enum/CoinEnum;</span>      <span class="token number">14</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class com/imooc/basic/learn_enum/CoinEnum</span>      <span class="token number">17</span><span class="token operator">:</span> dup      <span class="token number">18</span><span class="token operator">:</span> ldc           #<span class="token number">11</span>                 <span class="token comment" spellcheck="true">// String NICKEL</span>      <span class="token number">20</span><span class="token operator">:</span> iconst_1      <span class="token number">21</span><span class="token operator">:</span> iconst_5      <span class="token number">22</span><span class="token operator">:</span> invokespecial #<span class="token number">9</span>                  <span class="token comment" spellcheck="true">// Method "&lt;init>":(Ljava/lang/String;II)V</span>      <span class="token number">25</span><span class="token operator">:</span> putstatic     #<span class="token number">12</span>                 <span class="token comment" spellcheck="true">// Field NICKEL:Lcom/imooc/basic/learn_enum/CoinEnum;</span>      <span class="token number">28</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class com/imooc/basic/learn_enum/CoinEnum</span>      <span class="token number">31</span><span class="token operator">:</span> dup      <span class="token number">32</span><span class="token operator">:</span> ldc           #<span class="token number">13</span>                 <span class="token comment" spellcheck="true">// String DIME</span>      <span class="token number">34</span><span class="token operator">:</span> iconst_2      <span class="token number">35</span><span class="token operator">:</span> bipush        <span class="token number">10</span>      <span class="token number">37</span><span class="token operator">:</span> invokespecial #<span class="token number">9</span>                  <span class="token comment" spellcheck="true">// Method "&lt;init>":(Ljava/lang/String;II)V</span>      <span class="token number">40</span><span class="token operator">:</span> putstatic     #<span class="token number">14</span>                 <span class="token comment" spellcheck="true">// Field DIME:Lcom/imooc/basic/learn_enum/CoinEnum;</span>      <span class="token number">43</span><span class="token operator">:</span> <span class="token keyword">new</span>           #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class com/imooc/basic/learn_enum/CoinEnum</span>      <span class="token number">46</span><span class="token operator">:</span> dup      <span class="token number">47</span><span class="token operator">:</span> ldc           #<span class="token number">15</span>                 <span class="token comment" spellcheck="true">// String QUARTER</span>      <span class="token number">49</span><span class="token operator">:</span> iconst_3      <span class="token number">50</span><span class="token operator">:</span> bipush        <span class="token number">25</span>      <span class="token number">52</span><span class="token operator">:</span> invokespecial #<span class="token number">9</span>                  <span class="token comment" spellcheck="true">// Method "&lt;init>":(Ljava/lang/String;II)V</span>      <span class="token number">55</span><span class="token operator">:</span> putstatic     #<span class="token number">16</span>                 <span class="token comment" spellcheck="true">// Field QUARTER:Lcom/imooc/basic/learn_enum/CoinEnum;</span>      <span class="token number">58</span><span class="token operator">:</span> iconst_4      <span class="token number">59</span><span class="token operator">:</span> anewarray     #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class com/imooc/basic/learn_enum/CoinEnum</span>      <span class="token number">62</span><span class="token operator">:</span> dup      <span class="token number">63</span><span class="token operator">:</span> iconst_0      <span class="token number">64</span><span class="token operator">:</span> getstatic     #<span class="token number">10</span>                 <span class="token comment" spellcheck="true">// Field PENNY:Lcom/imooc/basic/learn_enum/CoinEnum;</span>      <span class="token number">67</span><span class="token operator">:</span> aastore      <span class="token number">68</span><span class="token operator">:</span> dup      <span class="token number">69</span><span class="token operator">:</span> iconst_1      <span class="token number">70</span><span class="token operator">:</span> getstatic     #<span class="token number">12</span>                 <span class="token comment" spellcheck="true">// Field NICKEL:Lcom/imooc/basic/learn_enum/CoinEnum;</span>      <span class="token number">73</span><span class="token operator">:</span> aastore      <span class="token number">74</span><span class="token operator">:</span> dup      <span class="token number">75</span><span class="token operator">:</span> iconst_2      <span class="token number">76</span><span class="token operator">:</span> getstatic     #<span class="token number">14</span>                 <span class="token comment" spellcheck="true">// Field DIME:Lcom/imooc/basic/learn_enum/CoinEnum;</span>      <span class="token number">79</span><span class="token operator">:</span> aastore      <span class="token number">80</span><span class="token operator">:</span> dup      <span class="token number">81</span><span class="token operator">:</span> iconst_3      <span class="token number">82</span><span class="token operator">:</span> getstatic     #<span class="token number">16</span>                 <span class="token comment" spellcheck="true">// Field QUARTER:Lcom/imooc/basic/learn_enum/CoinEnum;</span>      <span class="token number">85</span><span class="token operator">:</span> aastore      <span class="token number">86</span><span class="token operator">:</span> putstatic     #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Field $VALUES:[Lcom/imooc/basic/learn_enum/CoinEnum;</span>      <span class="token number">89</span><span class="token operator">:</span> <span class="token keyword">return</span><span class="token punctuation">}</span></code></pre><p>通过开头位置的继承关系 <code>com.imooc.basic.learn_enum.Coin extends java.lang.Enum</code>，验证了官方手册描述的 “枚举类型的 E 是Enum的直接子类。” 的说法。</p><p>我们还看到枚举类编译后被被自动加上 <code>final</code> 关键字。</p><p>枚举常量也会被加上 <code>public static final</code> 修饰。</p><p>另外我们还注意到和源码相比多了两个函数：</p><p>其中一个为：<code>public static com.imooc.basic.learn_enum.CoinEnum valueOf(java.lang.String);</code> （见“第 2 处代码” ）</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 第 2 处代码</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_enum<span class="token punctuation">.</span>CoinEnum <span class="token function">valueOf</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> ldc           #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class com/imooc/basic/learn_enum/CoinEnum</span>       <span class="token number">2</span><span class="token operator">:</span> aload_0       <span class="token number">3</span><span class="token operator">:</span> invokestatic  #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Enum.valueOf:(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;</span>       <span class="token number">6</span><span class="token operator">:</span> checkcast     #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// class com/imooc/basic/learn_enum/CoinEnum</span>       <span class="token number">9</span><span class="token operator">:</span> areturn</code></pre><p><strong>这是怎么回事？干嘛用的呢？</strong></p><p>通过第 2 处代码的 code 偏移为 3 处的代码，我们可以看出调用了 <code>java.lang.Enum#valueOf</code> 函数。</p><p>我们直接找到该函数的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Returns the enum constant of the specified enum type with the * specified name.  The name must match exactly an identifier used * to declare an enum constant in this type.  (Extraneous whitespace * characters are not permitted.) * * &lt;p>Note that for a particular enum type {@code T}, the * implicitly declared {@code public static T valueOf(String)} * method on that enum may be used instead of this method to map * from a name to the corresponding enum constant.  All the * constants of an enum type can be obtained by calling the * implicit {@code public static T[] values()} method of that * type. * * @param &lt;T> The enum type whose constant is to be returned * @param enumType the {@code Class} object of the enum type from which *      to return a constant * @param name the name of the constant to return * @return the enum constant of the specified enum type with the *      specified name * @throws IllegalArgumentException if the specified enum type has *         no constant with the specified name, or the specified *         class object does not represent an enum type * @throws NullPointerException if {@code enumType} or {@code name} *         is null * @since 1.5 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> T <span class="token function">valueOf</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> enumType<span class="token punctuation">,</span>                                            String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    T result <span class="token operator">=</span> enumType<span class="token punctuation">.</span><span class="token function">enumConstantDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"Name is null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>        <span class="token string">"No enum constant "</span> <span class="token operator">+</span> enumType<span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>根据注释我们可以知道：</p><ul><li>该函数的功能时根据枚举名称和枚举类型找到对应的枚举常量。</li><li>所有的枚举类型有一个隐式的函数<code>public static T valueOf(String)</code> 用来根据枚举名称来获取枚举常量。</li><li>如果想获取当前枚举的所有枚举常量可以通过调用隐式的 <code>public static T[] values()</code> 函数来实现。</li></ul><p>另外一个就是上面提到的<code>public static com.imooc.basic.learn_enum.CoinEnum[] values();</code>函数。</p><p>我们回到上面反汇编的代码，偏移为 58 到 86 的指令转为 Java <strong>代码效果</strong>和下面很类似：</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">private</span> <span class="token keyword">static</span> CoinEnum<span class="token punctuation">[</span><span class="token punctuation">]</span> $VALUES<span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token punctuation">{</span>      $VALUES <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CoinEnum</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      $VALUES<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> PENNY<span class="token punctuation">;</span>      $VALUES<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> NICKEL<span class="token punctuation">;</span>      $VALUES<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> DIME<span class="token punctuation">;</span>      $VALUES<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> QUARTER<span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>根据第 1 处代码</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">// 第 1 处代码</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> com<span class="token punctuation">.</span>imooc<span class="token punctuation">.</span>basic<span class="token punctuation">.</span>learn_enum<span class="token punctuation">.</span>CoinEnum<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Code<span class="token operator">:</span>       <span class="token number">0</span><span class="token operator">:</span> getstatic     #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Field $VALUES:[Lcom/imooc/basic/learn_enum/CoinEnum;</span>       <span class="token number">3</span><span class="token operator">:</span> invokevirtual #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// Method "[Lcom/imooc/basic/learn_enum/CoinEnum;".clone:()Ljava/lang/Object;</span>       <span class="token number">6</span><span class="token operator">:</span> checkcast     #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// class "[Lcom/imooc/basic/learn_enum/CoinEnum;"</span>       <span class="token number">9</span><span class="token operator">:</span> areturn</code></pre><p>我们可以大致还原成下面的代码：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> CoinEnum<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> $VALUES<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>因此整体的逻辑就很清楚了。</p><p>结合前面拷贝章节讲到的内容，接下来大家思考下一个新问题：<strong>为什么返回克隆对象而不是属性里的枚举数组呢？</strong></p><p>其实这样设计的主要原因是：避免枚举数组在外部进行修改，影响到下一次调用：<code>CoinEnum.values()</code> 的结果。如：</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Test</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      CoinEnum<span class="token punctuation">[</span><span class="token punctuation">]</span> values1 <span class="token operator">=</span> CoinEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      values1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> CoinEnum<span class="token punctuation">.</span>QUARTER<span class="token punctuation">;</span>      CoinEnum<span class="token punctuation">[</span><span class="token punctuation">]</span> values2 <span class="token operator">=</span> CoinEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>values2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>CoinEnum<span class="token punctuation">.</span>PENNY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>通过上面代码片段可以看出：对通过 clone 函数构造的新的数组对象（values1）的某个元素重新赋值并不会影响到原数组。</p><p>因此再次调用<code>CoinEnum.values()</code> 仍然会返回基于原始枚举数组创建的新的拷贝对象（values2）。</p><h5 id="4-源码大法"><a href="#4-源码大法" class="headerlink" title="4. 源码大法"></a>4. 源码大法</h5><p>通过官方文档和反汇编，我们知道：枚举类都是 <code>java.lang.Enum</code> 的子类型。正因如此，我们可以通过查看 <code>Enum</code> 类的源码来学习枚举的一些知识。</p><p>我们通过 IDEA 自带的 Diagrams -&gt; Show Diagrams -&gt; Java Class Diagram 可以看到 Enum 类的继承关系，以及属性和函数等信息。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/Enum.jpeg" alt="Enum"></p><p>可以看到实现了<code>Comparable</code> 和 <code>Serializable</code> 接口。</p><p><strong>那么为什么要实现这两个接口？</strong></p><ul><li>实现 <code>Comparable</code> 接口很好理解，是为了排序。</li><li>实现 <code>Serializable</code> 接口是为了序列化。</li></ul><p>前面序列化的小节中讲到：“一个类实现序列化接口，那么其子类也具备序列化的能力。”</p><p>从这里大家就会明白，正是因为其父类 <code>Enum</code> 实现了序列化接口，我们的枚举类没有显式实现序列化接口，使用 Java 原生序列化也并不会报错。</p><p>其中 <code>Enum</code> 类有两个属性**：</p><p><code>name</code> 表示枚举的名称。</p><p><code>ordinal</code> 表示枚举的顺序，其主要用在 <code>java.util.EnumSet</code> 和 <code>java.util.EnumMap</code> 这两种基于枚举的数据结构中。</p><p>感兴趣的同学可以继续研究这两个数据结构的用法。</p><p>接下来我带大家重点看两个函数的源码： <code>java.lang.Enum#clone</code>函数和 <code>java.lang.Enum#compareTo</code>函数。</p><p>我们查看 <code>Enum</code>类的 <code>clone</code> 函数：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Throws CloneNotSupportedException.  This guarantees that enums * are never cloned, which is necessary to preserve their "singleton" * status. * * @return (never returns) */</span><span class="token keyword">protected</span> <span class="token keyword">final</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CloneNotSupportedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过注释和源码我们可以明确地学习到，枚举类不支持 <code>clone</code> , 如果调用会报 <code>CloneNotSupportedException</code> 异常。</p><p><strong>目的是为了保证枚举不能被克隆，维持单例的状态</strong>。</p><p>我们知道即使将构造方法设置为私有，也可以通过反射机制 <code>setAccessible</code> 为 <code>true</code> 后调用。普通的类可以通过 <code>java.lang.reflect.Constructor#newInstance</code> 来构造实例，这样就破坏了单例。</p><p>然而在该函数源码中对枚举类型会作判断并报 <code>IllegalArgumentException</code>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">newInstance</span><span class="token punctuation">(</span>Object <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initargs<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InstantiationException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span>           IllegalArgumentException<span class="token punctuation">,</span> InvocationTargetException<span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 省略..</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> Modifier<span class="token punctuation">.</span>ENUM<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Cannot reflectively create enum objects"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 省略..</span>    <span class="token keyword">return</span> inst<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这样就防止了通过反射来构造枚举实例的可能性。</p><p>接下来我们看 <code>compareTo</code> 函数源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Compares this enum with the specified object for order.  Returns a * negative integer, zero, or a positive integer as this object is less * than, equal to, or greater than the specified object. * * Enum constants are only comparable to other enum constants of the * same enum type.  The natural order implemented by this * method is the order in which the constants are declared. */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>E o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Enum<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> other <span class="token operator">=</span> <span class="token punctuation">(</span>Enum<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>    Enum<span class="token operator">&lt;</span>E<span class="token operator">></span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> other<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// optimization</span>        self<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> other<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassCastException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>ordinal <span class="token operator">-</span> other<span class="token punctuation">.</span>ordinal<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>根据注释和源码，我们可以看到：其排序的依据是 枚举常量在枚举类的声明顺序。</p><h5 id="5-断点大法"><a href="#5-断点大法" class="headerlink" title="5. 断点大法"></a>5. 断点大法</h5><p>那么我们想想为啥《手册》中会有下面的这个规定呢？</p><blockquote><p>【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。</p><p>注：</p><p>二方是指公司内部的其他部门；</p><p>二方库是指公司内部发布到中央仓库，可供公司内部其他应用依赖的库（jar包）。</p></blockquote><p>我们写一个测试函数来研究这个问题：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">serialTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    CoinEnum<span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> CoinEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 序列化</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> serialize <span class="token operator">=</span> SerializationUtils<span class="token punctuation">.</span><span class="token function">serialize</span><span class="token punctuation">(</span>values<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"序列化后的字符：{}"</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>serialize<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 反序列化</span>    CoinEnum<span class="token punctuation">[</span><span class="token punctuation">]</span> values2 <span class="token operator">=</span> SerializationUtils<span class="token punctuation">.</span><span class="token function">deserialize</span><span class="token punctuation">(</span>serialize<span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertTrue</span><span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">deepEquals</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> values2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们在 <code>java.lang.Enum#valueOf</code> 函数第一行打断点。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/Enum-valueOf.jpeg" alt="Enum-valueOf"></p><p>大家一定要自己尝试双击左下角的调用栈部分，查看从顶层调用</p><p><code>org.apache.commons.lang3.SerializationUtils#deserialize(byte[])</code> 到</p><p><code>java.lang.Enum#valueOf</code> 的整个调用过程。大家还可以通过表达式来查看参数的各种属性。</p><p>可以看到枚举的反序列化是通过调用 <code>java.lang.Enum#valueOf</code> 来实现的**。</p><p>另外我们可以查看序列化后的字节流的字符表示形式：</p><p>序列化后的字符：</p><blockquote><p>��ur&amp;[Lcom.imooc.basic.learn_enum.CoinEnum;ċ���&gt;��xpr#com.imooc.basic.learn_enum.CoinEnumxrjava.lang.EnumxptPENNYqtNICKELqtDIMEq~tQUARTER</p></blockquote><p>大致可以看出，序列化后的数据中主要包含<strong>枚举的类型</strong>和<strong>枚举名称</strong>。</p><p>我们了解了枚举的序列化和反序列化的原理后我们再思考：<strong>为什么接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象？</strong></p><p>上面讲到反序列化枚举类会调用 <code>java.lang.Enum#valueOf</code> ：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * Returns the enum constant of the specified enum type with the     * specified name.  The name must match exactly an identifier used     * to declare an enum constant in this type.  (Extraneous whitespace     * characters are not permitted.)     *     * &lt;p>Note that for a particular enum type {@code T}, the     * implicitly declared {@code public static T valueOf(String)}     * method on that enum may be used instead of this method to map     * from a name to the corresponding enum constant.  All the     * constants of an enum type can be obtained by calling the     * implicit {@code public static T[] values()} method of that     * type.     *     * @param &lt;T> The enum type whose constant is to be returned     * @param enumType the {@code Class} object of the enum type from which     *      to return a constant     * @param name the name of the constant to return     * @return the enum constant of the specified enum type with the     *      specified name     * @throws IllegalArgumentException if the specified enum type has     *         no constant with the specified name, or the specified     *         class object does not represent an enum type     * @throws NullPointerException if {@code enumType} or {@code name}     *         is null     * @since 1.5     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Enum</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> T <span class="token function">valueOf</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> enumType<span class="token punctuation">,</span>                                                String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        T result <span class="token operator">=</span> enumType<span class="token punctuation">.</span><span class="token function">enumConstantDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"Name is null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>            <span class="token string">"No enum constant "</span> <span class="token operator">+</span> enumType<span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"."</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>大家可以设想一下，如果将枚举当做 RPC 接口的返回值或者返回值对象的属性。如果己方接口新增枚举常量，而二方（公司的其他部门）没有及时升级 JAR 包，会出现什么情况？</p><p>此时，如果己方调用此接口时传入新的枚举常量，进行序列化。</p><p>反序列化时会调用到 <code>java.lang.Enum#valueOf</code> 函数， 此时参数 <code>name</code> 值为新的枚举名称。</p><pre class=" language-java"><code class="language-java">T result <span class="token operator">=</span> enumType<span class="token punctuation">.</span><span class="token function">enumConstantDirectory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>此时 <code>result = null</code> ，从源码可以看出，将会抛出 <code>IllegalArgumentException</code> 。</p><p>通过查看该函数顶部的 <code>@throws IllegalArgumentException</code> 注释，我们也可以得知：</p><blockquote><p>如果枚举类没有该常量，或者该反序列化的类对象并不是枚举类型则会抛出该异常。</p></blockquote><p>因此，二方的枚举类添加新的常量后，如果使用方没有及时更新 JAR 包，使用 Java 反序列化时可能会抛出 <code>IllegalArgumentException</code> 。</p><p>除了 Java 序列化、反序列化外，其他的序列化框架对于枚举类处理也容易出现各种错误，因此请严格遵守这一条。</p><p>大家可以通过为 <code>CoinEnum</code> 枚举类新增一个枚举常量，并将新增的枚举常量通过 Java 序列化到文件中，然后在源码中注释掉新增的枚举常量，再反序列化，来复现这个BUG。</p><p><strong>有没有好的解决办法？</strong></p><p>最常见的做法就是返回枚举的数值，并在返回的包中给出枚举类，在枚举类中提供通过根据值去获取枚举常量的方法（具体做法见下文）。</p><p>并通过使用 <code>@see</code> 或 <code>{@link}</code> 在该返回的枚举的数值注释中给出指向枚举类的快捷方式，如：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 硬币值，对应的枚举参见{@link CoinEnum} */</span><span class="token keyword">private</span> Integer coinValue<span class="token punctuation">;</span></code></pre><h4 id="1-9-3-根据值获取枚举常量的用法"><a href="#1-9-3-根据值获取枚举常量的用法" class="headerlink" title="1.9.3-根据值获取枚举常量的用法"></a>1.9.3-根据值获取枚举常量的用法</h4><p>偶尔会遇到有些团队实现通过枚举中的值获取枚举常量时，居然用 switch ，非常让人吃惊。</p><p>如上面的 <code>CoinEnum</code> 的根据值获取枚举的函数，有些人会这么写：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> CoinEnum <span class="token function">getEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>                <span class="token keyword">return</span> PENNY<span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">5</span><span class="token operator">:</span>                <span class="token keyword">return</span> NICKEL<span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">10</span><span class="token operator">:</span>                <span class="token keyword">return</span> DIME<span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">25</span><span class="token operator">:</span>                <span class="token keyword">return</span> QUARTER<span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token operator">:</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>这样做不符合设计模式的六大原则之一的 “开闭原则”，因为如果删除、新增一个枚举常量等，也需要修改该函数。</p><blockquote><p>开闭原则：对拓展开放，对修改关闭。</p></blockquote><p>另外如果枚举常量较多，很容易映射错误，后期很难维护。</p><p>可以利用前面讲到的枚举的 values 函数实现该功能，参考写法如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> CoinEnum <span class="token function">getEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>CoinEnum coinEnum <span class="token operator">:</span> CoinEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>coinEnum<span class="token punctuation">.</span>value <span class="token operator">==</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> coinEnum<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用上面的写法，如果后面需要对枚举常量进行修改，该函数不需要改动，显然比之前好了很多。</p><p>实际工作中这种写法也很常见。</p><p><strong>那么还有改进空间吗？</strong></p><p>这种写法虽然挺不错，但是每次获取枚举对象都要遍历一次枚举数组，时间复杂度是O(n)。</p><p>降低时间复杂度该怎么做？一个常见的思路就是<strong>空间换时间</strong>。</p><p>因此我们可以事先通过Map 将映射关系存起来，使用时直接从Map中获取，参考代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Getter</span><span class="token keyword">public</span> <span class="token keyword">enum</span> CoinEnum <span class="token punctuation">{</span>    <span class="token function">PENNY</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">NICKEL</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">DIME</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">QUARTER</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">/*,NEWONE(50)*/</span><span class="token punctuation">;</span>    <span class="token function">CoinEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> CoinEnum<span class="token operator">></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>CoinEnum coinEnum <span class="token operator">:</span> CoinEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>coinEnum<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> coinEnum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CoinEnum <span class="token function">getEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过上面的优化，使用时时间复杂度为 O(1)，性能有所提升。</p><p><strong>那么还有改进的空间吗？</strong></p><p>上面的代码还存在以下几个问题：</p><ul><li>每个枚举类中都需要编写类似的代码，很繁琐。</li><li>引入提供上述工具的很多枚举类，如果仅使用枚举常量，也会触发静态代码块的执行。</li></ul><p>可不可以不修改枚举就能具备这种功能？是不是可以抽取公共部分代码封装成工具类？</p><p>我们来试一试。</p><p>首先大家可以想想，如果我们要将这部分封装成工具函数，需要哪些参数？</p><p>显然需要枚举的类型，还需要知道枚举中哪个属性作为缓存的 key，还需要传入匹配的参数。</p><p>因此可以编写如下工具类封装获取枚举对象的方法：</p><pre class=" language-java"><code class="language-java">mport java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Optional<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ConcurrentHashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Function<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumUtils</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> key2EnumMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Set<span class="token operator">&lt;</span>Class<span class="token operator">></span> enumSet <span class="token operator">=</span> ConcurrentHashMap<span class="token punctuation">.</span><span class="token function">newKeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 带缓存的获取枚举值方式     *     * @param enumType    枚举类型     * @param keyFunction 根据枚举类型获取key的函数     * @param key         带匹配的Key     * @param &lt;T>         枚举泛型     * @return 枚举类型     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Enum</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">getEnumWithCache</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> enumType<span class="token punctuation">,</span> Function<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Object<span class="token operator">></span> keyFunction<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>enumSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>enumType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 不同的枚举类型相互不影响</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>enumType<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>enumSet<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>enumType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 添加枚举</span>                    enumSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>enumType<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 缓存枚举键值对</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span>T enumThis <span class="token operator">:</span> enumType<span class="token punctuation">.</span><span class="token function">getEnumConstants</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 避免重复</span>                        String mapKey <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span>enumType<span class="token punctuation">,</span> keyFunction<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>enumThis<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        key2EnumMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>mapKey<span class="token punctuation">,</span> enumThis<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>         <span class="token keyword">return</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> key2EnumMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token function">getKey</span><span class="token punctuation">(</span>enumType<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取key     * 注：带上枚举路径避免不同枚举的Key 重复     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Enum</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> String <span class="token function">getKey</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> enumType<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> enumType<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 不带缓存的获取枚举值方式     *     * @param enumType    枚举类型     * @param keyFunction 根据枚举类型获取key的函数     * @param key         带匹配的Key     * @param &lt;T>         枚举泛型     * @return 枚举类型     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Enum</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">getEnum</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> enumType<span class="token punctuation">,</span> Function<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Object<span class="token operator">></span> keyFunction<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>T enumThis <span class="token operator">:</span> enumType<span class="token punctuation">.</span><span class="token function">getEnumConstants</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>keyFunction<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>enumThis<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>enumThis<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Optional<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>注：上述的几种写法，仅适合枚举常量和对应的属性一对一的情况，其他场景可能要换一种写法。</p><p>另外建议大家再思考下此方案还有没有优化的空间？是否还有其他优雅解决方案？</p></blockquote><p>使用也非常简单:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> key <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    CoinEnum targetEnum <span class="token operator">=</span> CoinEnum<span class="token punctuation">.</span>NICKEL<span class="token punctuation">;</span>    CoinEnum anEnum <span class="token operator">=</span> CoinEnum<span class="token punctuation">.</span><span class="token function">getEnum</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>targetEnum<span class="token punctuation">,</span> anEnum<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用缓存</span>    Optional<span class="token operator">&lt;</span>CoinEnum<span class="token operator">></span> enumWithCache <span class="token operator">=</span> EnumUtils<span class="token punctuation">.</span><span class="token function">getEnumWithCache</span><span class="token punctuation">(</span>CoinEnum<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> CoinEnum<span class="token operator">:</span><span class="token operator">:</span>getValue<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertTrue</span><span class="token punctuation">(</span>enumWithCache<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>targetEnum<span class="token punctuation">,</span> enumWithCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 不使用缓存（遍历）</span>    Optional<span class="token operator">&lt;</span>CoinEnum<span class="token operator">></span> enumResult <span class="token operator">=</span> EnumUtils<span class="token punctuation">.</span><span class="token function">getEnum</span><span class="token punctuation">(</span>CoinEnum<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> CoinEnum<span class="token operator">:</span><span class="token operator">:</span>getValue<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertTrue</span><span class="token punctuation">(</span>enumResult<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>targetEnum<span class="token punctuation">,</span> enumResult<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>使用上面封装的工具类，不仅能够满足功能要求，还能实现了代码的复用，同时也做到了性能的优化。</p><p>通过上面的讲解，希望大家明白“尽信书不如无书”的道理，不要因为看到某个博客、某本书给出一个不错的写法就认为是标准答案，要有自己的思考，要有一定的代码优化意识。</p><h4 id="1-9-4-枚举的高级用法"><a href="#1-9-4-枚举的高级用法" class="headerlink" title="1.9.4-枚举的高级用法"></a>1.9.4-枚举的高级用法</h4><h5 id="1-实现计算"><a href="#1-实现计算" class="headerlink" title="1. 实现计算"></a>1. 实现计算</h5><p>从官方文档中我们可以看到，枚举常量可以带类方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">enum</span> Operation <span class="token punctuation">{</span>    PLUS <span class="token punctuation">{</span>        <span class="token keyword">double</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    MINUS <span class="token punctuation">{</span>        <span class="token keyword">double</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    TIMES <span class="token punctuation">{</span>        <span class="token keyword">double</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    DIVIDED_BY <span class="token punctuation">{</span>        <span class="token keyword">double</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Each constant supports an arithmetic operation</span>    <span class="token keyword">abstract</span> <span class="token keyword">double</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">double</span> x <span class="token operator">=</span> Double<span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">double</span> y <span class="token operator">=</span> Double<span class="token punctuation">.</span><span class="token function">parseDouble</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Operation op <span class="token operator">:</span> Operation<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> op <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> y <span class="token operator">+</span>                               <span class="token string">" = "</span> <span class="token operator">+</span> op<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以在枚举类中定义抽象方法，在枚举常量中实现该方法来提供计算等功能.</p><p>JDK 源码中常见的枚举类： <code>java.util.concurrent.TimeUnit</code> 类就有类似的用法。</p><p>这种策略枚举方式也是替代 if - else if - else 的一种解决方案。</p><h5 id="2-实现状态机"><a href="#2-实现状态机" class="headerlink" title="2. 实现状态机"></a>2. 实现状态机</h5><p>假设业务开发中需要实现状态流转的功能。</p><p>活动有：申报-&gt; 批准-&gt; 报名 -&gt; 开始 -&gt; 结束几种状态，依次流转。</p><p>我们可以通过下面的代码实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> ActivityStatesEnum <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 活动状态     * 申报-> 批准-> 报名 -> 开始 -> 结束     */</span>    <span class="token function">DEACLARE</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        ActivityStatesEnum <span class="token function">nextState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> APPROVE<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">APPROVE</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        ActivityStatesEnum <span class="token function">nextState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> ENROLL<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">ENROLL</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        ActivityStatesEnum <span class="token function">nextState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> START<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">START</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        ActivityStatesEnum <span class="token function">nextState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> END<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">END</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        ActivityStatesEnum <span class="token function">nextState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> status<span class="token punctuation">;</span>    <span class="token keyword">abstract</span> ActivityStatesEnum <span class="token function">nextState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ActivityStatesEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> status<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token keyword">public</span> ActivityStatesEnum <span class="token function">getEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>ActivityStatesEnum statesEnum <span class="token operator">:</span> ActivityStatesEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>statesEnum<span class="token punctuation">.</span>status <span class="token operator">==</span> status<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> statesEnum<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这样做的好处是可以通过 <code>getEnum</code> 函数获取枚举，直接通过 <code>nextState</code> 来获取下一个状态，更容易封装状态流转的函数，不需要每个状态都通过 <code>if</code> 判断再指定下一个状态，也降低出错的概率。</p><h5 id="3-灵活的特性组合"><a href="#3-灵活的特性组合" class="headerlink" title="3. 灵活的特性组合"></a>3. 灵活的特性组合</h5><p>fastjson 的 <code>com.alibaba.fastjson.parser.Feature</code> 类，灵活使用<code>java.lang.Enum#ordinal</code> 和位运算实现了灵活的特性组合。</p><p>源码如下：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">enum</span> Feature <span class="token punctuation">{</span>    AutoCloseSource<span class="token punctuation">,</span>   <span class="token comment" spellcheck="true">// 省略了一部分代码</span>   <span class="token function">Feature</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        mask <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> mask<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getMask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mask<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isEnabled</span><span class="token punctuation">(</span><span class="token keyword">int</span> features<span class="token punctuation">,</span> Feature feature<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>features <span class="token operator">&amp;</span> feature<span class="token punctuation">.</span>mask<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">config</span><span class="token punctuation">(</span><span class="token keyword">int</span> features<span class="token punctuation">,</span> Feature feature<span class="token punctuation">,</span> <span class="token keyword">boolean</span> state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>            features <span class="token operator">|=</span> feature<span class="token punctuation">.</span>mask<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            features <span class="token operator">&amp;=</span> <span class="token operator">~</span>feature<span class="token punctuation">.</span>mask<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> features<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">of</span><span class="token punctuation">(</span>Feature<span class="token punctuation">[</span><span class="token punctuation">]</span> features<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>features <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Feature feature<span class="token operator">:</span> features<span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">|=</span> feature<span class="token punctuation">.</span>mask<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>我们知道 <code>java.lang.Enum#ordinal</code> 表示枚举序号。因此可以通过将 1 左移枚举序号个位置，构造各种特性的掩码。</p><p>各种特性的掩码可以任意组合，来表示不同的特征组合，也可以根据特性值反向解析出这些特性组合。</p><h4 id="1-9-5-总结"><a href="#1-9-5-总结" class="headerlink" title="1.9.5-总结"></a>1.9.5-总结</h4><p>本节使用的学习方法有，思考技术的初衷，官方文档，读源码和反汇编。</p><p>主要要点如下：</p><ol><li>枚举一般表示相同类型的常量。</li><li>枚举隐式继承自 <code>Enum</code> ，实现了<code>Comparable</code> 和 <code>Serializable</code> 接口。</li><li><code>java.util.EnumSet</code> 和 <code>java.util.EnumMap</code> 是两种关于 <code>Enum</code> 的数据结构。</li><li>枚举类可以使用其<code>ordinal</code>属性，通过定义抽象函数、实现接口等方式实现高级用法。</li></ol><p>更多枚举进阶知识可参考《Effective Java》 第 6 章 枚举和注解。</p><p>下一节将讲述 <code>ArrayList</code> 类的 <code>subList</code> 函数和<code>Arrays</code> 类的<code>asList</code> 函数。</p><h3 id="1-10-ArrayList的subList和Arrays的asList学习"><a href="#1-10-ArrayList的subList和Arrays的asList学习" class="headerlink" title="1.10-ArrayList的subList和Arrays的asList学习"></a>1.10-ArrayList的subList和Arrays的asList学习</h3><h4 id="1-10-1-前言"><a href="#1-10-1-前言" class="headerlink" title="1.10.1-前言"></a>1.10.1-前言</h4><p>《手册》 第 11-12 页 对 <code>ArrayList</code> 的 <code>subList</code> 和 <code>Arrays.asList()</code> 进行了如下描述 <a href="https://www.imooc.com/read/55/article/1148#fn1" target="_blank" rel="noopener">1</a>：</p><blockquote><p>【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异 常，即 java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。</p><p>【强制】在 SubList 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p><p>【强制】使用工具类 Arrays.asList () 把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。</p></blockquote><p>那么我们思考下面几个问题：</p><ul><li>《手册》为什么要这么规定？</li><li>这对我们编码又有什么启发呢？</li></ul><p>这些都是本节重点解答的问题。</p><h4 id="1-10-2-问题分析"><a href="#1-10-2-问题分析" class="headerlink" title="1.10.2-问题分析"></a>1.10.2-问题分析</h4><p>通过前面章节的学习，相信很多人已经对通过使用类图、阅读源码和源码的注释等来学习方法已经轻车熟路了。</p><p>下面我们根据本节话题继续实战。</p><h5 id="1-ArrayList-的-subList-分析"><a href="#1-ArrayList-的-subList-分析" class="headerlink" title="1. ArrayList 的 subList 分析"></a>1. ArrayList 的 subList 分析</h5><h6 id="1-1-类图法"><a href="#1-1-类图法" class="headerlink" title="1.1 类图法"></a>1.1 类图法</h6><p>通过 IDEA 的提供的类图工具，我们可以查看该类的继承体系。</p><p>具体步骤：在 <code>SubList</code> 类中 右键，选择 “Diagrams” -&gt; “Show Diagram” 。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/ArrayList%E7%B1%BB%E5%9B%BE.jpeg" alt="ArrayList类图"></p><p>可以看到 <code>SubList</code> 和 <code>ArrayList</code> 的继承体系非常类似，都实现了 <code>RandomAccess</code> 接口 继承自 <code>AbstarctList。</code></p><p><code>SubList</code> 和 <code>ArrayList</code> 并没有继承关系，因此 “ <code>ArrayList</code> 的 <code>SubList</code> 并不能强转为 <code>ArrayList</code> 。</p><p>通过类图我们对 <code>SubList</code> 有了一个整体的了解，这将为我们进步学习打下很好的基础。</p><h6 id="1-2-DEMO-和调试大法"><a href="#1-2-DEMO-和调试大法" class="headerlink" title="1.2 DEMO 和调试大法"></a>1.2 DEMO 和调试大法</h6><p>如果想<strong>学习某个特性，最好的方法之一就是写一个小段 DEMO 来观察分析</strong>。</p><p>因此我们下面，写一个简单的测试代码片段来验证转换异常问题：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token punctuation">(</span>expected <span class="token operator">=</span> ClassCastException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testClassCast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> integerList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    integerList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    integerList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    integerList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> subList <span class="token operator">=</span> integerList<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 强转</span>    ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> cast <span class="token operator">=</span> <span class="token punctuation">(</span>ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">)</span> subList<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们还可以使用调试的表达式功能来验证我们的想法。</p><p>在调试界面的 “Variables” 窗口选择想研究的对象，如 <code>subList</code> ，然后右键选择 “Evaluate Expression”，输入想查执行的表达式，查看结果：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/ArrayList-Demo%E8%B0%83%E8%AF%95.jpeg" alt="ArrayList-Demo调试"></p><p>从上面的表达式的结果也可以清晰地看出，<code>subList</code> 并不是 <code>ArrayList</code> 类型的实例。</p><p>我们写一个代码片段来验证功能：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSubList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> stringList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"赵"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"钱"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"孙"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"李"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"周"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"吴"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"郑"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> subList <span class="token operator">=</span> stringList<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子列表："</span> <span class="token operator">+</span> subList<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子列表长度："</span> <span class="token operator">+</span> subList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subList<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"慕容"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子列表："</span> <span class="token operator">+</span> subList<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"原始列表："</span> <span class="token operator">+</span> stringList<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>输出结果为：</p><blockquote><p>子列表：[孙，李]<br>子列表长度：2<br>子列表：[孙，慕容]<br>原始列表：[赵，钱，孙，慕容，周，吴，郑，王]</p></blockquote><p>可以观察到，对子列表的修改最终对原始列表产生了影响。</p><p>那么为啥修改子序列的索引为 1 的值影响的是原始列表的第 4 个元素呢？后面将进行分析和解读。</p><h6 id="1-3-源码分析"><a href="#1-3-源码分析" class="headerlink" title="1.3 源码分析"></a>1.3 源码分析</h6><p><code>java.util.ArrayList#subList</code> 源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Returns a view of the portion of this list between the specified * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If * {@code fromIndex} and {@code toIndex} are equal, the returned list is * empty.)  The returned list is backed by this list, so non-structural * changes in the returned list are reflected in this list, and vice-versa. * The returned list supports all of the optional list operations. * * &lt;p>This method eliminates the need for explicit range operations (of * the sort that commonly exist for arrays).  Any operation that expects * a list can be used as a range operation by passing a subList view * instead of a whole list.  For example, the following idiom * removes a range of elements from a list: * &lt;pre> *      list.subList(from, to).clear(); * &lt;/pre> * Similar idioms may be constructed for {@link #indexOf(Object)} and * {@link #lastIndexOf(Object)}, and all of the algorithms in the * {@link Collections} class can be applied to a subList. * * &lt;p>The semantics of the list returned by this method become undefined if * the backing list (i.e., this list) is &lt;i>structurally modified&lt;/i> in * any way other than via the returned list.  (Structural modifications are * those that change the size of this list, or otherwise perturb it in such * a fashion that iterations in progress may yield incorrect results.) * * @throws IndexOutOfBoundsException {@inheritDoc} * @throws IllegalArgumentException {@inheritDoc} */</span><span class="token keyword">public</span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">subList</span><span class="token punctuation">(</span><span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">subListRangeCheck</span><span class="token punctuation">(</span>fromIndex<span class="token punctuation">,</span> toIndex<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SubList</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fromIndex<span class="token punctuation">,</span> toIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过源码可以看到该方法主要有两个核心逻辑：一个是检查索引的范围，一个是构造子列表对象。</p><p>通注释我们可以学到核心知识点：</p><blockquote><p>该方法返回本列表中 fromIndex （包含）和 toIndex （不包含）之间的<strong>元素视图</strong>。如果两个索引相等会返回一个空列表。</p><p>如果需要对 list 的某个范围的元素进行操作，可以用 subList，如：</p><p>list.subList(from, to).clear();</p><p>任何对子列表的操作最终都会反映到原列表中。</p></blockquote><p>我们查看函数 <code>java.util.ArrayList.SubList#set</code> 源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    E oldValue <span class="token operator">=</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">elementData</span><span class="token punctuation">(</span>offset <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">[</span>offset <span class="token operator">+</span> index<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到替换值的时候，获取索引是通过 <code>offset + index</code> 计算得来的。</p><p>这里的 <code>java.util.ArrayList#elementData</code> 即为原始列表存储元素的数组。</p><pre class=" language-java"><code class="language-java"><span class="token function">SubList</span><span class="token punctuation">(</span>AbstractList<span class="token operator">&lt;</span>E<span class="token operator">></span> parent<span class="token punctuation">,</span>        <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>parentOffset <span class="token operator">=</span> fromIndex<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>offset <span class="token operator">=</span> offset <span class="token operator">+</span> fromIndex<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> toIndex <span class="token operator">-</span> fromIndex<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>modCount <span class="token operator">=</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>modCount<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意：此处复制了 ArrayList的 modCount</span><span class="token punctuation">}</span></code></pre><p>通过子列表的构造函数我们知道，这里的偏移量 ( <code>offset</code> ) 的值为 <code>fromIndex</code> 参数。</p><p>因此上小节提到的：** 为啥子序列的索引为 1 的值影响的是原始列表的第 4 个元素呢？** 的问题就不言自明了。</p><p>另外在 <code>SubList</code> 的构造函数中，会将 <code>ArrayList</code> 的 <code>modCount</code> 赋值给 <code>SubList</code> 的 <code>modCount</code> 。</p><p>我们再回到规约中规定：</p><blockquote><p>【强制】在 subList 场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p></blockquote><p>我们看 <code>java.util.ArrayList#add(E)</code> 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt>true&lt;/tt> (as specified by {@link Collection#add}) */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以发现新增元素和删除元素，都会对 <code>modCount</code> 进行修改。</p><p>我们再看 <code>SubList</code> 的 核心的函数，如 <code>java.util.ArrayList.SubList#get</code> 和 <code>java.util.ArrayList.SubList#size</code> ：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">elementData</span><span class="token punctuation">(</span>offset <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>都会进行修改检查：</p><pre><code>java.util.ArrayList.SubList#checkForComodificationprivate void checkForComodification() {    if (ArrayList.this.modCount != this.modCount)        throw new ConcurrentModificationException();}</code></pre><p>而从上面的 <code>SubList</code> 的构造函数我们可以看到，<code>SubList</code> 复制了 ArrayList 的 modCount，因此对原函数的新增或删除都会导致 <code>ArrayList</code> 的 <code>modCount</code> 的变化。而子列表的遍历、增加、删除时又会检查创建 <code>SubList</code> 时的 modCount 是否一致，显然此时两者会不一致，导致抛出 <code>ConcurrentModificationException</code> (并发修改异常)。</p><p>至此上面约定的原因我们也非常明了了。</p><h5 id="2-Arrays-asList-分析"><a href="#2-Arrays-asList-分析" class="headerlink" title="2. Arrays.asList () 分析"></a>2. Arrays.asList () 分析</h5><h6 id="2-1-类图法"><a href="#2-1-类图法" class="headerlink" title="2.1 类图法"></a>2.1 类图法</h6><p>和前面一样，查看类图来了解 <code>Arrays.asList()</code> 的返回类型。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/Arrays-asList%E7%B1%BB%E5%9B%BE.jpeg" alt="Arrays-asList类图"></p><p>发现该 <code>java.util.Arrays.ArrayList</code> (右侧) 和 <code>java.util.ArrayList</code> （左侧），的继承体系非常相似，继承自 <code>java.util.AbstractList</code> 。</p><p>我们打开左上角的 “Method” 功能，对比两者的主要函数的异同：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/Arrays.asList%E5%92%8CArrayList%E6%96%B9%E6%B3%95.jpeg" alt="Arrays.asList和ArrayList方法"></p><p>我们可以清楚地发现， <code>java.util.Arrays.ArrayList</code> (右侧) 并没有像左侧一样 重写 <code>add</code> 、 <code>remove</code> 函数。</p><h6 id="2-2-源码大法"><a href="#2-2-源码大法" class="headerlink" title="2.2 源码大法"></a>2.2 源码大法</h6><p>接下来我们分析 <code>Arrays.asList()</code> 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Returns a fixed-size list backed by the specified array.  (Changes to * the returned list "write through" to the array.)  This method acts * as bridge between array-based and collection-based APIs, in * combination with {@link Collection#toArray}.  The returned list is * serializable and implements {@link RandomAccess}. * * &lt;p>This method also provides a convenient way to create a fixed-size * list initialized to contain several elements: * &lt;pre> *     List&amp;lt;String&amp;gt; stooges = Arrays.asList("Larry", "Moe", "Curly"); * &lt;/pre> * * @param &lt;T> the class of the objects in the array * @param a the array by which the list will be backed * @return a list view of the specified array */</span><span class="token annotation punctuation">@SafeVarargs</span><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"varargs"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">asList</span><span class="token punctuation">(</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过注释我们可以得到下面的要点：</p><blockquote><p>返回基于特定数组的<strong>定长列表</strong>。</p><p>该方法扮演数组到集合的桥梁。</p><p>该方法也提供了包含多个元素的定长列表的方法：</p><p>List stooges = Arrays.asList(“Larry”, “Moe”, “Curly”);</p></blockquote><p>可看出此方法的功能是为了返回<strong>定长的列表</strong>。</p><p>这里的” 定长列表 “的描述非常重要，这也就解释了为什么不支持增加和删除元素的原因。</p><p>结合前面的类图，我们去查看 <code>AbstactList</code> 的 <code>add</code> 和 <code>remove</code> 相关函数：</p><pre><code>java.util.AbstractList#add(int, E)public void add(int index, E element) {    throw new UnsupportedOperationException();}java.util.AbstractList#removepublic E remove(int index) {    throw new UnsupportedOperationException();}</code></pre><p>可知如果子类不重写这两个函数，就会抛出 <code>UnsupportedOperationException</code>（不支持的操作异常）。</p><p>我们再看看 <code>java.util.AbstractList#clear</code> 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Removes all of the elements from this list (optional operation). * The list will be empty after this call returns. * * &lt;p>This implementation calls {@code removeRange(0, size())}. * * &lt;p>Note that this implementation throws an * {@code UnsupportedOperationException} unless {@code remove(int * index)} or {@code removeRange(int fromIndex, int toIndex)} is * overridden. * * @throws UnsupportedOperationException if the {@code clear} operation *         is not supported by this list */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">removeRange</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过注释可知 如果没有重写 <code>remove(int index)</code> 或 <code>removeRange(int fromIndex, int toIndex)</code> 同样也会抛出 <code>UnsupportedOperationException</code> 。</p><h4 id="1-10-3-学习的启发"><a href="#1-10-3-学习的启发" class="headerlink" title="1.10.3-学习的启发"></a>1.10.3-学习的启发</h4><p>在 Java 的学习过程中，大多数人都是通过看视频，读博客，搜索引擎搜索，买书等来学习知识。</p><p>但是很多资料都是告诉你结论，但这样容易浮于表面，知其然而不知其所以然。而源码、官方文档等才是权威的知识。</p><p>希望从现在开始学习和开发中能够偶尔到感兴趣的类中查看源码，这样学的更快，更扎实。通过进入源码中自主研究，这样印象更加深刻，掌握的程度更深。</p><p>我们同样发现学习的手段并非只有一种，往往多种研究方式结合起来效果最好。</p><h4 id="1-10-4-本文通过类图分析、源码分析以及-DEMO-和调试的方式对-ArrayList-的-SubList-问题和-Arrays-的-asList-进行分析。并根据分析阐述了对我们学习的启发。"><a href="#1-10-4-本文通过类图分析、源码分析以及-DEMO-和调试的方式对-ArrayList-的-SubList-问题和-Arrays-的-asList-进行分析。并根据分析阐述了对我们学习的启发。" class="headerlink" title="1.10.4-本文通过类图分析、源码分析以及 DEMO 和调试的方式对 ArrayList 的 SubList 问题和 Arrays 的 asList 进行分析。并根据分析阐述了对我们学习的启发。"></a>1.10.4-本文通过类图分析、源码分析以及 DEMO 和调试的方式对 <code>ArrayList</code> 的 <code>SubList</code> 问题和 <code>Arrays</code> 的 <code>asList</code> 进行分析。并根据分析阐述了对我们学习的启发。</h4><p>本节的要点：</p><ol><li><code>ArrayList</code> 内部类 <code>SubList</code> 和 <code>ArrayList</code> 没有继承关系，因此无法将其强转为 <code>ArrayList</code> 。</li><li><code>ArrayList</code> 的 <code>SubList</code> 构造时传入 <code>ArrayList</code> 的 <code>modCount</code>，因此对原列表的修改将会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</li><li><code>Arrays.asList()</code> 函数是提供通过数组构造定长集合的功能，该函数提供数组到集合的桥梁。</li></ol><p>下一节我们将讲述添加注释的正确姿势。</p><h4 id="1-10-5-课后练习"><a href="#1-10-5-课后练习" class="headerlink" title="1.10.5-课后练习"></a>1.10.5-课后练习</h4><p>《手册》第 11 页 集合处理章节有这么一条规定：</p><blockquote><p>【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。</p></blockquote><p>那么问题来了，为什么 “不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式”？</p><p>请大家结合前面和本小节所学的内容自己实际动手研究一下。</p><h3 id="1-11-添加注释的正确姿势"><a href="#1-11-添加注释的正确姿势" class="headerlink" title="1.11-添加注释的正确姿势"></a>1.11-添加注释的正确姿势</h3><h4 id="1-11-1-前言"><a href="#1-11-1-前言" class="headerlink" title="1.11.1-前言"></a>1.11.1-前言</h4><p>《手册》 21 页，第八节 注释规约部分对注释规范的要点给出了比较全面的指导 <a href="https://www.imooc.com/read/55/article/1149#fn1" target="_blank" rel="noopener">1</a>。</p><blockquote><p>【强制】所有类都必须添加创建者和日期。</p><p>【强制】所有的枚举类型字段都必须有注释，说明每个数据项的用途。</p><p>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等修改。</p><p>【参考】特殊标记，请注明标记人与标记时间。</p></blockquote><p>我们要思考以下几个问题：</p><ul><li>你平时写注释吗？</li><li>你知道注释的目的是什么？</li><li>有哪些好的注释范例？</li><li>为什么会有这些规定？</li><li>还有哪些好的规约？</li></ul><p>本节将为你解答上述疑问。</p><h4 id="1-11-2-注释的目的"><a href="#1-11-2-注释的目的" class="headerlink" title="1.11.2-注释的目的"></a>1.11.2-注释的目的</h4><p>注释的目的是：<strong>辅助读代码的人员更快速的理解代码</strong>。</p><p>因此我们写注释的时候不管使用何种规约和技巧都要围绕这个目的展开。</p><p>这就要求编写注释时，要能够<strong>准确描述函数的功能，核心逻辑，潜在风险，注意事项等</strong>。</p><p>如果注释写地好，即使过了很久自己可以通过注释快速理解代码，也可以帮助团队其他合作的成员快速理解自己的代码，快速找到相关文档，也将方便未来接手自己工作的开发人员。这也是一个优秀程序员专业性的一种体现。</p><h4 id="1-11-3-常见的注释类型和写法"><a href="#1-11-3-常见的注释类型和写法" class="headerlink" title="1.11.3-常见的注释类型和写法"></a>1.11.3-常见的注释类型和写法</h4><h5 id="1-常规注释"><a href="#1-常规注释" class="headerlink" title="1. 常规注释"></a>1. 常规注释</h5><p>常规注释主要指普通的注释，比如每个接口几乎都会有的：接口的功能，接口的参数以及含义，接口异常和出现异常的原因，接口的返回值。</p><p>首先我们从 JDK 代码注释中寻找灵感。</p><p>我们可以参考 <code>ThreadPoolExecutor#ThreadPoolExecutor</code> 构造函数的注释：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Creates a new {@code ThreadPoolExecutor} with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless {@code allowCoreThreadTimeOut} is set * @param maximumPoolSize the maximum number of threads to allow in the *        pool * @param keepAliveTime when the number of threads is greater than *        the core, this is the maximum time that excess idle threads *        will wait for new tasks before terminating. * @param unit the time unit for the {@code keepAliveTime} argument * @param workQueue the queue to use for holding tasks before they are *        executed.  This queue will hold only the {@code Runnable} *        tasks submitted by the {@code execute} method. * @param threadFactory the factory to use when the executor *        creates a new thread * @param handler the handler to use when execution is blocked *        because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br> *         {@code corePoolSize &lt; 0}&lt;br> *         {@code keepAliveTime &lt; 0}&lt;br> *         {@code maximumPoolSize &lt;= 0}&lt;br> *         {@code maximumPoolSize &lt; corePoolSize} * @throws NullPointerException if {@code workQueue} *         or {@code threadFactory} or {@code handler} is null */</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>acc <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span>            null <span class="token operator">:</span>            AccessController<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到该注释先给出了该构造函数的<strong>功能说明</strong>，然后对<strong>每个参数的含义</strong>进行解读，然后给出了<strong>抛出的异常以及抛出异常对应的具体原因</strong>。</p><p>正是 JDK 的注释非常专业和详细，才为我们学习源码提供了便利。试想如果没有注释，我们学习和理解源码的速度会不会更慢呢？</p><h5 id="2-工具函数注释"><a href="#2-工具函数注释" class="headerlink" title="2. 工具函数注释"></a>2. 工具函数注释</h5><p>工具类的注释主要包含：函数的功能，函数的使用范例，函数的参数和返回值描述，该函数出现的起始版本等。</p><p>我们选取 commons-lang3 的 <code>StringUtils</code> 类的 <code>StringUtils#isAnyEmpty</code> 函数的源码来学习工具函数的注释。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * &lt;p>Checks if any of the CharSequences are empty ("") or null.&lt;/p> * * &lt;pre> * StringUtils.isAnyEmpty((String) null)    = true * StringUtils.isAnyEmpty((String[]) null)  = false * StringUtils.isAnyEmpty(null, "foo")      = true * StringUtils.isAnyEmpty("", "bar")        = true * StringUtils.isAnyEmpty("bob", "")        = true * StringUtils.isAnyEmpty("  bob  ", null)  = true * StringUtils.isAnyEmpty(" ", "bar")       = false * StringUtils.isAnyEmpty("foo", "bar")     = false * StringUtils.isAnyEmpty(new String[]{})   = false * StringUtils.isAnyEmpty(new String[]{""}) = true * &lt;/pre> * * @param css  the CharSequences to check, may be null or empty * @return {@code true} if any of the CharSequences are empty or null * @since 3.2 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isAnyEmpty</span><span class="token punctuation">(</span><span class="token keyword">final</span> CharSequence<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> css<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>css<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">final</span> CharSequence cs <span class="token operator">:</span> css<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>cs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>除了前面提到的功能描述，参数和返回值描述外，该注释部分还给出了<strong>常见的使用范例和执行结果</strong>，能够帮助读者快速理解函数的用法。</p><p>强烈建议我们在编写工具类时参考这种写法，方便使用者的同时也体现了我们的专业水准。</p><h5 id="3-废弃代码的注释"><a href="#3-废弃代码的注释" class="headerlink" title="3. 废弃代码的注释"></a>3. 废弃代码的注释</h5><p>正如专栏的 ” 过期类、属性和接口的正确处理方式 “ 小节所讲的：废弃的接口要给出废弃的原因和替代方案等。</p><p>我们可以参考下面代码废弃函数的注释：</p><pre><code>com.google.common.io.LittleEndianDataOutputStream#writeBytes/** * @deprecated The semantics of {@code writeBytes(String s)} are considered dangerous. Please use *     {@link #writeUTF(String s)}, {@link #writeChars(String s)} or another write method instead. */@Deprecated@Overridepublic void writeBytes(String s) throws IOException {  ((DataOutputStream) out).writeBytes(s);}</code></pre><p>该函数给出了废弃的原因：该函数比较危险。</p><p>给出了两个替代方案： <code>{@link #writeUTF(String s)}, {@link #writeChars(String s)}</code> 。</p><p>从这里我们学到，除了交代废弃的原因和替代方法外，还可以使用 <code>{@link}</code> 提供跳转到替代函数的快捷方式。</p><h5 id="4-警告类注释"><a href="#4-警告类注释" class="headerlink" title="4. 警告类注释"></a>4. 警告类注释</h5><p>比如有很多程序员为了方便测试会写一个测试控制器，如 <code>TestController</code> ，来提供 HTTP 接口的控制器，预留一些 “测试后门”，通常会有一个比较好的做法是放到某个特定测试分支，不会带到线上。</p><p>如：</p><ul><li>提供查看项目的 apollo 配置项是否生效的接口。</li><li>提供查看 redis 数据的接口。</li><li>提供修复数据的接口。</li><li>提供某项功能的开关接口。</li><li>等</li></ul><p>那么如果有些接口操作姿势 “非常特别” 或者 “非常危险”，一定要接口上加上注释，防止其他人员误触，导致故障。</p><p>如果某个函数仅供内部使用或者仅供某个功能使用，最好可以在注释上加上警示。</p><p>这些都极大降低沟通成功，极大降低团队其他成员犯错的几率。</p><h5 id="5-特殊注释"><a href="#5-特殊注释" class="headerlink" title="5. 特殊注释"></a>5. 特殊注释</h5><p>开发中特殊注释如：TODO 注释和 FIXME 注释也非常常见。</p><p><strong>TODO 注释主要用在本该做还没做的事项。</strong></p><ul><li>待斟酌函数的命名。</li><li>性能不佳，待后期优化。</li><li>开发过程某个功能使用前需要进行权限校验，但是权限校验依赖的新接口对方还没开发好。</li></ul><p>此时可以加上 TODO 注释可以参考下面格式：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// TODO:: [xxx功能] 负责人：张三，事项：待添加权限验证逻辑，添加时间：2019-08-25 预计处理时间：2019-09-01</span></code></pre><p>包含功能名称、责任人、事项、添加时间和预处理时间等信息。</p><p>我们看看 <code>com.google.common.io.Resources#getResource(java.lang.String)</code> 源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Returns a {@code URL} pointing to {@code resourceName} if the resource is found using the * {@linkplain Thread#getContextClassLoader() context class loader}. In simple environments, the * context class loader will find resources from the class path. In environments where different * threads can have different class loaders, for example app servers, the context class loader * will typically have been set to an appropriate loader for the current thread. * * &lt;p>In the unusual case where the context class loader is null, the class loader that loaded * this class ({@code Resources}) will be used instead. * * @throws IllegalArgumentException if the resource is not found */</span><span class="token annotation punctuation">@CanIgnoreReturnValue</span> <span class="token comment" spellcheck="true">// being used to check if a resource exists</span><span class="token comment" spellcheck="true">// TODO(cgdecker): maybe add a better way to check if a resource exists</span><span class="token comment" spellcheck="true">// e.g. Optional&lt;URL> tryGetResource or boolean resourceExists</span><span class="token keyword">public</span> <span class="token keyword">static</span> URL <span class="token function">getResource</span><span class="token punctuation">(</span>String resourceName<span class="token punctuation">)</span> <span class="token punctuation">{</span>  ClassLoader loader <span class="token operator">=</span>      MoreObjects<span class="token punctuation">.</span><span class="token function">firstNonNull</span><span class="token punctuation">(</span>          Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Resources<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  URL url <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span>resourceName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">checkArgument</span><span class="token punctuation">(</span>url <span class="token operator">!=</span> null<span class="token punctuation">,</span> <span class="token string">"resource %s not found."</span><span class="token punctuation">,</span> resourceName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> url<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其中注释的最后两行用到了 TODO 注释，该注释包含了责任人和修改思路。</p><p>因此如果有未来优化的思路时，可以通过 TODO 进行注释，在未来代码迭代时实现该注释的想法。</p><p><code>com.google.common.escape.Escapers#wrap</code> 也有一个不错的范例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> UnicodeEscaper <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token keyword">final</span> CharEscaper escaper<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 省略</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>hiChars <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// TODO: Is this faster than System.arraycopy() for small arrays?</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> n <span class="token operator">&lt;</span> hiChars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>      output<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> hiChars<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    output<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> surrogateChars<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 省略</span><span class="token punctuation">}</span></code></pre><p>这里表明作者还没有将两者性能进行对比，得到最佳选项。</p><p><strong>FIXME 注释，主要用在某些出错代码处，一般是一些不能工作需要及时纠正的错误。</strong></p><p>如编写了一处代码，其中部分代码涉及到了计算，但是自测时发现计算结果出错。此时可以参考下面的格式添加 FIXME 注释。在代码上线前一定要修复并验证好相关错误。</p><p>示例：</p><pre><code>// FIXME:: [xxx功能] 负责人：张三，错误：计算错误，添加时间：2019-08-08 预计处理时间：2019</code></pre><h4 id="1-11-4-为什么这么规定？"><a href="#1-11-4-为什么这么规定？" class="headerlink" title="1.11.4-为什么这么规定？"></a>1.11.4-为什么这么规定？</h4><p>不知道大家有没有思考过这个问题： <strong>为什么《手册》会有这些规定？</strong></p><p>我想这么做的最主要原因是为了帮助读代码的人员快速理解代码。</p><p>下面选取几条进行解读：</p><p><strong>【强制】方法内部单行注释，在被注释语句上方另起一行，使用 // 注释。方法内部多行注释</strong><br><strong>使用 /* */ 注释，注意与代码对齐。</strong></p><p>方法内部单行注释，在被注释的语句上方另起一行。主要体现了整体思维，也是为了实现 ” 代码意群 “效应，从视觉上让注释和下面的代码更接近。</p><p><strong>【强制】 所有的类都必须添加创建者和创建时间。</strong></p><p>类添加了创建者，读者就可以知道第一个创建该类的人（一般是最熟悉的人）是谁，遇到问题可以找他核实。</p><p>类添加了创建时间，有助于阅读此代码的人更方便地了解类的编写时间。</p><p>另外在这里给出一个技巧：如果我们使用的是 IDEA，并用 GIT 进行代码版本管理，可以在编辑器的左侧行数附近，右键选择 “Annotate”， 可以查看某行代码修改的人和时间。</p><p>如果你对该部分代码有疑问，可以快速定位到修改的人和修改时间，对我们协调和解决问题有极大的帮助。</p><h4 id="1-11-5-补充"><a href="#1-11-5-补充" class="headerlink" title="1.11.5-补充"></a>1.11.5-补充</h4><p><strong>【强制】如果代码逻辑和注释不符，必须进行修改</strong></p><p>代码逻辑和注释不符，容易让使用者误用，增加出错的概率，容易造成返工降低开发效率。</p><p>通常由于开发者理解有误，偶尔会写出了误导性注释，如果发现这类问题一定要认真核实，如果确认是误导性注释，一定要及时修改，避免团队其他成员重复趟坑。</p><p><strong>【推荐】 TODO 注释要加上功能名称</strong></p><p><strong>为什么特殊注释要加上功能名称？</strong></p><p>通常我们会有很多项目的 TODO 注释，但是最常遇到的需求是快速定位正在开发的某个功能的 TODO 注释或者其他某个想修改的功能的 TODO 进行修改。此时如果 TODO 较多且没有标注功能名称，要想找到自己要修改的 TODO 项，通常需要通过搜索自己的姓名来查找，如果 TODO 较多查找起来将非常耗时。</p><p><strong>【推荐】方法注释中建议添加相关需求文档，接口文档地址。</strong></p><p>很多公司都会有接口平台，开发人员可以将 Dubbo 或 HTTP 接口传到接口平台中，从而得到访问链接，方便前后端对接。</p><p>建议将上传的 Dubbo 和 HTTP 接口文档地址顺手加入到注释中，避免每次需要使用时都要手动搜索。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *  xxx功能（功能描述） * *  需求文档：{@link &lt;a href="http://doc.imooc.com/xxx/process/0001"/>} *  接口文档：{@link &lt;a href="http://api.imooc.com/xxx/process/0001"/>} *  对接人员：@张三 * * @param param  参数描述 * @return  返回值描述 */</span><span class="token keyword">public</span> Object <span class="token function">something</span><span class="token punctuation">(</span>Object param<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1. 查询xx数据</span>    <span class="token comment" spellcheck="true">// 2. 过滤yy条件</span>    <span class="token comment" spellcheck="true">// 3. 组装结果</span><span class="token punctuation">}</span></code></pre><p>尤其是对依赖的三方 / 二方接口的封装，大家可以将此接口的相关文档和负责人添加到注释中。</p><p>后面自己也可能经常需要找接口的文档链接，开发过程中遇到问题也可及时和对接人沟通，这将极大提供工作效率。</p><p>这是一条非常值得推荐的技巧，这种注释风格非常能够体现出一个人的专业素养。</p><p><strong>【推荐】容易费解的地方一定要加注释。</strong></p><p>自己某块代码的写法很诡异，一定要注明原因。</p><p>否则极有可能因为时间久远，后面自己再回头看，或者别人问你为什么这么写，自己都蒙圈了。</p><p>导致别人不敢乱改，自己也不敢改动的尴尬情况。</p><p>这将是一个非常大的隐患。</p><p><strong>【推荐】推荐 git 提交注释的格式为： [功能名称] &lt; 提交类型 &gt; 修改点描述。</strong></p><p>很多公司对 git 提交注释的格式有自己的要求， 但是很多公司没有规定，导致大家写的都很随意。</p><p>很多人提交的注释都是功能的描述，无法得知因哪个功能做的修改。</p><p>建议大家可以养成好的习惯，在提交的描述中增加功能名称，并且能够再添加修改的性质就更好了。</p><p>修改的性质包括：<strong>新增、删除、修改、修复等</strong>。</p><p>比如我们独立开发的一个功能，突然中间有一个提交没有带我们的功能名称或功能名称不对，我们可以及时感知到可能出现了问题。</p><p>比如我们很久之后发现之前自己对某个函数进行了修改，自己却忘记修改的目的，我们可以查看提交记录，根据注释快速了解到是由于哪个功能导致的修改。</p><p><strong>正例</strong>：</p><pre><code>[a功能] &lt;add&gt;  某某接口[a功能] &lt;delete&gt; 删除了无用的注释[a功能] &lt;update&gt;  修改函数命名[a功能] &lt;fix&gt; 修复了某个错误</code></pre><p>大家实践之后就会发现该规约的好处。</p><p><strong>【参考】 利用 //—– 或 /* —- 分组 — */ 注释实现” 方法分组 “</strong></p><p><code>org.apache.commons.lang3.BooleanUtils</code> 工具类中就广泛应用了这种方式：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Integer to Boolean methods</span><span class="token comment" spellcheck="true">//-----------------------------------------------------------------------</span><span class="token comment" spellcheck="true">// 各种整型转布尔类型的函数</span></code></pre><p>再如 <code>java.util.HashMap</code> 中的方法分组注释:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/* ---------------- Static utilities -------------- */</span></code></pre><p>通过方法分组的注释可以很好地实现函数的 ” 分组 “，将类中功能相似的方法放在一起，并使用上述注释进行分割，是一个不错的技巧。</p><p><strong>【参考】多写设计的目的，注意事项，不要写从代码显而易见的注释。</strong></p><p>很多人喜欢写一些显而易见的注释，导致自己花费了时间对团队其他人却没太大帮助。</p><p>如果方法比较复杂，尽量写<strong>设计的目的和注意的事项等更有帮助的内容</strong>。</p><p><strong>反例</strong>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Boolean <span class="token function">isLegal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果在售或有库存或有敏感词则返回false</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isOnSell <span class="token operator">==</span> null <span class="token operator">||</span> hasStock <span class="token operator">==</span> null <span class="token operator">||</span> hasSensitiveWords <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> isOnSell <span class="token operator">&amp;&amp;</span> hasStock <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasSensitiveWords<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>【参考】 可以将方法的核心逻辑拆分成多个步骤，关键步骤在函数内部可以加上注释并带上序号，之前空一行。</strong></p><p>函数内的逻辑注释，将有助于我们养成任务拆解的思维，也有助于自己或团队其他成员快速理解编程的逻辑。</p><p>如果核心逻辑的关键步骤加上注释，当代码较长时可以快速帮助读代码的人理解。</p><p>这样当代码行数超过 80 行时，开发者也可以根据核心逻辑注释来拆分子函数。</p><p>即使不在核心步骤添加注释 (或提取子函数)，在核心步骤之间加上一个空格行，方便读者理解。</p><p>大家可以在每个大的步骤前加注释，也可以在核心逻辑前将注释分条列举。</p><p>可以参考 <code>java.util.concurrent.ThreadPoolExecutor#execute</code> 函数的注释：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Executes the given task sometime in the future.  The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current {@code RejectedExecutionHandler}. * * @param command the task to execute * @throws RejectedExecutionException at discretion of *         {@code RejectedExecutionHandler}, if the task *         cannot be accepted for execution * @throws NullPointerException if {@code command} is null */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * Proceed in 3 steps:     *     * 1. If fewer than corePoolSize threads are running, try to     * start a new thread with the given command as its first     * task.  The call to addWorker atomically checks runState and     * workerCount, and so prevents false alarms that would add     * threads when it shouldn't, by returning false.     *     * 2. If a task can be successfully queued, then we still need     * to double-check whether we should have added a thread     * (because existing ones died since last checking) or that     * the pool shut down since entry into this method. So we     * recheck state and if necessary roll back the enqueuing if     * stopped, or start a new thread if there are none.     *     * 3. If we cannot queue task, then we try to add a new     * thread.  If it fails, we know we are shut down or saturated     * and so reject the task.     */</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="1-11-6-总结"><a href="#1-11-6-总结" class="headerlink" title="1.11.6-总结"></a>1.11.6-总结</h4><p>本节如果你只记一句话那就是：<strong>注释的目的是让读者更快理解代码的含义</strong> 。注释的其他规约都是围绕这一点展开的。</p><p>本节讲述了注释的目的，并结合实际的开发经验对注释相关规约进行了解读和补充。</p><p>编写恰当的注释是一个程序员专业性的体现，希望大家在编程中能够严格要求自己，能够认真实践好的注释规范，提高开发效率，少趟坑。</p><p>下一节将讲述变长参数的奥秘。</p><h3 id="1-12-你真得了解可变参数吗"><a href="#1-12-你真得了解可变参数吗" class="headerlink" title="1.12-你真得了解可变参数吗?"></a>1.12-你真得了解可变参数吗?</h3><h4 id="1-12-1-前言"><a href="#1-12-1-前言" class="headerlink" title="1.12.1-前言"></a>1.12.1-前言</h4><p>《手册》第 7 页 有一段关于 Java 变长参数的规约<a href="https://www.imooc.com/read/55/article/1150#fn1" target="_blank" rel="noopener">1</a> ：</p><blockquote><p>【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 <code>Object</code> 。说明:可变参数必须放置在参数列表的最后。(提倡同学们尽量不用可变参数编程)<br>正例: <code>public List listUsers(String type, Long... ids) {...}</code></p></blockquote><p>那么我们要思考下面几个问题：</p><ul><li>为什么要有变长参数？</li><li>可变参数的常见用法是什么？</li><li>可变参数有哪些诡异的表现？</li></ul><p>本节将详细探讨这些问题。</p><h4 id="1-12-2-变长参数的思考"><a href="#1-12-2-变长参数的思考" class="headerlink" title="1.12.2-变长参数的思考"></a>1.12.2-变长参数的思考</h4><h5 id="1-初步了解可变参数"><a href="#1-初步了解可变参数" class="headerlink" title="1. 初步了解可变参数"></a>1. 初步了解可变参数</h5><p>我们知道可变参数（vararg）方法（又叫 variable arity method）语言特性是在 Java 5 出现的。</p><p>可变参数方法接受 <strong>0 到多个相同类型参数（通常都是1个及以上）</strong>。</p><p>其核心原理是：<strong>创建一个数组，数组大小为可变参数传入的元素个数，最终将数组传递给方法</strong>。</p><h5 id="2-可变参数的思考"><a href="#2-可变参数的思考" class="headerlink" title="2. 可变参数的思考"></a>2. 可变参数的思考</h5><p>我们学习 Java 一些语言特性时，最好能够思考它为什么会出现？是为了解决什么问题？有哪些优势？没有它会有哪些困难？等。</p><p>我们思考这样一个问题：<strong>可变参数的目的是什么?</strong></p><p>试想一下，如果没有变长参数的语言特性，我们会怎么处理？</p><ul><li>我们可以通过定义多个相同类型的参数进行重载。但是如果这样做如果参数数量不固定就无法实现。</li><li>我们还可以通过定义数组的参数进行重载。但是这就要求调用时要构造数组，又变成了 “定长”，而且需要增加构造数组的代码，代码不够简洁。</li></ul><p>由此可见，变长参数适应了不定参数个数的情况，<strong>避免了手动构造数组，提高语言的简洁性和代码的灵活性</strong>。</p><h4 id="1-12-3-常见变长参数函数"><a href="#1-12-3-常见变长参数函数" class="headerlink" title="1.12.3-常见变长参数函数"></a>1.12.3-常见变长参数函数</h4><h5 id="1-JDK中变长参数函数举例"><a href="#1-JDK中变长参数函数举例" class="headerlink" title="1. JDK中变长参数函数举例"></a>1. JDK中变长参数函数举例</h5><p>包括 JDK 在内的很多库都封装了很多带有变长参数的函数。</p><p><code>java.lang.String#format(java.lang.String, java.lang.Object...)</code> 就是JDK 中非常常见的变长参数函数之一。</p><p>其源码如下：</p><pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">/**     * Returns a formatted string using the specified format string and     * arguments.     *     * &lt;p> The locale always used is the one returned by {@link     * java.util.Locale#getDefault() Locale.getDefault()}.     *     * @param  format     *         A &lt;a href="../util/Formatter.html#syntax">format string&lt;/a>     *     * @param  args     *         Arguments referenced by the format specifiers in the format     *         string.  If there are more arguments than format specifiers, the     *         extra arguments are ignored.  The number of arguments is     *         variable and may be zero.  The maximum number of arguments is     *         limited by the maximum dimension of a Java array as defined by     *         &lt;cite>The Java&amp;trade; Virtual Machine Specification&lt;/cite>.     *         The behaviour on a     *         {@code null} argument depends on the &lt;a     *         href="../util/Formatter.html#syntax">conversion&lt;/a>.     *     * @throws  java.util.IllegalFormatException     *          If a format string contains an illegal syntax, a format     *          specifier that is incompatible with the given arguments,     *          insufficient arguments given the format string, or other     *          illegal conditions.  For specification of all possible     *          formatting errors, see the &lt;a     *          href="../util/Formatter.html#detail">Details&lt;/a> section of the     *          formatter class specification.     *     * @return  A formatted string     *     * @see  java.util.Formatter     * @since  1.5     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">format</span><span class="token punctuation">(</span>String format<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Formatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>根据参数名称或源码注释可知：第一个参数是格式定义，第二个参数为变长参数为前面的格式定义占位符对应的参数。</p><p>用法如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">format</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    String pattern <span class="token operator">=</span> <span class="token string">"我喜欢在 %s 上学习 %s"</span><span class="token punctuation">;</span>    String arg0 <span class="token operator">=</span> <span class="token string">"https://www.imooc.com/"</span><span class="token punctuation">;</span>    String arg1 <span class="token operator">=</span> <span class="token string">"编程"</span><span class="token punctuation">;</span>    String format <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> arg0<span class="token punctuation">,</span> arg1<span class="token punctuation">)</span><span class="token punctuation">;</span>    String expected <span class="token operator">=</span> <span class="token string">"我喜欢在 "</span> <span class="token operator">+</span> arg0 <span class="token operator">+</span> <span class="token string">" 上学习 "</span> <span class="token operator">+</span> arg1<span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertEquals</span><span class="token punctuation">(</span>expected<span class="token punctuation">,</span> format<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>由于第二个参数为变长参数，我们只需要根据前面占位符的个数填充对应个数的参数即可，非常方便。</p><h5 id="2-第三方库的可变参数函数举例"><a href="#2-第三方库的可变参数函数举例" class="headerlink" title="2. 第三方库的可变参数函数举例"></a>2. 第三方库的可变参数函数举例</h5><p>再如 commons-lang3 的字符串工具类 <code>org.apache.commons.lang3.StringUtils#isAllEmpty</code>函数源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * &lt;p>Checks if all of the CharSequences are empty ("") or null.&lt;/p> * * &lt;pre> * StringUtils.isAllEmpty(null)             = true * StringUtils.isAllEmpty(null, "")         = true * StringUtils.isAllEmpty(new String[] {})  = true * StringUtils.isAllEmpty(null, "foo")      = false * StringUtils.isAllEmpty("", "bar")        = false * StringUtils.isAllEmpty("bob", "")        = false * StringUtils.isAllEmpty("  bob  ", null)  = false * StringUtils.isAllEmpty(" ", "bar")       = false * StringUtils.isAllEmpty("foo", "bar")     = false * &lt;/pre> * * @param css  the CharSequences to check, may be null or empty * @return {@code true} if all of the CharSequences are empty or null * @since 3.6 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isAllEmpty</span><span class="token punctuation">(</span><span class="token keyword">final</span> CharSequence<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> css<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ArrayUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>css<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">final</span> CharSequence cs <span class="token operator">:</span> css<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>cs<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>该函数的功能是判断传入的参数（个数不固定）是否都是空字符串或 <code>null</code>。</p><p>用法非常简单：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">isAllEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">boolean</span> result <span class="token operator">=</span> StringUtils<span class="token punctuation">.</span><span class="token function">isAllEmpty</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Assert<span class="token punctuation">.</span><span class="token function">assertFalse</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>有了变长参数支持，我们不需要根据参数的数量构造定长数组或变长的集合，用法上更加简洁</strong>。</p><p>我们还看到<code>org.apache.commons.lang3.StringUtils</code> 工具类中还封装了</p><p><code>StringUtils#isEmpty</code> 单个参数的判空函数。</p><p>通过函数命名和参数列表可以很容易地区分哪个是针对单参数，哪个是针对多参数（变长参数）。</p><p>这里也隐含了一个潜规则： 虽然变长参数支持 0 到多个参数，但是更多时候是用在 2 个参数及其以上的场景。</p><p>大家编写带变长参数函数时可以借鉴这种写法，即为单个参数和不定数量参数编写两个不同的函数。</p><p>如果大家平时使用三方工具包时能够留心看其源码，还会发现很多类似的变长参数函数。</p><h4 id="1-12-4-可变参数诡异问题分析"><a href="#1-12-4-可变参数诡异问题分析" class="headerlink" title="1.12.4-可变参数诡异问题分析"></a>1.12.4-可变参数诡异问题分析</h4><p>通过上面的两个例子，我们了解了变长参数函数的优势。</p><p>接下来我们通过下面一个示例并结合 commons-lang 包的布尔工具类： <code>org.apache.commons.lang3.BooleanUtils</code> 来学习和分析可变参数导致的一个诡异问题。</p><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BooleanDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token function">and</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">justPrint</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 函数1</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">justPrint</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 函数2</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">justPrint</span><span class="token punctuation">(</span>Boolean b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 函数3</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">and</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> booleans<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"boolean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">boolean</span> b <span class="token operator">:</span> booleans<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 函数4</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">and</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> booleans<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Boolean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Boolean b <span class="token operator">:</span> booleans<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>请问上面程序的结果是什么呢？</p><p>相信很多人会回答 <code>true</code>、<code>true</code>。</p><p>回答的依据应该是：示例中 <code>main</code> 函数调用的可变参数都是基本类型，因此和函数 3 最贴合，应该会选择函数 3 来执行。</p><p>实际是这样的吗？</p><p>将代码输入到 IDEA，就会发现 IDEA 就会给出下面这段提示：</p><blockquote><p>Ambiguous method call. Both <code>and (boolean...)</code> in <code>BooleanDemo</code> and <code>and (Boolean...)</code> in <code>BooleanDemo</code> match.</p><p>模糊的函数调用。该函数调用和 <code>and (boolean...)</code> 和 <code>and (Boolean...)</code>两个函数签名都匹配。</p></blockquote><h5 id="1-为啥会提示-ambiguous-method-call-？"><a href="#1-为啥会提示-ambiguous-method-call-？" class="headerlink" title="1. 为啥会提示 ambiguous method call ？"></a>1. 为啥会提示 ambiguous method call ？</h5><p>很多人看到这里可能会毫无头绪，<strong>我们该怎么学习和分析这个问题呢？</strong></p><p>按照我们的传统，我们从 JLS<a href="https://www.imooc.com/read/55/article/1150#fn2" target="_blank" rel="noopener">2</a>中寻找答案。 我们发现其中 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.12.2" target="_blank" rel="noopener">15.12.2 节 Compile - Time Step 2 : Determine Method Signature</a> 中提到：</p><blockquote><p>为了兼容Java SE 5.0 之前的版本，方法签名的选择分为 3 个阶段。</p><p>第一阶段：<strong>不让自动装箱和拆箱，也不能使用可变参数的情况下选择重载</strong>。如果无法选择合适地方法，则进入第二阶段。</p><p>由于不允许自动拆箱、拆箱和可变参数，这一条保证了Java SE 5.0 之前的函数调用的合法性。</p><p>如果在第一阶段可变参数生效，如果在一个已经声明了 <code>m(Object)</code> 函数的类中声明 <code>m(Obejct...)</code> 函数，会导致即使有更适合的表达式（如 <code>m(null)</code> ） 也不会选择 <code>m(Object)</code> 。</p><p>第二阶段：<strong>允许自动装箱和拆箱，但是仍然排除变长参数的重载</strong>。如果仍然无法选择合适的方法，则进入第三阶段。</p><p>这是为了保证，如果定义了定长参数的函数情况下，不会选择变长参数。</p><p>第三阶段：<strong>允许自动装箱、拆箱和变长参数的重载</strong>。</p></blockquote><p>因此可见，在选择函数签名时，有以下几个阶段：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E9%80%89%E6%8B%A9%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D%E8%BF%87%E7%A8%8B.jpeg" alt="选择函数签名过程"></p><p>我们再回头看下示例代码。</p><p><strong>第一阶段</strong>，选择了函数1。</p><p><strong>第二阶段</strong>，允许自动装箱和拆箱，但是仍然不匹配可变参数的函数，仍然无法确认使用哪个 <code>and</code>函数，因为自动装箱仍然没有找到 3 个 boolean 参数的 <code>and</code> 函数。</p><p><strong>第三阶段</strong>，允许自动装箱和拆箱，允许匹配变长参数。</p><p>问题就出现在第三个阶段，允许匹配变长参数时就要允许自动拆箱和装箱，这样函数 3 和函数 4 都可匹配到，因此无法通过编译。</p><h5 id="2-变长参数的本质是什么？"><a href="#2-变长参数的本质是什么？" class="headerlink" title="2. 变长参数的本质是什么？"></a>2. 变长参数的本质是什么？</h5><h6 id="2-1-反编译"><a href="#2-1-反编译" class="headerlink" title="2.1 反编译"></a>2.1 反编译</h6><p>我们对项目进行编译，来到 IDEA的 target 目录，查看编译后的 class 文件。</p><p>也可以直接用 <code>javac BooleanDemo.java</code> 对该类进行编译，然后通过前面介绍的 JD-GUI 反编译工具查看。</p><p>下面是反编译后的代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 函数3</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">and</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> booleans<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"boolean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> var1 <span class="token operator">=</span> booleans<span class="token punctuation">;</span>        <span class="token keyword">int</span> var2 <span class="token operator">=</span> booleans<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var3 <span class="token operator">&lt;</span> var2<span class="token punctuation">;</span> <span class="token operator">++</span>var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">boolean</span> b <span class="token operator">=</span> var1<span class="token punctuation">[</span>var3<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 函数4</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">and</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> booleans<span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Boolean"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Boolean<span class="token punctuation">[</span><span class="token punctuation">]</span> var1 <span class="token operator">=</span> booleans<span class="token punctuation">;</span>      <span class="token keyword">int</span> var2 <span class="token operator">=</span> booleans<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> var3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> var3 <span class="token operator">&lt;</span> var2<span class="token punctuation">;</span> <span class="token operator">++</span>var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>          Boolean b <span class="token operator">=</span> var1<span class="token punctuation">[</span>var3<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们可以清楚地看到，变长参数编译后内部通过数组来处理。</p><h6 id="2-2-调试"><a href="#2-2-调试" class="headerlink" title="2.2 调试"></a>2.2 调试</h6><p>我们还可以在函数 3 中打断点，来观察 <code>booleans</code> 这个参数对象的各种属性。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/booleans%E7%9A%84%E5%B1%9E%E6%80%A7.jpeg" alt="booleans的属性"></p><p>通过 “variables” 可预览到参数的类型和数据，可以看到 <code>booleans</code> 为 <code>boolean</code> 类型的数组，长度为 3。</p><p>我们还可以通过在 “variables” 选项卡的<code>booleans</code> 上右键，选择 “Evaluate Expression”, 然后通过调用 <code>booleans.getClass().isArray()</code> 来验证其是否为数组，查看其长度等。</p><p>未来有类似的场景，大家都可以通过断点调试来观察数据，还可以通过表达式来研究对象的一些属性。</p><p>更多高级的调试技巧请参考本专栏后续章节。</p><h5 id="3-如何解决？"><a href="#3-如何解决？" class="headerlink" title="3. 如何解决？"></a>3. 如何解决？</h5><p>我们如果使用 commons-lang3 的 <code>org.apache.commons.lang3.BooleanUtils</code> 工具类中 <code>and</code> 函数，也会遇到类似的错误。</p><p>下面源码取自 commons-lang3 的 3.9版本。</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-lang3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>该类中有两个重载的变长参数函数：</p><pre><code>org.apache.commons.lang3.BooleanUtils#and(boolean...) /**     * &lt;p&gt;Performs an and on a set of booleans.&lt;/p&gt;     *     * &lt;pre&gt;     *   BooleanUtils.and(true, true)         = true     *   BooleanUtils.and(false, false)       = false     *   BooleanUtils.and(true, false)        = false     *   BooleanUtils.and(true, true, false)  = false     *   BooleanUtils.and(true, true, true)   = true     * &lt;/pre&gt;     *     * @param array  an array of {@code boolean}s     * @return {@code true} if the and is successful.     * @throws IllegalArgumentException if {@code array} is {@code null}     * @throws IllegalArgumentException if {@code array} is empty.     * @since 3.0.1     */    public static boolean and(final boolean... array) {        // Validates input        if (array == null) {            throw new IllegalArgumentException(&quot;The Array must not be null&quot;);        }        if (array.length == 0) {            throw new IllegalArgumentException(&quot;Array is empty&quot;);        }        for (final boolean element : array) {            if (!element) {                return false;            }        }        return true;    }</code></pre><p><code>org.apache.commons.lang3.BooleanUtils#and(java.lang.Boolean...)</code> 的源码和注释如下：</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/**     * &lt;p>Performs an and on an array of Booleans.&lt;/p>     *     * &lt;pre>     *   BooleanUtils.and(Boolean.TRUE, Boolean.TRUE)                 = Boolean.TRUE     *   BooleanUtils.and(Boolean.FALSE, Boolean.FALSE)               = Boolean.FALSE     *   BooleanUtils.and(Boolean.TRUE, Boolean.FALSE)                = Boolean.FALSE     *   BooleanUtils.and(Boolean.TRUE, Boolean.TRUE, Boolean.TRUE)   = Boolean.TRUE     *   BooleanUtils.and(Boolean.FALSE, Boolean.FALSE, Boolean.TRUE) = Boolean.FALSE     *   BooleanUtils.and(Boolean.TRUE, Boolean.FALSE, Boolean.TRUE)  = Boolean.FALSE     * &lt;/pre>     *     * @param array  an array of {@code Boolean}s     * @return {@code true} if the and is successful.     * @throws IllegalArgumentException if {@code array} is {@code null}     * @throws IllegalArgumentException if {@code array} is empty.     * @throws IllegalArgumentException if {@code array} contains a {@code null}     * @since 3.0.1     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Boolean <span class="token function">and</span><span class="token punctuation">(</span><span class="token keyword">final</span> Boolean<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"The Array must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Array is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> primitive <span class="token operator">=</span> ArrayUtils<span class="token punctuation">.</span><span class="token function">toPrimitive</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token function">and</span><span class="token punctuation">(</span>primitive<span class="token punctuation">)</span> <span class="token operator">?</span> Boolean<span class="token punctuation">.</span>TRUE <span class="token operator">:</span> Boolean<span class="token punctuation">.</span>FALSE<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">final</span> NullPointerException ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"The array must not contain any null elements"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>错误的原因和前面的示例所分析的一致，都是在选择函数签名时，在前两个阶段没找到匹配的函数，允许变长参数匹配时，允许自动装箱和拆箱，却找到了两个可以匹配的函数。</p><p>我们如果直接参考两个工具函数注释上的例子，会发现编译无法通过。从这一点来看，如果注释中的用法和实际使用无法对应，会对使用者造成极大地困扰。</p><p><strong>那么到底如何解决这个问题呢？</strong></p><p>正如前面讲到的，<strong>我们可以看源码的单元测试，也可以通过 codota 来学习其他优秀的开源项目关于此函数的用法。</strong></p><p>接下来我们实践一下。</p><h6 id="3-1-查看源码的单元测试"><a href="#3-1-查看源码的单元测试" class="headerlink" title="3.1 查看源码的单元测试"></a>3.1 查看源码的单元测试</h6><p>我们拉取 <a href="https://github.com/apache/commons-lang" target="_blank" rel="noopener">commons-lang</a> 源码，找到了 <code>BooleanUtilsTest</code> 关于 <code>and</code> 函数相关的单元测试代码。</p><pre><code>org.apache.commons.lang3.BooleanUtilsTest#testAnd_primitive_validInput_2items    @Test    public void testAnd_primitive_validInput_2items() {        assertTrue(                BooleanUtils.and(new boolean[] { true, true }),                &quot;False result for (true, true)&quot;);        assertTrue(                ! BooleanUtils.and(new boolean[] { false, false }),                &quot;True result for (false, false)&quot;);        assertTrue(                ! BooleanUtils.and(new boolean[] { true, false }),                &quot;True result for (true, false)&quot;);        assertTrue(                ! BooleanUtils.and(new boolean[] { false, true }),                &quot;True result for (false, true)&quot;);    }// 省略其他</code></pre><p>通过单元测试的代码，我们发现相关的测试代码的参数都是通过数组传入。</p><p><code>org.apache.commons.lang3.BooleanUtils#and(java.lang.Boolean...)</code> 相关的单测亦然。</p><p>因此我们可以放弃“变长参数”的好处，“回归自然”，我们可以仿照类似写法，使用数组传参。</p><h6 id="3-2-codota大法"><a href="#3-2-codota大法" class="headerlink" title="3.2 codota大法"></a>3.2 codota大法</h6><p>我们在 <a href="https://www.codota.com/code" target="_blank" rel="noopener">codota</a> 上找到该函数的相关范例，可以很好地解决本节所提到的问题。</p><p>第一个范例是自定义工具类来包装 <code>org.apache.commons.lang3.BooleanUtils#and(boolean...)</code> 函数：<br><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/BooleanUtil-and.jpeg" alt="BooleanUtil-and"></p><p>因为此工具类只包装了其中基本类型变长函数，如果传入基本类型的变长参数可以匹配，如果传入包装类型可以在第二阶段拆箱匹配到该工具函数。</p><p>第二个示例也是自定义工具类，但是参数是集合，实际使用时将集合转成数组再调用 <code>org.apache.commons.lang3.BooleanUtils#and(java.lang.Boolean...)</code>。<br><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/HtmlConverters-and.jpeg" alt="HtmlConverters-and"></p><p>通过该示例我们发现作者是用集合来替代不定长参数解决此问题的。</p><blockquote><p>注：通过 codota 我们还可以看到该工具类的其他函数的一些常见用法。</p></blockquote><p>以上两种方法都是通过自定义工具类的包装，巧妙地避免了直接调用该工具类导致函数签名选择的冲突问题。</p><h4 id="1-12-5-总结"><a href="#1-12-5-总结" class="headerlink" title="1.12.5-总结"></a>1.12.5-总结</h4><p>本文主要介绍了变长参数的主要使用场景， 变长参数使用过程中的一个诡异问题，带着大家分析该问题背后的原因，并给出了解决该问题的方法。</p><p>希望大家遇到类似问题时，能够通过本文提供的方法来快速分析原因，并找到应对的办法。</p><p>下一节我们将讲述集合去重的正确姿势，会对不同去重方式的性能差异的原因进行分析，并对其性能进行对比。</p><h3 id="1-13-集合去重的正确姿势"><a href="#1-13-集合去重的正确姿势" class="headerlink" title="1.13-集合去重的正确姿势"></a>1.13-集合去重的正确姿势</h3><h4 id="1-13-1-前言"><a href="#1-13-1-前言" class="headerlink" title="1.13.1-前言"></a>1.13.1-前言</h4><p>《手册》的第 11 页 关于集合处理的章节有这样的描述 <a href="https://www.imooc.com/read/55/article/1151#fn1" target="_blank" rel="noopener">1</a>：</p><blockquote><p>【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。</p><p>【强制】关于 hashCode 和 equals 的处理，遵循如下规则:</p><ol><li>只要覆写 equals，就必须覆写 hashCode；</li><li>因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须覆写这两个方法；</li><li>如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。<br>说明：String 已覆写 hashCode 和 equals 方法，所以我们可以愉快地使用 String 对象作为 key 来使用。</li></ol></blockquote><p>可能很多人会认为工作之后不会有人通过 <code>List</code> 的 <code>contains</code> 函数来去重，然而，最可怕的是真的有…</p><p>那么我们思考下面几个问题：</p><ul><li>Set 是怎样保证数据的唯一性呢？</li><li>Set 存储的是不重复的对象，是不是根据 hashCode 和 equals 来判断是否重复的呢？</li><li>Set 和 List 的去重性能差距是多大呢？</li></ul><p>本节将重点研究这几个问题。</p><h4 id="1-13-2-唯一性保证"><a href="#1-13-2-唯一性保证" class="headerlink" title="1.13.2-唯一性保证"></a>1.13.2-唯一性保证</h4><p>开发中常见到使用 <code>Set</code> 去重的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Set<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">removeDuplicateBySet</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>注：Set 自身可以保证不重复，不需要先通过 contains 判断不存在再添加元素。</p></blockquote><p>我们先看 <code>java.util.HashSet</code> 的类注释 （注释内容省略，具体请大家看源码）中的一些要点：</p><blockquote><p>实现了 <code>Set</code> 接口。</p><p>基于 <code>HashMap</code> 来实现核心功能。</p><p>允许存入 <code>null</code> 元素，不保证顺序。</p><p>该类的方法并没同步，如果想要同步需要外部处理，可以构造一个同步对象，也可以使用 <code>Collections#synchronizedSet</code> , 最佳实践：</p><pre><code>Set s = Collections.synchronizedSet(new HashSet(...));</code></pre><p>迭代方法返回的迭代器是 “fail-fast” 的，迭代器创建后如果调用除了迭代器自己的 <code>remove</code> 函数外的其他修改方法，会抛出：<code>ConcurrentModificationException</code>。</p></blockquote><p>我们再看看 <code>HashSet</code> 对应的构造函数 <code>java.util.HashSet#HashSet(java.util.Collection)</code> 源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Constructs a new set containing the elements in the specified * collection.  The &lt;tt>HashMap&lt;/tt> is created with default load factor * (0.75) and an initial capacity sufficient to contain the elements in * the specified collection. * * @param c the collection whose elements are to be placed into this set * @throws NullPointerException if the specified collection is null */</span><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token number">75f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从这里我们看到了底层的确是通过 <code>HashMap</code> 支持的，根据参数集合的长度构造对应默认容量的 <code>HashMap</code>。</p><p>然后调用父类的 <code>java.util.AbstractCollection#addAll</code> （添加所有元素的函数）：</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> modified <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>E e <span class="token operator">:</span> c<span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>                modified <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modified<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>从这里可以看出，通过 <code>for-each</code> 语法糖对集合进行迭代并调用 <code>add</code> 函数将元素依次添加到 <code>HashSet</code> 中。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Dummy value to associate with an Object in the backing Map</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Adds the specified element to this set if it is not already present. * More formally, adds the specified element &lt;tt>e&lt;/tt> to this set if * this set contains no element &lt;tt>e2&lt;/tt> such that * &lt;tt>(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt>. * If this set already contains the element, the call leaves the set * unchanged and returns &lt;tt>false&lt;/tt>. * * @param e element to be added to this set * @return &lt;tt>true&lt;/tt> if this set did not already contain the specified * element */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过这个函数的注释，我们可以看到：</p><blockquote><p>该函数的功能是添加 set 中没添加过的元素。</p><p>更准确地说，如果想将元素 e 添加到此集合中，那么集合中不能存在元素 e2 满足：</p><p><strong>( e== null ? e2 ==null : e.equals(e2) )</strong> 。</p><p>如果已经包含了该元素，那么集合将不会发生改变，将返回 false。</p></blockquote><p>从这里我们还看到，为了保持 <code>HashMap</code> 的用法，这里给底层的 <code>Map</code> 的值传入一个傀儡对象（PRESENT）。</p><p>我们进入更底层源码 <code>java.util.HashMap#put</code> :</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过这里我们看到，除了传入 <code>key</code> 和 <code>value</code> 外，第一个哈希值的参数 (<code>hash</code>) 是通过 <code>HashMap</code> 的 <code>hash</code> 函数实现的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到如果 <code>key</code> 为 <code>null</code> ，哈希值为 0，否则将 <code>key</code> 通过自身 <code>hashCode</code> 函数计算的的哈希值和其右移 16 位进行异或运算得到最终的哈希值。</p><p>在 <code>java.util.HashMap#putVal</code> 中，直接通过 <code>(n - 1) &amp; hash</code> 来得到当前元素在节点数组中的位置。如果不存在，直接构造新节点并存储到该节点数组的对应位置。如果存在，则通过下面逻辑：</p><pre class=" language-java"><code class="language-java">p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p><strong>来判断元素是否相等。</strong></p><p><strong>如果相等则用新值替换旧值，否则添加红黑树节点或者链表节点。</strong></p><p>这就是前言中第 2 和第 3 条规定的依据。</p><p>最终如果存在 <code>key</code> 则返回旧值，不存在则返回 <code>null</code>。</p><p>此时，我们再回看 <code>java.util.HashSet#add</code> 源码:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>一切就非常清晰了。</p><p>通过 <code>HashMap</code> 的 <code>key</code> 的唯一性保证 <code>HashSet</code> 的元素的唯一性。</p><p>我们再看 <code>HashSet</code> 的迭代器 <code>java.util.HashSet#iterator</code>:</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/**     * Returns an iterator over the elements in this set.  The elements     * are returned in no particular order.     *     * @return an Iterator over the elements in this set     * @see ConcurrentModificationException     */</span>    <span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>我们发现，其实 <code>HashSet</code> 的元素是存放在 <code>HashMap</code> 的 <code>keySet</code> 中。</p><p>大家可以进入 <code>HashSet</code> 的其他方法中查看，可以发现几乎 <code>HashSet</code> 的所有核心函数都是通过 <code>HashMap</code> 支撑的。</p><p><strong>由于 <code>HashSet</code> 底层采用 <code>HashMap</code> 实现，通过上述分析，我们可知其 “去重” 的时间复杂度是 O (n)。</strong></p><p>另外我们回答前言中 “关于 hashCode 和 equals 的处理” 的第 1 条：** 只要覆写 equals，就必须覆写 hashCode”。** 这个问题。</p><p>除了上面讲到的判断重复的依据外，从其源码 <code>java.lang.Object#equals</code> 的注释中也可以得到更本质的原因：</p><blockquote><p>Note that it is generally necessary to override the {@code hashCode} method whenever this method is overridden, so as to maintain the general contract for the {@code hashCode} method, which states that equal objects must have equal hash codes.</p><p>只要重写 equals 方法就要重新 hashCode 方法，来维持 hashCode 的约定，即 <strong>equals 的对象的哈希值必须相等</strong>。</p></blockquote><h4 id="1-13-3-性能差异的原因"><a href="#1-13-3-性能差异的原因" class="headerlink" title="1.13.3-性能差异的原因"></a>1.13.3-性能差异的原因</h4><p>前面讲到 “由于 <code>HashSet</code> 底层采用了 <code>HashMap</code> 实现，因此去重的时间复杂度是 O (n)”。</p><p>那么，通过 <code>List</code> 的 <code>contains</code> 函数来去重，原理又是怎样的呢？时间复杂度是多少呢？</p><p>且看下面基于 <code>List</code> 的 <code>contains</code> 函数来去重示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">removeDuplicateByList</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>T<span class="token operator">></span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    List<span class="token operator">&lt;</span>T<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>T current <span class="token operator">:</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其实 <code>HashSet</code> 和 <code>ArrayList</code> 去重性能差异的核心在于 <code>contains</code> 函数性能对比。</p><p>我们分别查看 <code>java.util.HashSet#contains</code> 和 <code>java.util.ArrayList#contains</code> 的实现。</p><p><code>java.util.HashSet#contains</code> 源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Returns &lt;tt>true&lt;/tt> if this set contains the specified element. * More formally, returns &lt;tt>true&lt;/tt> if and only if this set * contains an element &lt;tt>e&lt;/tt> such that * &lt;tt>(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt>. * * @param o element whose presence in this set is to be tested * @return &lt;tt>true&lt;/tt> if this set contains the specified element */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最终是通过 <code>java.util.HashMap#getNode</code> 来判断的（和 <code>java.util.HashMap#putVal</code> 的一些判断非常相似）：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Implements Map.get and related methods. * * @param hash hash for key * @param key the key * @return the node, or null if none */</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>先通过计算过的 hash 值找到 table 对应索引的第一个元素进行比较，如果相等则返回第一个元素。</p><p>如果是树节点，从红黑树中查找该元素，否则在链表中查找该元素。</p><p>如果 hash 冲突不是极其严重（大多数都没怎么有哈希冲突），n 个元素依次判断并插入到 Set 的时间复杂度接近于 O (n)。</p><p>接下来我们看 <code>java.util.ArrayList#contains</code> 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Returns &lt;tt>true&lt;/tt> if this list contains the specified element. * More formally, returns &lt;tt>true&lt;/tt> if and only if this list contains * at least one element &lt;tt>e&lt;/tt> such that * &lt;tt>(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt>. * * @param o element whose presence in this list is to be tested * @return &lt;tt>true&lt;/tt> if this list contains the specified element */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其功能实现依赖于 <code>java.util.ArrayList#indexOf</code>:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt>i&lt;/tt> such that * &lt;tt>(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt>, * or -1 if there is no such index. */</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>null<span class="token punctuation">)</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>发现其核心逻辑为：如果为 null, 则遍历整个集合判断是否有 null 元素；否则遍历整个列表，通过 <code>o.equals(当前遍历到的元素)</code> 判断与当前元素是否相等，相等则返回当前循环的索引。</p><p>所以， n 个元素依次通过 <code>java.util.ArrayList#contains</code> 判断并插入到 Set 的时间复杂度接近于 O (n^2)。</p><p>因此，通过时间复杂度的比较，性能差距就不言而喻了。</p><h4 id="1-13-4-性能对比"><a href="#1-13-4-性能对比" class="headerlink" title="1.13.4-性能对比"></a>1.13.4-性能对比</h4><p>上面我们分别对性能的差异原因， 时间复杂度进行了分析。</p><p>我们分别将两个时间复杂度函数进行作图， 两者增速对比非常明显：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E9%9B%86%E5%90%88%E5%8E%BB%E9%87%8D%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.jpeg" alt="集合去重性能对比"></p><p>实践是检验真理的标准，因此我们写一段代码粗略对比一下他们的性能差异：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SetDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> lengthList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> base <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            base <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>            lengthList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        StringRandomizer stringRandomizer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRandomizer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer length <span class="token operator">:</span> lengthList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"------------长度为 {} 时-------"</span><span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>            ListRandomizer<span class="token operator">&lt;</span>String<span class="token operator">></span> listRandomizer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListRandomizer</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>stringRandomizer<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> data <span class="token operator">=</span> listRandomizer<span class="token punctuation">.</span><span class="token function">getRandomValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            StopWatch stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Set<span class="token operator">&lt;</span>String<span class="token operator">></span> resultBySet <span class="token operator">=</span> CollectionUtil<span class="token punctuation">.</span><span class="token function">removeDuplicateBySet</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"set去重耗时：{} ms"</span><span class="token punctuation">,</span> stopWatch<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> resultByList <span class="token operator">=</span> CollectionUtil<span class="token punctuation">.</span><span class="token function">removeDuplicateByList</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"list去重耗时：{} ms"</span><span class="token punctuation">,</span> stopWatch<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最终得到下面的数据：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E9%9B%86%E5%90%88%E5%8E%BB%E9%87%8D%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE.jpeg" alt="集合去重性能数据"></p><p>我们重点观察最后两种情况：</p><blockquote><p>长度为 10 万时使用 List 去重耗时接近 1 分钟，而使用 Set 去重则只需要 17 毫秒；</p><p>而集合长度为 100 万时，使用 List 去重，耗时则约为 1.7 小时，使用 Set 去重则只需要 1.33 秒。</p></blockquote><p>对上述结果进行绘图如下：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E9%9B%86%E5%90%88%E5%8E%BB%E9%87%8D%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E7%BB%93%E6%9E%9C.jpeg" alt="集合去重性能对比结果"></p><p>通过此图，大家就可以非常直观地感受到两种去重方式的性能差异。</p><p>我们<strong>发现当元素较少时两者耗时差距很小，随着元素的增多耗时差距越来越大</strong>。</p><p>如果数据量不大时采用 <code>List</code> 去重勉强可以接受，但是数据量增大后，接口响应时间会超慢，这是难以忍受的，甚至造成大量线程阻塞引发故障。</p><blockquote><p>在工作中一次排查慢接口时，查到了一个函数耗时较长，最终定位到是通过 List 去重导致的。</p><p>由于测试环境还有线上早期数据较少，这个接口的性能问题没有引起较大关注，后面频繁超时，才引起重视。</p></blockquote><p>因此我们要养成好的编程习惯，尽可能地提高接口性能，避免因知识盲区导致故障。</p><h4 id="1-13-5-为什么有人会这么用？"><a href="#1-13-5-为什么有人会这么用？" class="headerlink" title="1.13.5-为什么有人会这么用？"></a>1.13.5-为什么有人会这么用？</h4><p>最后我们思考一下：为什么有人会用 List 的 contains 方法进行遍历、对比然后去重呢？</p><p>无非就是两个原因：</p><ul><li>基础不扎实，不了解这种操作的时间复杂度；</li><li>为了维持返回值的类型。</li></ul><p>对于第一个问题，基础不扎实我们要加强学习，多注意代码规范和代码的运行效率。</p><p>第二个问题是一种直线思维，是一种偷懒的表现。</p><p>比如某种特殊场景下需要的返回值类型为 <code>List</code>，“因此” 有些朋友就会声明一个 <code>List</code>，通过 <code>contains</code> 方法进行遍历、对比、去重，然后将其作为返回值返回。</p><p>其实，这种情况可以分两步走，先去重，然后通过 <code>ArrayList</code> 参数为集合的构造方法创建 <code>List</code> 对象来实现类型 “转换”，示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 数据</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> data <span class="token operator">=</span> listRandomizer<span class="token punctuation">.</span><span class="token function">getRandomValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 先去重</span>Set<span class="token operator">&lt;</span>String<span class="token operator">></span> resultBySet <span class="token operator">=</span> CollectionUtil<span class="token punctuation">.</span><span class="token function">removeDuplicateBySet</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 再转换格式</span>ArrayList<span class="token operator">&lt;</span>String<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>resultBySet<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="1-13-6-总结"><a href="#1-13-6-总结" class="headerlink" title="1.13.6-总结"></a>1.13.6-总结</h4><p>本节主要讲述集合去重的正确姿势，主要要点有：</p><ul><li><code>HashSet</code> 元素唯一性是通过 <code>HashMap</code> 的 key 唯一性来实现的；</li><li>性能的差距是元素查找函数的时间复杂度不同导致的；</li><li>元素较少时两者耗时差距很小，随着元素的增多耗时差距越来越大。</li></ul><p>下一节我们将学习如何学习线程池。</p><h3 id="1-14-学习线程池的正确姿势"><a href="#1-14-学习线程池的正确姿势" class="headerlink" title="1.14-学习线程池的正确姿势"></a>1.14-学习线程池的正确姿势</h3><h4 id="1-14-1-前言"><a href="#1-14-1-前言" class="headerlink" title="1.14.1-前言"></a>1.14.1-前言</h4><p>《手册》第 14 页有关于线程池的论述 <a href="https://www.imooc.com/read/55/article/1152#fn1" target="_blank" rel="noopener">1</a>：</p><blockquote><p>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p><p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程</p><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这 样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p></blockquote><p>看到这些规定我们可以思考下面几个问题：</p><ul><li>那么为何会有这样的规定呢？</li><li>线程池那么重要，我们该如何学习线程池？</li></ul><p>这些都是本节所要解决的问题。</p><h4 id="1-14-2-规定解释"><a href="#1-14-2-规定解释" class="headerlink" title="1.14.2-规定解释"></a>1.14.2-规定解释</h4><h5 id="1-为线程池指定有意义的线程名称"><a href="#1-为线程池指定有意义的线程名称" class="headerlink" title="1. 为线程池指定有意义的线程名称"></a>1. 为线程池指定有意义的线程名称</h5><p>那么第一个问题：<strong>为什么要指定有意义的线程名称呢？</strong></p><p>《手册》给出的解释是 “方便出错时回溯”。</p><p>如果大家还没啥体会的话， 可以对比一下下面通过 <code>jstack</code> 看到的线程片段：</p><p>默认命名：</p><pre class=" language-java"><code class="language-java"><span class="token string">"pool-1-thread-1"</span> #<span class="token number">11</span> prio<span class="token operator">=</span><span class="token number">5</span> os_prio<span class="token operator">=</span><span class="token number">31</span> tid<span class="token operator">=</span><span class="token number">0x00007fa0964c7000</span> nid<span class="token operator">=</span><span class="token number">0x4403</span> waiting on condition <span class="token punctuation">[</span><span class="token number">0x000070000db67000</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">748</span><span class="token punctuation">)</span></code></pre><p>自定义命名：</p><pre class=" language-java"><code class="language-java"><span class="token string">"定时短息任务线程 thread-2"</span> #<span class="token number">11</span> prio<span class="token operator">=</span><span class="token number">5</span> os_prio<span class="token operator">=</span><span class="token number">31</span> tid<span class="token operator">=</span><span class="token number">0x00007fa0964c7000</span> nid<span class="token operator">=</span><span class="token number">0x4403</span> waiting on condition <span class="token punctuation">[</span><span class="token number">0x000070000db67000</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>at java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">748</span><span class="token punctuation">)</span></code></pre><p>反差是不是很明显呢？</p><p>通过自定义名称，我们可以快速理解所关注的线程所属的线程池，对一些问题可以快速作出预判。</p><p><strong>如何实现呢？</strong></p><p>很多人总是先直接百度，直接查资料，虽然便捷，但是容易浅尝辄止，学啥都不深入，离开了资料就束手无策。</p><p>显然这不是我们想要的，那么怎么办呢？</p><p>我们可以去 <code>ThreadPoolExecutor</code> 的构造方法中寻找答案，构造函数中有一个 <code>threadFactory</code> 参数，通过常识或者其注释我们可以知道该参数是为线程池构造线程。</p><p>它的类型为： <code>java.util.concurrent.ThreadFactory</code> ，按照惯例，我们查看源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Constructs a new {@code Thread}.  Implementations may also initialize * priority, name, daemon status, {@code ThreadGroup}, etc. * * @param r a runnable to be executed by new thread instance * @return constructed thread, or {@code null} if the request to *         create a thread is rejected */</span>Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>通过注释我们可以知道，重写此函数可以指定线程的优先级，设置是否是守护线程、设置线程的线程组等。</p><p><strong>那么我们如何找到自定义 <code>ThreadFactory</code> 的参考范例呢？</strong></p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/ThreadFactory.jpeg" alt="ThreadFactory"></p><p>大家可以通过点击左侧的 f 标志或使用快捷键查看实现类，进行学习。</p><p>具体写法我们可以参考：<code>net.sf.ehcache.util.NamedThreadFactory</code></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * A {@link ThreadFactory} that sets names to the threads created by this factory. Threads created by this factory * will take names in the form of the string &lt;code>namePrefix + " thread-" + threadNum&lt;/code> where &lt;tt>threadNum&lt;/tt> is the  * count of threads created by this type of factory. *  * @author &lt;a href="mailto:asanoujam@terracottatech.com">Abhishek Sanoujam&lt;/a> *  */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NamedThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> AtomicInteger threadNumber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> String namePrefix<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> daemon<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Constructor accepting the prefix of the threads that will be created by this {@link ThreadFactory}     *      * @param namePrefix Prefix for names of threads     */</span>    <span class="token keyword">public</span> <span class="token function">NamedThreadFactory</span><span class="token punctuation">(</span>String namePrefix<span class="token punctuation">,</span> <span class="token keyword">boolean</span> daemon<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>namePrefix <span class="token operator">=</span> namePrefix<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>daemon <span class="token operator">=</span> daemon<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Constructor accepting the prefix of the threads that will be created by this {@link ThreadFactory}     *     * @param namePrefix     *            Prefix for names of threads     */</span>    <span class="token keyword">public</span> <span class="token function">NamedThreadFactory</span><span class="token punctuation">(</span>String namePrefix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>namePrefix<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Returns a new thread using a name as specified by this factory {@inheritDoc}     */</span>    <span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> namePrefix <span class="token operator">+</span> <span class="token string">" thread-"</span> <span class="token operator">+</span> threadNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span>daemon<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> thread<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>大家可以参考这个类进行改编。</p><p>另外，建议大家工作中如果不忙的时候要主动地去源码中看一看，看一些 JDK 源码中的接口有哪些实现类，它们的代码都是如何编写的，这对我们学习进阶有很大帮助。</p><h5 id="2-为什么不要在应用中显式创建线程？"><a href="#2-为什么不要在应用中显式创建线程？" class="headerlink" title="2. 为什么不要在应用中显式创建线程？"></a>2. 为什么不要在应用中显式创建线程？</h5><p>这里要先讲一个设计模式：“对象池模式”， 参见 《Java 设计模式及实践》 34 页 <a href="https://www.imooc.com/read/55/article/1152#fn2" target="_blank" rel="noopener">2</a>：</p><blockquote><p>对象的实例化是最耗费性能的操作之一，这在过去是一个大问题，现在已经不需要再那么关注。</p><p>但当我们处理封装外部资源的对象（例如数据库连接）时，对象的创建会耗费很多资源。</p><p>解决方案就是重用和共享这些创建成本昂贵的对象，这被称为对象池模式。</p></blockquote><p>而根据《 Java 虚拟机规范 (Java SE 8 版)》第 9 - 15 页 <a href="https://www.imooc.com/read/55/article/1152#fn3" target="_blank" rel="noopener">3</a> 描述，以及《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》第 39 页 <a href="https://www.imooc.com/read/55/article/1152#fn4" target="_blank" rel="noopener">4</a> 相关描述可知：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/JVM.jpeg" alt="JVM"></p><p>线程的创建需要开辟虚拟机栈、本地方法栈、程序计数器等线程私有的内存空间。</p><p>线程销毁时也会回收这些系统资源，因此如果频繁创建和销毁线程将大量消耗系统资源。</p><p>从上述特点我们可以看出，该场景非常符合对象池设计模式，其<strong>核心目的是复用资源消耗加大的对象</strong>。</p><blockquote><p>建议大家学习设计模式时，着重了解设计模式的常见使用场景，优势和劣势，而不是着急跟着书上敲代码。</p><p>这样才能在看到对应的源码时能够 “恍然大悟”，遇到使用的场景时才能够想到要用这种设计模式。</p></blockquote><p>另外，既然不提倡某种用法而提倡另外一种用法 / 技术，我们要着重思考另外一种用法 / 技术的优势。</p><p>不提倡手动创建线程的另外一个原因是线程池自身的优点，使用线程池有利于控制最大并发数，可以实现任务队列的缓存和拒绝策略，实现定时和周期执行任务，可以更好地隔离不同的场景等。</p><h5 id="3-如何学习线程池？"><a href="#3-如何学习线程池？" class="headerlink" title="3. 如何学习线程池？"></a>3. 如何学习线程池？</h5><p>推荐通过源码和写 DEMO 来学习线程池。</p><p>那么为什么推荐这种学习方式呢？</p><p>这是因为：</p><ol><li>源码最权威，通过读源码印象更深刻，面试时或者使用时更有底气。</li><li>写 DEMO 能够构造更多场景，我们可以通过运行看结果，通过各种调试技巧等方式验证自己的想法。</li></ol><p>另外大家如果细心，可以看到很多人用过线程池，但是面试时或者和别人交流时迷迷糊糊。</p><p>为什么呢？</p><p>其实，这是因为很多人都是通过读书来记住线程池的一些参数和用法，而不是通过读源码和练习来学习的，导致印象不深刻，回答问题时没底气，没把握。</p><p>接下来我们介绍一下这两种不错的方式在线程池学习中的运用。</p><h6 id="3-1-读源码"><a href="#3-1-读源码" class="headerlink" title="3.1 读源码"></a>3.1 读源码</h6><p>我们先从 <code>java.util.concurrent.ThreadPoolExecutor</code> 的构造函数说起。</p><p>前面注释章节讲过 JDK 的注释是我们学习的典范。<strong>我们看源码时注释是帮助我们理解的一大突破口。</strong></p><p><strong>如果不看书，我们如何更准确地理解参数含义呢？如何避免被一些博客误导呢？</strong></p><p>我们应该先从核心参数的名称对参数的含义有一个大概的了解，然后看再看线程池的核心函数的逻辑。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Creates a new {@code ThreadPoolExecutor} with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even *        if they are idle, unless {@code allowCoreThreadTimeOut} is set * @param maximumPoolSize the maximum number of threads to allow in the *        pool * @param keepAliveTime when the number of threads is greater than *        the core, this is the maximum time that excess idle threads *        will wait for new tasks before terminating. * @param unit the time unit for the {@code keepAliveTime} argument * @param workQueue the queue to use for holding tasks before they are *        executed.  This queue will hold only the {@code Runnable} *        tasks submitted by the {@code execute} method. * @param threadFactory the factory to use when the executor *        creates a new thread * @param handler the handler to use when execution is blocked *        because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br> *         {@code corePoolSize &lt; 0}&lt;br> *         {@code keepAliveTime &lt; 0}&lt;br> *         {@code maximumPoolSize &lt;= 0}&lt;br> *         {@code maximumPoolSize &lt; corePoolSize} * @throws NullPointerException if {@code workQueue} *         or {@code threadFactory} or {@code handler} is null */</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>acc <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span>            null <span class="token operator">:</span>            AccessController<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过注释我们可以清晰地知道每个参数的含义。</p><ul><li><code>corePoolSize</code> 表示核心常驻线程池。即使空闲也会在线程池中保活，除非设置了允许核心线程池超时；</li><li><code>maximumPoolSize</code> 表示线程池同时执行的最大线程数量；</li><li><code>keepAliveTime</code> 表示线程池中的线程空闲时间，线程在销毁前等待新任务的最大时限；</li><li><code>unit</code> 表示 <code>keepAliveTime</code> 的单位；</li><li><code>workQueue</code> 存放执行前的任务。只会存放通过 <code>execute</code> 函数提交的 <code>Runnable</code> 任务；</li><li><code>threadFactory</code> 创建新线程的工厂；</li><li><code>handler</code> 线程超限且队列容量也达到最大值时执行受阻的处理策略。</li></ul><p>注释中还给出了抛出异常的条件，大家可以自行学习。</p><p>接下来我们查看其核心函数之一的 <code>execute</code> 源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Executes the given task sometime in the future.  The task * may execute in a new thread or in an existing pooled thread. * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current {@code RejectedExecutionHandler}. * * @param command the task to execute * @throws RejectedExecutionException at discretion of *         {@code RejectedExecutionHandler}, if the task *         cannot be accepted for execution * @throws NullPointerException if {@code command} is null */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * Proceed in 3 steps:     *     * 1. If fewer than corePoolSize threads are running, try to     * start a new thread with the given command as its first     * task.  The call to addWorker atomically checks runState and     * workerCount, and so prevents false alarms that would add     * threads when it shouldn't, by returning false.     *     * 2. If a task can be successfully queued, then we still need     * to double-check whether we should have added a thread     * (because existing ones died since last checking) or that     * the pool shut down since entry into this method. So we     * recheck state and if necessary roll back the enqueuing if     * stopped, or start a new thread if there are none.     *     * 3. If we cannot queue task, then we try to add a new     * thread.  If it fails, we know we are shut down or saturated     * and so reject the task.     */</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过注释我们可以知道，该函数的作用：</p><blockquote><p>在未来的某个时刻执行给定的任务。该任务可能会被新创建的线程执行，也可能会被线程池中已经存在的线程执行。</p><p>如果任务因为 executor 被关闭 (shutdown) 或者容量达到上限而不能再提交执行时，会调用当前设置的 <code>RejectedExecutionHandler</code>。</p></blockquote><p>另外源码中关于执行步骤的注释是我们理解线程池的关键：</p><blockquote><p><code>execute</code> 分为 3 个处理步骤：</p><p>1、如果线程池中小于 <code>corePoolSize</code> 个执行的线程，则新建线程将当前任务作为第一个任务来执行；</p><p>2、如果任务成功入队，我们仍然需要 double-check 判断是否需要往线程池中新增线程（因为上次检查后可能有一个已经存在的线程挂了）或者进入这段函数时线程池关闭了；</p><p>3、如果不能入队，则创建一个新线程。如果失败，我们就知道线程池已经被关闭或已经饱和就需要调用拒绝策略来拒绝当前任务。</p></blockquote><p>读完注释，哪怕我们不读代码或者读不懂源码，我们对线程池的理解也会较为深入的理解，读完注释后再读代码就会发现容易了很多。</p><p>我们再学习 <code>java.util.concurrent.ThreadPoolExecutor#shutdown</code> 函数：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * Initiates an orderly shutdown in which previously submitted     * tasks are executed, but no new tasks will be accepted.     * Invocation has no additional effect if already shut down.     *     * &lt;p>This method does not wait for previously submitted tasks to     * complete execution.  Use {@link #awaitTermination awaitTermination}     * to do that.     *     * @throws SecurityException {@inheritDoc}     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>        mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">checkShutdownAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">advanceRunState</span><span class="token punctuation">(</span>SHUTDOWN<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">onShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// hook for ScheduledThreadPoolExecutor</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">tryTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>根据注释我们可知：</p><blockquote><p>已经提交的任务执行完后关闭，此时不会不再接收新的任务。</p><p>如果已经关闭，那么调用此函数没啥副作用。</p><p>此函数不会等待已经提交的任务执行完成（才返回）。如果需要可以使用 <code>java.util.concurrent.ThreadPoolExecutor#awaitTermination</code>。</p></blockquote><p>假如我们对这里关键的一句话：“This method does not wait for previously submitted tasks to complete execution.” 很困惑，可以通过 StackOverFlow 搜索相关关键词来寻找解答。</p><p>我们找到这样一篇：<a href="https://stackoverflow.com/questions/9905010/does-executorservice-shutdown-cancel-existing-tasks" target="_blank" rel="noopener">does-executorservice-shutdown-cancel-existing-tasks</a> 文章</p><blockquote><p>The point is that the <code>shutDown</code> method <em>returns</em> without waiting for the previously submitted tasks to complete, but it still <em>lets</em> them complete. You might want to think of it as a “start shutting down” method.</p><p><code>shutDown</code> 不会等待直接提交的任务执行完成（但是会让它们执行完毕）就会返回。你可以将该方法理解为 “开始关闭” 函数。</p></blockquote><p>线程池还有其它核心函数，需要大家自己去学习，这里就不作展开。</p><p>上面讲述了线程池的核心参数和核心函数。</p><p>那么我们来看另外一个问题，<strong>为啥《手册》不建议用 <code>Executors</code> 来创建线程池？</strong></p><p>我们以 <code>FixedThreadPool</code> 为例，来分析具体原因：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue, using the provided * ThreadFactory to create new threads when needed.  At any point, * at most {@code nThreads} threads will be active processing * tasks.  If additional tasks are submitted when all threads are * active, they will wait in the queue until a thread is * available.  If any thread terminates due to a failure during * execution prior to shutdown, a new one will take its place if * needed to execute subsequent tasks.  The threads in the pool will * exist until it is explicitly {@link ExecutorService#shutdown * shutdown}. * * @param nThreads the number of threads in the pool * @param threadFactory the factory to use when creating new threads * @return the newly created thread pool * @throws NullPointerException if threadFactory is null * @throws IllegalArgumentException if {@code nThreads &lt;= 0} */</span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                  0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                  threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过工作上面的学习我们知道，工作队列是用来存放线程执行前的任务。</p><p>通过上面源码我们可以看出 <code>FixedThreadPool</code> 的核心线程数和最大线程数相等，而工作队列为</p><p><code>java.util.concurrent.LinkedBlockingQueue</code>。</p><p>通过其默认构造方法，我们可以看出其容量为整数的最大值。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Creates a {@code LinkedBlockingQueue} with a capacity of * {@link Integer#MAX_VALUE}. */</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>根据前面学到的知识，我们试想一下这样的场景：</p><blockquote><p>如果对该线程池的请求不断增多，达到核心线程数后，任务将暂存到该工作队列。但是这个阻塞队列是 “无界” 的，如果大量任务过来，工作队列可能还没达到整数最大值可能就已经 OOM 了。</p></blockquote><p>如果我们自定义线程池对象，可以设置相对可控的最大线程数和可控的工作队列长度以及拒绝策略。那么即使任务大量堆积，在 OOM 之前就进入了拒绝策略。</p><p>总之通过自定义线程池参数，线程池的可控性更强。</p><h6 id="3-2-写-DEMO-大法"><a href="#3-2-写-DEMO-大法" class="headerlink" title="3.2 写 DEMO 大法"></a>3.2 写 DEMO 大法</h6><p>前面讲到 <code>java.util.concurrent.ThreadPoolExecutor#shutdown</code> 的功能，那么如何验证该函数的效果呢？</p><p>我们可以通过下面的例子来学习：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>LocalDateTime<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>ZoneId<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>LinkedBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolShutDownDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        ThreadPoolExecutor executorService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span>                0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">50000</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">NamedThreadFactory</span><span class="token punctuation">(</span><span class="token string">"shutdown-demo"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">20000</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5L<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//System.out.println(Thread.currentThread().getName());</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 第 1 处代码</span>        <span class="token comment" spellcheck="true">//executorService.shutdownNow();</span>        <span class="token function">printExecutorInfo</span><span class="token punctuation">(</span>total<span class="token punctuation">,</span> executorService<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 第 2 处代码</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 第 3 处代码</span>        <span class="token comment" spellcheck="true">/* shutdown()之后再提交任务        executorService.submit(() -> {        });*/</span>       <span class="token comment" spellcheck="true">// 线程池没结束，隔一秒打印任务情况</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>executorService<span class="token punctuation">.</span><span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printExecutorInfo</span><span class="token punctuation">(</span>total<span class="token punctuation">,</span> executorService<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 打印线程池信息     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printExecutorInfo</span><span class="token punctuation">(</span><span class="token keyword">int</span> total<span class="token punctuation">,</span> ThreadPoolExecutor executorService<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String dateString <span class="token operator">=</span> DateUtil<span class="token punctuation">.</span><span class="token function">toDateString</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">systemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"时间:{},总任务数：{}, 工作队列中有:{}个任务，已完成:{}个任务，正在执行:{}个任务"</span><span class="token punctuation">,</span> dateString<span class="token punctuation">,</span> total<span class="token punctuation">,</span> executorService<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> executorService<span class="token punctuation">.</span><span class="token function">getCompletedTaskCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> executorService<span class="token punctuation">.</span><span class="token function">getActiveCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行效果如下：</p><blockquote><p>时间：2019-08-24 20:58:50，总任务数：20000，工作队列中有：19900 个任务，已完成：90 个任务，正在执行：10 个任务</p><p>…</p><p>时间：2019-08-24 20:59:02，总任务数：20000，工作队列中有：0 个任务，已完成：20000 个任务，正在执行：0 个任务</p></blockquote><p>线程池没结束，每隔一秒打印一次线程池的任务信息。</p><p>从此示例中可以清楚地观察到调用 <code>executorService.shutdown()</code> 后 ，已经提交的任务仍然会被执行。</p><p>大家可以打开第 1 处代码，观察执行 <code>ThreadPoolExecutor#executorService.shutdownNow</code> 后如果继续提交任务将抛出 <code>RejectedExecutionException</code> 。</p><p>如果需要学习其他特性，大家都可以写一些简单的 DEMO，也可以断点调试观察更多细节。</p><h4 id="1-14-3-总结"><a href="#1-14-3-总结" class="headerlink" title="1.14.3-总结"></a>1.14.3-总结</h4><p>本节，我们再次使用源码法、StackOverFlow 大法、写 DEMO 法来学习线程池的一些知识点，包括线程池的核心参数，线程池的核心函数的源码和用法。</p><p>当然，大家还可以尝试断点调试法来进入核心函数来学习执行流程等。</p><p>下一节我们将带着大家深入研究：为何 JUnit 单元测试 “不支持多线程” 的问题。</p><h3 id="1-15-虚拟机退出时机问题研究"><a href="#1-15-虚拟机退出时机问题研究" class="headerlink" title="1.15-虚拟机退出时机问题研究"></a>1.15-虚拟机退出时机问题研究</h3><h4 id="1-15-1-前言"><a href="#1-15-1-前言" class="headerlink" title="1.15.1-前言"></a>1.15.1-前言</h4><p>前一节我们讲述了如何通过读源码，查询 StackOverFlow，写 DEMO 方式学习线程池。</p><p>然而线程池在使用过程中会遇到很多问题，本节将通过几个案例研究 Java 虚拟机关闭的问题。</p><h4 id="1-15-2-背景知识"><a href="#1-15-2-背景知识" class="headerlink" title="1.15.2-背景知识"></a>1.15.2-背景知识</h4><p>本节重点学习 JVM 关闭时机相关问题，那么 JVM 在何时正常退出呢（不包含通过 kill 指令杀死进程等情况）？</p><p>根据《 Java 虚拟机规范 (Java SE 8 版)》 第 228 页，对应英文版为 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.7" target="_blank" rel="noopener">5.7 Java Virtual Machine Exit</a> 的相关描述我们可知：</p><blockquote><p>Java 虚拟机退出的条件是，某个线程调用了 <code>Runtime</code> 类或 <code>System</code> 类的 <code>exit</code> 方法，或 <code>Runtime</code> 类的 <code>halt</code> 方法，并且 Java 安全管理器也允许这次 <code>exit</code> 或 <code>halt</code> 操作。</p><p>除此之外， JNI (Java Native Interface) 规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况 <a href="https://www.imooc.com/read/55/article/1153#fn1" target="_blank" rel="noopener">1</a>。</p></blockquote><p>根据《Java 并发编程实践》 164 页相关论述 ，我们还了解到：</p><blockquote><p>也可以通过一些其他平台相关的手段（比如发送 SIGINT, 或键入 Ctrl-C）, 都可以实现 JVM 的正常关闭。还可以调用 “杀死” JVM 的操作系统进程而强制关闭 JVM <a href="https://www.imooc.com/read/55/article/1153#fn2" target="_blank" rel="noopener">2</a>。</p></blockquote><p>另外根据《Java Language Specification : Java SE 8 Edition》<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html#jls-12.8" target="_blank" rel="noopener">12.8 Program Exit</a> 的相关描述 <a href="https://www.imooc.com/read/55/article/1153#fn3" target="_blank" rel="noopener">3</a> 我们可知：</p><blockquote><p>当下面两种情况发生时，程序将会结束所有活动并退出：</p><ul><li>只剩下守护线程（ daemon thread）时。</li><li>某个线程调用了 <code>Runtime</code> 类或 <code>System 类</code> 的 <code>exit</code> 方法，并且 Java 安全管理器也允许这次 <code>exit</code> 操作。</li></ul></blockquote><p>了解这个背景知识，接下来我们将开始分析相关的案例。</p><h4 id="1-15-3-案例及其分析"><a href="#1-15-3-案例及其分析" class="headerlink" title="1.15.3-案例及其分析"></a>1.15.3-案例及其分析</h4><h5 id="1-JUnit-单元测试不支持多线程问题"><a href="#1-JUnit-单元测试不支持多线程问题" class="headerlink" title="1. JUnit 单元测试不支持多线程问题"></a>1. JUnit 单元测试不支持多线程问题</h5><p>本案例涉及两个类，一个是自定义线程类，一个是测试类。</p><p>自定义线程类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">DemoThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-->"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>对应的单元测试：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadDemoTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        DemoThread demoThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DemoThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        DemoThread demoThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DemoThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demoThread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demoThread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>预期结果为，每个线程分别执行 4 次打印语句。</p><p>但是实际运行结果为：</p><blockquote><p>Thread-0–&gt;0<br>Thread-1–&gt;0</p></blockquote><p>打印两行文字后程序退出。</p><p>通过观察现象，我们看出 JUnit 单元测试 “不支持多线程” 测试，换句话说两个线程可能还没没执行完，程序就退出了。</p><p>我们首先尝试使用 ** 断点调试大法 ** 来寻找线索。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/Junit%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95.jpeg" alt="Junit断点调试"></p><p>我们通过查看左侧的调用栈，可以清晰地看到顶层的为 <code>com.intellij.rt.execution.junit.JUnitStarter#main</code> 的 70 行，通过一系列的调用，启动当前测试方法。</p><p>按照惯例，我们可以双击左侧的调用进入源码。</p><p>但是，<strong>令人吐血的是，双击没反应</strong>，崩溃中…</p><p>既然 IDEA 可以使用该类，那么显然此类可以被 IDEA 加载，根据最外层的入口包名（com.intellij.rt.execution.junit），我们断定不是 JDK 中的类，也不是我们 pom.xml 中引入的 jar 包中的类，应该是 idea 自己的类库。</p><p>我们去 IDEA 的安装目录去寻找线索。排查了 lib 文件夹下的所有 jar 包，发现和名称相匹配的 jar 包。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/junit-jar%E5%8C%85.jpeg" alt="junit-jar包"></p><p>我们如何查看这几个 jar 中有没有源码和上面的匹配呢？</p><p>可以使用前面介绍的 Java 反编译工具： <a href="http://java-decompiler.github.io/" target="_blank" rel="noopener">JD-GUI</a>，查看这些包的源码。</p><p>由于我们使用的是 JUnit4 我们首先查看 junit-rt.jar 的反编译代码。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/junit-rt.jar%E5%8F%8D%E7%BC%96%E8%AF%91.jpeg" alt="junit-rt.jar反编译"></p><p>我们在此处找到了 IDEA 调试时顶层的类！</p><p>从此反编译的代码可以看到， <code>main</code> 函数的 70 行。</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">int</span> exitCode <span class="token operator">=</span> <span class="token function">prepareStreamsAndStart</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> agentName<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该函数调用准备流和开始函数，并获得返回值作为退出码，然后调用 <code>System.exit(exitCode);</code> 退出 JVM。</p><p>因此问题就迎刃而解了。</p><p>我们重新梳理执行流程：</p><p>IDEA 运行 JUnit 4 时，</p><ol><li>先执行 <code>com.intellij.rt.execution.junit.JUnitStarter#main</code> ，此函数中调用 <code>prepareStreamsAndStart</code> 子函数；</li><li>子函数最终调用到 <code>ThreadDemoTest#test</code> 的代码。</li><li><code>ThreadDemoTest#test</code> 创建两个新线程并依次开启后结束，函数返回退出码，最终调用 <code>System.exit(exitCode);</code> 退出 JVM。</li></ol><p><strong>那么如何避免两个子线程尚未执行完单元测试函数，就被主线程调用 <code>System.exit</code> 导致 JVM 退出呢？</strong></p><p><strong>方案 1：可以将代码写在 main 函数中；</strong></p><p>还记得开头说的吗，只要有一个非守护线程还在运行，虚拟机就不会退出（正常情况下）。</p><p>使用 main 函数代码非常简单，这里就不再提供。</p><p><strong>方案 2：可以使用 CountDownLatch；</strong></p><p>改造自定义的线程类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>CountDownLatch<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> CountDownLatch countDownLatch<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DemoThread</span><span class="token punctuation">(</span>CountDownLatch countDownLatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>countDownLatch <span class="token operator">=</span> countDownLatch<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-->"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>修改单元测试函数：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    DemoThread demoThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DemoThread</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">;</span>    DemoThread demoThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DemoThread</span><span class="token punctuation">(</span>countDownLatch<span class="token punctuation">)</span><span class="token punctuation">;</span>    demoThread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    demoThread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>由于使用了 <code>countDownLatch.await();</code> 主线程会阻塞到两个线程都执行完毕。</p><p>具体原理大家可以查看 <code>java.util.concurrent.CountDownLatch#await()</code> 源码。</p><p><strong>方案 3：可以在测试函数最后调用 <code>join</code> 函数：</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    DemoThread demoThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DemoThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    DemoThread demoThread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DemoThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    demoThread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    demoThread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    demoThread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    demoThread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>join 函数会等待当前线程执行结束再继续执行。</p><h5 id="2-使用-CompletableFuture-的问题"><a href="#2-使用-CompletableFuture-的问题" class="headerlink" title="2. 使用 CompletableFuture 的问题"></a>2. 使用 CompletableFuture 的问题</h5><p>大家可以猜想一下下面代码的执行结果是啥？</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CompletableFutureDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CompletableFuture<span class="token punctuation">.</span><span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>2L<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"异步任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可能出乎很多人的意料，如果运行此段代码，大概率会发现：打印语句并没有被执行程序就退出了。</p><p>What? ** 前面不是说多线程问题可以通过将代码写在 main 函数中来避免的吗？** 怎么瞬间打脸？</p><p>别急，我们来研究一下这个问题：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Returns a new CompletableFuture that is asynchronously completed * by a task running in the given executor after it runs the given * action. * * @param runnable the action to run before completing the * returned CompletableFuture * @param executor the executor to use for asynchronous execution * @return the new CompletableFuture */</span><span class="token keyword">public</span> <span class="token keyword">static</span> CompletableFuture<span class="token operator">&lt;</span>Void<span class="token operator">></span> <span class="token function">runAsync</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">,</span>                                               Executor executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">asyncRunStage</span><span class="token punctuation">(</span><span class="token function">screenExecutor</span><span class="token punctuation">(</span>executor<span class="token punctuation">)</span><span class="token punctuation">,</span> runnable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过源码注释，我们可知该函数是使用给定的 <code>executor</code> 来异步执行任务。</p><p>那么使用的线程池类型是什么呢？</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Null-checks user executor argument, and translates uses of * commonPool to asyncPool in case parallelism disabled. */</span><span class="token keyword">static</span> Executor <span class="token function">screenExecutor</span><span class="token punctuation">(</span>Executor e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>useCommonPool <span class="token operator">&amp;&amp;</span> e <span class="token operator">==</span> ForkJoinPool<span class="token punctuation">.</span><span class="token function">commonPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> asyncPool<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们查看 <code>asyncPool</code> 的具体类型：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**   * Default executor -- ForkJoinPool.commonPool() unless it cannot   * support parallelism.   */</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Executor asyncPool <span class="token operator">=</span> useCommonPool <span class="token operator">?</span>      ForkJoinPool<span class="token punctuation">.</span><span class="token function">commonPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPerTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/** Fallback if ForkJoinPool.commonPool() cannot support parallelism */</span>  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPerTaskExecutor</span> <span class="token keyword">implements</span> <span class="token class-name">Executor</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><p>默认是 <code>ForkJoinPool.commonPool()</code> ，如果不支持并行则会构造一个新的 <code>ThreadPerTaskExecutor</code> 线程池对象。</p><p>我们再次回到正题，我们可以查看调用链：</p><pre><code>java.util.concurrent.CompletableFuture#runAsync(java.lang.Runnable)java.util.concurrent.CompletableFuture#asyncRunStagejava.util.concurrent.ForkJoinPool#execute(java.lang.Runnable)java.util.concurrent.ForkJoinPool#externalPush</code></pre><p>…</p><p>最终调用到：</p><pre><code>java.util.concurrent.ForkJoinPool#registerWorker</code></pre><p>如下图所示，大家可以在 <code>registerWorker</code> 函数的设置守护线程代码的地方打断点，然后调试，通过查看左侧 “Debugger” 选项卡的 “Frames” 调用栈来研究整个调用过程，也可以切换到 “Threads” 来查看线程的运行状态。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/registerWorker.jpeg" alt="registerWorker"></p><p>接下来我们看源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Callback from ForkJoinWorkerThread constructor to establish and * record its WorkQueue. * * @param wt the worker thread * @return the worker's queue */</span><span class="token keyword">final</span> WorkQueue <span class="token function">registerWorker</span><span class="token punctuation">(</span>ForkJoinWorkerThread wt<span class="token punctuation">)</span> <span class="token punctuation">{</span>    UncaughtExceptionHandler handler<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第 1 处</span>    wt<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment" spellcheck="true">// configure thread</span>    <span class="token comment" spellcheck="true">// 省略中间代码</span>    wt<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>workerNamePrefix<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> w<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从这里可知 <code>ForkJoinPool</code> 的工作线程类型为守护者线程。</p><p>根据前面背景知识的介绍，我们可知如果只有守护线程，程序将退出。</p><p>另外，我们也可以从设置守护线程的函数中找到相关描述：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Marks this thread as either a {@linkplain #isDaemon daemon} thread * or a user thread. The Java Virtual Machine exits when the only * threads running are all daemon threads. * * &lt;p> This method must be invoked before the thread is started. * * @param  on *         if {@code true}, marks this thread as a daemon thread * * @throws  IllegalThreadStateException *          if this thread is {@linkplain #isAlive alive} * * @throws  SecurityException *          if {@link #checkAccess} determines that the current *          thread cannot modify this thread */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> on<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkAccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    daemon <span class="token operator">=</span> on<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>因此我们重新分析上面的案例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 第 1 处</span>    CompletableFuture<span class="token punctuation">.</span><span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>2L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"异步任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 第 2 处</span><span class="token punctuation">}</span></code></pre><p>主线程为普通用户线程，执行到第 1 处，使用默认的 <code>ForkJoinPool</code> 来异步执行传入的任务。</p><p>此时工作线程（守护线程）如果得到运行机会，调用 <code>TimeUnit.SECONDS.sleep(2L);</code> 导致该线程 <code>sleep</code> 2 秒钟。</p><p>主线程执行到第 2 处 （无代码），然后主线程执行完毕。</p><p>此时已经没有非守护线程，还不等工作线程从 Time waiting 睡眠状态结束，虚拟机发现已经没有非守护线程，便退出了。</p><h5 id="3-拓展练习"><a href="#3-拓展练习" class="headerlink" title="3. 拓展练习"></a>3. 拓展练习</h5><p>有了上面的介绍，想必大家对虚拟机的退出时机有了一个不错的了解，那么我们看下面的代码片段：</p><p><strong>请问程序执行后是否一定执行到 finally 代码块，为什么？</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 省略一些代码 （第 1 处）</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 省略一些代码 （第 2 处）</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Exiting the program"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结合今天所学内容，很多朋友可能会想到，在第 2 处如果让当前虚拟机退出，那么 finally 代码块就不会再执行。</p><p>因此可以添加 <code>System.exit(2)</code> 来实现。</p><p>当然还有其他的方法能够实现，大家可以在评论区畅所欲言。</p><h4 id="1-15-4-总结"><a href="#1-15-4-总结" class="headerlink" title="1.15.4-总结"></a>1.15.4-总结</h4><p>本节重点讲述了虚拟机退出的条件，举了几个案例让大家能够对此有深刻的理解。</p><p>本节使用了读源码法，官方文档法，断点调试法等来分析这两个案例。</p><p>下一节我们将讲述如何解决多条件语句和条件语句的多层嵌套问题。</p><h4 id="1-15-5-思考题"><a href="#1-15-5-思考题" class="headerlink" title="1.15.5-思考题"></a>1.15.5-思考题</h4><p>请看下面代码片段，回答问题。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 省略一些代码 （第 1 处）</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"file.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Exiting the program"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>问题：<strong>如果 try 代码块发生异常，如何在第 1 处代码添加几行代码，使得 finally 代码块可以被执行到呢？</strong></p><h3 id="1-16-如何解决条件语句的多层嵌套问题？"><a href="#1-16-如何解决条件语句的多层嵌套问题？" class="headerlink" title="1.16-如何解决条件语句的多层嵌套问题？"></a>1.16-如何解决条件语句的多层嵌套问题？</h3><h4 id="1-16-1-前言"><a href="#1-16-1-前言" class="headerlink" title="1.16.1-前言"></a>1.16.1-前言</h4><p>《手册》第 19 页，有关于多 if-else 分支和嵌套的建议和解决方案 <a href="https://www.imooc.com/read/55/article/1154#fn1" target="_blank" rel="noopener">1</a>：</p><blockquote><p>表达分支时，如果非要使用 if ()…else if ()…else… 方式表达逻辑，避免后续代码维护困难，不允许超过三层。</p><p>如果超过 3 层可以使用卫语句、策略模式、状态模式等来实现。</p><p>其中卫语句代码逻辑优先考虑失败、异常、中断、退出等直接返回的情况。</p></blockquote><p>那么我们要思考以下几个问题：</p><ul><li>我们该如何将这几种方案落地呢？</li><li>使用过程中会遇到哪些奇葩的问题呢？</li></ul><p>这些都是本节重点研究的问题。</p><p>请看下面开发中可能会遇到的典型代码：</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getSalary</span><span class="token punctuation">(</span>Integer position<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">double</span> result<span class="token punctuation">;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"职位不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 老板</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isBoss</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           result <span class="token operator">=</span> <span class="token function">getBossSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 领导</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLeader</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               result <span class="token operator">=</span> <span class="token function">getLeaderSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// 普通员工</span>              result <span class="token operator">=</span> <span class="token function">getStaffSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们如何替代多分支和分支嵌套问题呢？如何让代码变得更容易维护和拓展呢？</p><p>请看下面的分析。</p><h4 id="1-16-2-卫语句"><a href="#1-16-2-卫语句" class="headerlink" title="1.16.2-卫语句"></a>1.16.2-卫语句</h4><p>《重构》 第 9 章 9.5 节 以卫语句取代嵌套条件表达式 中，有如下描述：</p><blockquote><p>如果某个条件极其罕见，就应该单独检查该条件，并在条件为真时立即从函数中返回。这样的单独检查常常被称为 “卫语句”。</p><p>卫语句要不就从函数中返回，要不就抛出一个异常。</p></blockquote><p>使用卫语句，我们可以对上面的示例修改为：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getSalaryGuard</span><span class="token punctuation">(</span>Integer position<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 条件检查</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>position <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"职位不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 老板</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isBoss</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getBossSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 领导</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLeader</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getLeaderSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 普通员工</span>    <span class="token keyword">return</span> <span class="token function">getStaffSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>先进行条件检查，然后将 if-else 逻辑转成对应的卫语句格式。</p><p>另外我们还可以参考 <code>org.apache.commons.lang3.ObjectUtils#isEmpty</code> 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token keyword">final</span> Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 第 1 处</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 第 2 处</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">CharSequence</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>CharSequence<span class="token punctuation">)</span> object<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 第 3 处</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>object<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Array<span class="token punctuation">.</span><span class="token function">getLength</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// 第 4 处</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">Collection</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> object<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// 第 5 处</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>object <span class="token keyword">instanceof</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> object<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>第 1 处代码满足：某个条件极其罕见，就应该单独检查该条件，并在条件为真时立即从函数中返回。</p><p>第 2 到第 5 处代码将某个分支条件转化成卫语句。</p><p>在这里特别提醒的是：<strong>对于复杂的判断逻辑，选择使用卫语句时，建议加上注释，并且要仔细核实逻辑是否正确</strong>。</p><p>请看下面的伪代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 第 1 处</span><span class="token comment" spellcheck="true">// 同时满足 a 和 b 两个条件</span><span class="token keyword">if</span><span class="token punctuation">(</span>condition_a <span class="token operator">&amp;&amp;</span> condition_b<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>conditon_c<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 业务代码</span>     <span class="token keyword">return</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 第 2 处</span><span class="token comment" spellcheck="true">// 条件a 和 b至少有一个不满足</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>conditon_c<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 业务代码</span>  <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面代码看似正确，其实有很大的问题。</p><p>如果同时满足条件 a 和 条件 b 且不满足条件 c，代码依然会执行到 第 2 处，此时 “条件 a 和 b 同时满足” 和 第 2 处的的注释 “条件 a 和 b 至少有一个不满足” 不一致。</p><p>我们需要对代码做出如下修改：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 第 1 处</span><span class="token comment" spellcheck="true">// 同时满足 a 和 b 两个条件</span><span class="token keyword">if</span><span class="token punctuation">(</span>condition_a <span class="token operator">&amp;&amp;</span> condition_b<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>conditon_c<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 业务代码</span>   <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 第 3 处</span>   <span class="token comment" spellcheck="true">// 保证整个if执行后返回</span>   <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 第 2 处</span><span class="token comment" spellcheck="true">// 条件a 和 b至少有一个不满足</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>conditon_c<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 业务代码</span>  <span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>因此使用卫语句是要特别注重卫语句的先后顺序，当条件非常复杂时，要特别注意卫语句的中断是否符合希望的逻辑。</p><h4 id="1-16-3-策略枚举"><a href="#1-16-3-策略枚举" class="headerlink" title="1.16.3-策略枚举"></a>1.16.3-策略枚举</h4><p>正如前面的枚举小节讲到的，《Effective Java 中文版》 第 34 条 ：用 enum 代替 int 常量 <a href="https://www.imooc.com/read/55/article/1154#fn2" target="_blank" rel="noopener">2</a> 小节描述了使用策略枚举，来替代分支语句，虽然失去了简洁性，但是更加安全和灵活。</p><p>通过在枚举内部定义抽象函数，每个枚举常量重写该函数，这样根据枚举值获取枚举常量后调用该函数即可获得期待的计算结果。</p><p>示例代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> SalaryStrategyEnum <span class="token punctuation">{</span>    <span class="token function">BOSS</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">double</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">100000</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">LEADER</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">double</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">50000</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">STAFF</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">double</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">10000</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> position<span class="token punctuation">;</span>    <span class="token function">SalaryStrategyEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>position <span class="token operator">=</span> position<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">abstract</span> <span class="token keyword">double</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SalaryStrategyEnum <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>SalaryStrategyEnum salaryStrategyEnum <span class="token operator">:</span> SalaryStrategyEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>salaryStrategyEnum<span class="token punctuation">.</span>position <span class="token operator">==</span> position<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> salaryStrategyEnum<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用时根据枚举值获取枚举对象，直接调用该枚举常量对应的策略:</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    SalaryStrategyEnum salaryStrategyEnum <span class="token operator">=</span> SalaryStrategyEnum<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>salaryStrategyEnum <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"角色：{}-->{} 元"</span><span class="token punctuation">,</span>salaryStrategyEnum<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>salaryStrategyEnum<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当然，大家也可以用非枚举的策略模式来替代多个条件语句。</p><blockquote><p>看到这里，可能有些人会认为这种写法工作中并不会用到。</p><p>实则不然，很多知识是你真正理解之后就会想到使用它，恰恰是自认为没用和没有真正理解才导致工作不能灵活运用。</p><p>在工作中，看到多个项目涉及到根据不同枚举计算不同的值时，都用到过类似的写法。</p></blockquote><h4 id="1-16-4-状态模式"><a href="#1-16-4-状态模式" class="headerlink" title="1.16.4-状态模式"></a>1.16.4-状态模式</h4><p>《设计模式之禅》 第 26 章 状态模式 (第 343 页) 中讲到：</p><blockquote><p>状态模式的使用场景有两类：一种是行为随着状态改变而改变的场景；另外一种是条件、分支判断语句的替代者。</p></blockquote><p>状态模式的其中一个优点就是 “结构清晰”。状态模式体现了开闭原则和单一职责原则，易于拓展和维护。</p><p>所谓的结构清晰就是避免了过多的 switch-case 或者 if-else 语句的使用，避免了程序的复杂性，提高了程序的可维护性 <a href="https://www.imooc.com/read/55/article/1154#fn3" target="_blank" rel="noopener">3</a>。</p><p>接下来我们采用状态模式通过另外一个例子来演示。</p><p>原始的 if-else 语句和文章首部给出的非常类似，根据当前状态来执行不同的行为：</p><p>学生类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@Setter</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> Long age<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对应的根据状态执行不同的处理函数代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span>Integer state<span class="token punctuation">,</span> Student student<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"状态不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>            <span class="token function">enroll</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>            <span class="token function">study</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>            <span class="token function">graduate</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 入学 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enroll</span><span class="token punctuation">(</span>Student student<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"学生%s报名中...."</span><span class="token punctuation">,</span> student<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 学习 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span>Student student<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"学生%s正在学习...."</span><span class="token punctuation">,</span> student<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 毕业 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">graduate</span><span class="token punctuation">(</span>Student student<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"学生%s毕业了...."</span><span class="token punctuation">,</span> student<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接下来我们使用状态模式对上面的示例进行修改。</p><p>对应的类图如下：</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.jpeg" alt="状态模式类图"></p><p>State 接口或者抽象类负责对象状态的定义。</p><p>Context 定义客户端所需的接口，并且负责状态的切换。</p><p>状态抽象类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> Context context<span class="token punctuation">;</span>    <span class="token keyword">protected</span> State nextState<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setContext</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>报名状态：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 报名状态 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnrollState</span> <span class="token keyword">extends</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">EnrollState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nextState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StudyState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"学生%s报名中...."</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>学习状态：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 学习状态 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudyState</span> <span class="token keyword">extends</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">StudyState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        nextState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GraduateState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"学生%s正在学习...."</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>毕业状态：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 毕业状态 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GraduateState</span> <span class="token keyword">extends</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">GraduateState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        nextState <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"学生%s毕业了...."</span><span class="token punctuation">,</span> context<span class="token punctuation">.</span><span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上下文类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Student student<span class="token punctuation">;</span>    <span class="token keyword">private</span> State currentState<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        currentState<span class="token punctuation">.</span><span class="token function">doAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> State <span class="token function">getCurrentState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> currentState<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCurrentState</span><span class="token punctuation">(</span>State currentState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>currentState <span class="token operator">=</span> currentState<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>currentState<span class="token punctuation">.</span><span class="token function">setContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> State <span class="token function">getNextSate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> currentState<span class="token punctuation">.</span>nextState<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Student <span class="token function">getStudent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> student<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setStudent</span><span class="token punctuation">(</span>Student student<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>student <span class="token operator">=</span> student<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>具体使用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StateClinet</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        student<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"tomcat"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">setStudent</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 报名状态</span>        context<span class="token punctuation">.</span><span class="token function">setCurrentState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EnrollState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">doAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 学习状态</span>        State nextSate <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getNextSate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>nextSate <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            context<span class="token punctuation">.</span><span class="token function">setCurrentState</span><span class="token punctuation">(</span>nextSate<span class="token punctuation">)</span><span class="token punctuation">;</span>            nextSate<span class="token punctuation">.</span><span class="token function">doAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextSate <span class="token operator">=</span> nextSate<span class="token punctuation">.</span>nextState<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出：</p><blockquote><p>学生 tomcat 报名中…<br>学生 tomcat 正在学习…<br>学生 tomcat 毕业了…</p></blockquote><p>上述示例通过状态模式解决了条件嵌套问题。</p><h4 id="1-16-5-拦截器过滤器模式"><a href="#1-16-5-拦截器过滤器模式" class="headerlink" title="1.16.5-拦截器过滤器模式"></a>1.16.5-拦截器过滤器模式</h4><p>如果是 Spring Web 项目中还可以通过实现 <code>org.springframework.context.ApplicationContextAware</code> 接口，构造待处理的类型到对应处理器的映射，这也是简化 if-else if-else 的一个重要手段，在实际开发中这种方式也很常见。</p><p>定义校验基类：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Validator</span><span class="token operator">&lt;</span>P<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 校验分组，枚举     */</span>    <span class="token keyword">private</span> Set<span class="token operator">&lt;</span>Enum<span class="token operator">></span> groups<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 验证参数     */</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">validate</span><span class="token punctuation">(</span>P param<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>自定义校验器：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserSexValidator</span> <span class="token keyword">extends</span> <span class="token class-name">Validator</span><span class="token operator">&lt;</span>UserParam<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">void</span> <span class="token function">validate</span><span class="token punctuation">(</span>UserParam param<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"验证性别"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>param <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BusinessException</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 模拟服务，根据userId查询性别</span>        <span class="token keyword">boolean</span> isFemale <span class="token operator">=</span> RandomUtils<span class="token punctuation">.</span><span class="token function">nextBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isFemale<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BusinessException</span><span class="token punctuation">(</span><span class="token string">"仅限女性玩家哦！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过继承上述父类，可以自定义针对某个类的各种类型的校验器。</p><p>构造校验类和校验处理器的映射：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ValidatorChain</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Class<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Validator<span class="token operator">>></span> validatorMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 根据自定义的校验器进行参数校验     */</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>P<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">checkParam</span><span class="token punctuation">(</span>P param<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">checkParam</span><span class="token punctuation">(</span>param<span class="token punctuation">,</span> validator <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 符合某种条件才参数校验     */</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>P<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">checkParam</span><span class="token punctuation">(</span>P param<span class="token punctuation">,</span> Predicate<span class="token operator">&lt;</span>Validator<span class="token operator">></span> predicate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Validator<span class="token operator">></span> validators <span class="token operator">=</span> <span class="token function">getValidators</span><span class="token punctuation">(</span>param<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>validators<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            validators<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>predicate<span class="token punctuation">)</span>                    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>validator <span class="token operator">-</span><span class="token operator">></span> validator<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span>ApplicationContext applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Validator<span class="token operator">></span> beansOfType <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBeansOfType</span><span class="token punctuation">(</span>Validator<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>validatorMap <span class="token operator">=</span> beansOfType<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>validator <span class="token operator">-</span><span class="token operator">></span> <span class="token function">getParamType</span><span class="token punctuation">(</span>validator<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 查找相关的所有校验器     */</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Validator<span class="token operator">></span> <span class="token function">getValidators</span><span class="token punctuation">(</span>Class <span class="token class-name">clazz</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> validatorMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 解析泛型待校验参数类型     */</span>    <span class="token keyword">private</span> Class <span class="token class-name">getParamType</span><span class="token punctuation">(</span>Class <span class="token class-name">clazz</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ResolvableType resolvableType <span class="token operator">=</span> ResolvableType<span class="token punctuation">.</span><span class="token function">forClass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> resolvableType<span class="token punctuation">.</span><span class="token function">getSuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getGeneric</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用校验链：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> ValidatorChain validatorChain<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> UserDTO <span class="token function">checkUser</span><span class="token punctuation">(</span>UserParam userParam<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 参数校验</span>        validatorChain<span class="token punctuation">.</span><span class="token function">checkParam</span><span class="token punctuation">(</span>userParam<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 业务逻辑</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span><span class="token string">"测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> UserDTO <span class="token function">checkUserSome</span><span class="token punctuation">(</span>UserParam userParam<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 参数校验(只校验类型为Some的)</span>        validatorChain<span class="token punctuation">.</span><span class="token function">checkParam</span><span class="token punctuation">(</span>userParam<span class="token punctuation">,</span> param <span class="token operator">-</span><span class="token operator">></span> param<span class="token punctuation">.</span><span class="token function">getGroups</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>UserValidateGroupEnum<span class="token punctuation">.</span>SOME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 业务逻辑</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UserDTO</span><span class="token punctuation">(</span><span class="token string">"测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过这种方式，对于不同类型对象的属性校验不需要通过 if -else 判断，新增某种类型的校验只需要添加一个自定义校验器即可。还可以支持通过 lambda 表达式传入过滤条件，让符合条件的自定义校验器生效。</p><h4 id="1-16-6-嵌套条件语句"><a href="#1-16-6-嵌套条件语句" class="headerlink" title="1.16.6-嵌套条件语句"></a>1.16.6-嵌套条件语句</h4><p>嵌套条件语句是多条件语句的变种，相当于增加了内层的一个或者多个嵌套层次。</p><p>实际开发中可以将多次使用同一个设计模式，也可以将各种设计模式综合在一起使用。</p><p>下面以一个简单的具体例子为例，为大家讲解如何解决嵌套的条件的情况：</p><p>用户类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>Data<span class="token punctuation">;</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Short age<span class="token punctuation">;</span>    <span class="token keyword">private</span> Boolean male<span class="token punctuation">;</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Demo demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setMale</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demo<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">some</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Short age <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>age <span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getMale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 其他代码</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"18岁 以下男性"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 其他代码</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"18岁 以下女性"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>age <span class="token operator">&lt;=</span> <span class="token number">60</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 其他代码</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"18到60岁 张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"18到60岁 李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 其他代码</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"18到60岁 其他"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"60岁以上"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接下来，我们使用职责链模式和 Map （也可以用标准的工厂模式）对该条件嵌套示例进行重构。</p><p>抽象类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Predicate<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAgeHandler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 下一个处理器     */</span>    <span class="token keyword">protected</span> AbstractAgeHandler nextAgeHandler<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 设置下一个处理器     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextAgeHandler</span><span class="token punctuation">(</span>AbstractAgeHandler nextAgeHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextAgeHandler <span class="token operator">=</span> nextAgeHandler<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">doHandle</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextAgeHandler <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            nextAgeHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 实际处理函数     */</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doHandle</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取查询条件     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Predicate<span class="token operator">&lt;</span>Short<span class="token operator">></span> <span class="token function">getCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>小于 18 岁的处理：</p><pre class=" language-java"><code class="language-java">mport java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Predicate<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LessThan18Handler</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractAgeHandler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 存储策略</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Boolean<span class="token punctuation">,</span> Runnable<span class="token operator">></span> SEX_STRATEGY_MAP <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        SEX_STRATEGY_MAP<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">.</span>TRUE<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 一种处理策略</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小于18岁  男性"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SEX_STRATEGY_MAP<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">.</span>FALSE<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 另外的处理策略</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小于18岁  女性"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 该条件的处理函数     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doHandle</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 处理小于18岁的代码逻辑</span>        <span class="token comment" spellcheck="true">// 处理性别部分</span>        SEX_STRATEGY_MAP<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getMale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 条件18岁     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Predicate<span class="token operator">&lt;</span>Short<span class="token operator">></span> <span class="token function">getCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> age <span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>18 到 60 岁之间的处理：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Predicate<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Between18And60Handler</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractAgeHandler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 存储策略</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Runnable<span class="token operator">></span> NAME_STRATEGY_MAP <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        NAME_STRATEGY_MAP<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 一种处理策略</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"18到60岁 张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        NAME_STRATEGY_MAP<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"李四"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 另外的处理策略</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"18到60岁 李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 该条件的处理函数     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doHandle</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 处理18 到60岁的代码逻辑</span>        <span class="token comment" spellcheck="true">// 处理性别部分</span>        Runnable runnable <span class="token operator">=</span> NAME_STRATEGY_MAP<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>runnable <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            runnable<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"18到60岁 其他"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 条件18岁     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Predicate<span class="token operator">&lt;</span>Short<span class="token operator">></span> <span class="token function">getCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> age <span class="token operator">>=</span> <span class="token number">18</span> <span class="token operator">&amp;&amp;</span> age <span class="token operator">&lt;=</span> <span class="token number">60</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>大于 60 岁的处理方式：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span>Predicate<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MoreThan60Handler</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractAgeHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doHandle</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"没有分支逻辑，支持处理"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Predicate<span class="token operator">&lt;</span>Short<span class="token operator">></span> <span class="token function">getCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> age <span class="token operator">></span> <span class="token number">60</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>示例代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 构造年龄处理器</span>        AbstractAgeHandler first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LessThan18Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AbstractAgeHandler second <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Between18And60Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AbstractAgeHandler third <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MoreThan60Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 编排</span>        first<span class="token punctuation">.</span><span class="token function">setNextAgeHandler</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>        second<span class="token punctuation">.</span><span class="token function">setNextAgeHandler</span><span class="token punctuation">(</span>third<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setMale</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        first<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>究竟选择哪种设计模式要结合具体的场景。</p><p>大家可以通过《设计模式之禅》、《Head Ffirst 设计模式》和菜鸟教程等学习常见的设计模式，了解其适合的场景，优缺点等，根据具体场景灵活使用。</p><h4 id="1-16-7-总结"><a href="#1-16-7-总结" class="headerlink" title="1.16.7-总结"></a>1.16.7-总结</h4><p>本节主要讲了如何解决 if-else 语句拓展性和多层嵌套问题。可以通过卫语句、策略模式、状态模式和过滤拦截器模式等方式解决。</p><p>希望大家能够在实际开发中尝试使用这些方法来编写更加优雅的代码。</p><p>下一节我们将学习异常处理的相关知识，给出异常处理不当的坑，还会给出一些异常处理的建议。</p><h3 id="加餐1：工欲善其事必先利其器"><a href="#加餐1：工欲善其事必先利其器" class="headerlink" title="加餐1：工欲善其事必先利其器"></a>加餐1：工欲善其事必先利其器</h3><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h4><p>俗话说：“工欲善其事，必先利其器”。</p><p>为了助力大家的学习和进阶，本小节介绍几个对 Java 学习非常有帮助的 IDEA 插件，代码反编译和反汇编工具，以及非常不错的网站等。</p><h4 id="2-IDEA-插件"><a href="#2-IDEA-插件" class="headerlink" title="2. IDEA 插件"></a>2. IDEA 插件</h4><p>首先不必多说，IDEA 是目前 Java工程师最主流的开发工具， IDEA 的强大之处不仅在于自身，还在于提供了丰富的插件（这点和谷歌浏览器非常类似）。</p><p>本部分介绍几款强大实用的 IDEA 插件，助力大家开发。</p><p>以下插件大都可以通过 IDEA 自带的插件管理中心安装，如果搜不到可以去 IDEA 插件官网下载本地导入。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/IDEA%E6%8F%92%E4%BB%B6.jpeg" alt="IDEA插件"></p><p>具体安装界面不同版本 IDEA略有差异，请自行研究。</p><p>如果连插件安装都不愿意学、学不会的话，很难成为一名合格的 Java 开发工程师。</p><h5 id="2-1-Alibaba-Java-Coding-Guidelines"><a href="#2-1-Alibaba-Java-Coding-Guidelines" class="headerlink" title="2.1 Alibaba Java Coding Guidelines"></a>2.1 Alibaba Java Coding Guidelines</h5><p>首先要推荐的是和《手册》配套的<a href="https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines" target="_blank" rel="noopener">阿里巴巴 Java代码规范插件</a>。</p><p>安装该插件后，代码超过 80 行、手动创建线程池等，这些和《手册》中的规约不符时，IDEA中会给出警告提示。</p><p>建议大家一定一定一定要安装该插件，它会帮助你检查出很多隐患，督促你写更规范的代码。</p><h5 id="2-2-jclasslib-bytecode-viewer"><a href="#2-2-jclasslib-bytecode-viewer" class="headerlink" title="2.2 jclasslib bytecode viewer"></a>2.2 jclasslib bytecode viewer</h5><p>下面要隆重介绍的是一款可视化的字节码查看插件：<a href="https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer" target="_blank" rel="noopener">jclasslib</a> 。</p><p>大家可以直接在 IDEA 插件管理中安装（安装步骤略）。</p><p><strong>使用方法</strong>：</p><ol><li>在 IDEA 打开想研究的类；</li><li>编译该类或者直接编译整个项目（ 如果想研究的类在 jar 包中，此步可略过）；</li><li>打开“view” 菜单，选择“Show Bytecode With jclasslib” 选项；</li><li>选择上述菜单项后 IDEA 中会弹出 jclasslib 工具窗口。</li></ol><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/jclasslib.jpeg" alt="jclasslib"></p><p>那么有自带的强大的反汇编工具 javap 还有必要用这个插件吗？</p><p>这个插件的<strong>强大之处</strong>在于：</p><ol><li>不需要敲命令，简单直接，在右侧方便和源代码进行对比学习；</li><li>字节码命令支持超链接，<strong>点击其中的虚拟机指令即可跳转到 jvms 相关章节</strong>，超级方便。</li></ol><p>该插件对我们学习虚拟机指令有极大的帮助。</p><h5 id="2-3-Codota"><a href="#2-3-Codota" class="headerlink" title="2.3 Codota"></a>2.3 Codota</h5><p>另外一个不得不说的就是专栏中提到的辅助开发神器: <a href="https://www.codota.com/code" target="_blank" rel="noopener">Codota</a>。</p><p>可以点击下图所示“Add Codota to you IDEA” 了解安装步骤。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/Codota%E6%8F%92%E4%BB%B6.jpeg" alt="Codota插件"></p><p>该插件的强大之处在于：</p><ol><li>支持智能代码自动提示，该功能可以增强 IDEA 的代码提示功能；</li><li>支持 JDK 和知名第三方库的函数的使用方法搜索，可以看到其他知名开源项目对该函数的用法。</li></ol><p>当我们第一次使用某个类，对某个函数不够熟悉时，可以通过该插件搜索相关用法，快速模仿学习。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/Codota%E7%9A%84%E4%BD%BF%E7%94%A8.jpeg" alt="Codota的使用"></p><p>如上图所示，我们想了解 <code>Stream</code> 类中 <code>flatMap</code> 函数的用法，可以使用该插件查看知名开源项目的用法。</p><p>插件窗口顶部还给出了该类最常用的函数，可以点击查看相关用法案例，每个案例右侧的 “view source”可以跳转到该片段对应的开源项目的源码中。</p><h5 id="2-4-Auto-filling-Java-call-arguments"><a href="#2-4-Auto-filling-Java-call-arguments" class="headerlink" title="2.4 Auto filling Java call arguments"></a>2.4 Auto filling Java call arguments</h5><p>开发中，我们通常会调用其它已经编写好的函数，调用后需要填充参数，但是绝大多数情况下，传入的变量名称和该函数的参数名一致，当参数较多时，手动单个填充参数非常浪费时间。</p><p>该插件就可以帮你解决这个问题。</p><p>安装完该插件以后，调用一个函数，使用 Alt+Enter 组合键，调出 “Auto fill call parameters” 自动使用该函数定义的参数名填充。</p><h5 id="2-5-GenerateO2O、GenerateAllSetter"><a href="#2-5-GenerateO2O、GenerateAllSetter" class="headerlink" title="2.5 GenerateO2O、GenerateAllSetter"></a>2.5 GenerateO2O、<strong>GenerateAllSetter</strong></h5><p>我们定义好从 A 类转换到 B 类的函数转换函数后，使用这两个插件可以自动调用 Getter 和 Setter 函数实行自动转换。</p><p>实际开发中还有一个非常常见的场景： 我们创建一个对象后，想依次调用 Setter 函数对属性赋值，如果属性较多很容易遗漏或者重复。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/GenerateAllSetter.jpeg" alt="GenerateAllSetter"></p><p>可以使用这 GenerateAllSetter 提供的功能，自动调用所有 Setter 函数（可填充默认值），然后自己再跟进实际需求设置属性值。</p><h5 id="2-6-Material-Theme-UI"><a href="#2-6-Material-Theme-UI" class="headerlink" title="2.6 Material Theme UI"></a>2.6 Material Theme UI</h5><p>对于很多人而言，写代码时略显枯燥的，如果能够安装自己喜欢的主题将为开发工作带来些许乐趣。</p><p>IDEA 支持各种主题插件，其中最出名的当属 Material Theme UI。</p><p>![Material Theme UI](Material Theme UI.jpeg)</p><p>安装后，可以从该插件内置的各种风格个选择自己最喜欢的一种。</p><h5 id="2-7-Rainbow-Brackets"><a href="#2-7-Rainbow-Brackets" class="headerlink" title="2.7 Rainbow Brackets"></a>2.7 Rainbow Brackets</h5><p>由于很多人没有养成好的编码风格，没有随手 format 代码的习惯，甚至有些同事会写代码超过几百行，阅读起来将非常痛苦。</p><p>痛苦的原因之一就是找到上下文，由于括号太多，不确定当前代码行是否属于某个代码块，此时这个插件就会帮上大忙。</p><p>插件 github 地址：<a href="https://github.com/izhangzhihao/intellij-rainbow-brackets。" target="_blank" rel="noopener">https://github.com/izhangzhihao/intellij-rainbow-brackets。</a></p><p>![Rainbow Brackets](Rainbow Brackets.jpeg)</p><p>大家可以观看其 github 首页的动图体会和学习其强大功能。</p><h5 id="2-8-Maven-Helper"><a href="#2-8-Maven-Helper" class="headerlink" title="2.8 Maven Helper"></a>2.8 Maven Helper</h5><p>现在 Java 项目通常会使用 maven 或者 gradle 构建，对于maven 项目来说， jar 包冲突非常常见。</p><p>那么如何更容易地查看和解决 jar 包冲突呢？</p><p>![Maven Helper](Maven Helper.jpeg)</p><p>大家可以安装该插件，安装后 IDEA 中打开 pom.xml 文件时，就会多出一个 “Dependency Analyzer” 选项卡。</p><p>如上图所示，该插件支持值插件冲突的 jar 包，可以选择冲突的 jar 包将其 exclude 掉。</p><h5 id="2-9-FindBugs"><a href="#2-9-FindBugs" class="headerlink" title="2.9 FindBugs"></a>2.9 FindBugs</h5><p>程序员总是想尽可能地避免写 BUG， <a href="https://plugins.jetbrains.com/plugin/3847-findbugs-idea" target="_blank" rel="noopener">FindBugs</a> 作为静态代码检查插件，可以检查你代码中的隐患，并给出原因。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/FindBugs.jpeg" alt="FindBugs"></p><p>当然还有很多类似的静态代码检查插件，大家可以自行了解安装。</p><h5 id="2-10-SequenceDiagram"><a href="#2-10-SequenceDiagram" class="headerlink" title="2.10 SequenceDiagram"></a>2.10 SequenceDiagram</h5><p><a href="https://plugins.jetbrains.com/plugin/8286-sequencediagram/" target="_blank" rel="noopener">SequenceDiagram </a>可以根据代码调用链路自动生成时序图，超级赞，超级推荐！</p><p>这对研究源码，梳理工作中的业务代码有极大的帮助，堪称神器。</p><p>安装完成后，在某个类的某个函数中，右键 –&gt; Sequence Diagaram 即可调出。</p><p>如下图是 Netty 的源码，可以通过该插件绘制出当前函数的调用链路。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/SequenceDiagram.jpeg" alt="SequenceDiagram"></p><p>双击顶部的类名可以跳转到对应类的源码中，双击调用的函数名可以直接调入某个函数的源码，总之非常强大</p><h5 id="2-11-Stack-trace-to-UML"><a href="#2-11-Stack-trace-to-UML" class="headerlink" title="2.11 Stack trace to UML"></a>2.11 Stack trace to UML</h5><p><a href="https://plugins.jetbrains.com/plugin/10749-stack-trace-to-uml/" target="_blank" rel="noopener">Stack trace to UML</a> 支持根据 JVM 异常堆栈画 UML时序图和通信图。</p><p>打开方式 <em>Analyze &gt; Open Stack trace to UML plugin</em> + Generate UML diagrams from stacktrace from debug</p><p>![Stack trace to UML](Stack trace to UML.jpeg)</p><h5 id="2-12-Java-Stream-Debugger"><a href="#2-12-Java-Stream-Debugger" class="headerlink" title="2.12 Java Stream Debugger"></a>2.12 Java Stream Debugger</h5><p>Stream 非常好用，可以灵活对数据进行操作，但是对很多刚接触的人来说，不好理解。</p><p>那么 <a href="https://plugins.jetbrains.com/plugin/9696-java-stream-debugger/" target="_blank" rel="noopener">Java Stream Debugger</a> 这款神器的 IDEA 就可以帮到你。它可以将 Stream 的操作步骤可视化，非常有助于我们的学习。</p><p>![Java Stream Debugger1](Java Stream Debugger1.jpeg)</p><p>![Java Stream Debugger2](Java Stream Debugger2.jpeg)</p><h5 id="2-13-其它"><a href="#2-13-其它" class="headerlink" title="2.13 其它"></a>2.13 其它</h5><p>IDEA 的插件浩如烟海，好的IDEA 插件欢迎留言交流。</p><p>另外大家可以通过<a href="https://plugins.jetbrains.com/" target="_blank" rel="noopener"> IDEA插件官网</a>进行搜索，有海量插件供你选择。</p><h4 id="3-反编译和反汇编软件"><a href="#3-反编译和反汇编软件" class="headerlink" title="3. 反编译和反汇编软件"></a>3. 反编译和反汇编软件</h4><p>Java 学习进阶之路离不开Java 反编译和反汇编。</p><p>实际开发中需要用到反汇编的典型场景有：</p><ul><li>自己或者二方上传的包含新的接口 jar 包到maven 仓库，下载下来查看 jar 包检查新的接口是否包含在新的 jar 包中；</li><li>需要临时查看某个 Jar 包的源码，不想加到本地仓库中；</li><li>拿不到源码，又想了解其源码究竟是怎么写的；</li><li>线上代码表现和自己的源码不一致，怀疑线上代码不对，可以反编译去核对。</li></ul><p>对于大多数普通 Java 工程师来说，使用反编译的场景多是为了学习研究。</p><h5 id="3-1-在线Java反编译工具"><a href="#3-1-在线Java反编译工具" class="headerlink" title="3.1 在线Java反编译工具"></a>3.1 在线Java反编译工具</h5><p>有很多在线反编译的网站，其中比较好用的主要是以下两个：</p><p><a href="http://www.decompiler.com/" target="_blank" rel="noopener">http://www.decompiler.com/</a></p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/decompile.jpeg" alt="decompile"></p><p>使用简单，直接将 jar 包和 class文件拖到页面即可。</p><p><a href="http://www.javadecompilers.com/" target="_blank" rel="noopener">http://www.javadecompilers.com/</a></p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/javadecompilers.jpeg" alt="javadecompilers"></p><p>功能很强大，支持多种反编译方式，但是浏览效果不如上面网站好。</p><h5 id="3-2-离线-Java-反编译工具"><a href="#3-2-离线-Java-反编译工具" class="headerlink" title="3.2 离线 Java 反编译工具"></a>3.2 离线 Java 反编译工具</h5><h6 id="3-2-1-反编译软件"><a href="#3-2-1-反编译软件" class="headerlink" title="3.2.1 反编译软件"></a>3.2.1 反编译软件</h6><p>很多人担心在线反编译可能会引起代码泄露等，所以倾向于使用本地的反编译工具。</p><p>这里推荐两款软件： JD-GUI 和 Luyten。</p><p><a href="http://java-decompiler.github.io/" target="_blank" rel="noopener">JD-GUI</a> 是一款可以根据 Java的 class 文件反编译出其源码的工具，界面简单，功能强大。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/JD-GUI.jpeg" alt="JD-GUI"></p><p>另外一个非常好用的反编译软件为 <a href="https://github.com/deathmarine/Luyten" target="_blank" rel="noopener">Luyten</a>， 它是反编译工具 Procyon 的可视化显示工具。</p><p>大家可以在其 github 上下载安装：<a href="https://github.com/deathmarine/Luyten/releases。" target="_blank" rel="noopener">https://github.com/deathmarine/Luyten/releases。</a></p><p>该软件的用法和 JD-GUI 类似。</p><p><strong>图形界面反编译虽然更直观，但是如果我们想反编译Linux服务器上的类文件可咋办呢？</strong></p><p>我们可以通过 <a href="http://www.kpdus.com/jad.html#download" target="_blank" rel="noopener">Jad</a> 、<a href="http://www.benf.org/other/cfr/" target="_blank" rel="noopener">CFR</a>、<a href="https://github.com/ststeiger/procyon" target="_blank" rel="noopener">Procyon</a>、ernflower、 JD等反编译工具。</p><p>另外知名的阿里开源 Java诊断工具 arthas 也支持 <a href="https://alibaba.github.io/arthas/jad.html" target="_blank" rel="noopener">jad 命令</a>，可以将 JVM 中实际运行的 class 文件的字节码反编译成 Java 代码，便于理解业务和排查问题。</p><blockquote><p>举一个真实发生过的典型的场景：</p><p>有一次代码发布上线，但是从功能表现看线上仍然是“旧代码”，但是从发布的 git 提交版本来看是最新版。</p><p>此时就可以使用 jad 反编译该类，来核查该问题。</p></blockquote><h6 id="3-2-2-反汇编"><a href="#3-2-2-反汇编" class="headerlink" title="3.2.2 反汇编"></a>3.2.2 反汇编</h6><p>这里简单介绍 Java 反编译和反汇编的区别。</p><p>这里说的反编译是指：将 class 文件反编译成 Java 源码的过程。</p><p>这里说的反汇编是指：将class 文件反解析为更可读的虚拟机指令的过程。</p><p>反汇编最权威和强大的当属 JDK 自带的 javap 工具，具体用法直接输入帮助指令<code>javap -help</code> 即可查看：</p><pre><code>用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括:  -help  --help  -?        输出此用法消息  -version                 版本信息  -v  -verbose             输出附加信息  -l                       输出行号和本地变量表  -public                  仅显示公共类和成员  -protected               显示受保护的/公共类和成员  -package                 显示程序包/受保护的/公共类                           和成员 (默认)  -p  -private             显示所有类和成员  -c                       对代码进行反汇编  -s                       输出内部类型签名  -sysinfo                 显示正在处理的类的                           系统信息 (路径, 大小, 日期, MD5 散列)  -constants               显示最终常量  -classpath &lt;path&gt;        指定查找用户类文件的位置  -cp &lt;path&gt;               指定查找用户类文件的位置  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</code></pre><p>大家一定要自己多动手实践，才能更好地掌握它。</p><p>另外一个比较好用的反汇编工具为 <a href="https://github.com/ingokegel/jclasslib/releases" target="_blank" rel="noopener">jclasslib</a>。</p><p><img src="/2020/02/15/a-li-ba-ba-java-kai-fa-shou-ce-xiang-jie/jclasslib%E8%BD%AF%E4%BB%B6.jpeg" alt="jclasslib软件"></p><p>在IDEA 插件中心中还可以搜到该工具的IDEA插件。</p><p>当然，还有很多其他好用的 Java 反编译和反汇编软件，希望大家平时多尝试，多练习。</p><p>希望大家能够熟练掌握其中一两种，能够快速反编译和反汇编，帮助自己学习知识和解决问题。</p><h4 id="4-效率软件"><a href="#4-效率软件" class="headerlink" title="4. 效率软件"></a>4. 效率软件</h4><h5 id="4-1-效率"><a href="#4-1-效率" class="headerlink" title="4.1 效率"></a>4.1 效率</h5><h6 id="4-1-1-Alfred"><a href="#4-1-1-Alfred" class="headerlink" title="4.1.1 Alfred"></a>4.1.1 Alfred</h6><p>Alfred 可以说是 Mac 系统的效率神器。该软件支持文件搜索、粘贴板管理、快捷短语提示、各种工作流等功能。</p><p>具体功能介绍可以看<a href="https://sspai.com/post/55098" target="_blank" rel="noopener">这篇文章</a>。</p><h6 id="4-1-2-Wox"><a href="#4-1-2-Wox" class="headerlink" title="4.1.2 Wox"></a>4.1.2 Wox</h6><p>有些朋友可能会说，我们系统是 windows 的肿么办？</p><p>这里推荐一个 windows 上的 alfred： <a href="http://www.wox.one/" target="_blank" rel="noopener">Wox</a>， 该软件支持软件、文件、浏览器书签等搜索，支持通过快捷键快速搜索网页，还支持丰富的插件，可以查询英语单词、查快递等。</p><h6 id="4-1-3-Snipaste"><a href="#4-1-3-Snipaste" class="headerlink" title="4.1.3 Snipaste"></a>4.1.3 Snipaste</h6><p>另外推荐一个非常好用的截图和贴图软件 <a href="https://zh.snipaste.com/" target="_blank" rel="noopener">Snipaste</a>。</p><p>该软件不仅是一款截图工具，还支持将截图贴到屏幕上，使用非常简单， F1 截图，然后 F3 贴图，截图就会桌面置顶显示。</p><h6 id="4-1-4-Contexts"><a href="#4-1-4-Contexts" class="headerlink" title="4.1.4 Contexts"></a>4.1.4 Contexts</h6><p>该软件目前只支持 mac 系统，可以实现窗口的快速切换。</p><h6 id="4-1-5-Paste"><a href="#4-1-5-Paste" class="headerlink" title="4.1.5 Paste"></a>4.1.5 Paste</h6><p>该软件目前只支持 mac 系统。</p><p>采用 iOS 多任务卡片切换界面，可以可视化粘贴板历史，支持剪切搜索，热键快速调用，可以快速选取想要的粘贴版历史内容并粘贴到当前应用中。</p><h5 id="4-2-画图神器"><a href="#4-2-画图神器" class="headerlink" title="4.2 画图神器"></a>4.2 画图神器</h5><p>作为一个合格的程序员，怎能没几个趁手的画图工具呢？</p><p>每个人的喜好各有不同，下面推荐几个本人和身边人开发中常用的画图工具。</p><h6 id="4-2-1-UML-画图工具"><a href="#4-2-1-UML-画图工具" class="headerlink" title="4.2.1 UML 画图工具"></a>4.2.1 UML 画图工具</h6><p><strong>visual-paradigm</strong></p><p>推荐 <a href="https://online.visual-paradigm.com/cn/diagrams/tutorials/" target="_blank" rel="noopener">visual-paradigm</a>的理由是该画图工具不仅支持软件本地画图，还支持在线画图，支持最新的语法，并且有丰富的参考示例。</p><p><strong>PlantUML</strong></p><p>强烈推荐大家画UML 图时使用<a href="http://plantuml.com/zh/index" target="_blank" rel="noopener">PlantUML</a>，理由是其他大多数作图软件都采用拖拽式，对于有些强迫症的人会浪费很多时间进行对齐等操作。</p><p>该软件还提供了 IDEA 插件，在IDEA中创建 plantUML 的图形支持实时预览。</p><p>通过 PlantUML 官网给出的示例，大家可以快速上手。</p><p><strong>其它UML画图工具</strong></p><p>可以使用 processon 来作图，优势是在线存储。windows 系统用户可以使用 visio，功能强大，画的图也很美观。</p><h6 id="4-2-2-思维导图"><a href="#4-2-2-思维导图" class="headerlink" title="4.2.2 思维导图"></a>4.2.2 思维导图</h6><p>很多人会有些奇怪，为啥推荐思维导图呢？</p><p>其实对于Java工程师来说，思维导图是梳理知识，梳理需求的重要工具。</p><p>然而画思维导图并不是照着目录列一遍，而是带上自己的思考，具体再画图篇会讲到。</p><p>思维导图软件推荐使用： xmind、mindjet、ithoughts 等。</p><h5 id="4-3-辅助开发"><a href="#4-3-辅助开发" class="headerlink" title="4.3 辅助开发"></a>4.3 辅助开发</h5><h6 id="4-3-1-PostMan"><a href="#4-3-1-PostMan" class="headerlink" title="4.3.1 PostMan"></a>4.3.1 PostMan</h6><p><a href="https://www.getpostman.com/" target="_blank" rel="noopener">PostMan</a> 可以模拟前端请求，可以将请求进行分类、保存，支持变量，支持将请求导出为 curl 等其他请求方式，功能非常强大，大家可以根据官方文档多摸索使用。</p><h6 id="4-3-2-VisulVM"><a href="#4-3-2-VisulVM" class="headerlink" title="4.3.2 VisulVM"></a>4.3.2 VisulVM</h6><p><a href="https://visualvm.github.io/" target="_blank" rel="noopener">VisulVM</a> 是 JDK 命令行工具的可视化整合工具，可以在开发和生产中使用。</p><p>常规用法是先启动软件，然后选择本地的 Java 进程，或者添加远程机器的 Ip 和端口号监控远程 Java 进程状况。</p><p>IDEA 中还有 <a href="https://plugins.jetbrains.com/plugin/7115-visualvm-launcher/" target="_blank" rel="noopener">VisualVM 的插件</a>，可以在本地应用启动时，自动启动 VisualVM。</p><h6 id="4-3-3-前端插件助手"><a href="#4-3-3-前端插件助手" class="headerlink" title="4.3.3 前端插件助手"></a>4.3.3 前端插件助手</h6><p>推荐一个方便大家开发的插件：<a href="https://www.baidufe.com/" target="_blank" rel="noopener">前端插件助手</a>。</p><p>该插件支持字符串的编解码、JSON串的格式化、代码美化、二维码生成器、页面滚动截屏、图片转Base64 、简易 Postman、Ajax 调试等功能。</p><p>虽然名叫“前端插件助手”，其实该插件对我们后端开发帮助也极大。</p><h6 id="4-3-4-Print-Friendly-amp-PDF"><a href="#4-3-4-Print-Friendly-amp-PDF" class="headerlink" title="4.3.4 Print Friendly &amp; PDF"></a>4.3.4 Print Friendly &amp; PDF</h6><p>我们平时看很多博客等，想保存为PDF，如果直接使用浏览器打印就会发现有很多广告等信息。</p><p>可以使用该插件，生成只包含页面主要内容的 PDF。</p><p>大家可以通过该软件的<a href="https://www.printfriendly.com/" target="_blank" rel="noopener">官网</a> 进一步了解该插件。</p><h6 id="4-3-5-ModHeader"><a href="#4-3-5-ModHeader" class="headerlink" title="4.3.5 ModHeader"></a>4.3.5 ModHeader</h6><p>该插件可以修改请求和响应头，在某种调试场合非常有用。</p><h6 id="4-3-6-Ajax-Interceptor"><a href="#4-3-6-Ajax-Interceptor" class="headerlink" title="4.3.6 Ajax Interceptor"></a>4.3.6 Ajax Interceptor</h6><p><a href="https://github.com/YGYOOO/ajax-interceptor" target="_blank" rel="noopener">该插件</a>非常强大，可以修改页面 Ajax 请求的返回结果。</p><h4 id="5-很赞的网站"><a href="#5-很赞的网站" class="headerlink" title="5. 很赞的网站"></a>5. 很赞的网站</h4><h5 id="5-1-在线练习网站"><a href="#5-1-在线练习网站" class="headerlink" title="5.1 在线练习网站"></a>5.1 在线练习网站</h5><p>很多人想学习某个技术，但是有自己电脑配置限制或者嫌麻烦等各种原因，可能不愿意安装某些环境。</p><p><strong>那么有没有可以在线练习的网站呢？</strong> 答案是：有。</p><p>接下来推荐几个非常强大的在线练习和学习网站。</p><h6 id="5-1-1-Git-在线练习"><a href="#5-1-1-Git-在线练习" class="headerlink" title="5.1.1 Git 在线练习"></a>5.1.1 Git 在线练习</h6><p>推荐一个在线学习 Git 的趣味网站: <a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">https://learngitbranching.js.org/</a></p><h6 id="5-1-2-kafka集群体验"><a href="#5-1-2-kafka集群体验" class="headerlink" title="5.1.2 kafka集群体验"></a>5.1.2 kafka集群体验</h6><p>有一个网站提供kafka集群的体验：<a href="https://www.cloudkarafka.com/" target="_blank" rel="noopener">https://www.cloudkarafka.com/</a></p><h6 id="5-1-3-leetcode"><a href="#5-1-3-leetcode" class="headerlink" title="5.1.3 leetcode"></a>5.1.3 leetcode</h6><p>此处，不得不提的是鼎鼎大名的 <a href="https://leetcode.com/" target="_blank" rel="noopener">leetcode</a>。</p><p>该网站提供了在算法、数据库和Shell 脚本的练习题。</p><h6 id="5-1-4-数据结构可视化"><a href="#5-1-4-数据结构可视化" class="headerlink" title="5.1.4 数据结构可视化"></a>5.1.4 数据结构可视化</h6><p>接下来推荐一个<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">数据结构可视化</a>的网站。可以选择某种数据结构，动态添加数据，观察变化过程。</p><h6 id="5-1-5-正则表达式"><a href="#5-1-5-正则表达式" class="headerlink" title="5.1.5 正则表达式"></a>5.1.5 正则表达式</h6><p>还有很多支持在线学习和验证正则表达式的网站，如 <a href="https://regexr.com/、" target="_blank" rel="noopener">https://regexr.com/、</a> <a href="https://c.runoob.com/front-end/854、https://tool.oschina.net/regex。" target="_blank" rel="noopener">https://c.runoob.com/front-end/854、https://tool.oschina.net/regex。</a></p><h6 id="5-1-6-在线练习SQL"><a href="#5-1-6-在线练习SQL" class="headerlink" title="5.1.6 在线练习SQL"></a>5.1.6 在线练习SQL</h6><p>推荐几个可在线练习 SQL 的超赞网站：<a href="https://sqlzoo.net/" target="_blank" rel="noopener">SQLZOO</a>、<a href="https://sqlbolt.com/" target="_blank" rel="noopener">SQLBolt</a>、<a href="http://sqlfiddle.com/" target="_blank" rel="noopener">SQL Fiddle</a>。</p><p>中文版：<a href="http://xuesql.cn/" target="_blank" rel="noopener">xuesql</a>、<a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1179610846971200" target="_blank" rel="noopener">廖雪峰SQL教程</a></p><h5 id="5-2-实用网站"><a href="#5-2-实用网站" class="headerlink" title="5.2 实用网站"></a>5.2 实用网站</h5><h6 id="5-2-1-时间戳转换"><a href="#5-2-1-时间戳转换" class="headerlink" title="5.2.1 时间戳转换"></a>5.2.1 时间戳转换</h6><p>时间戳转换工具：<a href="https://tool.chinaz.com/tools/unixtime.aspx" target="_blank" rel="noopener">https://tool.chinaz.com/tools/unixtime.aspx</a></p><h6 id="5-2-2-JSON相关"><a href="#5-2-2-JSON相关" class="headerlink" title="5.2.2 JSON相关"></a>5.2.2 JSON相关</h6><p><strong>JSON格式化</strong></p><p>开发中还会经常用到格式化 JSON 串的功能，<a href="https://www.bejson.com/" target="_blank" rel="noopener">bejson</a> 提供了 JSON相关的丰富功能，JSON的格式化校验、压缩、转义、去除转义等。</p><p><strong>JSON 和 Java实体互转</strong></p><p>有很多强大的网站支持 JSON和Java实体互转，如 <a href="https://www.bejson.com/json2javapojo/new/" target="_blank" rel="noopener">bejson</a>、<a href="http://www.jsonschema2pojo.org/" target="_blank" rel="noopener">jsonschema2pojo </a>、<a href="https://codebeautify.org/json-to-java-converter" target="_blank" rel="noopener">codebeautify</a>、<a href="https://www.freecodeformat.com/json2pojo.php" target="_blank" rel="noopener">FreeCodeFormat</a>、<a href="https://www.site24x7.com/tools/json-to-java.html" target="_blank" rel="noopener">site24*7</a> 等。</p><h6 id="5-2-3-超赞的英文-Java学习网站"><a href="#5-2-3-超赞的英文-Java学习网站" class="headerlink" title="5.2.3 超赞的英文 Java学习网站"></a>5.2.3 超赞的英文 Java学习网站</h6><p>除了咱们的慕课网外，推荐几个非常好的英文学习网站。</p><p>首推 <a href="https://www.baeldung.com/category/java/" target="_blank" rel="noopener">baeldung</a>该网站几乎所有的文章都有<a href="https://github.com/eugenp/tutorials" target="_blank" rel="noopener">配套代码</a>,。我们可以直接通过该网站的代码运行学习某些知识点，某些框架等。</p><p>其次是 <a href="https://www.javacodegeeks.com/" target="_blank" rel="noopener">javacodegeeks</a>, 该网站会提供丰富的 Java 教程，还会提供一些英文 PDF 教程。</p><p><a href="https://www.journaldev.com/" target="_blank" rel="noopener">journaldev</a> 和 <a href="http://blog.jamesdbloom.com/" target="_blank" rel="noopener">jamesdbloom</a> 对技术的讲解非常透彻。</p><h6 id="5-2-4-技术电子书百宝箱"><a href="#5-2-4-技术电子书百宝箱" class="headerlink" title="5.2.4 技术电子书百宝箱"></a>5.2.4 技术电子书百宝箱</h6><p>Library Genesis 号称是帮助全人类知识传播计划，其网站 <a href="http://gen.lib.rus.ec/" target="_blank" rel="noopener">http://gen.lib.rus.ec/</a> 提供了很多英文图书的下载。</p><p>我们 Java 开发需要用到知名英文书籍几乎都可以在上面找到电子版。</p><p>强烈建议大家购买纸质版经典的 Java 技术图书，反复学习。</p><h6 id="5-2-5-GitHub"><a href="#5-2-5-GitHub" class="headerlink" title="5.2.5 GitHub"></a>5.2.5 GitHub</h6><p>GitHub 也可堪称是百宝箱，大家可以通过它来搜索想学技术的源码和相关示例代码。</p><p>大家可以在 Java 的 <a href="https://github.com/topics/java" target="_blank" rel="noopener">topic栏目</a> 了解 stars 最多的，最近更新的，最佳的 Java项目等。</p><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h4><p>本文重点介绍了 Java 学习和工作中常用的软件、插件、网站等。熟练地使用这些工具，将有助于提高我的开发效率和编程体验。</p><p>肯定还有很多好用的插件和软件，由于篇幅有限就不在这里一一介绍，欢迎大家留言分享。</p><p>希望通过本小节的介绍能够助力大家的学习和进阶。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 开发手册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK源码详解</title>
      <link href="/2020/02/02/jdk-yuan-ma-xiang-jie/"/>
      <url>/2020/02/02/jdk-yuan-ma-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK源码详解"><a href="#JDK源码详解" class="headerlink" title="JDK源码详解"></a>JDK源码详解</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1-基础"></a>1-基础</h2><h3 id="1-1-String、Long-源码解析和面试题"><a href="#1-1-String、Long-源码解析和面试题" class="headerlink" title="1.1-String、Long 源码解析和面试题"></a>1.1-String、Long 源码解析和面试题</h3><p>String 和 Long 大家都很熟悉，本小节主要结合实际的工作场景，来一起看下 String 和 Long 的底层源码实现，看看平时我们使用时，有无需要注意的点，总结一下这些 API 都适用于哪些场景。</p><h4 id="1-1-1-String"><a href="#1-1-1-String" class="headerlink" title="1.1.1-String"></a>1.1.1-String</h4><ol><li><h5 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a><strong>不变性</strong></h5><p>我们常常听人说，HashMap 的 key 建议使用不可变类，比如说 String 这种不可变类。这里说的不可变指的是类值一旦被初始化，就不能再被改变了，如果被修改，将会是新的类，我们写个 demo 来演示一下。</p><pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">;</span>s <span class="token operator">=</span><span class="token string">"world"</span><span class="token punctuation">;</span></code></pre><p>从代码上来看，s 的值好像被修改了，但从 debug 的日志来看，其实是 s 的内存地址已经被修改了，也就说 <code>s =“world”</code> 这个看似简单的赋值，其实已经把 s 的引用指向了新的 String，debug 的截图显示内存地址已经被修改，两张截图如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/String1.jpeg" alt="String1"></p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/String2.jpeg" alt="String2"></p><p>我们从源码上查看一下原因：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    </code></pre><p>我们可以看出来两点：</p><ul><li>String 被 final 修饰，说明 String 类绝不可能被继承了，也就是说任何对 String 的操作方法，都不会被继承覆写；</li><li>String 中保存数据的是一个 char 的数组 value。我们发现 value 也是被 final 修饰的，也就是说 value 一旦被赋值，内存地址是绝对无法修改的，而且 value 的权限是 private 的，外部绝对访问不到，String 也没有开放出可以对 value 进行赋值的方法，所以说 value 一旦产生，内存地址就根本无法被修改。</li></ul><p>以上两点就是 String 不变性的原因，充分利用了 final 关键字的特性，如果你自定义类时，希望也是不可变的，也可以模仿 String 的这两点操作。</p><p><strong>因为 String 具有不变性，所以 String 的大多数操作方法，都会返回新的 String，</strong>如下面这种写法是不对的：</p><pre class=" language-java"><code class="language-java">String str <span class="token operator">=</span><span class="token string">"hello world !!"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 这种写法是替换不掉的，必须接受 replace 方法返回的参数才行，这样才行：str = str.replace("l","dd");</span>str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"l"</span><span class="token punctuation">,</span><span class="token string">"dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><h5 id="字符串乱码"><a href="#字符串乱码" class="headerlink" title="字符串乱码"></a><strong>字符串乱码</strong></h5><p>在生活中，我们经常碰到这样的场景，进行二进制转化操作时，本地测试的都没有问题，到其它环境机器上时，有时会出现字符串乱码的情况，这个主要是因为在二进制转化操作时，并没有强制规定文件编码，而不同的环境默认的文件编码不一致导致的。</p><p>我们也写了一个 demo 来模仿一下字符串乱码：</p><pre class=" language-java"><code class="language-java">String str  <span class="token operator">=</span><span class="token string">"nihao 你好 喬亂"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 字符串转化成 byte 数组</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// byte 数组转化成字符串</span>String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 结果打印为：</span>nihao <span class="token operator">?</span><span class="token operator">?</span> <span class="token operator">?</span><span class="token operator">?</span></code></pre><p>打印的结果为？？，这就是常见的乱码表现形式。这时候有同学说，是不是我把代码修改成 <code>String s2 = new String(bytes,&quot;ISO-8859-1&quot;);</code> 就可以了？这是不行的。主要是因为 ISO-8859-1 这种编码对中文的支持有限，导致中文会显示乱码。唯一的解决办法，就是在所有需要用到编码的地方，都统一使用 UTF-8，对于 String 来说，getBytes 和 new String 两个方法都会使用到编码，我们把这两处的编码替换成 UTF-8 后，打印出的结果就正常了。</p></li></ol><ol start="3"><li><h5 id="首字母大小写"><a href="#首字母大小写" class="headerlink" title="首字母大小写"></a><strong>首字母大小写</strong></h5><p>如果我们的项目被 Spring 托管的话，有时候我们会通过 <code>applicationContext.getBean(className);</code> 这种方式得到 <code>SpringBean</code>，这时 className 必须是要满足首字母小写的，除了该场景，在反射场景下面，我们也经常要使类属性的首字母小写，这时候我们一般都会这么做：</p><p><code>name.substring(0, 1).toLowerCase() + name.substring(1);</code>，使用 substring 方法，该方法主要是为了截取字符串连续的一部分，substring 有两个方法：</p><ul><li><code>public String substring(int beginIndex, int endIndex)</code> beginIndex：开始位置，endIndex：结束位置；</li><li><code>public String substring(int beginIndex)</code>beginIndex：开始位置，结束位置为文本末尾。</li></ul><p>substring 方法的底层使用的是字符数组范围截取的方法 ：<code>Arrays.copyOfRange(字符数组, 开始位置, 结束位置);</code> 从字符数组中进行一段范围的拷贝。</p><p>相反的，如果要修改成首字母大写，只需要修改成 <code>name.substring(0, 1).toUpperCase() + name.substring(1)</code> 即可。</p></li></ol><ol start="4"><li><h5 id="相等判断"><a href="#相等判断" class="headerlink" title="相等判断"></a><strong>相等判断</strong></h5><p>我们判断相等有两种办法，<code>equals</code> 和 <code>equalsIgnoreCase</code>。后者判断相等时，会忽略大小写，近期看见一些面试题在问：如果让你写判断两个 String 相等的逻辑，应该如何写，我们来一起看下 equals 的源码，整理一下思路：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断内存地址是否相同</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 待比较的对象是否是 String，如果不是 String，直接返回不相等</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String anotherString <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 两个字符串的长度是否相等，不等则直接返回不相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 依次比较每个字符是否相等，若有一个不等，直接返回不相等</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从 equals 的源码可以看出，逻辑非常清晰，完全是根据 String 底层的结构来编写出相等的代码。这也提供了一种思路给我们：如果有人问如何判断两者是否相等时，我们可以从两者的底层结构出发，这样可以迅速想到一种贴合实际的思路和方法，就像 String 底层的数据结构是 char 的数组一样，判断相等时，就挨个比较 char 数组中的字符是否相等即可。</p></li></ol><ol start="5"><li><h5 id="替换、删除"><a href="#替换、删除" class="headerlink" title="替换、删除"></a><strong>替换、删除</strong></h5><p>替换在工作中也经常使用，有 replace 替换所有字符、replaceAll 批量替换字符串、replaceFirst 替换遇到的第一个字符串三种场景。</p><p>其中在使用 replace 时需要注意，replace 有两个方法，一个入参是 char，一个入参是 String，前者表示替换所有字符，如：<code>name.replace(&#39;a&#39;,&#39;b&#39;)</code>，后者表示替换所有字符串，如：<code>name.replace(&quot;a&quot;,&quot;b&quot;)</code>，两者就是单引号和多引号的区别。</p><p>需要注意的是， replace 并不只是替换一个，是替换所有匹配到的字符或字符串哦。</p><p>写了一个 demo 演示一下三种场景：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  String str <span class="token operator">=</span><span class="token string">"hello word !!"</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"替换之前 :{}"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"替换所有字符 :{}"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">,</span><span class="token string">"l"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"替换全部 :{}"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replaceFirst</span><span class="token punctuation">(</span><span class="token string">"l"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"替换第一个 l :{}"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出的结果是：</span>替换之前 <span class="token operator">:</span>hello word <span class="token operator">!</span><span class="token operator">!</span>替换所有字符 <span class="token operator">:</span>heddo word <span class="token operator">!</span><span class="token operator">!</span>替换全部 <span class="token operator">:</span>hello worl <span class="token operator">!</span><span class="token operator">!</span>替换第一个 <span class="token operator">:</span>helo worl <span class="token operator">!</span><span class="token operator">!</span></code></pre><p>当然我们想要删除某些字符，也可以使用 replace 方法，把想删除的字符替换成 “” 即可。</p></li></ol><ol start="6"><li><h5 id="拆分和合并"><a href="#拆分和合并" class="headerlink" title="拆分和合并"></a><strong>拆分和合并</strong></h5><p>拆分我们使用 split 方法，该方法有两个入参数。第一个参数是我们拆分的标准字符，第二个参数是一个 int 值，叫 limit，来限制我们需要拆分成几个元素。如果 limit 比实际能拆分的个数小，按照 limit 的个数进行拆分。</p><p>我们演示一个 demo：</p><pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span><span class="token string">"boo:and:foo"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 我们对 s 进行了各种拆分，演示的代码和结果是：</span>s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"boo"</span><span class="token punctuation">,</span><span class="token string">"and"</span><span class="token punctuation">,</span><span class="token string">"foo"</span><span class="token punctuation">]</span>s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"boo"</span><span class="token punctuation">,</span><span class="token string">"and:foo"</span><span class="token punctuation">]</span>s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"boo"</span><span class="token punctuation">,</span><span class="token string">"and"</span><span class="token punctuation">,</span><span class="token string">"foo"</span><span class="token punctuation">]</span>s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"boo"</span><span class="token punctuation">,</span><span class="token string">"and"</span><span class="token punctuation">,</span><span class="token string">"foo"</span><span class="token punctuation">]</span>s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"o"</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">":and:f"</span><span class="token punctuation">]</span>s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"o"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"o:and:foo"</span><span class="token punctuation">]</span></code></pre><p>从演示的结果来看，limit 对拆分的结果，是具有限制作用的，还有就是拆分结果里面不会出现被拆分的字段。</p><p>那如果字符串里面有一些空值呢，拆分的结果如下：</p><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span><span class="token string">",a,,b,"</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">]</span></code></pre><p>从拆分结果中，我们可以看到，空值是拆分不掉的，仍然成为结果数组的一员，如果我们想删除空值，只能自己拿到结果后再做操作，但 Guava（Google 开源的技术工具） 提供了一些可靠的工具类，可以帮助我们快速去掉空值，如下：</p><pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span><span class="token string">",a, ,  b  c ,"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Splitter 是 Guava 提供的 API </span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Splitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">trimResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 去掉空格</span>    <span class="token punctuation">.</span><span class="token function">omitEmptyStrings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 去掉空值</span>    <span class="token punctuation">.</span><span class="token function">splitToList</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Guava 去掉空格的分割方法：{}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 打印出的结果为：</span><span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b  c"</span><span class="token punctuation">]</span></code></pre><p>从打印的结果中，可以看到去掉了空格和空值，这正是我们工作中常常期望的结果，所以推荐使用 Guava 的 API 对字符串进行分割。</p><p>合并我们使用 join 方法，此方法是静态的，我们可以直接使用。方法有两个入参，参数一是合并的分隔符，参数二是合并的数据源，数据源支持数组和 List，在使用的时候，我们发现有两个不太方便的地方：</p><ul><li>不支持依次 join 多个字符串，比如我们想依次 join 字符串 s 和 s1，如果你这么写的话 <code>String.join(&quot;,&quot;,s).join(&quot;,&quot;,s1)</code> 最后得到的是 s1 的值，第一次 join 的值被第二次 join 覆盖了；</li><li>如果 join 的是一个 List，无法自动过滤掉 null 值。</li></ul><p>而 Guava 正好提供了 API，解决上述问题，我们来演示一下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 依次 join 多个字符串，Joiner 是 Guava 提供的 API</span>Joiner joiner <span class="token operator">=</span> Joiner<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skipNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String result <span class="token operator">=</span> joiner<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token string">"china"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"依次 join 多个字符串:{}"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"china"</span><span class="token punctuation">,</span>null<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"自动删除 list 中空值:{}"</span><span class="token punctuation">,</span>joiner<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 输出的结果为；</span>依次 join 多个字符串<span class="token operator">:</span>hello<span class="token punctuation">,</span>china自动删除 list 中空值<span class="token operator">:</span>hello<span class="token punctuation">,</span>china</code></pre><p>从结果中，我们可以看到 Guava 不仅仅支持多个字符串的合并，还帮助我们去掉了 List 中的空值，这就是我们在工作中常常需要得到的结果。</p></li></ol><h4 id="1-1-2-Long"><a href="#1-1-2-Long" class="headerlink" title="1.1.2-Long"></a>1.1.2-Long</h4><ol><li><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h5><p>Long 最被我们关注的就是 Long 的缓存问题，Long 自己实现了一种缓存机制，缓存了从 -128 到 127 内的所有 Long 值，如果是这个范围内的 Long 值，就不会初始化，而是从缓存中拿，缓存初始化源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LongCache</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">LongCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 缓存，范围从 -128 到 127，+1 是因为有个 0</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Long cache<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">127</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 容器初始化时，进行加载</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 缓存 Long 值，注意这里是 i - 128 ，所以再拿的时候就需要 + 128</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="1-1-3-面试题"><a href="#1-1-3-面试题" class="headerlink" title="1.1.3-面试题"></a>1.1.3-面试题</h4><ol><li><h5 id="为什么使用-Long-时，大家推荐多使用-valueOf-方法，少使用-parseLong-方法"><a href="#为什么使用-Long-时，大家推荐多使用-valueOf-方法，少使用-parseLong-方法" class="headerlink" title="为什么使用 Long 时，大家推荐多使用 valueOf 方法，少使用 parseLong 方法"></a><strong>为什么使用 Long 时，大家推荐多使用 valueOf 方法，少使用 parseLong 方法</strong></h5><p>答：因为 Long 本身有缓存机制，缓存了 -128 到 127 范围内的 Long，valueOf 方法会从缓存中去拿值，如果命中缓存，会减少资源的开销，parseLong 方法就没有这个机制。</p></li><li><h5 id="如何解决-String-乱码的问题"><a href="#如何解决-String-乱码的问题" class="headerlink" title="如何解决 String 乱码的问题"></a><strong>如何解决 String 乱码的问题</strong></h5><p>答：乱码的问题的根源主要是两个：字符集不支持复杂汉字、二进制进行转化时字符集不匹配，所以在 String 乱码时我们可以这么做：</p><ul><li>所有可以指定字符集的地方强制指定字符集，比如 new String 和 getBytes 这两个地方；</li><li>我们应该使用 UTF-8 这种能完整支持复杂汉字的字符集。</li></ul></li><li><h5 id="为什么大家都说-String-是不可变的"><a href="#为什么大家都说-String-是不可变的" class="headerlink" title="为什么大家都说 String 是不可变的"></a><strong>为什么大家都说 String 是不可变的</strong></h5><p>答：主要是因为 String 和保存数据的 char 数组，都被 final 关键字所修饰，所以是不可变的，具体细节描述可以参考上文。</p></li><li><h5 id="String-一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题"><a href="#String-一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题" class="headerlink" title="String 一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题"></a><strong>String 一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题</strong></h5><p>答：这些都属于问 String 的基本操作题目，考察我们平时对 String 的使用熟练程度，可以参考上文。</p></li></ol><h3 id="1-2-Java常用关键字详解"><a href="#1-2-Java常用关键字详解" class="headerlink" title="1.2-Java常用关键字详解"></a>1.2-Java常用关键字详解</h3><p>Java 中的关键字很多，大约有 50+，在命名上我们不能和这些关键字冲突的，编译会报错，每个关键字都代表着不同场景下的不同含义，接下来我们挑选 6 个比较重要的关键字，深入学习一下。</p><h4 id="1-2-1-static"><a href="#1-2-1-static" class="headerlink" title="1.2.1-static"></a>1.2.1-static</h4><p>意思是静态的、全局的，一旦被修饰，说明被修饰的东西在一定范围内是共享的，谁都可以访问，这时候需要注意并发读写的问题。</p><ol><li><h5 id="修饰的对象"><a href="#修饰的对象" class="headerlink" title="修饰的对象"></a><strong>修饰的对象</strong></h5><p>static 只能修饰类变量、方法和方法块。</p><p><strong>当 static 修饰类变量时</strong>，如果该变量是 public 的话，表示该变量任何类都可以直接访问，而且无需初始化类，直接使用 <strong>类名.static 变量</strong> 这种形式访问即可。</p><p>这时候我们非常需要注意的一点就是线程安全的问题了，因为当多个线程同时对共享变量进行读写时，很有可能会出现并发问题，如我们定义了：<code>public static List list = new ArrayList();</code>这样的共享变量。这个 list 如果同时被多个线程访问的话，就有线程安全的问题，这时候一般有两个解决办法：</p><ul><li>把线程不安全的 ArrayList 换成 线程安全的 CopyOnWriteArrayList；</li><li>每次访问时，手动加锁。</li></ul><p>所以在使用 static 修饰类变量时，如何保证线程安全是我们常常需要考虑的。</p><p><strong>当 static 修饰方法时</strong>，代表该方法和当前类是无关的，任意类都可以直接访问（如果权限是 public 的话）。</p><p>有一点需要注意的是，该方法内部只能调用同样被 static 修饰的方法，不能调用普通方法，我们常用的 util 类里面的各种方法，我们比较喜欢用 static 修饰方法，好处就是调用特别方便。</p><p>static 方法内部的变量在执行时是没有线程安全问题的。方法执行时，数据运行在栈里面，栈的数据每个线程都是隔离开的，所以不会有线程安全的问题，所以 util 类的各个 static 方法，我们是可以放心使用的。</p><p><strong>当 static 修饰方法块时</strong>，我们叫做静态块，静态块常常用于在类启动之前，初始化一些值。</p><p>比如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 进行一些初始化的工作</span><span class="token keyword">static</span> <span class="token punctuation">{</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这段代码演示了静态块做一些初始化的工作，但需要注意的是，静态块只能调用同样被 static 修饰的变量，并且 static 的变量需要写在静态块的前面，不然编译也会报错。</p></li></ol><ol start="2"><li><h5 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a><strong>初始化时机</strong></h5><p>对于被 static 修饰的类变量、方法块和静态方法的初始化时机。</p><p>我们写了一个测试 demo，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/static.jpeg" alt="static"></p><p>打印出来的结果是：</p><pre class=" language-java"><code class="language-java">父类静态变量初始化父类静态块初始化子类静态变量初始化子类静态块初始化main 方法执行父类构造器初始化子类构造器初始化</code></pre><p>从结果中，我们可以看出两点：</p><ul><li>父类的静态变量和静态块比子类优先初始化；</li><li>静态变量和静态块比类构造器优先初始化。</li></ul><p>被 static 修饰的方法，在类初始化的时候并不会初始化，只有当自己被调用时，才会被执行。</p></li></ol><h4 id="1-2-2-final"><a href="#1-2-2-final" class="headerlink" title="1.2.2-final"></a>1.2.2-final</h4><p>final 的意思是不变的，一般来说用于以下三种场景：</p><ol><li>被 final 修饰的类，表明该类是无法继承的；</li><li>被 final 修饰的方法，表明该方法是无法覆写的；</li><li>被 final 修饰的变量，说明该变量在声明的时候，就必须初始化完成，而且以后也不能修改其内存地址。</li></ol><p>第三点注意下，我们说的是无法修改其内存地址，并没有说无法修改其值。因为对于 List、Map 这些集合类来说，被 final 修饰后，是可以修改其内部值的，但却无法修改其初始化时的内存地址。</p><p>例子我们就不举了，1-1 小节 String 的不变性就是一个很好的例子。</p><h4 id="1-2-3-try、catch、finally"><a href="#1-2-3-try、catch、finally" class="headerlink" title="1.2.3-try、catch、finally"></a>1.2.3-try、catch、finally</h4><p>这三个关键字常用于我们捕捉异常的一整套流程，try 用来确定代码执行的范围，catch 捕捉可能会发生的异常，finally 用来执行一定要执行的代码块，除了这些，我们还需要清楚，每个地方如果发生异常会怎么办。</p><p>我们举一个例子来演示一下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCatchFinally</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"try is run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"try exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"catch is run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"catch exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"finally is run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个代码演示了在 try、catch 中都遇到了异常，代码的执行顺序为：try -&gt; catch -&gt; finally。</p><p>输出的结果如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/try-catch.jpeg" alt="try-catch"></p><p>可以看到两点：</p><ul><li>finally 先执行后，再抛出 catch 的异常；</li><li>最终捕获的异常是 catch 的异常，try 抛出来的异常已经被 catch 吃掉了，所以当我们遇见 catch 也有可能会抛出异常时，我们可以先打印出 try 的异常，这样 try 的异常在日志中就会有所体现。</li></ul><h4 id="1-2-4-volatile"><a href="#1-2-4-volatile" class="headerlink" title="1.2.4-volatile"></a>1.2.4-volatile</h4><p>volatile 的意思是可见的，常用来修饰某个共享变量，意思是当共享变量的值被修改后，会及时通知到其它线程上，其它线程就能知道当前共享变量的值已经被修改了。</p><p>我们再说原理之前，先说下基础知识。就是在多核 CPU 下，为了提高效率，线程在拿值时，是直接和 CPU 缓存打交道的，而不是内存。主要是因为 CPU 缓存执行速度更快，比如线程要拿值 C，会直接从 CPU 缓存中拿， CPU 缓存中没有，就会从内存中拿，所以线程读的操作永远都是拿 CPU 缓存的值。</p><p>这时候会产生一个问题，CPU 缓存中的值和内存中的值可能并不是时刻都同步，导致线程计算的值可能不是最新的，共享变量的值有可能已经被其它线程所修改了，但此时修改是机器内存的值，CPU 缓存的值还是老的，导致计算会出现问题。</p><p>这时候有个机制，就是内存会主动通知 CPU 缓存。当前共享变量的值已经失效了，你需要重新来拉取一份，CPU 缓存就会重新从内存中拿取一份最新的值。</p><p>volatile 关键字就会触发这种机制，加了 volatile 关键字的变量，就会被识别成共享变量，内存中值被修改后，会通知到各个 CPU 缓存，使 CPU 缓存中的值也对应被修改，从而保证线程从 CPU 缓存中拿取出来的值是最新的。</p><p>我们画了一个图来说明一下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/volatile.jpeg" alt="volatile"></p><p>从图中我们可以看到，线程 1 和线程 2 一开始都读取了 C 值，CPU 1 和 CPU 2 缓存中也都有了 C 值，然后线程 1 把 C 值修改了，这时候内存的值和 CPU 2 缓存中的 C 值就不等了，内存这时发现 C 值被 volatile 关键字修饰，发现其是共享变量，就会使 CPU 2 缓存中的 C 值状态置为无效，CPU 2 会从内存中重新拉取最新的值，这时候线程 2 再来读取 C 值时，读取的已经是内存中最新的值了。</p><h4 id="1-2-5-transient"><a href="#1-2-5-transient" class="headerlink" title="1.2.5-transient"></a>1.2.5-transient</h4><p>transient 关键字我们常用来修饰类变量，意思是当前变量是无需进行序列化的。在序列化时，就会忽略该变量，这些在序列化工具底层，就已经对 transient 进行了支持。</p><h4 id="1-2-6-default"><a href="#1-2-6-default" class="headerlink" title="1.2.6-default"></a>1.2.6-default</h4><p>default 关键字一般会用在接口的方法上，意思是对于该接口，子类是无需强制实现的，但自己必须有默认实现，我们举个例子如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/default.jpeg" alt="default"></p><p>default 关键字被很多源码使用，我们后面会说。</p><h4 id="1-2-7-面试题"><a href="#1-2-7-面试题" class="headerlink" title="1.2.7-面试题"></a>1.2.7-面试题</h4><ol><li><h5 id="如何证明-static-静态变量和类无关？"><a href="#如何证明-static-静态变量和类无关？" class="headerlink" title="如何证明 static 静态变量和类无关？"></a><strong>如何证明 static 静态变量和类无关？</strong></h5><p>答：从三个方面就可以看出静态变量和类无关。</p><ol><li>我们不需要初始化类就可直接使用静态变量；</li><li>我们在类中写个 main 方法运行，即便不写初始化类的代码，静态变量都会自动初始化；</li><li>静态变量只会初始化一次，初始化完成之后，不管我再 new 多少个类出来，静态变量都不会再初始化了。</li></ol><p>不仅仅是静态变量，静态方法块也和类无关。</p></li><li><h5 id="常常看见变量和方法被-static-和-final-两个关键字修饰，为什么这么做？"><a href="#常常看见变量和方法被-static-和-final-两个关键字修饰，为什么这么做？" class="headerlink" title="常常看见变量和方法被 static 和 final 两个关键字修饰，为什么这么做？"></a><strong>常常看见变量和方法被 static 和 final 两个关键字修饰，为什么这么做？</strong></h5><p>答：这么做有两个目的：</p><ol><li>变量和方法于类无关，可以直接使用，使用比较方便；</li><li>强调变量内存地址不可变，方法不可继承覆写，强调了方法内部的稳定性。</li></ol></li><li><h5 id="catch-中发生了未知异常，finally-还会执行么？"><a href="#catch-中发生了未知异常，finally-还会执行么？" class="headerlink" title="catch 中发生了未知异常，finally 还会执行么？"></a><strong>catch 中发生了未知异常，finally 还会执行么？</strong></h5><p>答：会的，catch 发生了异常，finally 还会执行的，并且是 finally 执行完成之后，才会抛出 catch 中的异常。</p><p>不过 catch 会吃掉 try 中抛出的异常，为了避免这种情况，在一些可以预见 catch 中会发生异常的地方，先把 try 抛出的异常打印出来，这样从日志中就可以看到完整的异常了。</p></li><li><h5 id="volatile-关键字的作用和原理"><a href="#volatile-关键字的作用和原理" class="headerlink" title="volatile 关键字的作用和原理"></a><strong>volatile 关键字的作用和原理</strong></h5><p>答：这个上文说的比较清楚，可以参考上文。</p></li></ol><h4 id="1-2-8-总结"><a href="#1-2-8-总结" class="headerlink" title="1.2.8-总结"></a>1.2.8-总结</h4><p>Java 的关键字属于比较基础的内容，我们需要清晰明确其含义，才能在后续源码阅读和工作中碰到这些关键字时了然于心，才能明白为什么会在这里使用这样的关键字。比如 String 源码是如何使用 final 关键字达到起不变性的，比如 Java 8 集合中 Map 是如何利用 default 关键字新增各种方法的，这些我们在后续内容都会提到。</p><h3 id="1-3-Arrays、Collections、Objects-常用方法源码解析"><a href="#1-3-Arrays、Collections、Objects-常用方法源码解析" class="headerlink" title="1.3-Arrays、Collections、Objects 常用方法源码解析"></a>1.3-Arrays、Collections、Objects 常用方法源码解析</h3><p>我们在工作中都会写工具类，但如何才能使写出来的工具类更好用，也是有一些技巧的。本章内容以三种平时工作中经常使用的工具类为例，从使用案例出发，再看看底层源码的实现，看看能否学习到一些工具类的技巧，以及三种工具类的实际使用场景。</p><h4 id="1-3-1-工具类通用的特征"><a href="#1-3-1-工具类通用的特征" class="headerlink" title="1.3.1-工具类通用的特征"></a>1.3.1-工具类通用的特征</h4><p>再看细节之前，我们先总结一下好的工具类都有哪些通用的特征写法：</p><ol><li>构造器必须是私有的。这样的话，工具类就无法被 new 出来，因为工具类在使用的时候，无需初始化，直接使用即可，所以不会开放出构造器出来。</li><li>工具类的工具方法必须被 static、final 关键字修饰。这样的话就可以保证方法不可变，并且可以直接使用，非常方便。</li></ol><p>我们需要注意的是，尽量不在工具方法中，对共享变量有做修改的操作访问（如果必须要做的话，必须加锁），因为会有线程安全的问题。除此之外，工具类方法本身是没有线程安全问题的，可以放心使用。</p><h4 id="1-3-2-Arrays"><a href="#1-3-2-Arrays" class="headerlink" title="1.3.2-Arrays"></a>1.3.2-Arrays</h4><p>Arrays 主要对数组提供了一些高效的操作，比如说排序、查找、填充、拷贝、相等判断等等。</p><ol><li><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h5><p>Arrays.sort 方法主要用于排序，入参支持 int、long、double 等各种基本类型的数组，也支持自定义类的数组，下面我们写个 demo 来演示一下自定义类数组的排序：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token comment" spellcheck="true">// 自定义类</span><span class="token keyword">class</span> <span class="token class-name">SortDTO</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> String sortTarget<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">SortDTO</span><span class="token punctuation">(</span>String sortTarget<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sortTarget <span class="token operator">=</span> sortTarget<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  List<span class="token operator">&lt;</span>SortDTO<span class="token operator">></span> list <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>      <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"300"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"50"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"200"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"220"</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 我们先把数组的大小初始化成 list 的大小，保证能够正确执行 toArray</span>  SortDTO<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"排序之前：{}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> Comparator<span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span>SortDTO<span class="token operator">:</span><span class="token operator">:</span>getSortTarget<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"排序之后：{}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>输出结果为：排序之前：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"300"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"50"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"200"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"220"</span><span class="token punctuation">}</span><span class="token punctuation">]</span>排序之后：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"200"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"220"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"300"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"50"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre><p>从输出的结果中可以看到，排序之后的数组已经是有顺序的了，也可以看到 sort 方法支持两个入参：要排序的数组和外部排序器。</p><p>大家都说 sort 方法排序的性能较高，主要原因是 sort 使用了双轴快速排序算法，具体算法就不细说了。</p></li></ol><ol start="2"><li><h5 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a><strong>二分查找法</strong></h5><p>Arrays.binarySearch 方法主要用于快速从数组中查找出对应的值。其支持的入参类型非常多，如 <code>byte、int、long</code> 各种类型的数组。返回参数是查找到的对应数组下标的值，如果查询不到，则返回负数。</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95.jpeg" alt="二分查找法"></p><p>我们写了一个 demo 如下：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>SortDTO<span class="token operator">></span> list <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>    <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"300"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"50"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"200"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"220"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>SortDTO<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"搜索之前：{}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> Comparator<span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span>SortDTO<span class="token operator">:</span><span class="token operator">:</span>getSortTarget<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"先排序，结果为：{}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> index <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"200"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    Comparator<span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span>SortDTO<span class="token operator">:</span><span class="token operator">:</span>getSortTarget<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"没有找到 200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"搜索结果：{}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>输出的结果为：搜索之前：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"300"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"50"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"200"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"220"</span><span class="token punctuation">}</span><span class="token punctuation">]</span>先排序，结果为：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"200"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"220"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"300"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"50"</span><span class="token punctuation">}</span><span class="token punctuation">]</span>搜索结果：<span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"200"</span><span class="token punctuation">}</span></code></pre><p>从上述代码中我们需要注意两点：</p><ul><li>如果被搜索的数组是无序的，一定要先排序，否则二分搜索很有可能搜索不到，我们 demo 里面也先对数组进行了排序；</li><li>搜索方法返回的是数组的下标值。如果搜索不到，返回的下标值就会是负数，这时我们需要判断一下正负。如果是负数，还从数组中获取数据的话，会报数组越界的错误。demo 中对这种情况进行了判断，如果是负数，会提前抛出明确的异常。</li></ul><p>接下来，我们来看下二分法底层代码的实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// a：我们要搜索的数组，fromIndex：从那里开始搜索，默认是0； toIndex：搜索到何时停止，默认是数组大小</span><span class="token comment" spellcheck="true">// key：我们需要搜索的值 c：外部比较器</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">int</span> <span class="token function">binarySearch0</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">,</span>                                     T key<span class="token punctuation">,</span> Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果比较器 c 是空的，直接使用 key 的 Comparable.compareTo 方法进行排序</span>    <span class="token comment" spellcheck="true">// 假设 key 类型是 String 类型，String 默认实现了 Comparable 接口，就可以直接使用 compareTo 方法进行排序</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这是另外一个方法，使用内部排序器进行比较的方法</span>        <span class="token keyword">return</span> <span class="token function">binarySearch0</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> fromIndex<span class="token punctuation">,</span> toIndex<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> low <span class="token operator">=</span> fromIndex<span class="token punctuation">;</span>    <span class="token keyword">int</span> high <span class="token operator">=</span> toIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 开始位置小于结束位置，就会一直循环搜索</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 假设 low =0，high =10，那么 mid 就是 5，所以说二分的意思主要在这里，每次都是计算索引的中间值</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>        T midVal <span class="token operator">=</span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 比较数组中间值和给定的值的大小关系</span>        <span class="token keyword">int</span> cmp <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>midVal<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果数组中间值小于给定的值，说明我们要找的值在中间值的右边</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 我们要找的值在中间值的左边</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">// 找到了</span>            <span class="token keyword">return</span> mid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// key found</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回的值是负数，表示没有找到</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token punctuation">(</span>low <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// key not found.</span><span class="token punctuation">}</span></code></pre><p>二分的主要意思是每次查找之前，都找到中间值，然后拿我们要比较的值和中间值比较，根据结果修改比较的上限或者下限，通过循环最终找到相等的位置索引，以上代码实现比较简洁，大家可以在自己理解的基础上，自己复写一遍。</p></li></ol><ol start="3"><li><h5 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a><strong>拷贝</strong></h5><p>数组拷贝我们经常遇到，有时需要拷贝整个数组，有时需要拷贝部分，比如 ArrayList 在 add（扩容） 或 remove（删除元素不是最后一个） 操作时，会进行一些拷贝。拷贝整个数组我们可以使用 copyOf 方法，拷贝部分我们可以使用 copyOfRange 方法，以 copyOfRange 为例，看下底层源码的实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// original 原始数组数据</span><span class="token comment" spellcheck="true">// from 拷贝起点</span><span class="token comment" spellcheck="true">// to 拷贝终点</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOfRange</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 需要拷贝的长度</span>    <span class="token keyword">int</span> newLength <span class="token operator">=</span> to <span class="token operator">-</span> from<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newLength <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>from <span class="token operator">+</span> <span class="token string">" > "</span> <span class="token operator">+</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化新数组</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>newLength<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用 native 方法进行拷贝，参数的意思分别是：</span>    <span class="token comment" spellcheck="true">// 被拷贝的数组、从数组那里开始、目标数组、从目的数组那里开始拷贝、拷贝的长度</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> from<span class="token punctuation">,</span> copy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                     Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span>length <span class="token operator">-</span> from<span class="token punctuation">,</span> newLength<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> copy<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码中，我们发现，Arrays 的拷贝方法，实际上底层调用的是 System.arraycopy 这个 native 方法，如果你自己对底层拷贝方法比较熟悉的话，也可以直接使用。</p></li></ol><h4 id="1-3-3-Collections"><a href="#1-3-3-Collections" class="headerlink" title="1.3.3-Collections"></a>1.3.3-Collections</h4><p>Collections 是为了方便使用集合而产生的工具类，Arrays 方便数组使用，Collections 是方便集合使用。</p><p>Collections 也提供了 sort 和 binarySearch 方法，sort 底层使用的就是 Arrays.sort 方法，binarySearch 底层是自己重写了二分查找算法，实现的逻辑和 Arrays 的二分查找算法完全一致，这两个方法上 Collections 和 Arrays 的内部实现很类似，接下来我们来看下 Collections 独有的特性。</p><ol><li><h5 id="求集合中最大、小值"><a href="#求集合中最大、小值" class="headerlink" title="求集合中最大、小值"></a><strong>求集合中最大、小值</strong></h5><p>提供了 max 方法来取得集合中的最大值，min 方法来取得集合中的最小值，max 和 min 方法很相似的，我们以 max 方法为例来说明一下，max 提供了两种类型的方法，一个需要传外部排序器，一个不需要传排序器，但需要集合中的元素强制实现 Comparable 接口，后者的泛型定义很有意思，我们来看下（从右往左看）：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E6%B1%82%E9%9B%86%E5%90%88%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC.jpeg" alt="求集合最大值最小值"></p><p>从这段源码中，我们可以学习到两点：</p><ul><li>max 方法泛型 T 定义得非常巧妙，意思是泛型必须继承 Object 并且实现 Comparable 的接口。一般让我们来定义的话，我们可以会在方法里面去判断有无实现 Comparable 的接口，这种是在运行时才能知道结果。而这里泛型直接定义了必须实现 Comparable 接口，在编译的时候就可告诉使用者，当前类没有实现 Comparable 接口，使用起来很友好；</li><li>给我们提供了实现两种排序机制的好示例：自定义类实现 Comparable 接口和传入外部排序器。两种排序实现原理类似，但实现有所差别，我们在工作中如果需要些排序的工具类时，可以效仿。</li></ul></li></ol><ol start="2"><li><h5 id="多种类型的集合"><a href="#多种类型的集合" class="headerlink" title="多种类型的集合"></a><strong>多种类型的集合</strong></h5><p>Collections 对原始集合类进行了封装，提供了更好的集合类给我们，一种是线程安全的集合，一种是不可变的集合，针对 List、Map、Set 都有提供，我们先来看下线程安全的集合：</p><ul><li><p><strong>线程安全的集合</strong></p><p>线程安全的集合方法都是 synchronized 打头的，如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E6%96%B9%E6%B3%95.jpeg" alt="线程安全的集合方法"></p><p>从方法命名我们都可以看出来，底层是通过 synchronized 轻量锁来实现的，我们以 synchronizedList 为例来说明下底层的实现：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/synchronizedList.jpeg" alt="synchronizedList"></p><p>可以看到 List 的所有操作方法都被加上了 synchronized 锁，所以多线程对集合同时进行操作，是线程安全的。</p></li><li><p><strong>不可变的集合</strong></p><p>得到不可变集合的方法都是以 unmodifiable 开头的。这类方法的意思是，我们会从原集合中，得到一个不可变的新集合，新集合只能访问，无法修改；一旦修改，就会抛出异常。这主要是因为只开放了查询方法，其余任何修改操作都会抛出异常，我们以 unmodifiableList 为例来看下底层实现机制：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/unmodifiableList.jpeg" alt="unmodifiableList"></p></li><li><p><strong>小结</strong></p><p>以上两种 List 其实解决了工作中的一些困惑，比如说 ArrayList 是线程不安全的，然后其内部数组很容易被修改，有的时候，我们希望 List 一旦生成后，就不能被修改，Collections 对 List 重新进行了封装，提供了两种类型的集合封装形式，从而解决了工作中的一些烦恼，如果你平时使用 List 时有一些烦恼，也可以学习此种方式，自己对原始集合进行封装，来解决 List 使用过程中的不方便。</p></li></ul></li></ol><h4 id="1-3-4-Objects"><a href="#1-3-4-Objects" class="headerlink" title="1.3.4-Objects"></a>1.3.4-Objects</h4><p>对于 Objects，我们经常使用的就是两个场景，相等判断和判空。</p><ol><li><h5 id="相等判断-1"><a href="#相等判断-1" class="headerlink" title="相等判断"></a><strong>相等判断</strong></h5><p>Objects 有提供 equals 和 deepEquals 两个方法来进行相等判断，前者是判断基本类型和自定义类的，后者是用来判断数组的，我们来看下底层的源码实现：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Objects-equals.jpeg" alt="Objects-equals"></p><p>从源码中，可以看出 Objects 对基本类型和复杂类型的对象，都有着比较细粒度的判断，可以放心使用。</p></li></ol><ol start="2"><li><h5 id="为空判断"><a href="#为空判断" class="headerlink" title="为空判断"></a><strong>为空判断</strong></h5><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Objects-isNull.jpeg" alt="Objects-isNull"></p><p>Objects 提供了各种关于空的一些判断，isNull 和 nonNull 对于对象是否为空返回 Boolean 值，requireNonNull 方法更加严格，如果一旦为空，会直接抛出异常，我们需要根据生活的场景选择使用。</p></li></ol><h4 id="1-3-5-面试题"><a href="#1-3-5-面试题" class="headerlink" title="1.3.5-面试题"></a>1.3.5-面试题</h4><ol><li><h5 id="工作中有没有遇到特别好用的工具类，如何写好一个工具类"><a href="#工作中有没有遇到特别好用的工具类，如何写好一个工具类" class="headerlink" title="工作中有没有遇到特别好用的工具类，如何写好一个工具类"></a>工作中有没有遇到特别好用的工具类，如何写好一个工具类</h5><p>答：有的，像 Arrays 的排序、二分查找、Collections 的不可变、线程安全集合类、Objects 的判空相等判断等等工具类，好的工具类肯定很好用，比如说使用 static final 关键字对方法进行修饰，工具类构造器必须是私有等等手段来写好工具类。</p></li><li><h5 id="写一个二分查找算法的实现"><a href="#写一个二分查找算法的实现" class="headerlink" title="写一个二分查找算法的实现"></a>写一个二分查找算法的实现</h5><p>答：可以参考 Arrays 的 binarySearch 方法的源码实现。</p></li><li><h5 id="如果我希望-ArrayList-初始化之后，不能被修改，该怎么办"><a href="#如果我希望-ArrayList-初始化之后，不能被修改，该怎么办" class="headerlink" title="如果我希望 ArrayList 初始化之后，不能被修改，该怎么办"></a>如果我希望 ArrayList 初始化之后，不能被修改，该怎么办</h5><p>答：可以使用 <code>Collections</code> 的 <code>unmodifiableList</code> 的方法，该方法会返回一个不能被修改的内部类集合，这些集合类只开放查询的方法，对于调用修改集合的方法会直接抛出异常。</p></li></ol><h4 id="1-3-6-总结"><a href="#1-3-6-总结" class="headerlink" title="1.3.6-总结"></a>1.3.6-总结</h4><p>从三大工具类中，我们不仅学习到了如何写好一个工具类，还熟悉了三大工具类的具体使用姿势，甚至了解了其底层的源码实现，有兴趣的话，可以自己也可以仿照写个好用的工具类加深学习。</p><h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2-集合"></a>2-集合</h2><h3 id="2-1-ArrayList-源码解析和设计思路"><a href="#2-1-ArrayList-源码解析和设计思路" class="headerlink" title="2.1-ArrayList 源码解析和设计思路"></a>2.1-ArrayList 源码解析和设计思路</h3><p>ArrayList 我们几乎每天都会使用到，但真正面试的时候，发现还是有不少人对源码细节说不清楚，给面试官留下比较差的印象，本小节就和大家一起看看面试中和 ArrayList 相关的源码。</p><h4 id="2-1-1-整体架构"><a href="#2-1-1-整体架构" class="headerlink" title="2.1.1-整体架构"></a>2.1.1-整体架构</h4><p>ArrayList 整体架构比较简单，就是一个数组结构，比较简单，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayList.jpeg" alt="ArrayList"></p><p>图中展示是长度为 10 的数组，从 1 开始计数，index 表示数组的下标，从 0 开始计数，elementData 表示数组本身，源码中除了这两个概念，还有以下三个基本概念：</p><ul><li>DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；</li><li>size 表示当前数组的大小，类型 int，没有使用 volatile 修饰，非线程安全的；</li><li>modCount 统计当前数组被修改的版本次数，数组结构有变动，就会 +1。</li></ul><p><strong>类注释</strong></p><p>看源码，首先要看类注释，我们看看类注释上面都说了什么，如下：</p><ul><li>允许 put null 值，会自动扩容；</li><li>size、isEmpty、get、set、add 等方法时间复杂度都是 O (1)；</li><li>是非线程安全的，多线程情况下，推荐使用线程安全类：Collections#synchronizedList；</li><li>增强 for 循环，或者使用迭代器迭代过程中，如果数组大小被改变，会快速失败，抛出异常。</li></ul><p>除了上述注释中提到的 4 点，初始化、扩容的本质、迭代器等问题也经常被问，接下来我们从源码出发，一一解析。</p><h4 id="2-1-2-源码解析"><a href="#2-1-2-源码解析" class="headerlink" title="2.1.2-源码解析"></a>2.1.2-源码解析</h4><ol><li><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h5><p>我们有三种初始化办法：<strong>无参数直接初始化</strong>、<strong>指定大小初始化</strong>、<strong>指定初始数据初始化</strong>。</p><p>源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//无参数直接初始化，数组大小为空</span><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//指定初始数据初始化</span><span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//elementData 是保存数组的容器，默认为 null</span>    elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果给定的集合（c）数据有值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>        <span class="token comment" spellcheck="true">//如果集合元素类型不是 Object 类型，我们会转成 Object</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 给定集合（c）无值，则默认空数组</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>除了源码的中文注释，我们补充两点：</p><ul><li><p>ArrayList 无参构造器初始化时，默认大小是空数组，并不是大家常说的 10，10 是在第一次 add 的时候扩容的数组值。</p></li><li><p>指定初始数据初始化时，我们发现一个这样子的注释 see 6260652，这是 Java 的一个 bug，意思是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型。一般情况下都不会触发此 bug，只有在下列场景下才会触发：ArrayList 初始化之后（ArrayList 元素非 Object 类型），再次调用 toArray 方法，得到 Object 数组，并且往 Object 数组赋值时，才会触发此 bug。</p><p>代码和原因如图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayList-%E5%88%9D%E5%A7%8B%E5%8C%96Bug.jpeg" alt="ArrayList-初始化Bug"></p><p>官方查看文档地址：<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652，问题在" target="_blank" rel="noopener">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652，问题在</a> Java 9 中被解决。</p></li></ul></li></ol><ol start="2"><li><h5 id="新增和扩容实现"><a href="#新增和扩容实现" class="headerlink" title="新增和扩容实现"></a><strong>新增和扩容实现</strong></h5><p>新增就是往数组中添加元素，主要分成两步：</p><ul><li>判断是否需要扩容，如果需要执行扩容操作；</li><li>直接赋值。</li></ul><p>两步源码体现如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小</span>  <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>  <span class="token comment" spellcheck="true">//直接赋值，线程不安全的</span>  elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们先看下扩容（ensureCapacityInternal）的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>    minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//确保容积足够</span>  <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//记录数组被修改</span>  modCount<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//扩容，并把现有数据拷贝到新的数组里面去</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// oldCapacity >> 1 是把 oldCapacity 除以 2 的意思</span>  <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 如果扩容后的值 > jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 通过复制进行扩容</span>  elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>注解应该比较详细，我们需要注意的四点是：</p><ul><li>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原来容量的 1.5 倍；</li><li>ArrayList 中的数组的最大值是 <code>Integer.MAX_VALUE</code>，超过这个值，JVM 就不会给数组分配内存空间了。</li><li>新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的。</li></ul><p>从新增和扩容源码中，下面这点值得我们借鉴：</p><ul><li>源码在扩容的时候，有数组大小溢出意识，就是说扩容后数组的大小下界不能小于 0，上界不能大于 Integer 的最大值，这种意识我们可以学习。</li></ul><p>扩容完成之后，赋值是非常简单的，直接往数组上添加元素即可：<code>elementData [size++] = e</code>。也正是通过这种简单赋值，没有任何锁控制，所以这里的操作是线程不安全的。</p><p>对于新增和扩容的实现，画了一个动图，如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayList-%E6%96%B0%E5%A2%9E%E5%92%8C%E6%89%A9%E5%AE%B9.jpeg" alt="ArrayList-新增和扩容"></p></li></ol><ol start="3"><li><h5 id="扩容的本质"><a href="#扩容的本质" class="headerlink" title="扩容的本质"></a><strong>扩容的本质</strong></h5><p>扩容是通过这行代码来实现的：<code>Arrays.copyOf(elementData, newCapacity);</code>，这行代码描述的本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据拷贝过去，我们通过 System.arraycopy 方法进行拷贝，此方法是 native 的方法。</p><p>源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @param src     被拷贝的数组 * @param srcPos  从数组那里开始 * @param dest    目标数组 * @param destPos 从目标数组那个索引位置开始拷贝 * @param length  拷贝的长度  * 此方法是没有返回值的，通过 dest 的引用进行传值 */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span>Object src<span class="token punctuation">,</span> <span class="token keyword">int</span> srcPos<span class="token punctuation">,</span>                                    Object dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span>                                    <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们可以通过下面这行代码进行调用，newElementData 表示新的数组：</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>elementData<span class="token punctuation">.</span>length<span class="token punctuation">,</span>newCapacity</code></pre></li><li><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h5><p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理和思路都差不多，我们选取根据值删除方式来进行源码说明：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 如果要删除的值是 null，找到第一个值是 null 的删除</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果要删除的值不为 null，找到第一个和要删除的值相等的删除</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 这里是根据  equals 来判断值相等的，相等后再根据索引位置进行删除</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们需要注意的两点是：</p><ul><li>新增的时候是没有对 null 进行校验的，所以删除的时候也是允许删除 null 值的；</li><li>找到值在数组中的索引位置，是通过 equals 来判断的，如果数组元素不是基本类型，需要我们关注 equals 的具体实现。</li></ul><p>上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 记录数组的结构要发生变动了</span>  modCount<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去</span>  <span class="token comment" spellcheck="true">// 减 1 的原因，是因为 size 从 1 开始算起，index 从 0开始算起</span>  <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 numMoved</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//数组最后一个位置赋值 null，帮助 GC</span>  elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码中，我们可以看出，某一个元素被删除后，为了维护数组结构，我们都会把数组后面的元素往前移动，下面动图也演示了其过程：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayList-%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B.jpeg" alt="ArrayList-删除过程"></p></li></ol><ol start="5"><li><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><strong>迭代器</strong></h5><p>如果要自己实现迭代器，实现 java.util.Iterator 类就好了，ArrayList 也是这样做的，我们来看下迭代器的几个总要的参数：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> cursor<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 迭代过程中，下一个元素的位置，默认从 0 开始。</span><span class="token keyword">int</span> lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 新增场景：表示上一次迭代过程中，索引的位置；删除场景：为 -1。</span><span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// expectedModCount 表示迭代过程中，期望的版本号；modCount 表示数组实际的版本号。</span></code></pre><p>迭代器一般来说有三个方法：</p><ul><li>hasNext 还有没有值可以迭代</li><li>next 如果有值可以迭代，迭代的值是多少</li><li>remove 删除当前迭代的值</li></ul><p>我们来分别看下三个方法的源码：</p><p><strong>hasNext</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> cursor <span class="token operator">!=</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//cursor 表示下一个元素的位置，size 表示实际大小，如果两者相等，说明已经没有元素可以迭代了，如果不等，说明还可以迭代</span><span class="token punctuation">}</span></code></pre><p><strong>next</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span>  <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//本次迭代过程中，元素的索引位置</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> cursor<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> size<span class="token punctuation">)</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 下一次迭代时，元素的位置，为下一次迭代做准备</span>  cursor <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 返回元素值</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>lastRet <span class="token operator">=</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 版本号比较</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码中可以看到，next 方法就干了两件事情，第一是检验能不能继续迭代，第二是找到迭代的值，并为下一次迭代做准备<code>（cursor+1）</code>。</p><p><strong>remove</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 如果上一次操作时，数组的位置已经小于 0 了，说明数组已经被删除完了</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lastRet <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span>  <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lastRet<span class="token punctuation">)</span><span class="token punctuation">;</span>    cursor <span class="token operator">=</span> lastRet<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// -1 表示元素已经被删除，这里也防止重复删除</span>    lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 删除元素时 modCount 的值已经发生变化，在此赋值给 expectedModCount</span>    <span class="token comment" spellcheck="true">// 这样下次迭代时，两者的值是一致的了</span>    expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IndexOutOfBoundsException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里我们需要注意的两点是：</p><ul><li>lastRet = -1 的操作目的，是防止重复删除操作</li><li>删除元素成功，数组当前 <code>modCount</code> 就会发生变化，这里会把 <code>expectedModCount</code> 重新赋值，下次迭代时两者的值就会一致了</li></ul></li></ol><ol start="6"><li><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>从我们上面新增或删除方法的源码解析，对数组元素的操作，只需要根据数组索引，直接新增和删除，所以时间复杂度是 O (1)。</p></li></ol><ol start="7"><li><h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><p>我们需要强调的是，只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是方法内的局部变量时，是没有线程安全的问题的。</p><p>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p><p>类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，SynchronizedList 是通过在每个方法上面加上锁来实现，虽然实现了线程安全，但是性能大大降低，具体实现源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// synchronized 是一种轻量锁，mutex 表示一个当前 SynchronizedList</span>        <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h4 id="2-1-3-总结"><a href="#2-1-3-总结" class="headerlink" title="2.1.3-总结"></a>2.1.3-总结</h4><p>本文从 ArrayList 整体架构出发，落地到初始化、新增、扩容、删除、迭代等核心源码实现，我们发现 ArrayList 其实就是围绕底层数组结构，各个 API 都是对数组的操作进行封装，让使用者无需感知底层实现，只需关注如何使用即可。</p><h3 id="2-2-LinkedList-源码解析"><a href="#2-2-LinkedList-源码解析" class="headerlink" title="2.2-LinkedList 源码解析"></a>2.2-LinkedList 源码解析</h3><p>LinkedList 适用于集合元素先入先出和先入后出的场景，在队列源码中被频繁使用，面试也经常问到，本小节让我们通过源码来加深对 LinkedList 的了解。</p><h4 id="2-2-1-整体架构"><a href="#2-2-1-整体架构" class="headerlink" title="2.2.1-整体架构"></a>2.2.1-整体架构</h4><p>LinkedList 底层数据结构是一个双向链表，整体结构如下图所示：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/LinkedList.jpeg" alt="LinkedList"></p><p>上图代表了一个双向链表结构，链表中的每个节点都可以向前或者向后追溯，我们有几个概念如下：</p><ul><li>链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，代表后一个节点的位置；</li><li>first 是双向链表的头节点，它的前一个节点是 null。</li><li>last 是双向链表的尾节点，它的后一个节点是 null；</li><li>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；</li><li>因为是个双向链表，只要机器内存足够强大，是没有大小限制的。</li></ul><p>链表中的元素叫做 Node，我们看下 Node 的组成部分：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    E item<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 节点值</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向的下一个节点</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向的前一个节点</span>    <span class="token comment" spellcheck="true">// 初始化参数顺序分别是：前一个节点、本身节点值、后一个节点</span>    <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">,</span> E element<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-2-2-源码解析"><a href="#2-2-2-源码解析" class="headerlink" title="2.2.2-源码解析"></a>2.2.2-源码解析</h4><h5 id="1-新增"><a href="#1-新增" class="headerlink" title="1.新增"></a>1.新增</h5><p>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开始追加，addFirst 方法是从头部开始追加，我们分别来看下两种不同的追加方式：</p><p><strong>从尾部追加（add）</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 从尾部开始追加节点</span><span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 把尾节点数据暂存</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新建新的节点，初始化入参含义：</span>    <span class="token comment" spellcheck="true">// l 是新节点的前一个节点，当前值是尾节点值</span>    <span class="token comment" spellcheck="true">// e 表示当前新增节点，当前新增节点后一个节点是 null</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新建节点追加到尾部</span>    last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token operator">!</span><span class="token punctuation">[</span>图片描述<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">//img.mukewang.com/5d5fc69600013e4803600240.gif)</span>    <span class="token comment" spellcheck="true">//否则把前尾节点的下一个节点，指向当前尾节点。</span>    <span class="token keyword">else</span>        l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//大小和版本更改</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码上来看，尾部追加节点比较简单，只需要简单地把指向位置修改下即可，我们做个动图来描述下整个过程：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/LinkedList-%E6%96%B0%E5%A2%9E.jpeg" alt="LinkedList-新增"></p><p><strong>从头部追加（addFirst）</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 从头部追加</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 头节点赋值给临时变量</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新建节点，前一个节点指向null，e 是新建节点，f 是新建节点的下一个节点，目前值是头节点的值</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新建节点成为头节点</span>    first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 头节点为空，就是链表为空，头尾节点是一个节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//上一个头节点的前一个节点指向当前节点</span>    <span class="token keyword">else</span>        f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>头部追加节点和尾部追加节点非常类似，只是前者是移动头节点的 prev 指向，后者是移动尾节点的 next 指向。</p><h5 id="2-节点删除"><a href="#2-节点删除" class="headerlink" title="2.节点删除"></a>2.节点删除</h5><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。</p><p><strong>从头部删除</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//从头删除节点 f 是链表头节点</span><span class="token keyword">private</span> E <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 拿出头节点的值，作为方法的返回值</span>    <span class="token keyword">final</span> E element <span class="token operator">=</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拿出头节点的下一个节点</span>    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//帮助 GC 回收头节点</span>    f<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>    f<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 头节点的下一个节点成为头节点</span>    first <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果 next 为空，表明链表为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>        last <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//链表不为空，头节点的前一个节点指向 null</span>    <span class="token keyword">else</span>        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//修改链表大小和版本</span>    size<span class="token operator">--</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> element<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从尾部删除节点代码也是类似的，就不贴了。</p><p><strong>从源码中我们可以了解到，链表结构的节点新增、删除都非常简单，仅仅把前后节点的指向修改下就好了，所以 LinkedList 新增和删除速度很快。</strong></p><h5 id="3-节点查询"><a href="#3-节点查询" class="headerlink" title="3.节点查询"></a>3.节点查询</h5><p>链表查询某一个节点是比较慢的，需要挨个循环查找才行，我们看看 LinkedList 的源码是如何寻找节点的：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 根据链表索引位置查询节点</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果 index 处于队列的前半部分，从头开始找，size >> 1 是 size 除以 2 的意思。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 直到 for 循环到 index 的前一个 node 停止</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 如果 index 处于队列的后半部分，从尾开始找</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 直到 for 循环到 index 的后一个 node 停止</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>            x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从源码中我们可以发现，LinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，首先看看 index 是在链表的前半部分，还是后半部分。如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值得我们借鉴。</p><h5 id="4-方法对比"><a href="#4-方法对比" class="headerlink" title="4.方法对比"></a>4.方法对比</h5><p>LinkedList 实现了 Queue 接口，在新增、删除、查询等方面增加了很多新的方法，这些方法在平时特别容易混淆，在链表为空的情况下，返回值也不太一样，我们列一个表格，方便大家记录：</p><table><thead><tr><th align="left">方法含义</th><th align="left">返回异常</th><th align="left">返回特殊值</th><th align="left">底层实现</th></tr></thead><tbody><tr><td align="left">新增</td><td align="left">add(e)</td><td align="left">offer(e)</td><td align="left">底层实现相同</td></tr><tr><td align="left">删除</td><td align="left">remove()</td><td align="left">poll(e)</td><td align="left">链表为空时，remove 会抛出异常，poll 返回 null。</td></tr><tr><td align="left">查找</td><td align="left">element()</td><td align="left">peek()</td><td align="left">链表为空时，element 会抛出异常，peek 返回 null。</td></tr></tbody></table><p>PS：Queue 接口注释建议 add 方法操作失败时抛出异常，但 LinkedList 实现的 add 方法一直返回 true。<br>LinkedList 也实现了 Deque 接口，对新增、删除和查找都提供从头开始，还是从尾开始两种方向的方法，比如 remove 方法，Deque 提供了 removeFirst 和 removeLast 两种方向的使用方式，但当链表为空时的表现都和 remove 方法一样，都会抛出异常。</p><h5 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5.迭代器"></a>5.迭代器</h5><p>因为 LinkedList 要实现双向的迭代访问，所以我们使用 Iterator 接口肯定不行了，因为 Iterator 只支持从头到尾的访问。Java 新增了一个迭代接口，叫做：ListIterator，这个接口提供了向前和向后的迭代方法，如下所示：</p><table><thead><tr><th align="left">迭代顺序</th><th align="left">方法</th></tr></thead><tbody><tr><td align="left">从尾到头迭代方法</td><td align="left">hasPrevious、previous、previousIndex</td></tr><tr><td align="left">从头到尾迭代方法</td><td align="left">hasNext、next、nextIndex</td></tr></tbody></table><p>LinkedList 实现了 <code>ListIterator</code> 接口，如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 双向迭代器</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ListItr</span> <span class="token keyword">implements</span> <span class="token class-name">ListIterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> lastReturned<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上一次执行 next() 或者 previos() 方法时的节点位置</span>    <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下一个节点</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> nextIndex<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下一个节点的位置</span>    <span class="token comment" spellcheck="true">//expectedModCount：期望版本号；modCount：目前最新版本号</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    …………<span class="token punctuation">}</span></code></pre><p>我们先来看下从头到尾方向的迭代：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 判断还有没有下一个元素</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> nextIndex <span class="token operator">&lt;</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 下一个节点的索引小于链表的大小，就有</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 取下一个元素</span><span class="token keyword">public</span> E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//检查期望版本号有无发生变化</span>    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//再次检查</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// next 是当前节点，在上一次执行 next() 方法时被赋值的。</span>    <span class="token comment" spellcheck="true">// 第一次执行时，是在初始化迭代器的时候，next 被赋值的</span>    lastReturned <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// next 是下一个节点了，为下次迭代做准备</span>    next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述源码的思路就是直接取当前节点的下一个节点，而从尾到头迭代稍微复杂一点，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果上次节点索引位置大于 0，就还有节点可以迭代</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> nextIndex <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 取前一个节点</span><span class="token keyword">public</span> E <span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// next 为空场景：1:说明是第一次迭代，取尾节点(last);2:上一次操作把尾节点删除掉了</span>    <span class="token comment" spellcheck="true">// next 不为空场景：说明已经发生过迭代了，直接取前一个节点即可(next.prev)</span>    lastReturned <span class="token operator">=</span> next <span class="token operator">=</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> last <span class="token operator">:</span> next<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 索引位置变化</span>    nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里复杂点体现在需要判断 next 不为空和为空的场景，代码注释中有详细的描述。</p><p><strong>迭代器删除</strong></p><p>LinkedList 在删除元素时，也推荐通过迭代器进行删除，删除过程如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// lastReturned 是本次迭代需要删除的值，分以下空和非空两种情况：</span>    <span class="token comment" spellcheck="true">// lastReturned 为空，说明调用者没有主动执行过 next() 或者 previos()，直接报错</span>    <span class="token comment" spellcheck="true">// lastReturned 不为空，是在上次执行 next() 或者 previos()方法时赋的值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastReturned <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> lastNext <span class="token operator">=</span> lastReturned<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//删除当前节点</span>    <span class="token function">unlink</span><span class="token punctuation">(</span>lastReturned<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// next == lastReturned 的场景分析：从尾到头递归顺序，并且是第一次迭代，并且要删除最后一个元素的情况下</span>    <span class="token comment" spellcheck="true">// 这种情况下，previous() 方法里面设置了 lastReturned = next = last,所以 next 和 lastReturned会相等</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> lastReturned<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 这时候 lastReturned 是尾节点，lastNext 是 null，所以 next 也是 null，这样在 previous() 执行时，发现 next 是 null，就会把尾节点赋值给 next</span>        next <span class="token operator">=</span> lastNext<span class="token punctuation">;</span>    <span class="token keyword">else</span>        nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>    lastReturned <span class="token operator">=</span> null<span class="token punctuation">;</span>    expectedModCount<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-2-3-总结"><a href="#2-2-3-总结" class="headerlink" title="2.2.3-总结"></a>2.2.3-总结</h4><p>LinkedList 适用于要求有顺序、并且会按照顺序进行迭代的场景，主要是依赖于底层的链表结构，在面试中的频率还是蛮高的，相信理清楚上面的源码后，应对面试应该没有问题。</p><h3 id="2-3-List-源码会问哪些面试题"><a href="#2-3-List-源码会问哪些面试题" class="headerlink" title="2.3-List 源码会问哪些面试题"></a>2.3-List 源码会问哪些面试题</h3><p>List 作为工作中最常见的集合类型，在面试过程中，也是经常会被问到各种各样的面试题，一般来说，只要你看过源码，心中对 List 的总体结构和细节有所了解的话，基本问题都不大。</p><h4 id="2-3-1-面试题"><a href="#2-3-1-面试题" class="headerlink" title="2.3.1-面试题"></a>2.3.1-面试题</h4><h5 id="1-说说你自己对-ArrayList-的理解？"><a href="#1-说说你自己对-ArrayList-的理解？" class="headerlink" title="1. 说说你自己对 ArrayList 的理解？"></a>1. 说说你自己对 ArrayList 的理解？</h5><p>很多面试官喜欢这样子开头，考察面试同学对 ArrayList 有没有总结经验，介于 ArrayList 内容很多，建议先回答总体架构，再从某个细节出发作为突破口，比如这样：<br>ArrayList 底层数据结构是个数组，其 API 都做了一层对数组底层访问的封装，比如说 add 方法的过程是……（这里可以引用我们在 ArrayList 源码解析中 add 的过程）。</p><p>一般面试官看你回答得井井有条，并且没啥漏洞的话，基本就不会深究了，这样面试的主动权就掌握在自己手里面了，如果你回答得支支吾吾，那么面试官可能就会开启自己面试的套路了。</p><p>说说你自己对 LinkedList 的理解也是同样套路。</p><h5 id="2-扩容类问题"><a href="#2-扩容类问题" class="headerlink" title="2.扩容类问题"></a>2.扩容类问题</h5><h6 id="2-1-ArrayList-无参数构造器构造，现在-add-一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？"><a href="#2-1-ArrayList-无参数构造器构造，现在-add-一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？" class="headerlink" title="2.1-ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？"></a>2.1-ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？</h6><p>答：此处数组的大小是 1，下一次扩容前最大可用大小是 10，因为 ArrayList 第一次扩容时，是有默认值的，默认值是 10，在第一次 add 一个值进去时，数组的可用大小被扩容到 10 了。</p><h6 id="2-2-如果我连续往-list-里面新增值，增加到第-11-个的时候，数组的大小是多少？"><a href="#2-2-如果我连续往-list-里面新增值，增加到第-11-个的时候，数组的大小是多少？" class="headerlink" title="2.2-如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？"></a>2.2-如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？</h6><p>答：这里的考查点就是扩容的公式，当增加到 11 的时候，此时我们希望数组的大小为 11，但实际上数组的最大容量只有 10，不够了就需要扩容，扩容的公式是：oldCapacity + (oldCapacity&gt;&gt; 1)，oldCapacity 表示数组现有大小，目前场景计算公式是：10 + 10 ／2 = 15，然后我们发现 15 已经够用了，所以数组的大小会被扩容到 15。</p><h6 id="2-3-数组初始化，被加入一个值后，如果我使用-addAll-方法，一下子加入-15-个值，那么最终数组的大小是多少？"><a href="#2-3-数组初始化，被加入一个值后，如果我使用-addAll-方法，一下子加入-15-个值，那么最终数组的大小是多少？" class="headerlink" title="2.3-数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？"></a>2.3-数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？</h6><p>答：第一题中我们已经计算出来数组在加入一个值后，实际大小是 1，最大可用大小是 10 ，现在需要一下子加入 15 个值，那我们期望数组的大小值就是 16，此时数组最大可用大小只有 10，明显不够，需要扩容，扩容后的大小是：10 + 10 ／2 = 15，这时候发现扩容后的大小仍然不到我们期望的值 16，这时候源码中有一种策略如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// newCapacity 本次扩容的大小，minCapacity 我们期望的数组最小大小</span><span class="token comment" spellcheck="true">// 如果扩容后的值 &lt; 我们的期望值，我们的期望值就等于本次扩容的大小</span><span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span></code></pre><p>所以最终数组扩容后的大小为 16。</p><h6 id="2-4-现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？"><a href="#2-4-现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？" class="headerlink" title="2.4-现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？"></a>2.4-现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？</h6><p>答：因为原数组比较大，如果新建新数组的时候，不指定数组大小的话，就会频繁扩容，频繁扩容就会有大量拷贝的工作，造成拷贝的性能低下，所以回答说新建数组时，指定新数组的大小为 5k 即可。</p><h6 id="2-5-为什么说扩容会消耗性能？"><a href="#2-5-为什么说扩容会消耗性能？" class="headerlink" title="2.5-为什么说扩容会消耗性能？"></a>2.5-为什么说扩容会消耗性能？</h6><p>答：扩容底层使用的是 System.arraycopy 方法，会把原数组的数据全部拷贝到新数组上，所以性能消耗比较严重。</p><h6 id="2-6-源码扩容过程有什么值得借鉴的地方？"><a href="#2-6-源码扩容过程有什么值得借鉴的地方？" class="headerlink" title="2.6-源码扩容过程有什么值得借鉴的地方？"></a>2.6-源码扩容过程有什么值得借鉴的地方？</h6><p>答：有两点：</p><ul><li>是扩容的思想值得学习，通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时，也可快速扩容。</li><li>扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</li></ul><p>这两点在我们平时设计和写代码时都可以借鉴。</p><h5 id="3-删除类问题"><a href="#3-删除类问题" class="headerlink" title="3.删除类问题"></a>3.删除类问题</h5><h6 id="3-1-有一个-ArrayList，数据是-2、3、3、3、4，中间有三个-3，现在我通过-for-int-i-0-i-lt-list-size-i-的方式，想把值是-3-的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下："><a href="#3-1-有一个-ArrayList，数据是-2、3、3、3、4，中间有三个-3，现在我通过-for-int-i-0-i-lt-list-size-i-的方式，想把值是-3-的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下：" class="headerlink" title="3.1-有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，现在我通过 for (int i=0;i&lt;list.size ();i++) 的方式，想把值是 3 的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下："></a>3.1-有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，现在我通过 for (int i=0;i&lt;list.size ();i++) 的方式，想把值是 3 的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下：</h6><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>  <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>答：不能删除干净，最终删除的结果是 2、3、4，有一个 3 删除不掉，原因我们看下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayList-%E5%88%A0%E9%99%A4%E5%8E%9F%E5%9B%A0.jpeg" alt="ArrayList-删除原因"></p><p>从图中我们可以看到，每次删除一个元素后，该元素后面的元素就会往前移动，而此时循环的 i 在不断地增长，最终会使每次删除 3 的后一个 3 被遗漏，导致删除不掉。</p><h6 id="3-2-还是上面的-ArrayList-数组，我们通过增强-for-循环进行删除，可以么？"><a href="#3-2-还是上面的-ArrayList-数组，我们通过增强-for-循环进行删除，可以么？" class="headerlink" title="3.2-还是上面的 ArrayList 数组，我们通过增强 for 循环进行删除，可以么？"></a>3.2-还是上面的 ArrayList 数组，我们通过增强 for 循环进行删除，可以么？</h6><p>答：不可以，会报错。因为增强 for 循环过程其实调用的就是迭代器的 next () 方法，当你调用 list#remove () 方法进行删除时，modCount 的值会 +1，而这时候迭代器中的 expectedModCount 的值却没有变，导致在迭代器下次执行 next () 方法时，expectedModCount != modCount 就会报 ConcurrentModificationException 的错误。</p><h6 id="3-3-还是上面的数组，如果删除时使用-Iterator-remove-方法可以删除么，为什么？"><a href="#3-3-还是上面的数组，如果删除时使用-Iterator-remove-方法可以删除么，为什么？" class="headerlink" title="3.3-还是上面的数组，如果删除时使用 Iterator.remove () 方法可以删除么，为什么？"></a>3.3-还是上面的数组，如果删除时使用 Iterator.remove () 方法可以删除么，为什么？</h6><p>答：可以的，因为 Iterator.remove () 方法在执行的过程中，会把最新的 modCount 赋值给 expectedModCount，这样在下次循环过程中，modCount 和 expectedModCount 两者就会相等。</p><h6 id="3-4-以上三个问题对于-LinkedList-也是同样的结果么？"><a href="#3-4-以上三个问题对于-LinkedList-也是同样的结果么？" class="headerlink" title="3.4-以上三个问题对于 LinkedList 也是同样的结果么？"></a>3.4-以上三个问题对于 LinkedList 也是同样的结果么？</h6><p>答：是的，虽然 LinkedList 底层结构是双向链表，但对于上述三个问题，结果和 ArrayList 是一致的。</p><h5 id="4-对比类问题"><a href="#4-对比类问题" class="headerlink" title="4.对比类问题"></a>4.对比类问题</h5><h6 id="4-1-ArrayList-和-LinkedList-有何不同？"><a href="#4-1-ArrayList-和-LinkedList-有何不同？" class="headerlink" title="4.1-ArrayList 和 LinkedList 有何不同？"></a>4.1-ArrayList 和 LinkedList 有何不同？</h6><p>答：可以先从底层数据结构开始说起，然后以某一个方法为突破口深入，比如：最大的不同是两者底层的数据结构不同，ArrayList 底层是数组，LinkedList 底层是双向链表，两者的数据结构不同也导致了操作的 API 实现有所差异，拿新增实现来说，ArrayList 会先计算并决定是否扩容，然后把新增的数据直接赋值到数组上，而 LinkedList 仅仅只需要改变插入节点和其前后节点的指向位置关系即可。</p><h6 id="4-2-ArrayList-和-LinkedList-应用场景有何不同"><a href="#4-2-ArrayList-和-LinkedList-应用场景有何不同" class="headerlink" title="4.2-ArrayList 和 LinkedList 应用场景有何不同"></a>4.2-ArrayList 和 LinkedList 应用场景有何不同</h6><p>答：ArrayList 更适合于快速的查找匹配，不适合频繁新增删除，像工作中经常会对元素进行匹配查询的场景比较合适，LinkedList 更适合于经常新增和删除，对查询反而很少的场景。</p><h6 id="4-3-ArrayList-和-LinkedList-两者有没有最大容量"><a href="#4-3-ArrayList-和-LinkedList-两者有没有最大容量" class="headerlink" title="4.3-ArrayList 和 LinkedList 两者有没有最大容量"></a>4.3-ArrayList 和 LinkedList 两者有没有最大容量</h6><p>答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p><h6 id="4-4-ArrayList-和-LinkedList-是如何对-null-值进行处理的"><a href="#4-4-ArrayList-和-LinkedList-是如何对-null-值进行处理的" class="headerlink" title="4.4-ArrayList 和 LinkedList 是如何对 null 值进行处理的"></a>4.4-ArrayList 和 LinkedList 是如何对 null 值进行处理的</h6><p>答：ArrayList 允许 null 值新增，也允许 null 值删除。删除 null 值时，是从头开始，找到第一值是 null 的元素删除；LinkedList 新增删除时对 null 值没有特殊校验，是允许新增和删除的。</p><h6 id="4-5-ArrayList-和-LinedList-是线程安全的么，为什么？"><a href="#4-5-ArrayList-和-LinedList-是线程安全的么，为什么？" class="headerlink" title="4.5-ArrayList 和 LinedList 是线程安全的么，为什么？"></a>4.5-ArrayList 和 LinedList 是线程安全的么，为什么？</h6><p>答：当两者作为非共享变量时，比如说仅仅是在方法里面的局部变量时，是没有线程安全问题的，只有当两者是共享变量时，才会有线程安全问题。主要的问题点在于多线程环境下，所有线程任何时刻都可对数组和链表进行操作，这会导致值被覆盖，甚至混乱的情况。</p><p>如果有线程安全问题，在迭代的过程中，会频繁报 ConcurrentModificationException 的错误，意思是在我当前循环的过程中，数组或链表的结构被其它线程修改了。</p><h6 id="4-6-如何解决线程安全问题？"><a href="#4-6-如何解决线程安全问题？" class="headerlink" title="4.6-如何解决线程安全问题？"></a>4.6-如何解决线程安全问题？</h6><p>Java 源码中推荐使用 Collections#synchronizedList 进行解决，Collections#synchronizedList 的返回值是 List 的每个方法都加了 synchronized 锁，保证了在同一时刻，数组和链表只会被一个线程所修改，或者采用 CopyOnWriteArrayList 并发 List 来解决，这个类我们后面会说。</p><h5 id="5-其他类型问题"><a href="#5-其他类型问题" class="headerlink" title="5.其他类型问题"></a>5.其他类型问题</h5><h6 id="5-1-你能描述下双向链表么？"><a href="#5-1-你能描述下双向链表么？" class="headerlink" title="5.1-你能描述下双向链表么？"></a>5.1-你能描述下双向链表么？</h6><p>答：如果和面试官面对面沟通的话，你可以去画一下，可以把 《LinkedList 源码解析》中的 LinkedList 的结构画出来，如果是电话面试，可以这么描述：双向链表中双向的意思是说前后节点之间互相有引用，链表的节点我们称为 Node。Node 有三个属性组成：其前一个节点，本身节点的值，其下一个节点，假设 A、B 节点相邻，A 节点的下一个节点就是 B，B 节点的上一个节点就是 A，两者互相引用，在链表的头部节点，我们称为头节点。头节点的前一个节点是 null，尾部称为尾节点，尾节点的后一个节点是 null，如果链表数据为空的话，头尾节点是同一个节点，本身是 null，指向前后节点的值也是 null。</p><h6 id="5-2-描述下双向链表的新增和删除"><a href="#5-2-描述下双向链表的新增和删除" class="headerlink" title="5.2-描述下双向链表的新增和删除"></a>5.2-描述下双向链表的新增和删除</h6><p>答：如果是面对面沟通，最好可以直接画图，如果是电话面试，可以这么描述：</p><p>新增：我们可以选择从链表头新增，也可以选择从链表尾新增，如果是从链表尾新增的话，直接把当前节点追加到尾节点之后，本身节点自动变为尾节点。</p><p>删除：把删除节点的后一个节点的 prev 指向其前一个节点，把删除节点的前一个节点的 next 指向其后一个节点，最后把删除的节点置为 null 即可。</p><h4 id="2-3-2-总结"><a href="#2-3-2-总结" class="headerlink" title="2.3.2-总结"></a>2.3.2-总结</h4><p>List 在工作中经常遇到，熟读源码不仅仅是为了应对面试，也为了在工作中使用起来得心应手，如果想更深入了解 List，可以看一遍 ArrayList 源码之后，自己重新实现一个 List。这样的话，就会对 List 底层的数据结构和操作细节理解更深。</p><h3 id="2-4-HashMap-源码解析"><a href="#2-4-HashMap-源码解析" class="headerlink" title="2.4-HashMap 源码解析"></a>2.4-HashMap 源码解析</h3><p>HashMap 源码很长，面试的问题也非常多，但这些面试问题，基本都是从源码中衍生出来的，所以我们只需要弄清楚其底层实现原理，回答这些问题就会游刃有余。</p><h4 id="2-4-1-整体架构"><a href="#2-4-1-整体架构" class="headerlink" title="2.4.1-整体架构"></a>2.4.1-整体架构</h4><p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时，链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表，整体的数据结构如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/HashMap.jpeg" alt="HashMap"></p><p>图中左边竖着的是 HashMap 的数组结构，数组的元素可能是单个 Node，也可能是个链表，也可能是个红黑树，比如数组下标索引为 2 的位置就是一个链表，下标索引为 9 的位置对应的就是红黑树，具体细节我们下文再说。</p><h5 id="1-类注释"><a href="#1-类注释" class="headerlink" title="1.类注释"></a>1.类注释</h5><p>从 HashMap 的类注释中，我们可以得到如下信息：</p><ul><li>允许 null 值，不同于 HashTable ，是线程不安全的；</li><li><code>load factor</code>（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor；</li><li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能；</li><li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过 Collections#synchronizedMap 来实现线程安全，Collections#synchronizedMap 的实现是在每个方法上加上了 synchronized 锁；</li><li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li></ul><h5 id="2-常见属性"><a href="#2-常见属性" class="headerlink" title="2.常见属性"></a>2.常见属性</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//初始容量为 16</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//最大容量</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//负载因子默认值</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//桶上的链表长度大于等于8时，链表转化成红黑树</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//桶上的红黑树大小小于等于6时，红黑树转化成链表</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//当数组容量大于 64 时，链表才会转化成红黑树</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//记录迭代过程中 HashMap 结构是否发生变化，如果有变化，迭代时会 fail-fast</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//HashMap 的实际大小，可能不准(因为当你拿到这个值的时候，可能又发生了变化)</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//存放数据的数组</span> <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 扩容的门槛，有两种情况</span> <span class="token comment" spellcheck="true">// 如果初始化时，给定数组大小的话，通过 tableSizeFor 方法计算，数组大小永远接近于 2 的幂次方，比如你给定初始化大小 19，实际上初始化大小为 32，为 2 的 5 次方。</span> <span class="token comment" spellcheck="true">// 如果是通过 resize 方法进行扩容，大小 = 数组容量 * 0.75</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//链表的节点</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//红黑树的节点</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span></code></pre><h4 id="2-4-2-新增"><a href="#2-4-2-新增" class="headerlink" title="2.4.2-新增"></a>2.4.2-新增</h4><p>新增 key，value 大概的步骤如下：</p><ol><li>空数组有无初始化，没有的话初始化；</li><li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li><li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li><li>如果是链表，递归循环，把新元素追加到队尾；</li><li>如果是红黑树，调用红黑树新增的方法；</li><li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li><li>判断是否需要扩容，需要扩容进行扩容，结束。</li></ol><p>我们来画一张示意图来描述下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/HashMap-%E6%96%B0%E5%A2%9E%E8%BF%87%E7%A8%8B.jpeg" alt="HashMap-新增过程"></p><p>代码细节如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 入参 hash：通过 hash 算法计算出来的值。</span><span class="token comment" spellcheck="true">// 入参 onlyIfAbsent：false 表示即使 key 已经存在了，仍然会用新值覆盖原来的值，默认为 false</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// n 表示数组的长度，i 为数组索引下标，p 为 i 下标位置的 Node 值</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果数组为空，使用 resize 方法初始化</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果当前索引位置是空的，直接生成新的节点在当前索引位置上</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果当前索引位置有值的处理方法，即我们常说的如何解决 hash 冲突</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// e 当前节点的临时变量</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果 key 的 hash 和值都相等，直接把当前下标位置的 Node 值赋值给临时变量</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果是红黑树，使用红黑树的方式新增</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 是个链表，把新节点放到链表的尾端</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 自旋</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// e = p.next 表示从头开始，遍历链表</span>                <span class="token comment" spellcheck="true">// p.next == null 表明 p 是链表的尾节点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 把新节点放到链表的尾部 </span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 当链表的长度大于等于 8 时，链表转红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 链表遍历过程中，发现有元素和新增的元素相等，结束循环</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//更改循环的当前元素，使 p 在遍历过程中，一直往后移动。</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 说明新节点的新增位置已经找到了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 当 onlyIfAbsent 为 false 时，才会覆盖值 </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回老值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 记录 HashMap 的数据结构发生了变化</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果 HashMap 的实际大小大于扩容的门槛，开始扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>新增的流程上面应该已经表示很清楚了，接下来我们来看看链表和红黑树新增的细节：</p><h5 id="1-链表的新增"><a href="#1-链表的新增" class="headerlink" title="1.链表的新增"></a>1.链表的新增</h5><p>链表的新增比较简单，就是把当前节点追加到链表的尾部，和 LinkedList 的追加实现一样的。</p><p>当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组大小小于 64 时，只会触发扩容，不会转化成红黑树，转化成红黑树的过程也比较简单，具体转化的过程源码可以去 github：<a href="https://github.com/luanqiu/java8" target="_blank" rel="noopener">https://github.com/luanqiu/java8</a> 上面去查看。</p><p>可能面试的时候，有人问你为什么是 8，这个答案在源码中注释有说，中文翻译过来大概的意思是：</p><p>链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候，使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。</p><p>在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，链表各个长度的命中概率为：</p><pre class=" language-java"><code class="language-java"><span class="token operator">*</span> <span class="token number">0</span><span class="token operator">:</span>    <span class="token number">0.60653066</span><span class="token operator">*</span> <span class="token number">1</span><span class="token operator">:</span>    <span class="token number">0.30326533</span><span class="token operator">*</span> <span class="token number">2</span><span class="token operator">:</span>    <span class="token number">0.07581633</span><span class="token operator">*</span> <span class="token number">3</span><span class="token operator">:</span>    <span class="token number">0.01263606</span><span class="token operator">*</span> <span class="token number">4</span><span class="token operator">:</span>    <span class="token number">0.00157952</span><span class="token operator">*</span> <span class="token number">5</span><span class="token operator">:</span>    <span class="token number">0.00015795</span><span class="token operator">*</span> <span class="token number">6</span><span class="token operator">:</span>    <span class="token number">0.00001316</span><span class="token operator">*</span> <span class="token number">7</span><span class="token operator">:</span>    <span class="token number">0.00000094</span><span class="token operator">*</span> <span class="token number">8</span><span class="token operator">:</span>    <span class="token number">0.00000006</span></code></pre><p>意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写代码，使用 HashMap 时，几乎不会碰到链表转化成红黑树的情况，毕竟概念只有千万分之一。</p><h5 id="2-红黑树新增节点过程"><a href="#2-红黑树新增节点过程" class="headerlink" title="2.红黑树新增节点过程"></a>2.红黑树新增节点过程</h5><ol><li><p>首先判断新增的节点在红黑树上是不是已经存在，判断手段有如下两种：</p><p>1.1. 如果节点没有实现 Comparable 接口，使用 equals 进行判断；</p><p>1.2. 如果节点自己实现了 Comparable 接口，使用 compareTo 进行判断。</p></li><li><p>新增的节点如果已经在红黑树上，直接返回；不在的话，判断新增节点是在当前节点的左边还是右边，左边值小，右边值大；</p></li><li><p>自旋递归 1 和 2 步，直到当前节点的左边或者右边的节点为空时，停止自旋，当前节点即为我们新增节点的父节点；</p></li><li><p>把新增节点放到当前节点的左边或右边为空的地方，并于当前节点建立父子节点关系；</p></li><li><p>进行着色和旋转，结束。</p></li></ol><p>具体源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//入参 h：key 的hash值</span><span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">putTreeVal</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> map<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span>                               <span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> kc <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">boolean</span> searched <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//找到根节点</span>    TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> root <span class="token operator">=</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//自旋</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> dir<span class="token punctuation">,</span> ph<span class="token punctuation">;</span> K pk<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p hash 值大于 h，说明 p 在 h 的右边</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">></span> h<span class="token punctuation">)</span>            dir <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// p hash 值小于 h，说明 p 在 h 的左边</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ph <span class="token operator">&lt;</span> h<span class="token punctuation">)</span>            dir <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//要放进去key在当前树中已经存在了(equals来判断)</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> k <span class="token operator">||</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> k<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>pk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//自己实现的Comparable的话，不能用hashcode比较了，需要用compareTo</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>kc <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>                  <span class="token comment" spellcheck="true">//得到key的Class类型，如果key没有实现Comparable就是null</span>                  <span class="token punctuation">(</span>kc <span class="token operator">=</span> <span class="token function">comparableClassFor</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">||</span>                  <span class="token comment" spellcheck="true">//当前节点pk和入参k不等</span>                 <span class="token punctuation">(</span>dir <span class="token operator">=</span> <span class="token function">compareComparables</span><span class="token punctuation">(</span>kc<span class="token punctuation">,</span> k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>searched<span class="token punctuation">)</span> <span class="token punctuation">{</span>                TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> q<span class="token punctuation">,</span> ch<span class="token punctuation">;</span>                searched <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>                     <span class="token punctuation">(</span>q <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">||</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>                     <span class="token punctuation">(</span>q <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> q<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            dir <span class="token operator">=</span> <span class="token function">tieBreakOrder</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> xp <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找到和当前hashcode值相近的节点(当前节点的左右子节点其中一个为空即可)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>left <span class="token operator">:</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> xpn <span class="token operator">=</span> xp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//生成新的节点</span>            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> x <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">newTreeNode</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">,</span> xpn<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//把新节点放在当前子节点为空的位置上</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                xp<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token keyword">else</span>                xp<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//当前节点和新节点建立父子，前后关系</span>            xp<span class="token punctuation">.</span>next <span class="token operator">=</span> x<span class="token punctuation">;</span>            x<span class="token punctuation">.</span>parent <span class="token operator">=</span> x<span class="token punctuation">.</span>prev <span class="token operator">=</span> xp<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>xpn <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>xpn<span class="token punctuation">)</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> x<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//balanceInsertion 对红黑树进行着色或旋转，以达到更多的查找效率，着色或旋转的几种场景如下</span>            <span class="token comment" spellcheck="true">//着色：新节点总是为红色；如果新节点的父亲是黑色，则不需要重新着色；如果父亲是红色，那么必须通过重新着色或者旋转的方法，再次达到红黑树的5个约束条件</span>            <span class="token comment" spellcheck="true">//旋转： 父亲是红色，叔叔是黑色时，进行旋转</span>            <span class="token comment" spellcheck="true">//如果当前节点是父亲的右节点，则进行左旋</span>            <span class="token comment" spellcheck="true">//如果当前节点是父亲的左节点，则进行右旋</span>            <span class="token comment" spellcheck="true">//moveRootToFront 方法是把算出来的root放到根节点上</span>            <span class="token function">moveRootToFront</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token function">balanceInsertion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>红黑树的新增，要求大家对红黑树的数据结构有一定的了解。面试的时候，一般只会问到新增节点到红黑树上大概是什么样的一个过程，着色和旋转的细节不会问，因为很难说清楚，但我们要清楚着色指的是给红黑树的节点着上红色或黑色，旋转是为了让红黑树更加平衡，提高查询的效率，总的来说都是为了满足红黑树的 5 个原则：</p><ol><li>节点是红色或黑色</li><li>根是黑色</li><li>所有叶子都是黑色</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li><li>从每个叶子到根的所有路径上不能有两个连续的红色节点</li></ol><h4 id="2-4-3-查找"><a href="#2-4-3-查找" class="headerlink" title="2.4.3-查找"></a>2.4.3-查找</h4><p>HashMap 的查找主要分为以下三步：</p><ul><li>根据 hash 算法定位数组的索引位置，equals 判断当前节点是否是我们需要寻找的 key，是的话直接返回，不是的话往下。</li><li>判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。</li><li>分别走链表和红黑树不同类型的查找方法。</li></ul><p>链表查找的关键代码是：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 采用自旋方式从链表中查找 key，e 初始为为链表的头节点</span><span class="token keyword">do</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果当前节点 hash 等于 key 的 hash，并且 equals 相等，当前节点就是我们要找的节点</span>    <span class="token comment" spellcheck="true">// 当 hash 冲突时，同一个 hash 值上是一个链表的时候，我们是通过 equals 方法来比较 key 是否相等的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 否则，把当前节点的下一个节点拿出来继续寻找</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>红黑树查找的代码很多，我们大概说下思路，实际步骤比较复杂，可以去 github 上面去查看源码：</p><ol><li>从根节点递归查找；</li><li>根据 hashcode，比较查找节点，左边节点，右边节点之间的大小，根本红黑树左小右大的特性进行判断；</li><li>判断查找节点在第 2 步有无定位节点位置，有的话返回，没有的话重复 2，3 两步；</li><li>一直自旋到定位到节点位置为止。</li></ol><p>如果红黑树比较平衡的话，每次查找的次数就是树的深度。</p><h4 id="2-4-4-总结"><a href="#2-4-4-总结" class="headerlink" title="2.4.4-总结"></a>2.4.4-总结</h4><p>HashMap 的内容虽然较多，但大多数 api 都只是对数组 + 链表 + 红黑树这种数据结构进行封装而已，本小节我们从新增和查找两个角度进行了源码的深入分析，分析了是如何对数组、链表和红黑树进行操作的。想了解更多，可以前往 github 上查看更多源码。</p><h3 id="2-5-TreeMap-和-LinkedHashMap-核心源码解析"><a href="#2-5-TreeMap-和-LinkedHashMap-核心源码解析" class="headerlink" title="2.5-TreeMap 和 LinkedHashMap 核心源码解析"></a>2.5-TreeMap 和 LinkedHashMap 核心源码解析</h3><p>在熟悉 HashMap 之后，本小节我们来看下 TreeMap 和 LinkedHashMap，看看 TreeMap 是如何根据 key 进行排序的，LinkedHashMap 是如何用两种策略进行访问的。</p><h4 id="2-5-1-知识储备"><a href="#2-5-1-知识储备" class="headerlink" title="2.5.1-知识储备"></a>2.5.1-知识储备</h4><p>在了解 TreeMap 之前，我们来看下日常工作中排序的两种方式，作为我们学习的基础储备。</p><p>两种方式的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeMapDemo</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Data</span>  <span class="token comment" spellcheck="true">// DTO 为我们排序的对象</span>  <span class="token keyword">class</span> <span class="token class-name">DTO</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>DTO<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DTO</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>DTO o<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//默认从小到大排序</span>      <span class="token keyword">return</span> id <span class="token operator">-</span> o<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTwoComparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 第一种排序，从小到大排序，实现 Comparable 的 compareTo 方法进行排序</span>    List<span class="token operator">&lt;</span>DTO<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DTO</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第二种排序，从大到小排序，利用外部排序器 Comparator 进行排序</span>    Comparator comparator <span class="token operator">=</span> <span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span>DTO<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> o2<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o1<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>DTO<span class="token operator">></span> list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      list2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DTO</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>第一种排序输出的结果从小到大，结果是：<code>[{“id”:1},{“id”:2},{“id”:3},{“id”:4},{“id”:5}]</code>；</p><p>第二种输出的结果恰好相反，结果是：<code>[{“id”:5},{“id”:4},{“id”:3},{“id”:2},{“id”:1}]</code>。</p><p>以上两种就是分别通过 Comparable 和 Comparator 两者进行排序的方式，而 TreeMap 利用的也是此原理，从而实现了对 key 的排序，我们一起来看下。</p><h4 id="2-5-2-TreeMap-整体架构"><a href="#2-5-2-TreeMap-整体架构" class="headerlink" title="2.5.2-TreeMap 整体架构"></a>2.5.2-TreeMap 整体架构</h4><p>TreeMap 底层的数据结构就是红黑树，和 HashMap 的红黑树结构一样。</p><p>不同的是，TreeMap 利用了红黑树左节点小，右节点大的性质，根据 key 进行排序，使每个元素能够插入到红黑树大小适当的位置，维护了 key 的大小关系，适用于 key 需要排序的场景。</p><p>因为底层使用的是平衡红黑树的结构，所以 containsKey、get、put、remove 等方法的时间复杂度都是 log(n)。</p><h5 id="1-属性"><a href="#1-属性" class="headerlink" title="1.属性"></a>1.属性</h5><p>TreeMap 常见的属性有：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//比较器，如果外部有传进来 Comparator 比较器，首先用外部的</span><span class="token comment" spellcheck="true">//如果外部比较器为空，则使用 key 自己实现的 Comparable#compareTo 方法</span><span class="token comment" spellcheck="true">//比较手段和上面日常工作中的比较 demo 是一致的</span><span class="token keyword">private</span> <span class="token keyword">final</span> Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span> comparator<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红黑树的根节点</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> root<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红黑树的已有元素大小</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//树结构变化的版本号，用于迭代过程中的快速失败场景</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红黑树的节点</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h5 id="2-新增节点"><a href="#2-新增节点" class="headerlink" title="2.新增节点"></a>2.新增节点</h5><p>我们来看下 TreeMap 新增节点的步骤：</p><ol><li><p>判断红黑树的节点是否为空，为空的话，新增的节点直接作为根节点，代码如下：</p><pre class=" language-java"><code class="language-java">Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> t <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//红黑树根节点为空，直接新建</span><span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// compare 方法限制了 key 不能为 null</span>    <span class="token function">compare</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// type (and possibly null) check</span>    <span class="token comment" spellcheck="true">// 成为根节点</span>    root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>根据红黑树左小右大的特性，进行判断，找到应该新增节点的父节点，代码如下：</p><pre class=" language-java"><code class="language-java">Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span> cpr <span class="token operator">=</span> comparator<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cpr <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//自旋找到 key 应该新增的位置，就是应该挂载那个节点的头上</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//一次循环结束时，parent 就是上次比过的对象</span>        parent <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过 compare 来比较 key 的大小</span>        cmp <span class="token operator">=</span> cpr<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> t<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//key 小于 t，把 t 左边的值赋予 t，因为红黑树左边的值比较小，循环再比</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            t <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//key 大于 t，把 t 右边的值赋予 t，因为红黑树右边的值比较大，循环再比</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            t <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果相等的话，直接覆盖原值</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// t 为空，说明已经到叶子节点了</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>在父节点的左边或右边插入新增节点，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//cmp 代表最后一次对比的大小，小于 0 ，代表 e 在上一节点的左边</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>    parent<span class="token punctuation">.</span>left <span class="token operator">=</span> e<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//cmp 代表最后一次对比的大小，大于 0 ，代表 e 在上一节点的右边，相等的情况第二步已经处理了。</span><span class="token keyword">else</span>    parent<span class="token punctuation">.</span>right <span class="token operator">=</span> e<span class="token punctuation">;</span></code></pre></li><li><p>着色旋转，达到平衡，结束。</p></li></ol><p>从源码中，我们可以看到：</p><ol><li>新增节点时，就是利用了红黑树左小右大的特性，从根节点不断往下查找，直到找到节点是 null 为止，节点为 null 说明到达了叶子结点；</li><li>查找过程中，发现 key 值已经存在，直接覆盖；</li><li>TreeMap 是禁止 key 是 null 值的。</li></ol><p>类似的，TreeMap 查找也是类似的原理，有兴趣的同学可以去 github 上面去查看源码。</p><h5 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h5><p>TreeMap 相对来说比较简单，红黑树和 HashMap 比较类似，比较关键的是通过 compare 来比较 key 的大小，然后利用红黑树左小右大的特性，为每个 key 找到自己的位置，从而维护了 key 的大小排序顺序。</p><h4 id="2-5-3-LinkedHashMap-整体架构"><a href="#2-5-3-LinkedHashMap-整体架构" class="headerlink" title="2.5.3-LinkedHashMap 整体架构"></a>2.5.3-LinkedHashMap 整体架构</h4><p>HashMap 是无序的，TreeMap 可以按照 key 进行排序，那有木有 Map 是可以维护插入的顺序的呢？接下来我们一起来看下 LinkedHashMap。</p><p>LinkedHashMap 本身是继承 HashMap 的，所以它拥有 HashMap 的所有特性，再此基础上，还提供了两大特性：</p><ul><li>按照插入顺序进行访问；</li><li>实现了访问最少最先删除功能，其目的是把很久都没有访问的 key 自动删除。</li></ul><p>接着我们来看下上述两大特性。</p><h5 id="1-按照插入顺序访问"><a href="#1-按照插入顺序访问" class="headerlink" title="1.按照插入顺序访问"></a>1.按照插入顺序访问</h5><h6 id="1-1-LinkedHashMap-链表结构"><a href="#1-1-LinkedHashMap-链表结构" class="headerlink" title="1.1-LinkedHashMap 链表结构"></a>1.1-LinkedHashMap 链表结构</h6><p>我们看下 LinkedHashMap 新增了哪些属性，以达到了链表结构的：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 链表头</span><span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 链表尾</span><span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 继承 Node，为数组的每个元素增加了 before 和 after 属性</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>    <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 控制两种访问模式的字段，默认 false</span><span class="token comment" spellcheck="true">// true 按照访问顺序，会把经常访问的 key 放到队尾</span><span class="token comment" spellcheck="true">// false 按照插入顺序提供访问</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span></code></pre><p>从上述 Map 新增的属性可以看到，LinkedHashMap 的数据结构很像是把 LinkedList 的每个元素换成了 HashMap 的 Node，像是两者的结合体，也正是因为增加了这些结构，从而能把 Map 的元素都串联起来，形成一个链表，而链表就可以保证顺序了，就可以维护元素插入进来的顺序。</p><h6 id="1-2-如何按照顺序新增"><a href="#1-2-如何按照顺序新增" class="headerlink" title="1.2-如何按照顺序新增"></a>1.2-如何按照顺序新增</h6><p>LinkedHashMap 初始化时，默认 accessOrder 为 false，就是会按照插入顺序提供访问，插入方法使用的是父类 HashMap 的 put 方法，不过覆写了 put 方法执行中调用的 <code>newNode/newTreeNode 和 afterNodeAccess 方法</code>。</p><p>newNode/newTreeNode 方法，控制新增节点追加到链表的尾部，这样每次新节点都追加到尾部，即可保证插入顺序了，我们以 newNode 源码为例：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 新增节点，并追加到链表的尾部</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 新增节点</span>    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 追加到链表的尾部</span>    <span class="token function">linkNodeLast</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// link at the end of list</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkNodeLast</span><span class="token punctuation">(</span>LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> last <span class="token operator">=</span> tail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新增节点等于位节点</span>    tail <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// last 为空，说明链表为空，首尾节点相等</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> null<span class="token punctuation">)</span>        head <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 链表有数据，直接建立新增节点和上个尾节点之间的前后关系即可</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>        last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>LinkedHashMap 通过新增头节点、尾节点，给每个节点增加 before、after 属性，每次新增时，都把节点追加到尾节点等手段，在新增的时候，就已经维护了按照插入顺序的链表结构了。</p><h6 id="1-3-按照顺序访问"><a href="#1-3-按照顺序访问" class="headerlink" title="1.3-按照顺序访问"></a>1.3-按照顺序访问</h6><p>LinkedHashMap 只提供了单向访问，即按照插入的顺序从头到尾进行访问，不能像 LinkedList 那样可以双向访问。</p><p>我们主要通过迭代器进行访问，迭代器初始化的时候，默认从头节点开始访问，在迭代的过程中，不断访问当前节点的 after 节点即可。</p><p>Map 对 key、value 和 entity（节点） 都提供出了迭代的方法，假设我们需要迭代 entity，就可使用 <code>LinkedHashMap.entrySet().iterator()</code> 这种写法直接返回 LinkedHashIterator ，LinkedHashIterator 是迭代器，我们调用迭代器的 nextNode 方法就可以得到下一个节点，迭代器的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 初始化时，默认从头节点开始访问</span><span class="token function">LinkedHashIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 头节点作为第一个访问的节点</span>    next <span class="token operator">=</span> head<span class="token punctuation">;</span>    expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>    current <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 校验</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    current <span class="token operator">=</span> e<span class="token punctuation">;</span>    next <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过链表的 after 结构，找到下一个迭代的节点</span>    <span class="token keyword">return</span> e<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在新增节点时，我们就已经维护了元素之间的插入顺序了，所以迭代访问时非常简单，只需要不断的访问当前节点的下一个节点即可。</p><h5 id="2-访问最少删除策略"><a href="#2-访问最少删除策略" class="headerlink" title="2.访问最少删除策略"></a>2.访问最少删除策略</h5><h6 id="2-1-Demo"><a href="#2-1-Demo" class="headerlink" title="2.1-Demo"></a>2.1-Demo</h6><p>这种策略也叫做 LRU（Least recently used,最近最少使用），大概的意思就是经常访问的元素会被追加到队尾，这样不经常访问的数据自然就靠近队头，然后我们可以通过设置删除策略，比如当 Map 元素个数大于多少时，把头节点删除，我们写个 demo 方便大家理解。demo 如下，完整代码可到 github 上查看：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAccessOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 新建 LinkedHashMap</span>  LinkedHashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0.75f</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">{</span>      <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token comment" spellcheck="true">// 覆写了删除策略的方法，我们设定当节点个数大于 3 时，就开始删除头节点</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"初始化：{}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Assert<span class="token punctuation">.</span><span class="token function">assertNotNull</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"map.get(9)：{}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Assert<span class="token punctuation">.</span><span class="token function">assertNotNull</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"map.get(20)：{}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>打印出来的结果如下：</p><pre class=" language-java"><code class="language-java">初始化：<span class="token punctuation">{</span><span class="token number">9</span><span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>：<span class="token punctuation">{</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">}</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>：<span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">}</span></code></pre><p>可以看到，map 初始化的时候，我们放进去四个元素，但结果只有三个元素，10 不见了，这个主要是因为我们覆写了 removeEldestEntry 方法，我们实现了如果 map 中元素个数大于 3 时，我们就把队头的元素删除，当 put(1, 1) 执行的时候，正好把队头的 10 删除，这个体现了达到我们设定的删除策略时，会自动的删除头节点。</p><p>当我们调用 map.get(9) 方法时，元素 9 移动到队尾，调用 map.get(20) 方法时， 元素 20 被移动到队尾，这个体现了经常被访问的节点会被移动到队尾。</p><p>这个例子就很好的说明了访问最少删除策略，接下来我们看下原理。</p><h6 id="2-2-元素被转移到队尾"><a href="#2-2-元素被转移到队尾" class="headerlink" title="2.2-元素被转移到队尾"></a>2.2-元素被转移到队尾</h6><p>我们先来看下为什么 get 时，元素会被移动到队尾：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 调用 HashMap  get 方法</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果设置了 LRU 策略</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 这个方法把当前 key 移动到队尾</span>        <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从上述源码中，可以看到，通过 afterNodeAccess 方法把当前访问节点移动到了队尾，其实不仅仅是 get 方法，执行 <code>getOrDefault、compute、computeIfAbsent、computeIfPresent、merge 方法</code>时，也会这么做，通过不断的把经常访问的节点移动到队尾，那么靠近队头的节点，自然就是很少被访问的元素了。</p><h6 id="2-3-删除策略"><a href="#2-3-删除策略" class="headerlink" title="2.3-删除策略"></a>2.3-删除策略</h6><p>上述 demo 我们在执行 put 方法时，发现队头元素被删除了，LinkedHashMap 本身是没有 put 方法实现的，调用的是 HashMap 的 put 方法，但 LinkedHashMap 实现了 put 方法中的调用 afterNodeInsertion 方法，这个方式实现了删除，我们看下源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 删除很少被访问的元素，被 HashMap 的 put 方法所调用</span><span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 得到元素头节点</span>    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// removeEldestEntry 来控制删除策略，如果队列不为空，并且删除策略允许删除的情况下，删除头节点</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        K key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// removeNode 删除头节点</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="3-小结-1"><a href="#3-小结-1" class="headerlink" title="3.小结"></a>3.小结</h5><p>LinkedHashMap 提供了两个很有意思的功能：按照插入顺序访问和删除最少访问元素策略，简单地通过链表的结构就实现了，设计得非常巧妙。</p><h4 id="2-5-4-总结"><a href="#2-5-4-总结" class="headerlink" title="2.5.4-总结"></a>2.5.4-总结</h4><p>本小节主要说了 TreeMap 和 LinkedHashMap 的的数据结构，分析了两者的核心内容源码，我们发现两者充分利用了底层数据结构的特性，TreeMap 利用了红黑树左小右大的特性进行排序，LinkedHashMap 在 HashMap 的基础上简单地加了链表结构，就形成了节点的顺序，非常巧妙，很有意思，大家可以在看源码的过程中，可以多想想设计思路，说不定会有不一样的感悟。</p><h3 id="2-6-Map源码会问哪些面试题"><a href="#2-6-Map源码会问哪些面试题" class="headerlink" title="2.6-Map源码会问哪些面试题"></a>2.6-Map源码会问哪些面试题</h3><p>Map 在面试中，占据了很大一部分的面试题目，其中以 HashMap 为主，这些面试题目有的可以说得清楚，有的很难说清楚，如果是面对面面试的话，建议画一画。</p><h4 id="2-6-1-Map-整体数据结构类问题"><a href="#2-6-1-Map-整体数据结构类问题" class="headerlink" title="2.6.1-Map 整体数据结构类问题"></a>2.6.1-Map 整体数据结构类问题</h4><h5 id="1-说一说-HashMap-底层数据结构"><a href="#1-说一说-HashMap-底层数据结构" class="headerlink" title="1.说一说 HashMap 底层数据结构"></a>1.说一说 HashMap 底层数据结构</h5><p>答：HashMap 底层是数组 + 链表 + 红黑树的数据结构，数组的主要作用是方便快速查找，时间复杂度是 O(1)，默认大小是 16，数组的下标索引是通过 key 的 hashcode 计算出来的，数组元素叫做 Node，当多个 key 的 hashcode 一致，但 key 值不同时，单个 Node 就会转化成链表，链表的查询复杂度是 O(n)，当链表的长度大于等于 8 并且数组的大小超过 64 时，链表就会转化成红黑树，红黑树的查询复杂度是 O(log(n))，简单来说，最坏的查询次数相当于红黑树的最大深度。</p><h5 id="2-HashMap、TreeMap、LinkedHashMap-三者有啥相同点，有啥不同点？"><a href="#2-HashMap、TreeMap、LinkedHashMap-三者有啥相同点，有啥不同点？" class="headerlink" title="2.HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点？"></a>2.HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点？</h5><p>答：相同点：</p><ol><li>三者在特定的情况下，都会使用红黑树；</li><li>底层的 hash 算法相同；</li><li>在迭代的过程中，如果 Map 的数据结构被改动，都会报 ConcurrentModificationException 的错误。</li></ol><p>不同点：</p><ol><li>HashMap 数据结构以数组为主，查询非常快，TreeMap 数据结构以红黑树为主，利用了红黑树左小右大的特点，可以实现 key 的排序，LinkedHashMap 在 HashMap 的基础上增加了链表的结构，实现了插入顺序访问和最少访问删除两种策略;</li><li>由于三种 Map 底层数据结构的差别，导致了三者的使用场景的不同，TreeMap 适合需要根据 key 进行排序的场景，LinkedHashMap 适合按照插入顺序访问，或需要删除最少访问元素的场景，剩余场景我们使用 HashMap 即可，我们工作中大部分场景基本都在使用 HashMap；</li><li>由于三种 map 的底层数据结构的不同，导致上层包装的 api 略有差别。</li></ol><h5 id="3-说一下-Map-的-hash-算法"><a href="#3-说一下-Map-的-hash-算法" class="headerlink" title="3.说一下 Map 的 hash 算法"></a>3.说一下 Map 的 hash 算法</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> h<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>key 在数组中的位置公式：tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span></code></pre><p>如上代码是 HashMap 的hash 算法。</p><p>这其实是一个数学问题，源码中就是通过以上代码来计算 hash 的，首先计算出 key 的 hashcode，因为 key 是 Object，所以会根据 key 的不同类型进行 hashcode 的计算，接着计算 h ^ (h &gt;&gt;&gt; 16) ，这么做的好处是使大多数场景下，算出来的 hash 值比较分散。</p><p>一般来说，hash 值算出来之后，要计算当前 key 在数组中的索引下标位置时，可以采用取模的方式，就是索引下标位置 = hash 值 % 数组大小，这样做的好处，就是可以保证计算出来的索引下标值可以均匀的分布在数组的各个索引位置上，但取模操作对于处理器的计算是比较慢的，数学上有个公式，当 b 是 2 的幂次方时，a % b = a &amp;（b-1），所以此处索引位置的计算公式我们可以更换为： (n-1) &amp; hash。</p><p>此问题可以延伸出三个小问题：</p><p>1：为什么不用 key % 数组大小，而是需要用 key 的 hash 值 % 数组大小。</p><p>答：如果 key 是数字，直接用 key % 数组大小是完全没有问题的，但我们的 key 还有可能是字符串，是复杂对象，这时候用 字符串或复杂对象 % 数组大小是不行的，所以需要先计算出 key 的 hash 值。</p><p>2：计算 hash 值时，为什么需要右移 16 位？</p><p>答：hash 算法是 h ^ (h &gt;&gt;&gt; 16)，为了使计算出的 hash 值更分散，所以选择先将 h 无符号右移 16 位，然后再于 h 异或时，就能达到 h 的高 16 位和低 16 位都能参与计算，减少了碰撞的可能性。</p><p>3：为什么把取模操作换成了 &amp; 操作？</p><p>答：key.hashCode() 算出来的 hash 值还不是数组的索引下标，为了随机的计算出索引的下表位置，我们还会用 hash 值和数组大小进行取模，这样子计算出来的索引下标比较均匀分布。</p><p>取模操作处理器计算比较慢，处理器对 &amp; 操作就比较擅长，换成了 &amp; 操作，是有数学上证明的支撑，为了提高了处理器处理的速度。</p><p>4：为什么提倡数组大小是 2 的幂次方？</p><p>答：因为只有大小是 2 的幂次方时，才能使 hash 值 % n(数组大小) == (n-1) &amp; hash 公式成立。</p><h5 id="4-为解决-hash-冲突，大概有哪些办法。"><a href="#4-为解决-hash-冲突，大概有哪些办法。" class="headerlink" title="4.为解决 hash 冲突，大概有哪些办法。"></a>4.为解决 hash 冲突，大概有哪些办法。</h5><p>答：1：好的 hash 算法，细问的话复述一下上题的 hash 算法;</p><p>2：自动扩容，当数组大小快满的时候，采取自动扩容，可以减少 hash 冲突;</p><p>3：hash 冲突发生时，采用链表来解决;</p><p>4：hash 冲突严重时，链表会自动转化成红黑树，提高遍历速度。</p><p>网上列举的一些其它办法，如开放定址法，尽量不要说，因为这些方法资料很少，实战用过的人更少，如果你没有深入研究的话，面试官让你深入描述一下很难说清楚，反而留下不好的印象，说 HashMap 现有的措施就足够了。</p><h4 id="2-6-2-HashMap-源码细节类问题"><a href="#2-6-2-HashMap-源码细节类问题" class="headerlink" title="2.6.2-HashMap 源码细节类问题"></a>2.6.2-HashMap 源码细节类问题</h4><h5 id="1-HashMap-是如何扩容的？"><a href="#1-HashMap-是如何扩容的？" class="headerlink" title="1.HashMap 是如何扩容的？"></a>1.HashMap 是如何扩容的？</h5><p>答：扩容的时机：</p><ol><li>put 时，发现数组为空，进行初始化扩容，默认扩容大小为 16;</li><li>put 成功后，发现现有数组大小大于扩容的门阀值时，进行扩容，扩容为老数组大小的 2 倍;</li></ol><p>扩容的门阀是 threshold，每次扩容时 threshold 都会被重新计算，门阀值等于数组的大小 * 影响因子（0.75）。</p><p>新数组初始化之后，需要将老数组的值拷贝到新数组上，链表和红黑树都有自己拷贝的方法。</p><h5 id="2-hash-冲突时怎么办？"><a href="#2-hash-冲突时怎么办？" class="headerlink" title="2.hash 冲突时怎么办？"></a>2.hash 冲突时怎么办？</h5><p>答：hash 冲突指的是 key 值的 hashcode 计算相同，但 key 值不同的情况。</p><p>如果桶中元素原本只有一个或已经是链表了，新增元素直接追加到链表尾部；</p><p>如果桶中元素已经是链表，并且链表个数大于等于 8 时，此时有两种情况：</p><ol><li>如果此时数组大小小于 64，数组再次扩容，链表不会转化成红黑树;</li><li>如果数组大小大于 64 时，链表就会转化成红黑树。</li></ol><p>这里不仅仅判断链表个数大于等于 8，还判断了数组大小，数组容量小于 64 没有立即转化的原因，猜测主要是因为红黑树占用的空间比链表大很多，转化也比较耗时，所以数组容量小的情况下冲突严重，我们可以先尝试扩容，看看能否通过扩容来解决冲突的问题。</p><h5 id="3-为什么链表个数大于等于-8-时，链表要转化成红黑树了？"><a href="#3-为什么链表个数大于等于-8-时，链表要转化成红黑树了？" class="headerlink" title="3.为什么链表个数大于等于 8 时，链表要转化成红黑树了？"></a>3.为什么链表个数大于等于 8 时，链表要转化成红黑树了？</h5><p>答：当链表个数太多了，遍历可能比较耗时，转化成红黑树，可以使遍历的时间复杂度降低，但转化成红黑树，有空间和转化耗时的成本，我们通过泊松分布公式计算，正常情况下，链表个数出现 8 的概念不到千万分之一，所以说正常情况下，链表都不会转化成红黑树，这样设计的目的，是为了防止非正常情况下，比如 hash 算法出了问题时，导致链表个数轻易大于等于 8 时，仍然能够快速遍历。</p><p>延伸问题：红黑树什么时候转变成链表。</p><p>答：当节点的个数小于等于 6 时，红黑树会自动转化成链表，主要还是考虑红黑树的空间成本问题，当节点个数小于等于 6 时，遍历链表也很快，所以红黑树会重新变成链表。</p><h5 id="4-HashMap-在-put-时，如果数组中已经有了这个-key，我不想把-value-覆盖怎么办？取值时，如果得到的-value-是空时，想返回默认值怎么办？"><a href="#4-HashMap-在-put-时，如果数组中已经有了这个-key，我不想把-value-覆盖怎么办？取值时，如果得到的-value-是空时，想返回默认值怎么办？" class="headerlink" title="4.HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办？"></a>4.HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办？</h5><p>答：如果数组有了 key，但不想覆盖 value ，可以选择 putIfAbsent 方法，这个方法有个内置变量 onlyIfAbsent，内置是 true ，就不会覆盖，我们平时使用的 put 方法，内置 onlyIfAbsent 为 false，是允许覆盖的。</p><p>取值时，如果为空，想返回默认值，可以使用 getOrDefault 方法，方法第一参数为 key，第二个参数为你想返回的默认值，如 map.getOrDefault(“2”,“0”)，当 map 中没有 key 为 2 的值时，会默认返回 0，而不是空。</p><h5 id="5-通过以下代码进行删除，是否可行？"><a href="#5-通过以下代码进行删除，是否可行？" class="headerlink" title="5.通过以下代码进行删除，是否可行？"></a>5.通过以下代码进行删除，是否可行？</h5><pre class=" language-java"><code class="language-java">HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String <span class="token operator">></span> map <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>答：不行，会报错误 ConcurrentModificationException，原因如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/HashMap-%E5%88%A0%E9%99%A4%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0.jpeg" alt="HashMap-删除报错原因"></p><p>建议使用迭代器的方式进行删除，原理同 ArrayList 迭代器原理，我们在《List 源码会问那些面试题》中有说到。</p><h5 id="6-描述一下-HashMap-get、put-的过程"><a href="#6-描述一下-HashMap-get、put-的过程" class="headerlink" title="6.描述一下 HashMap get、put 的过程"></a>6.描述一下 HashMap get、put 的过程</h5><p>答：我们在源码解析中有说，可以详细描述下源码的实现路径，说不清楚的话，可以画一画。</p><h4 id="2-6-3-其它-Map-面试题"><a href="#2-6-3-其它-Map-面试题" class="headerlink" title="2.6.3-其它 Map 面试题"></a>2.6.3-其它 Map 面试题</h4><h5 id="1-DTO-作为-Map-的-key-时，有无需要注意的点？"><a href="#1-DTO-作为-Map-的-key-时，有无需要注意的点？" class="headerlink" title="1.DTO 作为 Map 的 key 时，有无需要注意的点？"></a>1.DTO 作为 Map 的 key 时，有无需要注意的点？</h5><p>答：DTO 就是一个数据载体，可以看做拥有很多属性的 Java 类，我们可以对这些属性进行 get、set 操作。</p><p>看是什么类型的 Map，如果是 HashMap 的话，一定需要覆写 equals 和 hashCode 方法，因为在 get 和 put 的时候，需要通过 equals 方法进行相等的判断；如果是 TreeMap 的话，DTO 需要实现 Comparable 接口，因为 TreeMap 会使用 Comparable 接口进行判断 key 的大小；如果是 LinkedHashMap 的话，和 HashMap 一样的。</p><h5 id="2-LinkedHashMap-中的-LRU-是什么意思，是如何实现的。"><a href="#2-LinkedHashMap-中的-LRU-是什么意思，是如何实现的。" class="headerlink" title="2.LinkedHashMap 中的 LRU 是什么意思，是如何实现的。"></a>2.LinkedHashMap 中的 LRU 是什么意思，是如何实现的。</h5><p>答：LRU ，英文全称：Least recently used，中文叫做最近最少访问，在 LinkedHashMap 中，也叫做最少访问删除策略，我们可以通过 removeEldestEntry 方法设定一定的策略，使最少被访问的元素，在适当的时机被删除，原理是在 put 方法执行的最后，LinkedHashMap 会去检查这种策略，如果满足策略，就删除头节点。</p><p>保证头节点就是最少访问的元素的原理是：LinkedHashMap 在 get 的时候，都会把当前访问的节点，移动到链表的尾部，慢慢的，就会使头部的节点都是最少被访问的元素。</p><h5 id="3-为什么推荐-TreeMap-的元素最好都实现-Comparable-接口？但-key-是-String-的时候，我们却没有额外的工作呢？"><a href="#3-为什么推荐-TreeMap-的元素最好都实现-Comparable-接口？但-key-是-String-的时候，我们却没有额外的工作呢？" class="headerlink" title="3.为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？"></a>3.为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？</h5><p>答：因为 TreeMap 的底层就是通过排序来比较两个 key 的大小的，所以推荐 key 实现 Comparable 接口，是为了往你希望的排序顺序上发展， 而 String 本身已经实现了 Comparable 接口，所以使用 String 时，我们不需要额外的工作，不仅仅是 String ，其他包装类型也都实现了 Comparable 接口，如 Long、Double、Short 等等。</p><h4 id="2-6-4-总结"><a href="#2-6-4-总结" class="headerlink" title="2.6.4-总结"></a>2.6.4-总结</h4><p>Map 的面试题主要是 HashMap 为主，会问很多源码方面的东西，TreeMap 和 LinkedHashMap 主要以功能和场景为主，作为加分项。<br>Map 的面试题型很多，但只要弄懂原理，题目再多变化，回答起来都会比较简单。</p><h3 id="2-7-HashSet、TreeSet-源码解析"><a href="#2-7-HashSet、TreeSet-源码解析" class="headerlink" title="2.7-HashSet、TreeSet 源码解析"></a>2.7-HashSet、TreeSet 源码解析</h3><p>HashSet、TreeSet 两个类是在 Map 的基础上组装起来的类，我们学习的侧重点，主要在于 Set 是如何利用 Map 现有的功能，来达成自己的目标的，也就是说如何基于现有的功能进行创新，然后再看看一些改变的小细节是否值得我们学习。</p><h4 id="2-7-1-HashSet"><a href="#2-7-1-HashSet" class="headerlink" title="2.7.1-HashSet"></a>2.7.1-HashSet</h4><h5 id="1-类注释-1"><a href="#1-类注释-1" class="headerlink" title="1.类注释"></a>1.类注释</h5><p>看源码先看类注释上，我们可以得到的信息有：</p><ol><li>底层实现基于 HashMap，所以迭代时不能保证按照插入顺序，或者其它顺序进行迭代；</li><li>add、remove、contanins、size 等方法的耗时性能，是不会随着数据量的增加而增加的，这个主要跟 HashMap 底层的数组数据结构有关，不管数据量多大，不考虑 hash 冲突的情况下，时间复杂度都是 O (1)；</li><li>线程不安全的，如果需要安全请自行加锁，或者使用 Collections.synchronizedSet；</li><li>迭代过程中，如果数据结构被改变，会快速失败的，会抛出 ConcurrentModificationException 异常。</li></ol><p>我们之前也看过 List、Map 的类注释，我们发现 2、3、4 点信息在类注释中都有提到，所以如果有人问 List、Map、 Set 三者的共同点，那么就可以说 2、3、4 三点。</p><h5 id="2-HashSet-是如何组合-HashMap-的"><a href="#2-HashSet-是如何组合-HashMap-的" class="headerlink" title="2.HashSet 是如何组合 HashMap 的"></a>2.HashSet 是如何组合 HashMap 的</h5><p>刚才是从类注释 1 中看到，HashSet 的实现是基于 HashMap 的，在 Java 中，要基于基础类进行创新实现，有两种办法：</p><ul><li>继承基础类，覆写基础类的方法，比如说继承 HashMap , 覆写其 add 的方法；</li><li>组合基础类，通过调用基础类的方法，来复用基础类的能力。</li></ul><p>HashSet 使用的就是组合 HashMap，其优点如下：</p><ol><li>继承表示父子类是同一个事物，而 Set 和 Map 本来就是想表达两种事物，所以继承不妥，而且 Java 语法限制，子类只能继承一个父类，后续难以扩展。</li><li>组合更加灵活，可以任意的组合现有的基础类，并且可以在基础类方法的基础上进行扩展、编排等，而且方法命名可以任意命名，无需和基础类的方法名称保持一致。</li></ol><p>我们在工作中，如果碰到类似问题，我们的原则也是尽量多用组合，少用继承。</p><p>组合就是把 HashMap 当作自己的一个局部变量，以下是 HashSet 的组合实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 把 HashMap 组合进来，key 是 Hashset 的 key，value 是下面的 PRESENT</span><span class="token keyword">private</span> <span class="token keyword">transient</span> HashMap<span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span> map<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// HashMap 中的 value</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>从这两行代码中，我们可以看出两点：</p><ol><li>我们在使用 HashSet 时，比如 add 方法，只有一个入参，但组合的 Map 的 add 方法却有 key，value 两个入参，相对应上 Map 的 key 就是我们 add 的入参，value 就是第二行代码中的 PRESENT，此处设计非常巧妙，用一个默认值 PRESENT 来代替 Map 的 Value；</li><li>如果 HashSet 是被共享的，当多个线程访问的时候，就会有线程安全问题，因为在后续的所有操作中，并没有加锁。</li></ol><p>HashSet 在以 HashMap 为基础进行实现的时候，首先选择组合的方式，接着使用默认值来代替了 Map 中的 Value 值，设计得非常巧妙，给使用者的体验很好，使用起来简单方便，我们在工作中也可以借鉴这种思想，可以把底层复杂实现包装一下，一些默认实现可以自己吃掉，使吐出去的接口尽量简单好用。</p><h6 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1-初始化"></a>2.1-初始化</h6><p>HashSet 的初始化比较简单，直接 new HashMap 即可，比较有意思的是，当有原始集合数据进行初始化的情况下，会对 HashMap 的初始容量进行计算，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对 HashMap 的容量进行了计算</span><span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token number">75f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述代码中：Math.max ((int) (c.size ()/.75f) + 1, 16)，就是对 HashMap 的容量进行了计算，翻译成中文就是 取括号中两个数的最大值（期望的值 / 0.75+1，默认值 16），从计算中，我们可以看出 HashSet 的实现者对 HashMap 的底层实现是非常清楚的，主要体现在两个方面：</p><ol><li>和 16 比较大小的意思是说，如果给定 HashMap 初始容量小于 16 ，就按照 HashMap 默认的 16 初始化好了，如果大于 16，就按照给定值初始化。</li><li>HashMap 扩容的伐值的计算公式是：Map 的容量 * 0.75f，一旦达到阀值就会扩容，此处用 (int) (c.size ()/.75f) + 1 来表示初始化的值，这样使我们期望的大小值正好比扩容的阀值还大 1，就不会扩容，符合 HashMap 扩容的公式。</li></ol><p>从简单的构造器中，我们就可以看出要很好的组合 api 接口，并没有那么简单，我们可能需要去了解一下被组合的 api 底层的实现，这样才能用好 api。</p><p>同时这种写法，也提供了一种思路给我们，如果有人问你，往 HashMap 拷贝大集合时，如何给 HashMap 初始化大小时，完全可以借鉴这种写法：取最大值（期望的值 / 0.75 + 1，默认值 16）。</p><p>至于 HashSet 的其他方法就比较简单了，就是对 Map 的 api 进行了一些包装，如下的 add 方法实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 直接使用 HashMap 的 put 方法，进行一些简单的逻辑判断</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从 add 方法中，我们就可以看到组合的好处，方法的入参、名称、返回值都可以自定义，如果是继承的话就不行了。</p><h6 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2-小结"></a>2.2-小结</h6><p>HashSet 具体实现值得我们借鉴的地方主要有如下地方，我们平时写代码的时候，完全可以参考参考：</p><ol><li>对组合还是继承的分析和把握；</li><li>对复杂逻辑进行一些包装，使吐出去的接口尽量简单好用；</li><li>组合其他 api 时，尽量多对组合的 api 多些了解，这样才能更好的使用 api；</li><li>HashMap 初始化大小值的模版公式：取括号内两者的最大值（期望的值 / 0.75+1，默认值 16）。</li></ol><h4 id="2-7-2-TreeSet"><a href="#2-7-2-TreeSet" class="headerlink" title="2.7.2-TreeSet"></a>2.7.2-TreeSet</h4><p>TreeSet 大致的结构和 HashSet 相似，底层组合的是 TreeMap，所以继承了 TreeMap key 能够排序的功能，迭代的时候，也可以按照 key 的排序顺序进行迭代，我们主要来看复用 TreeMap 时，复用的两种思路：</p><h5 id="1-复用-TreeMap-的思路一"><a href="#1-复用-TreeMap-的思路一" class="headerlink" title="1.复用 TreeMap 的思路一"></a>1.复用 TreeMap 的思路一</h5><p>场景一： TreeSet 的 add 方法，我们来看下其源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到，底层直接使用的是 HashMap 的 put 的能力，直接拿来用就好了。</p><h5 id="2-复用-TreeMap-的思路二"><a href="#2-复用-TreeMap-的思路二" class="headerlink" title="2.复用 TreeMap 的思路二"></a>2.复用 TreeMap 的思路二</h5><p>场景二：需要迭代 TreeSet 中的元素，那应该也是像 add 那样，直接使用 HashMap 已有的迭代能力，比如像下面这样：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 模仿思路一的方式实现</span><span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">descendingIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 直接使用 HashMap.keySet 的迭代能力</span>    <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这种是思路一的实现方式，TreeSet 组合 TreeMap，直接选择 TreeMap 的底层能力进行包装，但 TreeSet 实际执行的思路却完全相反，我们看源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// NavigableSet 接口，定义了迭代的一些规范，和一些取值的特殊方法</span><span class="token comment" spellcheck="true">// TreeSet 实现了该方法，也就是说 TreeSet 本身已经定义了迭代的规范</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">NavigableSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">SortedSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    E <span class="token function">lower</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// m.navigableKeySet() 是 TreeMap 写了一个子类实现了 NavigableSet</span><span class="token comment" spellcheck="true">// 接口，实现了 TreeSet 定义的迭代规范</span><span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">navigableKeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>TreeMap 中对 NavigableSet 接口的实现源码截图如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/TreeMap-NavigableSet.jpeg" alt="TreeMap-NavigableSet"></p><p>从截图中（截图是在 TreeMap 中），我们可以看出 TreeMap 实现了 TreeSet 定义的各种特殊方法。</p><p>我们可以看到，这种思路是 TreeSet 定义了接口的规范，TreeMap 负责去实现，实现思路和思路一是相反的。</p><p>我们总结下 TreeSet 组合 TreeMap 实现的两种思路：</p><ol><li>TreeSet 直接使用 TreeMap 的某些功能，自己包装成新的 api。</li><li>TreeSet 定义自己想要的 api，自己定义接口规范，让 TreeMap 去实现。</li></ol><p>方案 1 和 2 的调用关系，都是 TreeSet 调用 TreeMap，但功能的实现关系完全相反，第一种是功能的定义和实现都在 TreeMap，TreeSet 只是简单的调用而已，第二种 TreeSet 把接口定义出来后，让 TreeMap 去实现内部逻辑，TreeSet 负责接口定义，TreeMap 负责具体实现，这样子的话因为接口是 TreeSet 定义的，所以实现一定是 TreeSet 最想要的，TreeSet 甚至都不用包装，可以直接把返回值吐出去都行。</p><p>我们思考下这两种复用思路的原因：</p><ol><li>像 add 这些简单的方法，我们直接使用的是思路 1，主要是 add 这些方法实现比较简单，没有复杂逻辑，所以 TreeSet 自己实现起来比较简单；</li><li>思路 2 主要适用于复杂场景，比如说迭代场景，TreeSet 的场景复杂，比如要能从头开始迭代，比如要能取第一个值，比如要能取最后一个值，再加上 TreeMap 底层结构比较复杂，TreeSet 可能并不清楚 TreeMap 底层的复杂逻辑，这时候让 TreeSet 来实现如此复杂的场景逻辑，TreeSet 就搞不定了，不如接口让 TreeSet 来定义，让 TreeMap 去负责实现，TreeMap 对底层的复杂结构非常清楚，实现起来既准确又简单。</li></ol><h3 id="3-小结-2"><a href="#3-小结-2" class="headerlink" title="3.小结"></a>3.小结</h3><p>TreeSet 对 TreeMap 的两种不同复用思路，很重要，在工作中经常会遇到，特别是思路二，比如说 dubbo 的泛化调用，DDD 中的依赖倒置等等，原理都是 TreeSet 第二种的复用思想。</p><h4 id="2-7-3-面试题"><a href="#2-7-3-面试题" class="headerlink" title="2.7.3-面试题"></a>2.7.3-面试题</h4><p>HashSet 和 TreeSet 的面试概率比不上 List 和 Map，但只要有机会，并把本文的内容表达出来，绝对是加分项，因为现在 List 和 Map 面试题太多，面试官认为你能答的出来是应该的，但只要你有机会对 HashSet 和 TreeSet 说出本文见解，并且说自己是看源码时领悟到的，绝对肯定是加分项，这些就是你超过面试官预期的惊喜，以下是一些常用的题目：</p><h5 id="1-TreeSet-有用过么，平时都在什么场景下使用？"><a href="#1-TreeSet-有用过么，平时都在什么场景下使用？" class="headerlink" title="1.TreeSet 有用过么，平时都在什么场景下使用？"></a>1.TreeSet 有用过么，平时都在什么场景下使用？</h5><p>答：有木有用过如实回答就好了，我们一般都是在需要把元素进行排序的时候使用 TreeSet，使用时需要我们注意元素最好实现 Comparable 接口，这样方便底层的 TreeMap 根据 key 进行排序。</p><h5 id="2-追问，如果我想实现根据-key-的新增顺序进行遍历怎么办？"><a href="#2-追问，如果我想实现根据-key-的新增顺序进行遍历怎么办？" class="headerlink" title="2.追问，如果我想实现根据 key 的新增顺序进行遍历怎么办？"></a>2.追问，如果我想实现根据 key 的新增顺序进行遍历怎么办？</h5><p>答：要按照 key 的新增顺序进行遍历，首先想到的应该就是 LinkedHashMap，而 LinkedHashSet 正好是基于 LinkedHashMap 实现的，所以我们可以选择使用 LinkedHashSet。</p><h5 id="3-追问，如果我想对-key-进行去重，有什么好的办法么？"><a href="#3-追问，如果我想对-key-进行去重，有什么好的办法么？" class="headerlink" title="3.追问，如果我想对 key 进行去重，有什么好的办法么？"></a>3.追问，如果我想对 key 进行去重，有什么好的办法么？</h5><p>答：我们首先想到的是 TreeSet，TreeSet 底层使用的是 TreeMap，TreeMap 在 put 的时候，如果发现 key 是相同的，会把 value 值进行覆盖，所有不会产生重复的 key ，利用这一特性，使用 TreeSet 正好可以去重。</p><h5 id="4-说说-TreeSet-和-HashSet-两个-Set-的内部实现结构和原理？"><a href="#4-说说-TreeSet-和-HashSet-两个-Set-的内部实现结构和原理？" class="headerlink" title="4.说说 TreeSet 和 HashSet 两个 Set 的内部实现结构和原理？"></a>4.说说 TreeSet 和 HashSet 两个 Set 的内部实现结构和原理？</h5><p>答： HashSet 底层对 HashMap 的能力进行封装，比如说 add 方法，是直接使用 HashMap 的 put 方法，比较简单，但在初始化的时候，我看源码有一些感悟：说一下 HashSet 小结的四小点。</p><p>TreeSet 主要是对 TreeMap 底层能力进行封装复用，我发现了两种非常有意思的复用思路，重复 TreeSet 两种复用思路。</p><h4 id="2-7-4-总结"><a href="#2-7-4-总结" class="headerlink" title="2.7.4-总结"></a>2.7.4-总结</h4><p>本小节主要说了 Set 源码中两处亮点：</p><ol><li>HashSet 对组合的 HashMap 类扩容的门阀值的深入了解和设计，值得我们借鉴；</li><li>TreeSet 对 TreeMap 两种复用思路，值得我们学习，特别是第二种复用思路。</li></ol><p>HashSet 和 TreeSet 不会是面试的重点，但通过以上两点，可以让我们给面试官一种精益求精的感觉，成为加分项。</p><h3 id="2-8-彰显细节：看集合源码对我们实际工作的帮助和应用"><a href="#2-8-彰显细节：看集合源码对我们实际工作的帮助和应用" class="headerlink" title="2.8-彰显细节：看集合源码对我们实际工作的帮助和应用"></a>2.8-彰显细节：看集合源码对我们实际工作的帮助和应用</h3><p>本节中，我们先跳出源码的视角，来看看集合类的类图，看看在设计层面上，是否有可疑借鉴之处，接着通过源码来找找工作中的集合坑，提前扫雷。</p><h4 id="2-8-1-集合类图"><a href="#2-8-1-集合类图" class="headerlink" title="2.8.1-集合类图"></a>2.8.1-集合类图</h4><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%BE.jpeg" alt="集合类图"></p><p>上图是目前我们已学的集合类图，大概可以看出以下几点：</p><ol><li>每个接口做的事情非常明确，比如 Serializable，只负责序列化，Cloneable 只负责拷贝，Map 只负责定义 Map 的接口，整个图看起来虽然接口众多，但职责都很清晰；</li><li>复杂功能通过接口的继承来实现，比如 ArrayList 通过实现了 Serializable、Cloneable、RandomAccess、AbstractList、List 等接口，从而拥有了序列化、拷贝、对数组各种操作定义等各种功能；</li><li>上述类图只能看见继承的关系，组合的关系还看不出来，比如说 Set 组合封装 Map 的底层能力等。</li></ol><p>上述设计的最大好处是，每个接口能力职责单一，众多的接口变成了接口能力的积累，假设我们想再实现一个数据结构类，我们就可以从这些已有的能力接口中，挑选出能满足需求的能力接口，进行一些简单的组装，从而加快开发速度。</p><p>这种思想在平时的工作中也经常被使用，我们会把一些通用的代码块抽象出来，沉淀成代码块池，碰到不同的场景的时候，我们就从代码块池中，把我们需要的代码块提取出来，进行简单的编排和组装，从而实现我们需要的场景功能。</p><h4 id="2-8-2-集合工作中一些注意事项"><a href="#2-8-2-集合工作中一些注意事项" class="headerlink" title="2.8.2-集合工作中一些注意事项"></a>2.8.2-集合工作中一些注意事项</h4><h5 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1.线程安全"></a>1.线程安全</h5><p>我们说集合都是非线程安全的，这里说的非线程安全指的是集合类作为共享变量，被多线程读写的时候，才是不安全的，如果要实现线程安全的集合，在类注释中，JDK 统一推荐我们使用 Collections.synchronized* 类， Collections 帮我们实现了 List、Set、Map 对应的线程安全的方法， 如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Collections-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%96%B9%E6%B3%95.jpeg" alt="Collections-线程安全方法"></p><p>图中实现了各种集合类型的线程安全的方法，我们以 synchronizedList 为例，从源码上来看下，Collections 是如何实现线程安全的：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// mutex 就是我们需要锁住的对象</span><span class="token keyword">final</span> Object mutex<span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>        <span class="token keyword">extends</span> <span class="token class-name">SynchronizedCollection</span><span class="token operator">&lt;</span>E<span class="token operator">></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>7754090372962971524L<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这个 List 就是我们需要保证线程安全的类</span>        <span class="token keyword">final</span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> list<span class="token punctuation">;</span>        <span class="token function">SynchronizedList</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>E<span class="token operator">></span> list<span class="token punctuation">,</span> Object mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>list <span class="token operator">=</span> list<span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 我们可以看到，List 的所有操作都使用了 synchronized 关键字，来进行加锁</span>                <span class="token comment" spellcheck="true">// synchronized 是一种悲观锁，能够保证同一时刻，只能有一个线程能够获得锁</span>        <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token punctuation">}</span>…………<span class="token punctuation">}</span>      </code></pre><p>从源码中我们可以看到 Collections 是通过 synchronized 关键字给 List 操作数组的方法加上锁，来实现线程安全的。</p><h5 id="2-集合性能"><a href="#2-集合性能" class="headerlink" title="2.集合性能"></a>2.集合性能</h5><p>集合的单个操作，一般都没有性能问题，性能问题主要出现的批量操作上。</p><h6 id="2-1-批量新增"><a href="#2-1-批量新增" class="headerlink" title="2.1-批量新增"></a>2.1-批量新增</h6><p>在 List 和 Map 大量数据新增的时候，我们不要使用 for 循环 + add/put 方法新增，这样子会有很大的扩容成本，我们应该尽量使用 addAll 和 putAll 方法进行新增，以 ArrayList 为例写了一个 demo 如下，演示了两种方案的性能对比：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testBatchInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 准备拷贝数据</span>  ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3000000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// for 循环 + add</span>  ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">long</span> start1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    list2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"单个 for 循环新增 300 w 个，耗时{}"</span><span class="token punctuation">,</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 批量新增</span>  ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">long</span> start2 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  list3<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"批量新增 300 w 个，耗时{}"</span><span class="token punctuation">,</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>最后打印出来的日志为：</p><p>16:52:59.865 [main] INFO demo.one.ArrayListDemo - 单个 for 循环新增 300 w 个，耗时1518<br>16:52:59.880 [main] INFO demo.one.ArrayListDemo - 批量新增 300 w 个，耗时8</p><p>可以看到，批量新增方法性能是单个新增方法性能的 189 倍，主要原因在于批量新增，只会扩容一次，大大缩短了运行时间，而单个新增，每次到达扩容阀值时，都会进行扩容，在整个过程中就会不断的扩容，浪费了很多时间，我们来看下批量新增的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 确保容量充足，整个过程只会扩容一次</span>  <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 进行数组的拷贝</span>  System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>  size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>  <span class="token keyword">return</span> numNew <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>以上是 ArrayList 批量新增的演示，我们可以看到，整个批量新增的过程中，只扩容了一次，HashMap 的 putAll 方法也是如此，整个新增过程只会扩容一次，大大缩短了批量新增的时间，提高了性能。</p><p>所以如果有人问你当碰到集合批量拷贝，批量新增场景，如何提高新增性能的时候 ，就可以从目标集合初始化方面应答。</p><p>这里也提醒了我们，在容器初始化的时候，最好能给容器赋上初始值，这样可以防止在 put 的过程中不断的扩容，从而缩短时间，上章 HashSet 的源码给我们演示了，给 HashMap 赋初始值的公式为：取括号内两者的最大值（期望的值/0.75+1，默认值 16）。</p><h6 id="2-2-批量删除"><a href="#2-2-批量删除" class="headerlink" title="2.2-批量删除"></a>2.2-批量删除</h6><p>批量删除 ArrayList 提供了 removeAll 的方法，HashMap 没有提供批量删除的方法，我们一起来看下 removeAll 的源码实现，是如何提高性能的：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 批量删除，removeAll 方法底层调用的是 batchRemove 方法</span><span class="token comment" spellcheck="true">// complement 参数默认是 false,false 的意思是数组中不包含 c 中数据的节点往头移动</span><span class="token comment" spellcheck="true">// true 意思是数组中包含 c 中数据的节点往头移动，这个是根据你要删除数据和原数组大小的比例来决定的</span><span class="token comment" spellcheck="true">// 如果你要删除的数据很多，选择 false 性能更好，当然 removeAll 方法默认就是 false。</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">batchRemove</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">,</span> <span class="token keyword">boolean</span> complement<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// r 表示当前循环的位置、w 位置之前都是不需要被删除的数据，w 位置之后都是需要被删除的数据</span>  <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span> modified <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 从 0 位置开始判断，当前数组中元素是不是要被删除的元素，不是的话移到数组头</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> complement<span class="token punctuation">)</span>        elementData<span class="token punctuation">[</span>w<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> elementData<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// r 和 size 不等，说明在 try 过程中发生了异常，在 r 处断开</span>    <span class="token comment" spellcheck="true">// 把 r 位置之后的数组移动到 w 位置之后(r 位置之后的数组数据都是没有判断过的数据，这样不会影响没有判断的数据，判断过的数据可以被删除)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>      System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> r<span class="token punctuation">,</span>                       elementData<span class="token punctuation">,</span> w<span class="token punctuation">,</span>                       size <span class="token operator">-</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>      w <span class="token operator">+=</span> size <span class="token operator">-</span> r<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// w != size 说明数组中是有数据需要被删除的</span>    <span class="token comment" spellcheck="true">// 如果 w、size 相等，说明没有数据需要被删除</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">!=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// w 之后都是需要删除的数据，赋值为空，帮助 gc。</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> w<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>      modCount <span class="token operator">+=</span> size <span class="token operator">-</span> w<span class="token punctuation">;</span>      size <span class="token operator">=</span> w<span class="token punctuation">;</span>      modified <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> modified<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们看到 ArrayList 在批量删除时，如果程序执行正常，只有一次 for 循环，如果程序执行异常，才会加一次拷贝，而单个 remove 方法，每次执行的时候都会进行数组的拷贝（当删除的元素正好是数组最后一个元素时除外），当数组越大，需要删除的数据越多时，批量删除的性能会越差，所以在 ArrayList 批量删除时，强烈建议使用 removeAll 方法进行删除。</p><h5 id="3-集合的一些坑"><a href="#3-集合的一些坑" class="headerlink" title="3.集合的一些坑"></a>3.集合的一些坑</h5><ol><li>当集合的元素是自定义类时，自定义类强制实现 equals 和 hashCode 方法，并且两个都要实现。</li></ol><p>在集合中，除了 TreeMap 和 TreeSet 是通过比较器比较元素大小外，其余的集合类在判断索引位置和相等时，都会使用到 equals 和 hashCode 方法，这个在之前的源码解析中，我们有说到，所以当集合的元素是自定义类时，我们强烈建议覆写 equals 和 hashCode 方法，我们可以直接使用 IDEA 工具覆写这两个方法，非常方便；</p><ol><li>所有集合类，在 for 循环进行删除时，如果直接使用集合类的 remove 方法进行删除，都会快速失败，报 ConcurrentModificationException 的错误，所以在任意循环删除的场景下，都建议使用迭代器进行删除；</li><li>我们把数组转化成集合时，常使用 Arrays.asList(array)，这个方法有两个坑，代码演示坑为：</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testArrayToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 坑1：修改数组的值，会直接影响原 list</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"数组被修改之前，集合第一个元素为：{}"</span><span class="token punctuation">,</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"数组被修改之前，集合第一个元素为：{}"</span><span class="token punctuation">,</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 坑2：使用 add、remove 等操作 list 的方法时，</span>  <span class="token comment" spellcheck="true">// 会报 UnsupportedOperationException 异常</span>  list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>坑 <span class="token number">1</span>：数组被修改后，会直接影响到新 List 的值。坑 <span class="token number">2</span>：不能对新 List 进行 add、remove 等操作，否则运行时会报 UnsupportedOperationException 错误。</code></pre><p>我们来看下 Arrays.asList 的源码实现，就能知道问题所在了，源码如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Arrays-asList.jpeg" alt="Arrays-asList"></p><p>从上图中，我们可以发现，Arrays.asList 方法返回的 List 并不是 java.util.ArrayList，而是自己内部的一个静态类，该静态类直接持有数组的引用，并且没有实现 add、remove 等方法，这些就是坑 1 和 2 的原因。</p><ol><li>集合 List 转化成数组，我们通常使用 toArray 这个方法，这个方法很危险，稍微不注意，就踩进大坑，我们示例代码如下：</li></ol><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testListToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>      <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 下面这行被注释的代码这么写是无法转化成数组的，无参 toArray 返回的是 Object[],</span>    <span class="token comment" spellcheck="true">// 无法向下转化成 List&lt;Integer>，编译都无法通过</span>    <span class="token comment" spellcheck="true">// List&lt;Integer> list2 = list.toArray();</span>    <span class="token comment" spellcheck="true">// 演示有参 toArray 方法，数组大小不够时，得到数组为 null 情况</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> array0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array0<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"toArray 数组大小不够，array0 数组[0] 值是{},数组[1] 值是{},"</span><span class="token punctuation">,</span>array0<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>array0<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 演示数组初始化大小正好，正好转化成数组</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> array1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array1<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"toArray 数组大小正好，array1 数组[3] 值是{}"</span><span class="token punctuation">,</span>array1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 演示数组初始化大小大于实际所需大小，也可以转化成数组</span>    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> array2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array2<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"toArray 数组大小多了，array2 数组[3] 值是{}，数组[4] 值是{}"</span><span class="token punctuation">,</span>array2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>array2<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token number">19</span><span class="token operator">:</span><span class="token number">33</span><span class="token operator">:</span><span class="token number">07.687</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO demo<span class="token punctuation">.</span>one<span class="token punctuation">.</span>ArrayListDemo <span class="token operator">-</span> toArray 数组大小不够，array0 数组<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> 值是null<span class="token punctuation">,</span>数组<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> 值是null<span class="token punctuation">,</span><span class="token number">19</span><span class="token operator">:</span><span class="token number">33</span><span class="token operator">:</span><span class="token number">07.697</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO demo<span class="token punctuation">.</span>one<span class="token punctuation">.</span>ArrayListDemo <span class="token operator">-</span> toArray 数组大小正好，array1 数组<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> 值是<span class="token number">4</span><span class="token number">19</span><span class="token operator">:</span><span class="token number">33</span><span class="token operator">:</span><span class="token number">07.697</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO demo<span class="token punctuation">.</span>one<span class="token punctuation">.</span>ArrayListDemo <span class="token operator">-</span> toArray 数组大小多了，array2 数组<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> 值是<span class="token number">4</span>，数组<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> 值是null</code></pre><p>toArray 的无参方法，无法强转成具体类型，这个编译的时候，就会有提醒，我们一般都会去使用带有参数的 toArray 方法，这时就有一个坑，如果参数数组的大小不够，这时候返回的数组值竟然是空，上述代码中的 array0 的返回值就体现了这点，但我们去看 toArray 源码，发现源码中返回的是 4 个大小值的数据，返回的并不是空，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// List 转化成数组</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 如果数组长度不够，按照 List 的大小进行拷贝，return 的时候返回的都是正确的数组</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// Make a new array of a's runtime type, but my contents:</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 数组长度大于 List 大小的，赋值为 null</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">></span> size<span class="token punctuation">)</span>    a<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token keyword">return</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码中，我们丝毫看不出为什么 array0 的元素值为什么是 null，最后我们去看方法的注释，发现是这样子描述的：</p><pre class=" language-java"><code class="language-java">If the list fits in the specified array<span class="token punctuation">,</span> it is returned therein<span class="token punctuation">.</span>  Otherwise<span class="token punctuation">,</span> a <span class="token keyword">new</span> <span class="token class-name">array</span> is allocated with the runtime type of the specified array and the size of <span class="token keyword">this</span> list。</code></pre><p>翻译过来的意思就是说：如果返回的数组大小和申明的数组大小一致，那么就会正常返回，否则，一个新数组就会被分配返回。</p><p>所以我们在使用有参 toArray 方法时，申明的数组大小一定要大于等于 List 的大小，如果小于的话，你会得到一个空数组。</p><h4 id="2-8-3-总结"><a href="#2-8-3-总结" class="headerlink" title="2.8.3-总结"></a>2.8.3-总结</h4><p>本小节，我们详细描述了集合的线程安全、性能优化和日常工作中一些坑，这些问题我们在工作中经常会碰到，稍不留神就会引发线上故障，面试的时候也经常会通过这些问题，来考察大家的工作经验，所以阅读本章时，建议大家自己动手试一试，加深印象。</p><h3 id="2-9-差异对比：集合在-Java-7-和-8-有何不同和改进"><a href="#2-9-差异对比：集合在-Java-7-和-8-有何不同和改进" class="headerlink" title="2.9-差异对比：集合在 Java 7 和 8 有何不同和改进"></a>2.9-差异对比：集合在 Java 7 和 8 有何不同和改进</h3><p>Java 8 在 Java 7 的基础上，做了一些改进和优化，但我们在平时工作中，或者直接升级到 Java 8 的过程中，我们好像无需做任何兼容逻辑，那么 Java 8 底层是如何处理的呢，在改进的同时，是如何优雅兼容 Java 老版本，让使用者无需感知，接下来我们通过对比 Java 7 和 8 的差异，来展示 Java 8 是如何优雅升级的。</p><h4 id="2-9-1-通用区别"><a href="#2-9-1-通用区别" class="headerlink" title="2.9.1-通用区别"></a>2.9.1-通用区别</h4><h5 id="1-所有集合都新增了forEach-方法"><a href="#1-所有集合都新增了forEach-方法" class="headerlink" title="1.所有集合都新增了forEach 方法"></a>1.所有集合都新增了forEach 方法</h5><p>List、Set、Map 在 Java 8 版本中都增加了 forEach 的方法，方法的入参是 Consumer，Consumer 是一个函数式接口，可以简单理解成允许一个入参，但没有返回值的函数式接口，我们以 ArrayList 的 forEach 的源码为例，来看下方法是如何实现的 ：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span>Consumer<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 判断非空</span>  Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// modCount的原始值被拷贝</span>  <span class="token keyword">final</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>  <span class="token keyword">final</span> E<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>  <span class="token keyword">final</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 每次循环都会判断数组有没有被修改，一旦被修改，停止循环</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> modCount <span class="token operator">==</span> expectedModCount <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 执行循环内容，action 代表我们要干的事情</span>    action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 数组如果被修改了，抛异常</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从这段源码中，很容易产生两个问题：</p><p>1、action.accept 到底是个啥？</p><p>action.accept 就是你在 for 循环中要干的事情，你可以进行任何事情，比如我们打印一句话，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testForEach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// value 是每次循环的入参，就是 list 中的每个元素</span>  list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> value<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前值为：{}"</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>输出为：当前值为：<span class="token number">1</span>当前值为：<span class="token number">3</span>当前值为：<span class="token number">2</span>当前值为：<span class="token number">4</span></code></pre><p>log.info(“当前值为：{}”,value) 就是我们要干的事情，就是 action。</p><p>2.、forEach 方法上打了 @Override 注解，说明该方法是被继承实现的，该方法是被定义在 Iterable 接口上的，Java 7 和 8 的 ArrayList 都实现了该接口，但我们在 Java 7 的 ArrayList 并没有发现有实现该方法，编译器也木有报错，这个主要是因为 Iterable 接口的 forEach 方法被加上了 default 关键字，这个关键字只会出现在接口类中，被该关键字修饰的方法无需强制要求子类继承，但需要自己实现默认实现，我们看下源码：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Iterable.jpeg" alt="Iterable"></p><p>不仅仅是 forEach 这一个方法是这么干的，List、Set、Map 接口中很多新增的方法都是这么干的，通过 default 关键字，可以让 Java 7 的集合子类无需实现 Java 8 中新增的方法。</p><p>如果想在接口中新增一个方法，但又不想子类强制实现该方法时，可以给该方法加上 default 关键字，这个在实际工作中，也经常使用到，算是重构的小技巧吧。</p><h4 id="2-9-2-List区别"><a href="#2-9-2-List区别" class="headerlink" title="2.9.2-List区别"></a>2.9.2-List区别</h4><h5 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.ArrayList"></a>1.ArrayList</h5><p>ArrayList 无参初始化时，Java 7 是直接初始化 10 的大小，Java 8 去掉了这个逻辑，初始化时是空数组，在第一次 add 时才开始按照 10 进行扩容，下图是源码的差异对比图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayList-78%E5%AF%B9%E6%AF%94.jpeg" alt="ArrayList-78对比"></p><p>List 其它方面 java7 和 8 并没有改动。</p><h4 id="2-9-3-Map区别"><a href="#2-9-3-Map区别" class="headerlink" title="2.9.3-Map区别"></a>2.9.3-Map区别</h4><h5 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h5><ol><li>和 ArrayList 一样，Java 8 中 HashMap 在无参构造器中，丢弃了 Java 7 中直接把数组初始化 16 的做法，而是采用在第一次新增的时候，才开始扩容数组大小；</li><li>hash 算法计算公式不同，Java 8 的 hash 算法更加简单，代码更加简洁；</li><li>Java 8 的 HashMap 增加了红黑树的数据结构，这个是 Java 7 中没有的，Java 7 只有数组 + 链表的结构，Java 8 中提出了数组 + 链表 + 红黑树的结构，一般 key 是 Java 的 API 时，比如说 String 这些 hashcode 实现很好的 API，很少出现链表转化成红黑树的情况，因为 String 这些 API 的 hash 算法够好了，只有当 key 是我们自定义的类，而且我们覆写的 hashcode 算法非常糟糕时，才会真正使用到红黑树，提高我们的检索速度。</li></ol><p>也是因为 Java 8 新增了红黑树，所以几乎所有操作数组的方法的实现，都发生了变动，比如说 put、remove 等操作，可以说 Java 8 的 HashMap 几乎重写了一遍，所以 Java 7 的很多问题都被 Java 8 解决了，比如扩容时极小概率死锁，丢失数据等等。</p><ol><li>新增了一些好用的方法，比如 getOrDefault，我们看下源码，非常简单：</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果 key 对应的值不存在，返回期望的默认值 defaultValue</span><span class="token keyword">public</span> V <span class="token function">getOrDefault</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> V defaultValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> defaultValue <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>还有 putIfAbsent(K key, V value) 方法，意思是，如果 map 中存在 key 了，那么 value 就不会覆盖，如果不存在 key ，新增成功。</p><p>还有 compute 方法，意思是允许我们把 key 和 value 的值进行计算后，再 put 到 map 中，为防止 key 值不存在造成未知错误，map 还提供了 computeIfPresent 方法，表示只有在 key 存在的时候，才执行计算，demo 如下：</p><pre class=" language-java"><code class="language-java">  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"compute 之前值为：{}"</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> key <span class="token operator">*</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"compute 之后值为：{}"</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 还原测试值</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果为 11 的 key 不存在的话，需要注意 value 为空的情况，下面这行代码就会报空指针</span>    <span class="token comment" spellcheck="true">//  map.compute(11,(key,value) -> key * value);</span>    <span class="token comment" spellcheck="true">// 为了防止 key 不存在时导致的未知异常，我们一般有两种办法</span>    <span class="token comment" spellcheck="true">// 1：自己判断空指针</span>    map<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> null <span class="token operator">==</span> value <span class="token operator">?</span> null <span class="token operator">:</span> key <span class="token operator">*</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2：computeIfPresent 方法里面判断</span>    map<span class="token punctuation">.</span><span class="token function">computeIfPresent</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> key <span class="token operator">*</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"computeIfPresent 之后值为：{}"</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>结果是：compute 之前值为：<span class="token number">10</span>compute 之后值为：<span class="token number">100</span>computeIfPresent 之后值为：null（这个结果中，可以看出，使用 computeIfPresent 避免了空指针）</code></pre><p>上述 Java 8 新增的几种方法非常好用，在实际工作中，可以大大减少我们的代码量，computeIfPresent 的源码就不贴了，有兴趣可以去 github 上面查看，主要的实现原理如下：</p><ul><li>找到 key 对应的老值，会分别从数组、链表、红黑树中找；</li><li>根据 key 和老值进行计算，得到新值；</li><li>用新值替换掉老值，可能是普通替换、链表替换或红黑树替换。</li></ul><h5 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2.LinkedHashMap"></a>2.LinkedHashMap</h5><p>由于 Java 8 的底层数据有变动，导致 HashMap 操作数据的方法几乎重写，也使 LinkedHashMap 的实现名称上有所差异，原理上都相同，我们看下面的图，左边是 Java 7，右边是 Java 8。</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/LinkedHashMap-78%E5%8C%BA%E5%88%AB.jpeg" alt="LinkedHashMap-78区别"></p><p>从图中，我们发现 LinkedHashMap 的方法名有所修改，底层的实现逻辑其实都差不多的。</p><h4 id="2-9-4-其他区别"><a href="#2-9-4-其他区别" class="headerlink" title="2.9.4-其他区别"></a>2.9.4-其他区别</h4><h5 id="1-Arrays-提供了很多-parallel-开头的方法。"><a href="#1-Arrays-提供了很多-parallel-开头的方法。" class="headerlink" title="1.Arrays 提供了很多 parallel 开头的方法。"></a>1.Arrays 提供了很多 parallel 开头的方法。</h5><p>Java 8 的 Arrays 提供了一些 parallel 开头的方法，这些方法支持并行的计算，在数据量大的时候，会充分利用 CPU ，提高计算效率，比如说 parallelSort 方法，方法底层有判断，只有数据量大于 8192 时，才会真正走并行的实现，在实际的实验中，并行计算的确能够快速的提高计算速度。</p><h4 id="2-9-5-面试题"><a href="#2-9-5-面试题" class="headerlink" title="2.9.5-面试题"></a>2.9.5-面试题</h4><h5 id="1-Java-8-在-List、Map-接口上新增了很多方法，为什么-Java-7-中这些接口的实现者不需要强制实现这些方法呢？"><a href="#1-Java-8-在-List、Map-接口上新增了很多方法，为什么-Java-7-中这些接口的实现者不需要强制实现这些方法呢？" class="headerlink" title="1.Java 8 在 List、Map 接口上新增了很多方法，为什么 Java 7 中这些接口的实现者不需要强制实现这些方法呢？"></a>1.Java 8 在 List、Map 接口上新增了很多方法，为什么 Java 7 中这些接口的实现者不需要强制实现这些方法呢？</h5><p>答：主要是因为这些新增的方法被 default 关键字修饰了，default 一旦修饰接口上的方法，我们需要在接口的方法中写默认实现，并且子类无需强制实现这些方法，所以 Java 7 接口的实现者无需感知。</p><h5 id="2-Java-8-中有新增很多实用的方法，你在平时工作中有使用过么？"><a href="#2-Java-8-中有新增很多实用的方法，你在平时工作中有使用过么？" class="headerlink" title="2.Java 8 中有新增很多实用的方法，你在平时工作中有使用过么？"></a>2.Java 8 中有新增很多实用的方法，你在平时工作中有使用过么？</h5><p>答：有的，比如说 getOrDefault、putIfAbsent、computeIfPresent 方法等等，具体使用细节参考上文。</p><h5 id="3-说说-computeIfPresent-方法的使用姿势？"><a href="#3-说说-computeIfPresent-方法的使用姿势？" class="headerlink" title="3.说说 computeIfPresent 方法的使用姿势？"></a>3.说说 computeIfPresent 方法的使用姿势？</h5><p>答：computeIfPresent 是可以对 key 和 value 进行计算后，把计算的结果重新赋值给 key，并且如果 key 不存在时，不会报空指针，会返回 null 值。</p><h5 id="4-Java-8-集合新增了-forEach-方法，和普通的-for-循环有啥不同？"><a href="#4-Java-8-集合新增了-forEach-方法，和普通的-for-循环有啥不同？" class="headerlink" title="4.Java 8 集合新增了 forEach 方法，和普通的 for 循环有啥不同？"></a>4.Java 8 集合新增了 forEach 方法，和普通的 for 循环有啥不同？</h5><p>答：新增的 forEach 方法的入参是函数式的接口，比如说 Consumer 和 BiConsumer，这样子做的好处就是封装了 for 循环的代码，让使用者只需关注实现每次循环的业务逻辑，简化了重复的 for 循环代码，使代码更加简洁，普通的 for 循环，每次都需要写重复的 for 循环代码，forEach 把这种重复的计算逻辑吃掉了，使用起来更加方便。</p><h5 id="5-HashMap-8-和-7-有啥区别？"><a href="#5-HashMap-8-和-7-有啥区别？" class="headerlink" title="5.HashMap 8 和 7 有啥区别？"></a>5.HashMap 8 和 7 有啥区别？</h5><p>答：HashMap 8 和 7 的差别太大了，新增了红黑树，修改了底层数据逻辑，修改了 hash 算法，几乎所有底层数组变动的方法都重写了一遍，可以说 Java 8 的 HashMap 几乎重新了一遍。</p><h4 id="2-9-6-总结"><a href="#2-9-6-总结" class="headerlink" title="2.9.6-总结"></a>2.9.6-总结</h4><p>总体来说，List 方面是小改动，HashMap 几乎重写了一套，所有的集合都新增了函数式的方法，比如说 forEach，也新增了很多好用的函数，比如说 getOrDefault，这些函数可以大大减少我们的代码量，让我们把关注点聚焦在业务逻辑的实现上，这其实是一种思想，把繁琐重复的计算逻辑抽取出来，从计算逻辑中扩展出业务逻辑的口子，让使用者只专心关注业务逻辑的实现即可。</p><p>想要了解更多差异，也可直接前往 JDK 8 新特性查看，地址为：<a href="http://openjdk.java.net/projects/jdk8/features#103。" target="_blank" rel="noopener">http://openjdk.java.net/projects/jdk8/features#103。</a></p><h3 id="2-10-简化工作：Guava-Lists-Maps-实际工作运用和源码"><a href="#2-10-简化工作：Guava-Lists-Maps-实际工作运用和源码" class="headerlink" title="2.10-简化工作：Guava Lists Maps 实际工作运用和源码"></a>2.10-简化工作：Guava Lists Maps 实际工作运用和源码</h3><p>在日常工作中，我们经常会使用一些三方的 API 来简化我们的工作，Guava 就是其中一种，Guava 是 Google 开源的技术框架，使用率高，社区活跃度也很高。</p><p>本小节我们从工作中对 Guava 集合的使用入手，然后深入的看下其底层的实现，最后总结其设计思想，感兴趣的同学也可以下载源码学习，GitHub 地址：<a href="https://github.com/google/guava，源码中" target="_blank" rel="noopener">https://github.com/google/guava，源码中</a> guava 的文件夹为其源码。</p><h4 id="2-10-1-运用工厂模式进行初始化"><a href="#2-10-1-运用工厂模式进行初始化" class="headerlink" title="2.10.1-运用工厂模式进行初始化"></a>2.10.1-运用工厂模式进行初始化</h4><p>在集合类初始化方面，Guava 比 Java 原生的 API 更加好用，还发明了很多新的功能，比如说在 JDK 7 之前，我们新建集合类时，声明和初始化都必须写上泛型说明，像这样：<code>List&lt;泛型&gt; list = new ArrayList&lt;泛型&gt;();</code> ， JDK 7 之后有所改变，我们只需要在声明处写上泛型说明，像这样：<code>List&lt;泛型&gt; list = new ArrayList&lt;&gt;();</code>。</p><p>Guava 提供了更加方便的使用姿势，采用了工厂模式，把集合创建的逻辑交给了工厂，开发者无需关注工厂底层是如何创建的，只需要关心，工厂能产生什么，代码于是变成了这样：<code>List&lt;泛型&gt; list = Lists.newArrayList();</code>，Lists 就是 Guava 提供出来的，方便操作 List 的工具类。</p><p>这种写法其实就是一种简单的工厂模式，只需要定义好工厂的入参和出参，就能对外隐藏其内部的创建逻辑，提供更加方便的使用体验。</p><p>当然除了 Lists，Guava 还提供了很多其他实用工具，如 Maps、Sets，接下来我们分别来看下这些常用工具的使用和原理。</p><h4 id="2-10-2-Lists"><a href="#2-10-2-Lists" class="headerlink" title="2.10.2-Lists"></a>2.10.2-Lists</h4><h5 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h5><p>Lists 最大的功能是能帮助我们进行 List 的初始化，比如我们刚说的 newArrayList 这种：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> ArrayList<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 这种底层是帮助我们写好了泛型，E 代表泛型，表示当前返回的泛型类型和声明的一致即可，在编译的时候，会把泛型 E 转化成我们声明的 String。</span></code></pre><p>如果你清楚 List 的大小，我们也可以这样做：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 可以预估 list 的大小为 20</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayListWithCapacity</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 不太肯定 list 大小是多少，但期望是大小是 20 上下。</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayListWithExpectedSize</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>newArrayListWithCapacity(20) 方法内部实现是：<code>new ArrayList&lt;&gt;(20);</code>，而 newArrayListWithExpectedSize 方法内部实现是对 List 大小有一个计算公式的，计算公式为：<code>5L + arraySize + (arraySize / 10)</code> ，arraySize 表示传进来的值，公式简化下就是 5 + 11/10 * arraySize，因为这个方法表示期望的大小，所以这里取的约是期望值的十分之十一，比传进来的值约大十分之一，所以根据 20 最终计算出来的值是 27。</p><p>Lists 在初始化的时候，还支持传迭代器的入参（只适合小数据量的迭代器的入参），源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> ArrayList<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">newArrayList</span><span class="token punctuation">(</span>Iterator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> elements<span class="token punctuation">)</span> <span class="token punctuation">{</span>  ArrayList<span class="token operator">&lt;</span>E<span class="token operator">></span> list <span class="token operator">=</span> <span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// addAll 方法底层其实通过迭代器进行 for 循环添加</span>  Iterators<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> list<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从 Lists 对 List 初始化进行包装的底层源码来看，底层源码非常简单的，但我们还是愿意使用这种方式的包装，主要是因为这种工厂模式的包装，使我们的使用姿势更加优雅，使用起来更加方便。</p><h5 id="2-分组和反转排序"><a href="#2-分组和反转排序" class="headerlink" title="2.分组和反转排序"></a>2.分组和反转排序</h5><p>除了初始化之外，Lists 还提供了两个比较实用的功能，分组和反转排序功能，我们分别来演示一下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 演示反转排序</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"30"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"40"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"反转之前："</span><span class="token operator">+</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"反转之后："</span><span class="token operator">+</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 打印出来的结果为：</span>反转之前：<span class="token punctuation">[</span><span class="token string">"10"</span><span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">,</span><span class="token string">"30"</span><span class="token punctuation">,</span><span class="token string">"40"</span><span class="token punctuation">]</span>反转之后：<span class="token punctuation">[</span><span class="token string">"40"</span><span class="token punctuation">,</span><span class="token string">"30"</span><span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">,</span><span class="token string">"10"</span><span class="token punctuation">]</span></code></pre><p>reverse 方法底层实现非常巧妙，底层覆写了 List 原生的 get(index) 方法，会把传进来的 index 进行 (size - 1) - index 的计算，使计算得到的索引位置和 index 位置正好相反，这样当我们 get 时，数组索引位置的 index 已经是相反的位置了，达到了反转排序的效果，其实底层并没有进行反转排序，只是在计算相反的索引位置，通过计算相反的索引位置这样简单的设计，得到了反转排序的效果，很精妙。</p><p>在工作中，有时候我们需要把一个大的 list 进行切分，然后再把每份丢给线程池去运行，最后将每份运行的结果汇总，Lists 工具类就提供了一个对 list 进行切分分组的方法，演示 demo 如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 分组</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testPartition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"30"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"40"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"分组之前："</span><span class="token operator">+</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> list2 <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"分组之后："</span><span class="token operator">+</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>输出结果为：分组之前：<span class="token punctuation">[</span><span class="token string">"10"</span><span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">,</span><span class="token string">"30"</span><span class="token punctuation">,</span><span class="token string">"40"</span><span class="token punctuation">]</span>分组之后：<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"10"</span><span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">,</span><span class="token string">"30"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"40"</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><p>partition 方法的第二个参数的意思，你想让分组后的 List 包含几个元素，这个方法的底层实现其实就是 subList 方法。</p><p>有一点需要我们注意的是这两个方法返回的 List 并不是 ArrayList，是自定义的 List，所以对于 ArrayList 的有些功能可能并不支持，使用的时候最好能看下源码，看看底层有无支持。</p><h5 id="3-小结-3"><a href="#3-小结-3" class="headerlink" title="3.小结"></a>3.小结</h5><p>Lists 上述的方法大大的方便了我们进行开发，简化了使用姿势，但其内部实现却非常简单巧妙，比如说 reverse 方法可以输出相反排序的 List，但底层并没有实现排序，只是计算了索引位置的相反值而已，这点值得我们学习。</p><h4 id="2-10-3-Maps"><a href="#2-10-3-Maps" class="headerlink" title="2.10.3-Maps"></a>2.10.3-Maps</h4><h5 id="1-初始化-1"><a href="#1-初始化-1" class="headerlink" title="1.初始化"></a>1.初始化</h5><p>Maps 也是有着各种初始化 Map 的各种方法，原理不说了，和 Lists 类似，我们演示下如何使用：</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> hashMap <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> linkedHashMap <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newLinkedHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 这里 Map 的初始化大小公式和 HashSet 初始化公式类似，还记得 HashSet 初始化 HashMap 时，经典的计算初始大小的公式么：取最大值（期望的值 / 0.75 + 1，默认值 16），newHashMapWithExpectedSize 方法底层也是这么算的初始化大小的</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> withExpectedSizeHashMap <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMapWithExpectedSize</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="2-difference"><a href="#2-difference" class="headerlink" title="2.difference"></a>2.difference</h5><p>Maps 提供了一个特别有趣也很实用的方法：difference，此方法的目的是比较两个 Map 的差异，入参就是两个 Map，比较之后能够返回四种差异：</p><ol><li>左边 Map 独有 key。</li><li>右边 Map 独有 key。</li><li>左右边 Map 都有 key，并且 value 相等。</li><li>左右边 Map 都有 key，但是 value 不等。</li></ol><p>我们用代码来演示一下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ImmutableMap.of 也是 Guava 提供初始化 Map 的方法，入参格式为 k1,v1,k2,v2,k3,v3……</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> leftMap <span class="token operator">=</span> ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> rightMap <span class="token operator">=</span> ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"30"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>MapDifference difference <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">difference</span><span class="token punctuation">(</span>leftMap<span class="token punctuation">,</span> rightMap<span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"左边 map 独有 key：{}"</span><span class="token punctuation">,</span>difference<span class="token punctuation">.</span><span class="token function">entriesOnlyOnLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"右边 map 独有 key：{}"</span><span class="token punctuation">,</span>difference<span class="token punctuation">.</span><span class="token function">entriesOnlyOnRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"左右边 map 都有 key，并且 value 相等：{}"</span><span class="token punctuation">,</span>difference<span class="token punctuation">.</span><span class="token function">entriesInCommon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"左右边 map 都有 key，但 value 不等：{}"</span><span class="token punctuation">,</span>difference<span class="token punctuation">.</span><span class="token function">entriesDiffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>最后打印结果为：左边 map 独有 key：<span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>右边 map 独有 key：<span class="token punctuation">{</span><span class="token number">4</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">}</span>左右边 map 都有 key，并且 value 相等：<span class="token punctuation">{</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>左右边 map 都有 key，但 value 不等：<span class="token punctuation">{</span><span class="token number">3</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>从这个 demo 我们可以看到此方法的强大威力，我们在工作中经常遇到 Map 或者 List 间比较差异的任务，我们就可以直接使用该方法进行对比，List 可以先转化成 Map。</p><p>而且 difference 底层的实现也算是最优的实现了，只需要循环一遍，就可得到上述四种差异结果，源码解析如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对比两个 map 的差异</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">doDifference</span><span class="token punctuation">(</span>    Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> left<span class="token punctuation">,</span>    Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> right<span class="token punctuation">,</span>    Equivalence<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> V<span class="token operator">></span> valueEquivalence<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// key 只在左边 map 出现</span>    Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> onlyOnLeft<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// key 只在右边 map 出现，调用 doDifference 方法前已经包含了全部右边的值</span>    Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> onlyOnRight<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// key 在左右 map 中都出现过，并且 value 都相等</span>    Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> onBoth<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// key 在左右 map 中都出现过，但 value 不等</span>    Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> MapDifference<span class="token punctuation">.</span>ValueDifference<span class="token operator">&lt;</span>V<span class="token operator">>></span> differences<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 以左边 map 为基准进行循环</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> entry <span class="token operator">:</span> left<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    K leftKey <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    V leftValue <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 右边 map 包含左边的 key</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// onlyOnRight 已经包含全部右边的值 所以需要删除当前 key</span>      V rightValue <span class="token operator">=</span> onlyOnRight<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// key 相等，并且 value 值也相等</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>valueEquivalence<span class="token punctuation">.</span><span class="token function">equivalent</span><span class="token punctuation">(</span>leftValue<span class="token punctuation">,</span> rightValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        onBoth<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">,</span> leftValue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// key 相等，但 value 值不等</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        differences<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">,</span> ValueDifferenceImpl<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>leftValue<span class="token punctuation">,</span> rightValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 右边 map 不包含左边的 key，就是左边 map 独有的 key</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      onlyOnLeft<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">,</span> leftValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这是一种比较优秀的，快速比对的算法，可以好好看下上面的源码，然后把这种算法背下来，或者自己再次实现一次。</p><p>Sets 的使用方式和 Lists 和 Maps 很类似，没有太大的亮点，我们就不说了。</p><h4 id="2-10-4-总结"><a href="#2-10-4-总结" class="headerlink" title="2.10.4-总结"></a>2.10.4-总结</h4><p>这一小节主要都是实战内容，在实际工作中可以用起来。</p><p>在 Guava 对集合的设计中，有两个大点是非常值得我们学习的：</p><ol><li>Lists、Maps 的出现给我们提供了更方便的使用姿势和方法，我们在实际工作中，如果碰到特别繁琐，或者特别难用的 API，我们也可以进行一些包装，使更好用，这个是属于在解决目前的痛点的问题上进行创新，是非常值得提倡的一件事情，往往可以帮助你拿到更好的绩效。</li><li>如果有人问你，List 或者 Map 高效的差异排序算法，完全可以参考 Maps.difference 的内部实现，该方法只使用了一次循环，就可得到所有的相同或不同结果，这种算法在我们工作中也经常被使用。</li></ol><p>了解更多，可以直接前往 Guava 的代码库查看：<a href="https://github.com/google/guava" target="_blank" rel="noopener">https://github.com/google/guava</a></p><h2 id="3-并发集合类"><a href="#3-并发集合类" class="headerlink" title="3-并发集合类"></a>3-并发集合类</h2><h3 id="3-1-CopyOnWriteArrayList-源码解析和设计思路"><a href="#3-1-CopyOnWriteArrayList-源码解析和设计思路" class="headerlink" title="3.1-CopyOnWriteArrayList 源码解析和设计思路"></a>3.1-CopyOnWriteArrayList 源码解析和设计思路</h3><p>在 ArrayList 的类注释上，JDK 就提醒了我们，如果要把 ArrayList 作为共享变量的话，是线程不安全的，推荐我们自己加锁或者使用 Collections.synchronizedList 方法，其实 JDK 还提供了另外一种线程安全的 List，叫做 CopyOnWriteArrayList，这个 List 具有以下特征：</p><ol><li>线程安全的，多线程环境下可以直接使用，无需加锁；</li><li>通过锁 + 数组拷贝 + volatile 关键字保证了线程安全；</li><li>每次数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作成功之后再赋值回去。</li></ol><h4 id="3-1-1-整体架构"><a href="#3-1-1-整体架构" class="headerlink" title="3.1.1-整体架构"></a>3.1.1-整体架构</h4><p>从整体架构上来说，CopyOnWriteArrayList 数据结构和 ArrayList 是一致的，底层是个数组，只不过 CopyOnWriteArrayList 在对数组进行操作的时候，基本会分四步走：</p><ol><li>加锁；</li><li>从原数组中拷贝出新数组；</li><li>在新数组上进行操作，并把新数组赋值给数组容器；</li><li>解锁。</li></ol><p>除了加锁之外，CopyOnWriteArrayList 的底层数组还被 volatile 关键字修饰，意思是一旦数组被修改，其它线程立马能够感知到，代码如下：</p><p><code>private transient volatile Object[] array;</code></p><p>整体上来说，CopyOnWriteArrayList 就是利用锁 + 数组拷贝 + volatile 关键字保证了 List 的线程安全。</p><h5 id="1-类注释-2"><a href="#1-类注释-2" class="headerlink" title="1.类注释"></a>1.类注释</h5><p>我们看看从 CopyOnWriteArrayList 的类注释上能得到哪些信息：</p><ol><li>所有的操作都是线程安全的，因为操作都是在新拷贝数组上进行的；</li><li>数组的拷贝虽然有一定的成本，但往往比一般的替代方案效率高；</li><li>迭代过程中，不会影响到原来的数组，也不会抛出 ConcurrentModificationException 异常。</li></ol><p>接着我们来看下 CopyOnWriteArrayList 的核心方法源码。</p><h4 id="3-1-2-新增"><a href="#3-1-2-新增" class="headerlink" title="3.1.2-新增"></a>3.1.2-新增</h4><p>新增有很多种情况，比如说：新增到数组尾部、新增到数组某一个索引位置、批量新增等等，操作的思路还是我们开头说的四步，我们拿新增到数组尾部的方法举例，来看看底层源码的实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 添加元素到数组尾部</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 加锁</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 得到所有的原数组</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 拷贝到新数组里面，新数组的长度是 + 1 的，因为新增会多一个元素</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 在新数组中进行赋值，新元素直接放在数组的尾部</span>        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 替换掉原来的数组</span>        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// finally 里面释放锁，保证即使 try 发生了异常，仍然能够释放锁   </span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从源码中，我们发现整个 add 过程都是在持有锁的状态下进行的，通过加锁，来保证同一时刻只能有一个线程能够对同一个数组进行 add 操作。</p><p>除了加锁之外，还会从老数组中创建出一个新数组，然后把老数组的值拷贝到新数组上，这时候就有一个问题：都已经加锁了，为什么需要拷贝数组，而不是在原来数组上面进行操作呢，原因主要为：</p><ol><li>volatile 关键字修饰的是数组，如果我们简单的在原来数组上修改其中某几个元素的值，是无法触发可见性的，我们必须通过修改数组的内存地址才行，也就说要对数组进行重新赋值才行。</li><li>在新的数组上进行拷贝，对老数组没有任何影响，只有新数组完全拷贝完成之后，外部才能访问到，降低了在赋值过程中，老数组数据变动的影响。</li></ol><p>简单 add 操作是直接添加到数组的尾部，接着我们来看下指定位置添加元素的关键源码（部分源码）：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// len：数组的长度、index：插入的位置</span><span class="token keyword">int</span> numMoved <span class="token operator">=</span> len <span class="token operator">-</span> index<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果要插入的位置正好等于数组的末尾，直接拷贝数组即可</span><span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>    newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 如果要插入的位置在数组的中间，就需要拷贝 2 次</span><span class="token comment" spellcheck="true">// 第一次从 0 拷贝到 index。</span><span class="token comment" spellcheck="true">// 第二次从 index+1 拷贝到末尾。</span>    newElements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index<span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// index 索引位置的值是空的，直接赋值即可。</span>newElements<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 把新数组的值赋值给数组的容器中</span><span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>从源码中可以看到，当插入的位置正好处于末尾时，只需要拷贝一次，当插入的位置处于中间时，此时我们会把原数组一分为二，进行两次拷贝操作。</p><p>最后还有个批量新增操作，源码我们就不贴了，底层也是拷贝数组的操作。</p><h5 id="1-小结"><a href="#1-小结" class="headerlink" title="1.小结"></a>1.小结</h5><p>从 add 系列方法可以看出，CopyOnWriteArrayList 通过加锁 + 数组拷贝+ volatile 来保证了线程安全，每一个要素都有着其独特的含义：</p><ol><li>加锁：保证同一时刻数组只能被一个线程操作；</li><li>数组拷贝：保证数组的内存地址被修改，修改后触发 volatile 的可见性，其它线程可以立马知道数组已经被修改；</li><li>volatile：值被修改后，其它线程能够立马感知最新值。</li></ol><p>3 个要素缺一不可，比如说我们只使用 1 和 3 ，去掉 2，这样当我们修改数组中某个值时，并不会触发 volatile 的可见特性的，只有当数组内存地址被修改后，才能触发把最新值通知给其他线程的特性。</p><h4 id="3-1-3-删除"><a href="#3-1-3-删除" class="headerlink" title="3.1.3-删除"></a>3.1.3-删除</h4><p>接着我们来看下指定数组索引位置删除的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 删除某个索引位置的数据</span><span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 加锁</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 先得到老值</span>        E oldValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> len <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果要删除的数据正好是数组的尾部，直接删除</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">setArray</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果删除的数据在数组的中间，分三步走</span>            <span class="token comment" spellcheck="true">// 1. 设置新数组的长度减一，因为是减少一个元素</span>            <span class="token comment" spellcheck="true">// 2. 从 0 拷贝到数组新位置</span>            <span class="token comment" spellcheck="true">// 3. 从新位置拷贝到数组尾部</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>步骤分为三步：</p><ol><li>加锁；</li><li>判断删除索引的位置，从而进行不同策略的拷贝；</li><li>解锁。</li></ol><p>代码整体的结构风格也比较统一：锁 + try finally +数组拷贝，锁被 final 修饰的，保证了在加锁过程中，锁的内存地址肯定不会被修改，finally 保证锁一定能够被释放，数组拷贝是为了删除其中某个位置的元素。</p><h4 id="3-1-4-批量删除"><a href="#3-1-4-批量删除" class="headerlink" title="3.1.4-批量删除"></a>3.1.4-批量删除</h4><p>数组的批量删除很有意思，接下来我们来看下 CopyOnWriteArrayList 的批量删除的实现过程：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 批量删除包含在 c 中的元素</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 说明数组有值，数组无值直接返回 false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// newlen 表示新数组的索引位置，新数组中存在不包含在 c 中的元素</span>            <span class="token keyword">int</span> newlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 循环，把不包含在 c 里面的元素，放到新数组中</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Object element <span class="token operator">=</span> elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 不包含在 c 中的元素，从 0 开始放到新数组中</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span>                    temp<span class="token punctuation">[</span>newlen<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 拷贝新数组，变相的删除了不包含在 c 中的元素</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>newlen <span class="token operator">!=</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setArray</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> newlen<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从源码中，我们可以看到，我们并不会直接对数组中的元素进行挨个删除，而是先对数组中的值进行循环判断，把我们不需要删除的数据放到临时数组中，最后临时数组中的数据就是我们不需要删除的数据。</p><p>不知道大家有木有似曾相识的感觉，ArrayList 的批量删除的思想也是和这个类似的，所以我们在需要删除多个元素的时候，最好都使用这种批量删除的思想，而不是采用在 for 循环中使用单个删除的方法，单个删除的话，在每次删除的时候都会进行一次数组拷贝(删除最后一个元素时不会拷贝)，很消耗性能，也耗时，会导致加锁时间太长，并发大的情况下，会造成大量请求在等待锁，这也会占用一定的内存。</p><h4 id="3-1-5-其他方法"><a href="#3-1-5-其他方法" class="headerlink" title="3.1.5-其他方法"></a>3.1.5-其他方法</h4><h5 id="1-indexOf"><a href="#1-indexOf" class="headerlink" title="1.indexOf"></a>1.indexOf</h5><p>indexOf 方法的主要用处是查找元素在数组中的下标位置，如果元素存在就返回元素的下标位置，元素不存在的话返回 -1，不但支持 null 值的搜索，还支持正向和反向的查找，我们以正向查找为例，通过源码来说明一下其底层的实现方式：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// o：我们需要搜索的元素</span><span class="token comment" spellcheck="true">// elements：我们搜索的目标数组</span><span class="token comment" spellcheck="true">// index：搜索的开始位置</span><span class="token comment" spellcheck="true">// fence：搜索的结束位置</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">,</span>                           <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> fence<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 支持对 null 的搜索</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fence<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 找到第一个 null 值，返回下标索引的位置</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 通过 equals 方法来判断元素是否相等</span>        <span class="token comment" spellcheck="true">// 如果相等，返回元素的下标位置</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fence<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>indexOf 方法在 CopyOnWriteArrayList 内部使用也比较广泛，比如在判断元素是否存在时（contains），在删除元素方法中校验元素是否存在时，都会使用到 indexOf 方法，indexOf 方法通过一次 for 循环来查找元素，我们在调用此方法时，需要注意如果找不到元素时，返回的是 -1，所以有可能我们会对这个特殊值进行判断。</p><h5 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2.迭代"></a>2.迭代</h5><p>在 CopyOnWriteArrayList 类注释中，明确说明了，在其迭代过程中，即使数组的原值被改变，也不会抛出 ConcurrentModificationException 异常，其根源在于数组的每次变动，都会生成新的数组，不会影响老数组，这样的话，迭代过程中，根本就不会发生迭代数组的变动，我们截几个图说明一下：</p><ol><li><p>迭代是直接持有原有数组的引用，也就是说迭代过程中，一旦原有数组的值内存地址发生变化，必然会影响到迭代过程，下图源码演示的是 CopyOnWriteArrayList 的迭代方法，我们可以看到迭代器是直接持有原数组的引用：</p><p>![CopyOnWriteArrayList 的迭代方法](CopyOnWriteArrayList 的迭代方法.jpeg)</p></li><li><p>我们写了一个 demo，在 CopyOnWriteArrayList 迭代之后，往 CopyOnWriteArrayList 里面新增值，从下图中可以看到在 CopyOnWriteArrayList 迭代之前，数组的内存地址是 962，请记住这个数字：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/testIterator.jpeg" alt="testIterator"></p></li><li><p>CopyOnWriteArrayList 迭代之后，我们使用 add(“50”) 代码给数组新增一个数据后，数组内存地址发生了变化，内存地址从原来的 962 变成了 968，这是因为 CopyOnWriteArrayList 的 add 操作，会生成新的数组，所以数组的内存地址发生了变化：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/testIterator2.jpeg" alt="testIterator2"></p></li><li><p>迭代继续进行时，我们发现迭代器中的地址仍然是迭代之前引用的地址，是 962，而不是新的数组的内存地址：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/testIterator3.jpeg" alt="testIterator3"></p></li></ol><p>从上面 4 张截图，我们可以得到迭代过程中，即使 CopyOnWriteArrayList 的结构发生变动了，也不会抛出 ConcurrentModificationException 异常的原因：CopyOnWriteArrayList 迭代持有的是老数组的引用，而 CopyOnWriteArrayList 每次的数据变动，都会产生新的数组，对老数组的值不会产生影响，所以迭代也可以正常进行。</p><h4 id="3-1-6-总结"><a href="#3-1-6-总结" class="headerlink" title="3.1.6-总结"></a>3.1.6-总结</h4><p>当我们需要在线程不安全场景下使用 List 时，建议使用 CopyOnWriteArrayList，CopyOnWriteArrayList 通过锁 + 数组拷贝 + volatile 之间的相互配合，实现了 List 的线程安全，我们抛弃 Java 的这种实现，如果让我们自己实现，你又将如何实现呢？</p><h3 id="3-2-ConcurrentHashMap-源码解析和设计思路"><a href="#3-2-ConcurrentHashMap-源码解析和设计思路" class="headerlink" title="3.2-ConcurrentHashMap 源码解析和设计思路"></a>3.2-ConcurrentHashMap 源码解析和设计思路</h3><p>当我们碰到线程不安全场景下，需要使用 Map 的时候，我们第一个想到的 API 估计就是 ConcurrentHashMap，ConcurrentHashMap 内部封装了锁和各种数据结构来保证访问 Map 是线程安全的，接下来我们一一来看下，和 HashMap 相比，多了哪些数据结构，又是如何保证线程安全的。</p><h4 id="3-2-1-类注释"><a href="#3-2-1-类注释" class="headerlink" title="3.2.1-类注释"></a>3.2.1-类注释</h4><p>我们从类注释上大概可以得到如下信息：</p><ol><li>所有的操作都是线程安全的，我们在使用时，无需再加锁；</li><li>多个线程同时进行 put、remove 等操作时并不会阻塞，可以同时进行，和 HashTable 不同，HashTable 在操作时，会锁住整个 Map；</li><li>迭代过程中，即使 Map 结构被修改，也不会抛 ConcurrentModificationException 异常；</li><li>除了数组 + 链表 + 红黑树的基本结构外，新增了转移节点，是为了保证扩容时的线程安全的节点；</li><li>提供了很多 Stream 流式方法，比如说：forEach、search、reduce 等等。</li></ol><p>从类注释中，我们可以看出 ConcurrentHashMap 和 HashMap 相比，新增了转移节点的数据结构，至于底层如何实现线程安全，转移节点的具体细节，暂且看不出来，接下来我们细看源码。</p><h4 id="3-2-2-结构"><a href="#3-2-2-结构" class="headerlink" title="3.2.2-结构"></a>3.2.2-结构</h4><p>虽然 ConcurrentHashMap 的底层数据结构，和方法的实现细节和 HashMap 大体一致，但两者在类结构上却没有任何关联，我们看下 ConcurrentHashMap 的类图：</p><p>![ConcurrentHashMap 的类图](ConcurrentHashMap 的类图.jpeg)</p><p>看 ConcurrentHashMap 源码，我们会发现很多方法和代码和 HashMap 很相似，有的同学可能会问，为什么不继承 HashMap 呢？继承的确是个好办法，但尴尬的是，ConcurrentHashMap 都是在方法中间进行一些加锁操作，也就是说加锁把方法切割了，继承就很难解决这个问题。</p><p>ConcurrentHashMap 和 HashMap 两者的相同之处：</p><ol><li>数组、链表结构几乎相同，所以底层对数据结构的操作思路是相同的（只是思路相同，底层实现不同）；</li><li>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以大多数的方法也都是相同的，HashMap 有的方法，ConcurrentHashMap 几乎都有，所以当我们需要从 HashMap 切换到 ConcurrentHashMap 时，无需关心两者之间的兼容问题。</li></ol><p>不同之处：</p><ol><li>红黑树结构略有不同，HashMap 的红黑树中的节点叫做 TreeNode，TreeNode 不仅仅有属性，还维护着红黑树的结构，比如说查找，新增等等；ConcurrentHashMap 中红黑树被拆分成两块，TreeNode 仅仅维护的属性和查找功能，新增了 TreeBin，来维护红黑树结构，并负责根节点的加锁和解锁；</li><li>新增 ForwardingNode （转移）节点，扩容的时候会使用到，通过使用该节点，来保证扩容时的线程安全。</li></ol><h4 id="3-2-3-put"><a href="#3-2-3-put" class="headerlink" title="3.2.3-put"></a>3.2.3-put</h4><p>ConcurrentHashMap 在 put 方法上的整体思路和 HashMap 相同，但在线程安全方面写了很多保障的代码，我们先来看下大体思路：</p><ol><li>如果数组为空，初始化，初始化完成之后，走 2；</li><li>计算当前槽点有没有值，没有值的话，cas 创建，失败继续自旋（for 死循环），直到成功，槽点有值的话，走 3；</li><li>如果槽点是转移节点(正在扩容)，就会一直自旋等待扩容完成之后再新增，不是转移节点走 4；</li><li>槽点有值的，先锁定当前槽点，保证其余线程不能操作，如果是链表，新增值到链表的尾部，如果是红黑树，使用红黑树新增的方法新增；</li><li>新增完成之后 check 需不需要扩容，需要的话去扩容。</li></ol><p>具体源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">||</span> value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//计算hash</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//table是空的，进行初始化</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果当前索引位置没有值，直接创建</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//cas 在 i 位置创建新的元素，当 i 位置是空时，即能创建成功，结束for自循，否则继续自旋</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span>                         <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// no lock when adding to empty bin</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果当前槽点是转移节点，表示该槽点正在扩容，就会一直等待扩容完成</span>        <span class="token comment" spellcheck="true">//转移节点的 hash 值是固定的，都是 MOVED</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>            tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//槽点上有值的</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            V oldVal <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//锁定当前槽点，其余线程不能操作，保证了安全</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//这里再次判断 i 索引位置的数据没有被修改</span>                <span class="token comment" spellcheck="true">//binCount 被赋值的话，说明走到了修改表的过程里面</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//链表</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            K ek<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//值有的话，直接返回</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>                                 <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                    e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">//把新增的元素赋值到链表的最后，退出自旋</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>                                                          value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">//红黑树，这里没有使用 TreeNode,使用的是 TreeBin，TreeNode 只是红黑树的一个节点</span>                    <span class="token comment" spellcheck="true">//TreeBin 持有红黑树的引用，并且会对其加锁，保证其操作的线程安全</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>                        binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">//满足if的话，把老的值给oldVal</span>                        <span class="token comment" spellcheck="true">//在putTreeVal方法里面，在给红黑树重新着色旋转的时候</span>                        <span class="token comment" spellcheck="true">//会锁住红黑树的根节点</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>                                                       value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>                                p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//binCount不为空，并且 oldVal 有值的情况，说明已经新增成功了</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 链表是否需要转化成红黑树</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD<span class="token punctuation">)</span>                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//这一步几乎走不到。槽点已经上锁，只有在红黑树或者链表新增失败的时候</span>                <span class="token comment" spellcheck="true">//才会走到这里，这两者新增都是自旋的，几乎不会失败</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//check 容器是否需要扩容，如果需要去扩容，调用 transfer 方法去扩容</span>    <span class="token comment" spellcheck="true">//如果已经在扩容中了，check有无完成</span>    <span class="token function">addCount</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>源码中都有非常详细的注释，就不解释了，我们重点说一下，ConcurrentHashMap 在 put 过程中，采用了哪些手段来保证线程安全。</p><h5 id="1-数组初始化时的线程安全"><a href="#1-数组初始化时的线程安全" class="headerlink" title="1.数组初始化时的线程安全"></a>1.数组初始化时的线程安全</h5><p>数组初始化时，首先通过自旋来保证一定可以初始化成功，然后通过 CAS 设置 SIZECTL 变量的值，来保证同一时刻只能有一个线程对数组进行初始化，CAS 成功之后，还会再次判断当前数组是否已经初始化完成，如果已经初始化完成，就不会再次初始化，通过自旋 + CAS + 双重 check 等手段保证了数组初始化时的线程安全，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//初始化 table，通过对 sizeCtl 的变量赋值来保证数组只能被初始化一次</span><span class="token keyword">private</span> <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过自旋保证初始化成功</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 小于 0 代表有线程正在初始化，释放当前 CPU 的调度权，重新发起锁的竞争</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lost initialization race; just spin</span>        <span class="token comment" spellcheck="true">// CAS 赋值保证当前只有一个线程在初始化，-1 代表当前只有一个线程能初始化</span>        <span class="token comment" spellcheck="true">// 保证了数组的初始化的安全性</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 很有可能执行到这里的时候，table 已经不为空了，这里是双重 check</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 进行初始化</span>                    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>                    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>                    table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>                    sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> tab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-新增槽点值时的线程安全"><a href="#2-新增槽点值时的线程安全" class="headerlink" title="2.新增槽点值时的线程安全"></a>2.新增槽点值时的线程安全</h5><p>此时为了保证线程安全，做了四处优化：</p><ol><li>通过自旋死循环保证一定可以新增成功。</li></ol><p>在新增之前，通过 <code>for (Node[] tab = table;;)</code> 这样的死循环来保证新增一定可以成功，一旦新增成功，就可以退出当前死循环，新增失败的话，会重复新增的步骤，直到新增成功为止。</p><ol start="2"><li>当前槽点为空时，通过 CAS 新增。</li></ol><p>Java 这里的写法非常严谨，没有在判断槽点为空的情况下直接赋值，因为在判断槽点为空和赋值的瞬间，很有可能槽点已经被其他线程赋值了，所以我们采用 CAS 算法，能够保证槽点为空的情况下赋值成功，如果恰好槽点已经被其他线程赋值，当前 CAS 操作失败，会再次执行 for 自旋，再走槽点有值的 put 流程，这里就是自旋 + CAS 的结合。</p><ol start="3"><li>当前槽点有值，锁住当前槽点。</li></ol><p>put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树，我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改，截图如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ConcurrentHashMap-hash%E5%86%B2%E7%AA%81.jpeg" alt="ConcurrentHashMap-hash冲突"></p><ol start="4"><li><p>红黑树旋转时，锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转。</p><p>代码截图如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ConcurrentHashMap-%E9%94%81%E4%BD%8F%E7%BA%A2%E9%BB%91%E6%A0%91.jpeg" alt="ConcurrentHashMap-锁住红黑树"></p></li></ol><p>通过以上 4 点，保证了在各种情况下的新增（不考虑扩容的情况下），都是线程安全的，通过自旋 + CAS + 锁三大姿势，实现的很巧妙，值得我们借鉴。</p><h5 id="3-扩容时的线程安全"><a href="#3-扩容时的线程安全" class="headerlink" title="3.扩容时的线程安全"></a>3.扩容时的线程安全</h5><p>ConcurrentHashMap 的扩容时机和 HashMap 相同，都是在 put 方法的最后一步检查是否需要扩容，如果需要则进行扩容，但两者扩容的过程完全不同，ConcurrentHashMap 扩容的方法叫做 transfer，从 put 方法的 addCount 方法进去，就能找到 transfer 方法，transfer 方法的主要思路是：</p><ol><li>首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝；</li><li>拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时，把原数组槽点赋值为转移节点；</li><li>这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在扩容完成之前，该槽点对应的数据是不会发生变化的；</li><li>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点；</li><li>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。</li></ol><p>关键源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 扩容主要分 2 步，第一新建新的空数组，第二移动拷贝每个元素到新数组中去</span><span class="token comment" spellcheck="true">// tab：原数组，nextTab：新数组</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 老数组的长度</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">,</span> stride<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span>NCPU <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> NCPU <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TRANSFER_STRIDE<span class="token punctuation">)</span>        stride <span class="token operator">=</span> MIN_TRANSFER_STRIDE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// subdivide range</span>    <span class="token comment" spellcheck="true">// 如果新数组为空，初始化，大小为原数组的两倍，n &lt;&lt; 1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// initiating</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            nextTab <span class="token operator">=</span> nt<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// try to cope with OOME</span>            sizeCtl <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        nextTable <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>        transferIndex <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 新数组的长度</span>    <span class="token keyword">int</span> nextn <span class="token operator">=</span> nextTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 代表转移节点，如果原数组上是转移节点，说明该节点正在被扩容</span>    ForwardingNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> finishing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// to ensure sweep before committing nextTab</span>    <span class="token comment" spellcheck="true">// 无限自旋，i 的值会从原数组的最大值开始，慢慢递减到 0</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> fh<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>advance<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> nextIndex<span class="token punctuation">,</span> nextBound<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 结束循环的标志</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>i <span class="token operator">>=</span> bound <span class="token operator">||</span> finishing<span class="token punctuation">)</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 已经拷贝完成</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextIndex <span class="token operator">=</span> transferIndex<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 每次减少 i 的值</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span>                     <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> TRANSFERINDEX<span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span>                      nextBound <span class="token operator">=</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">></span> stride <span class="token operator">?</span>                                   nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                bound <span class="token operator">=</span> nextBound<span class="token punctuation">;</span>                i <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// if 任意条件满足说明拷贝结束了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> n <span class="token operator">||</span> i <span class="token operator">+</span> n <span class="token operator">>=</span> nextn<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> sc<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 拷贝结束，直接赋值，因为每次拷贝完一个节点，都在原数组上放转移节点，所以拷贝完成的节点的数据一定不会再发生变化。</span>            <span class="token comment" spellcheck="true">// 原数组发现是转移节点，是不会操作的，会一直等待转移节点消失之后在进行操作。</span>            <span class="token comment" spellcheck="true">// 也就是说数组节点一旦被标记为转移节点，是不会再发生任何变动的，所以不会有任何线程安全的问题</span>            <span class="token comment" spellcheck="true">// 所以此处直接赋值，没有任何问题。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>finishing<span class="token punctuation">)</span> <span class="token punctuation">{</span>                nextTable <span class="token operator">=</span> null<span class="token punctuation">;</span>                table <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>                sizeCtl <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">,</span> sc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                finishing <span class="token operator">=</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// recheck before commit</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            advance <span class="token operator">=</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>            advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// already processed</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 进行节点的拷贝</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> ln<span class="token punctuation">,</span> hn<span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> runBit <span class="token operator">=</span> fh <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lastRun <span class="token operator">=</span> f<span class="token punctuation">;</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> runBit<span class="token punctuation">)</span> <span class="token punctuation">{</span>                                runBit <span class="token operator">=</span> b<span class="token punctuation">;</span>                                lastRun <span class="token operator">=</span> p<span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>runBit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            ln <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                            hn <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            hn <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>                            ln <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 如果节点只有单个数据，直接拷贝，如果是链表，循环多次组成链表拷贝</span>                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span> K pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span> V pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                                ln <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 在新数组位置上放置拷贝的值</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 在老数组位置上放上 ForwardingNode 节点</span>                        <span class="token comment" spellcheck="true">// put 时，发现是 ForwardingNode 节点，就不会再动这个节点的数据了</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 红黑树的拷贝</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 红黑树的拷贝工作，同 HashMap 的内容，代码忽略</span>                        …………                        <span class="token comment" spellcheck="true">// 在老数组位置上放上 ForwardingNode 节点</span>                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>扩容中的关键点，就是如何保证是线程安全的，小结有如下几点：</p><ol><li>拷贝槽点时，会把原数组的槽点锁住；</li><li>拷贝成功之后，会把原数组的槽点设置成转移节点，这样如果有数据需要 put 到该节点时，发现该槽点是转移节点，会一直等待，直到扩容成功之后，才能继续 put，可以参考 put 方法中的 helpTransfer 方法；</li><li>从尾到头进行拷贝，拷贝成功就把原数组的槽点设置成转移节点。</li><li>等扩容拷贝都完成之后，直接把新数组的值赋值给数组容器，之前等待 put 的数据才能继续 put。</li></ol><p>扩容方法还是很有意思的，通过在原数组上设置转移节点，put 时碰到转移节点时会等待扩容成功之后才能 put 的策略，来保证了整个扩容过程中肯定是线程安全的，因为数组的槽点一旦被设置成转移节点，在没有扩容完成之前，是无法进行操作的。</p><h4 id="3-2-4-get"><a href="#3-2-4-get" class="headerlink" title="3.2.4-get"></a>3.2.4-get</h4><p>ConcurrentHashMap 读的话，就比较简单，先获取数组的下标，然后通过判断数组下标的 key 是否和我们的 key 相等，相等的话直接返回，如果下标的槽点是链表或红黑树的话，分别调用相应的查找数据的方法，整体思路和 HashMap 很像，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">,</span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> eh<span class="token punctuation">;</span> K ek<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//计算hashcode</span>    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不是空的数组 &amp;&amp; 并且当前索引的槽点数据不是空的</span>    <span class="token comment" spellcheck="true">//否则该key对应的值不存在，返回null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//槽点第一个值和key相等，直接返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果是红黑树或者转移节点，使用对应的find方法</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span> p<span class="token punctuation">.</span>val <span class="token operator">:</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果是链表，遍历查找</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5-总结"></a>3.2.5-总结</h4><p>本文摘取 ConcurrentHashMap 两个核心的方法讲解了一下，特别是 put 方法，采取了很多手段来保证了线程安全，是平时面试时的重中之重，大家可以尝试 debug 来调试一下源码，其他方法感兴趣的话，可以尝试去 GitHub 上去查看源码。</p><h3 id="3-3-并发-List、Map源码面试题"><a href="#3-3-并发-List、Map源码面试题" class="headerlink" title="3.3-并发 List、Map源码面试题"></a>3.3-并发 List、Map源码面试题</h3><p>并发 List 和 Map 是技术面时常问的问题，问的问题也都比较深入，有很多问题都是面试官自创的，市面上找不到，所以说通过背题的方式，这一关大部分是过不了的，只有我们真正理解了 API 内部的实现，阅读过源码，才能自如应对各种类型的面试题，接着我们来看一下并发 List、Map 源码相关的面试题集。</p><h4 id="3-3-1-CopyOnWriteArrayList-相关"><a href="#3-3-1-CopyOnWriteArrayList-相关" class="headerlink" title="3.3.1-CopyOnWriteArrayList 相关"></a>3.3.1-CopyOnWriteArrayList 相关</h4><h5 id="1-CopyOnWriteArrayList-和-ArrayList-相比有哪些相同点和不同点？"><a href="#1-CopyOnWriteArrayList-和-ArrayList-相比有哪些相同点和不同点？" class="headerlink" title="1.CopyOnWriteArrayList 和 ArrayList 相比有哪些相同点和不同点？"></a>1.CopyOnWriteArrayList 和 ArrayList 相比有哪些相同点和不同点？</h5><p>答：相同点：底层的数据结构是相同的，都是数组的数据结构，提供出来的 API 都是对数组结构进行操作，让我们更好的使用。</p><p>不同点：后者是线程安全的，在多线程环境下使用，无需加锁，可直接使用。</p><h5 id="2-CopyOnWriteArrayList-通过哪些手段实现了线程安全？"><a href="#2-CopyOnWriteArrayList-通过哪些手段实现了线程安全？" class="headerlink" title="2.CopyOnWriteArrayList 通过哪些手段实现了线程安全？"></a>2.CopyOnWriteArrayList 通过哪些手段实现了线程安全？</h5><p>答：主要有：1. 数组容器被 volatile 关键字修饰，保证了数组内存地址被任意线程修改后，都会通知到其他线程；</p><ol><li>对数组的所有修改操作，都进行了加锁，保证了同一时刻，只能有一个线程对数组进行修改，比如我在 add 时，就无法 remove；</li><li>修改过程中对原数组进行了复制，是在新数组上进行修改的，修改过程中，不会对原数组产生任何影响。</li></ol><p>通过以上三点保证了线程安全。</p><h5 id="3-在-add-方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？"><a href="#3-在-add-方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？" class="headerlink" title="3.在 add 方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？"></a>3.在 add 方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？</h5><p>答：的确，对数组进行加锁后，能够保证同一时刻，只有一个线程能对数组进行 add，在同单核 CPU 下的多线程环境下肯定没有问题，但我们现在的机器都是多核 CPU，如果我们不通过复制拷贝新建数组，修改原数组容器的内存地址的话，是无法触发 volatile 可见性效果的，那么其他 CPU 下的线程就无法感知数组原来已经被修改了，就会引发多核 CPU 下的线程安全问题。</p><p>假设我们不复制拷贝，而是在原来数组上直接修改值，数组的内存地址就不会变，而数组被 volatile 修饰时，必须当数组的内存地址变更时，才能及时的通知到其他线程，内存地址不变，仅仅是数组元素值发生变化时，是无法把数组元素值发生变动的事实，通知到其它线程的。</p><h5 id="4-对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？"><a href="#4-对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？" class="headerlink" title="4.对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？"></a>4.对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？</h5><p>答：主要有：</p><ol><li>在批量操作时，尽量使用 addAll、removeAll 方法，而不要在循环里面使用 add、remove 方法，主要是因为 for 循环里面使用 add 、remove 的方式，在每次操作时，都会进行一次数组的拷贝(甚至多次)，非常耗性能，而 addAll、removeAll 方法底层做了优化，整个操作只会进行一次数组拷贝，由此可见，当批量操作的数据越多时，批量方法的高性能体现的越明显。</li></ol><h5 id="5-为什么-CopyOnWriteArrayList-迭代过程中，数组结构变动，不会抛出ConcurrentModificationException-了"><a href="#5-为什么-CopyOnWriteArrayList-迭代过程中，数组结构变动，不会抛出ConcurrentModificationException-了" class="headerlink" title="5.为什么 CopyOnWriteArrayList 迭代过程中，数组结构变动，不会抛出ConcurrentModificationException 了"></a>5.为什么 CopyOnWriteArrayList 迭代过程中，数组结构变动，不会抛出ConcurrentModificationException 了</h5><p>答：主要是因为 CopyOnWriteArrayList 每次操作时，都会产生新的数组，而迭代时，持有的仍然是老数组的引用，所以我们说的数组结构变动，是用新数组替换了老数组，老数组的结构并没有发生变化，所以不会抛出异常了。</p><h5 id="6-插入的数据正好在-List-的中间，请问两种-List-分别拷贝数组几次？为什么？"><a href="#6-插入的数据正好在-List-的中间，请问两种-List-分别拷贝数组几次？为什么？" class="headerlink" title="6.插入的数据正好在 List 的中间，请问两种 List 分别拷贝数组几次？为什么？"></a>6.插入的数据正好在 List 的中间，请问两种 List 分别拷贝数组几次？为什么？</h5><p>答：ArrayList 只需拷贝一次，假设插入的位置是 2，只需要把位置 2 （包含 2）后面的数据都往后移动一位即可，所以拷贝一次。</p><p>CopyOnWriteArrayList 拷贝两次，因为 CopyOnWriteArrayList 多了把老数组的数据拷贝到新数组上这一步，可能有的同学会想到这种方式：先把老数组拷贝到新数组，再把 2 后面的数据往后移动一位，这的确是一种拷贝的方式，但 CopyOnWriteArrayList 底层实现更加灵活，而是：把老数组 0 到 2 的数据拷贝到新数组上，预留出新数组 2 的位置，再把老数组 3～ 最后的数据拷贝到新数组上，这种拷贝方式可以减少我们拷贝的数据，虽然是两次拷贝，但拷贝的数据却仍然是老数组的大小，设计的非常巧妙。</p><h4 id="3-3-2-ConcurrentHashMap-相关"><a href="#3-3-2-ConcurrentHashMap-相关" class="headerlink" title="3.3.2-ConcurrentHashMap 相关"></a>3.3.2-ConcurrentHashMap 相关</h4><h5 id="1-ConcurrentHashMap-和-HashMap-的相同点和不同点"><a href="#1-ConcurrentHashMap-和-HashMap-的相同点和不同点" class="headerlink" title="1.ConcurrentHashMap 和 HashMap 的相同点和不同点"></a>1.ConcurrentHashMap 和 HashMap 的相同点和不同点</h5><p>答：</p><p>相同点：</p><ul><li>都是数组 + 链表 +红黑树的数据结构，所以基本操作的思想相同；</li><li>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以两者的方法大多都是相似的，可以互相切换。</li></ul><p>不同点：</p><ul><li>ConcurrentHashMap 是线程安全的，在多线程环境下，无需加锁，可直接使用；</li><li>数据结构上，ConcurrentHashMap 多了转移节点，主要用于保证扩容时的线程安全。</li></ul><h5 id="2-ConcurrentHashMap-通过哪些手段保证了线程安全。"><a href="#2-ConcurrentHashMap-通过哪些手段保证了线程安全。" class="headerlink" title="2.ConcurrentHashMap 通过哪些手段保证了线程安全。"></a>2.ConcurrentHashMap 通过哪些手段保证了线程安全。</h5><p>答：主要有以下几点：</p><ol><li>储存 Map 数据的数组被 volatile 关键字修饰，一旦被修改，立马就能通知其他线程，因为是数组，所以需要改变其内存值，才能真正的发挥出 volatile 的可见特性；</li><li>put 时，如果计算出来的数组下标索引没有值的话，采用无限 for 循环 + CAS 算法，来保证一定可以新增成功，又不会覆盖其他线程 put 进去的值；</li><li>如果 put 的节点正好在扩容，会等待扩容完成之后，再进行 put ，保证了在扩容时，老数组的值不会发生变化；</li><li>对数组的槽点进行操作时，会先锁住槽点，保证只有当前线程才能对槽点上的链表或红黑树进行操作；</li><li>红黑树旋转时，会锁住根节点，保证旋转时的线程安全。</li></ol><h5 id="3-描述一下-CAS-算法在-ConcurrentHashMap-中的应用？"><a href="#3-描述一下-CAS-算法在-ConcurrentHashMap-中的应用？" class="headerlink" title="3.描述一下 CAS 算法在 ConcurrentHashMap 中的应用？"></a>3.描述一下 CAS 算法在 ConcurrentHashMap 中的应用？</h5><p>答：CAS 其实是一种乐观锁，一般有三个值，分别为：赋值对象，原值，新值，在执行的时候，会先判断内存中的值是否和原值相等，相等的话把新值赋值给对象，否则赋值失败，整个过程都是原子性操作，没有线程安全问题。</p><p>ConcurrentHashMap 的 put 方法中，有使用到 CAS ，是结合无限 for 循环一起使用的，步骤如下：</p><ol><li>计算出数组索引下标，拿出下标对应的原值；</li><li>CAS 覆盖当前下标的值，赋值时，如果发现内存值和 1 拿出来的原值相等，执行赋值，退出循环，否则不赋值，转到 3；</li><li>进行下一次 for 循环，重复执行 1，2，直到成功为止。</li></ol><p>可以看到这样做的好处，第一是不会盲目的覆盖原值，第二是一定可以赋值成功。</p><h5 id="4-ConcurrentHashMap-是如何发现当前槽点正在扩容的。"><a href="#4-ConcurrentHashMap-是如何发现当前槽点正在扩容的。" class="headerlink" title="4.ConcurrentHashMap 是如何发现当前槽点正在扩容的。"></a>4.ConcurrentHashMap 是如何发现当前槽点正在扩容的。</h5><p>答：ConcurrentHashMap 新增了一个节点类型，叫做转移节点，当我们发现当前槽点是转移节点时（转移节点的 hash 值是 -1），即表示 Map 正在进行扩容。</p><h5 id="5-发现槽点正在扩容时，put-操作会怎么办？"><a href="#5-发现槽点正在扩容时，put-操作会怎么办？" class="headerlink" title="5.发现槽点正在扩容时，put 操作会怎么办？"></a>5.发现槽点正在扩容时，put 操作会怎么办？</h5><p>答：无限 for 循环，或者走到扩容方法中去，帮助扩容，一直等待扩容完成之后，再执行 put 操作。</p><h5 id="6-两种-Map-扩容时，有啥区别？"><a href="#6-两种-Map-扩容时，有啥区别？" class="headerlink" title="6.两种 Map 扩容时，有啥区别？"></a>6.两种 Map 扩容时，有啥区别？</h5><p>答：区别很大，HashMap 是直接在老数据上面进行扩容，多线程环境下，会有线程安全的问题，而 ConcurrentHashMap 就不太一样，扩容过程是这样的：</p><ol><li>从数组的队尾开始拷贝；</li><li>拷贝数组的槽点时，先把原数组槽点锁住，拷贝成功到新数组时，把原数组槽点赋值为转移节点；</li><li>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组的槽点设置成转移节点；</li><li>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。</li></ol><p>简单来说，通过扩容时给槽点加锁，和发现槽点正在扩容就等待的策略，保证了 ConcurrentHashMap 可以慢慢一个一个槽点的转移，保证了扩容时的线程安全，转移节点比较重要，平时问的人也比较多。</p><h5 id="7-ConcurrentHashMap-在-Java-7-和-8-中关于线程安全的做法有啥不同？"><a href="#7-ConcurrentHashMap-在-Java-7-和-8-中关于线程安全的做法有啥不同？" class="headerlink" title="7.ConcurrentHashMap 在 Java 7 和 8 中关于线程安全的做法有啥不同？"></a>7.ConcurrentHashMap 在 Java 7 和 8 中关于线程安全的做法有啥不同？</h5><p>答：非常不一样，拿 put 方法为例，Java 7 的做法是：</p><ol><li>把数组进行分段，找到当前 key 对应的是那一段；</li><li>将当前段锁住，然后再根据 hash 寻找对应的值，进行赋值操作。</li></ol><p>Java 7 的做法比较简单，缺点也很明显，就是当我们需要 put 数据时，我们会锁住改该数据对应的某一段，这一段数据可能会有很多，比如我只想 put 一个值，锁住的却是一段数据，导致这一段的其他数据都不能进行写入操作，大大的降低了并发性的效率。Java 8 解决了这个问题，从锁住某一段，修改成锁住某一个槽点，提高了并发效率。</p><p>不仅仅是 put，删除也是，仅仅是锁住当前槽点，缩小了锁的范围，增大了效率。</p><h4 id="3-3-3-总结"><a href="#3-3-3-总结" class="headerlink" title="3.3.3-总结"></a>3.3.3-总结</h4><p>因为目前大多数公司都已经在使用 Java 8 了，所以大部分面试内容还是以 Java 8 的 API 为主，特别是 CopyOnWriteArrayList 和 ConcurrentHashMap 两个 API，文章毕竟篇幅有限，建议大家多多阅读剩余源码。</p><h3 id="3-4-场景集合：并发-List、Map的应用场景"><a href="#3-4-场景集合：并发-List、Map的应用场景" class="headerlink" title="3.4-场景集合：并发 List、Map的应用场景"></a>3.4-场景集合：并发 List、Map的应用场景</h3><p>并发 List、Map 使用最多的就是 CopyOnWriteArrayList 和 ConcurrentHashMap，在考虑 API 时，我们也无需迟疑，这两个并发类在安全和性能方面都很好，我们都可以直接使用。</p><p>并发的场景很多，但归根结底其实就是共享变量被多个线程同时访问，也就是说 CopyOnWriteArrayList 或 ConcurrentHashMap 会被作为共享变量，本节我们会以流程引擎为案例，现身说法，增加一下大家的工作经验积累。</p><p>流程引擎在实际工作中经常被使用，其主要功能就是对我们需要完成的事情，进行编排和组装，比如在淘宝下单流程中，我们一共会执行 20 个 Spring Bean，流程引擎就可以帮助我们调起 20 个 Spring Bean，并帮助我们去执行，本文介绍的重点在于如何使用 Map + List 来设计流程引擎的数据结构，以及其中需要注意到的线程安全的问题。</p><h4 id="3-4-1-嵌套-Map，简单流程引擎"><a href="#3-4-1-嵌套-Map，简单流程引擎" class="headerlink" title="3.4.1-嵌套 Map，简单流程引擎"></a>3.4.1-嵌套 Map，简单流程引擎</h4><p>市面上有很多流程引擎，比如说 Activiti、Flowable、Camunda 等等，功能非常齐全，但我们本小节只实现一种最最简单的流程引擎，只要能对我们需要完成的事情进行编排，并能依次的调用就行。</p><h5 id="1-流程引擎设计思路"><a href="#1-流程引擎设计思路" class="headerlink" title="1.流程引擎设计思路"></a>1.流程引擎设计思路</h5><p>我们认为每个流程都会做 4 个阶段的事情，阶段主要是指在整个流程中，大概可以分为几个大的步骤，每个阶段可以等同为大的步骤，分别如下：</p><ol><li>参数校验，主要是对流程的入参数进行校验；</li><li>业务校验，主要是对当前流程中的业务进行逻辑校验；</li><li>事务中落库，主要把数据落库，控制事务；</li><li>事务后事件，我们在数据落库，事务提交之后，可能会做一些其他事情，比如说发消息出来等等。</li></ol><p>以上每个大的阶段，都会做一些粒度较细的事情，比如说业务校验，我们可能会对两个业务对象进行校验，那么此时业务校验阶段就会做两件事情，每件具体的事情，我们叫做领域行为，在实际项目中，一个领域行为一般都是一个 Spring Bean。</p><p>综上所述，流程引擎嵌套数据结构就是：流程 -&gt; 阶段 -&gt; 领域行为，前者对应后者，都是一对一或者一对多的关系。</p><p>我们以在淘宝上买东西时，下单为例，下单指的是我们在淘宝选择好了商品和优惠券后，点击购买按钮时触发的动作。</p><p>为了方便举例，我们假设在淘宝上买电视和电影票，在后端，会分别对应着两个下单流程，我们画图示意一下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E6%B7%98%E5%AE%9D%E4%B8%8B%E5%8D%95%E6%B5%81%E7%A8%8B.jpeg" alt="淘宝下单流程"></p><p>上图中，左右两个黑色长方形大框代表着两个流程，流程下面有多个阶段，阶段用蓝色表示，每个阶段下面有多个领域行为，用红色表示。</p><p>可以看到两个流程中，都包含有四个阶段，阶段都是相同的，但每个阶段中的领域行为，有的相同，有的却是特有的。</p><p>三个概念，每个概念层层嵌套，整体组装起来，用来表示一个流程，那么这个数据结构，我们应该如何表示呢？</p><p>使用 Map + List 即可！</p><h5 id="2-数据结构的定义"><a href="#2-数据结构的定义" class="headerlink" title="2.数据结构的定义"></a>2.数据结构的定义</h5><p>流程的数据结构定义分成两步：</p><ol><li>定义出阶段、领域行为基础概念；</li><li>把阶段、领域行为、流程概念组合起来，定义出流程的数据结构。</li></ol><p>首先给阶段定义一个枚举，如下 StageEnum 代表流程中的阶段或步骤：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> StageEnum <span class="token punctuation">{</span>  <span class="token function">PARAM_VALID</span><span class="token punctuation">(</span><span class="token string">"PARAM_VALID"</span><span class="token punctuation">,</span> <span class="token string">"参数校验"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">BUSINESS_VALID</span><span class="token punctuation">(</span><span class="token string">"BUSINESS_VALID"</span><span class="token punctuation">,</span> <span class="token string">"业务校验"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">IN_TRANSACTION</span><span class="token punctuation">(</span><span class="token string">"IN_TRANSACTION"</span><span class="token punctuation">,</span> <span class="token string">"事务中落库"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">AFTER_TRANSACTION</span><span class="token punctuation">(</span><span class="token string">"AFTER_TRANSACTION"</span><span class="token punctuation">,</span> <span class="token string">"事务后事件"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">;</span>  <span class="token keyword">private</span> String code<span class="token punctuation">;</span>  <span class="token keyword">private</span> String desc<span class="token punctuation">;</span>  <span class="token function">StageEnum</span><span class="token punctuation">(</span>String code<span class="token punctuation">,</span> String desc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>desc <span class="token operator">=</span> desc<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>领域行为我们无需定义，目前通用的技术框架都是 Spring Boot，领域行为都是 Spring Bean，为了简单起见，我们给领域行为定义了一个接口，每个领域行为都要实现这个接口，方便我们编排，接口如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 领域行为 * author  wenhe * date 2019/8/11 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DomainAbilityBean</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/**   * 领域行为的方法入口   */</span>  FlowContent <span class="token function">invoke</span><span class="token punctuation">(</span>FlowContent content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接着我们使用 Map + List 来定义流程，定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 第一个 key 是流程的名字 * 第二个 map 的 key 是阶段，为 StageEnum 枚举，值为多个领域行为的集合 */</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Map<span class="token operator">&lt;</span>StageEnum<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>DomainAbilityBean<span class="token operator">>>></span> flowMap</code></pre><p>至此，我们定义出了，简单流程引擎的数据结构，流程引擎看着很复杂，利用 Map + List 的组合，就巧妙的定义好了。</p><h4 id="3-4-2-容器初始化时，本地缓存使用"><a href="#3-4-2-容器初始化时，本地缓存使用" class="headerlink" title="3.4.2-容器初始化时，本地缓存使用"></a>3.4.2-容器初始化时，本地缓存使用</h4><p>我们定义好 Map 后，我们就需要去使用他，我们使用的大体步骤为：</p><ol><li>项目启动时，把所有的流程信息初始化到 flowMap(刚刚定义的流程的数据结构叫做 flowMap) 中去，可能是从数据库中加载，也可能是从 xml 文件中加载；</li><li>查找流程时，直接从 flowMap 中获取即可。</li></ol><h5 id="1-初始化-2"><a href="#1-初始化-2" class="headerlink" title="1.初始化"></a>1.初始化</h5><p>以上两步最为关键的点就是 flowMap 必须是可以随时访问到的，所有我们会把 flowMap 作为共享变量使用，也就是会被 static final 关键字所修饰，我们首先来 mock 一下把所有信息初始化到 flowMap 中去的代码，如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowCenter</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/**   * flowMap 是共享变量，方便访问，并且是 ConcurrentHashMap   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>StageEnum<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>DomainAbilityBean<span class="token operator">>>></span> flowMap      <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * PostConstruct 注解的意思就是   * 在容器启动成功之后，执行 init 方法，初始化 flowMap   */</span>  <span class="token annotation punctuation">@PostConstruct</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 初始化 flowMap，可能是从数据库，或者 xml 文件中加载 map</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上代码，关键地方在于三点：</p><ol><li>flowMap 被 static final 修饰，是个共享变量，方便访问；</li><li>flowMap 是 ConcurrentHashMap，所以我们所有的操作都无需加锁，比如我们在 init 方法中，对 flowMap 进行初始化，就无需加锁，因为 ConcurrentHashMap 本身已经保证了线程安全；</li><li>这里我们初始化的时机是在容器启动的时候，在实际的工作中，我们经常在容器启动的时候，把不会经常发生变动的数据，放到类似 List、Map 这样的共享变量中，这样当我们频繁要使用的时候，直接从内存中读取即可。</li></ol><h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h5><p>那我们实际使用的时候，只需要告诉 flowMap 当前是那个流程的那个阶段，就可以返回该流程该阶段下面的所有领域行为了，我们写了一个流程引擎使用的工具类入口，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 流程引擎对外的 API</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowStart</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/**   * 流程引擎开始   *   * @param flowName 流程的名字   */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">invokeParamValid</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">invokeBusinessValid</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">invokeInTramsactionValid</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">invokeAfterTramsactionValid</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 执行参数校验</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeParamValid</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">stageInvoke</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> StageEnum<span class="token punctuation">.</span>PARAM_VALID<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 执行业务校验</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeBusinessValid</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">stageInvoke</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> StageEnum<span class="token punctuation">.</span>BUSINESS_VALID<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 执行事务中</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeInTramsactionValid</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">stageInvoke</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> StageEnum<span class="token punctuation">.</span>IN_TRANSACTION<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 执行事务后</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeAfterTramsactionValid</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">stageInvoke</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> StageEnum<span class="token punctuation">.</span>AFTER_TRANSACTION<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 批量执行 Spring Bean</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">stageInvoke</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> StageEnum stage<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>DomainAbilityBean<span class="token operator">></span>        domainAbilitys <span class="token operator">=</span>        FlowCenter<span class="token punctuation">.</span>flowMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>stage<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>domainAbilitys<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"找不到该流程对应的领域行为"</span> <span class="token operator">+</span> flowName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>DomainAbilityBean domainAbility <span class="token operator">:</span> domainAbilitys<span class="token punctuation">)</span> <span class="token punctuation">{</span>      domainAbility<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从代码中可以看到，我们在流程引擎的入口，只要根据参数校验、业务校验、事务中、事务后四个阶段，从 flowMap 中得到领域行为的集合，然后对领域行为进行顺序执行即可。</p><p>我们在使用时，直接使用上述类的 start 方法即可。</p><p>当然以上演示的流程引擎只是一个大的框架，还有很多地方需要改进的地方，比如如何找到 flowName，如何初始化 flowMap，但这些都不是本节重点，本节主要想通过流程引擎案例来说明几点：</p><ol><li>把 List 和 Map 作为共享变量非常常见，就像咱们这种项目启动时，从数据库中把数据捞出来，然后封装成 List 或 Map 的结构，这样做的优点就是节约资源，不用每次用的时候都去查数据库，直接从内存中获取即可；</li><li>并发场景下，我们可以放心的使用 CopyOnWriteArrayList 和 ConcurrentHashMap 两个并发类，首先用 static final 对两者进行修饰，使其成为共享变量，接着在写入或者查询的时候，无需加锁，两个 API 内部已经实现了加锁的功能了；</li><li>有一点需要澄清一下，就是 CopyOnWriteArrayList 和 ConcurrentHashMap 只能作为单机的共享变量，如果是分布式系统，多台机器的情况下，这样做不行了，需要使用分布式缓存了。</li></ol><h4 id="3-4-3-总结"><a href="#3-4-3-总结" class="headerlink" title="3.4.3-总结"></a>3.4.3-总结</h4><p>本节内容，以流程引擎为例，说明了如何使用 Map + List 的嵌套结构设计流程引擎，以及在并发情况下，如何安全的使用 List 和 Map。</p><p>本案列是高并发项目的真实案例，感兴趣的同学可以在此流程引擎框架基础上进行细节补充，实现可运行的流程引擎。</p><h2 id="4-队列"><a href="#4-队列" class="headerlink" title="4-队列"></a>4-队列</h2><h3 id="4-1-LinkedBlockingQueue-源码解析"><a href="#4-1-LinkedBlockingQueue-源码解析" class="headerlink" title="4.1-LinkedBlockingQueue 源码解析"></a>4.1-LinkedBlockingQueue 源码解析</h3><p>说到队列，大家的反应可能是我从来都没有用过，应该是不重要的 API 吧。如果这么想，那就大错特错了，我们平时使用到的线程池、读写锁、消息队列等等技术和框架，底层原理都是队列，所以我们万万不可轻视队列，队列是很多高级 API 的基础，学好队列，对自己深入 Java 学习非常重要。</p><p>本文主要以 LinkedBlockingQueue 队列为例，详细描述一下底层具体的实现。</p><h4 id="4-1-1-整体架构"><a href="#4-1-1-整体架构" class="headerlink" title="4.1.1-整体架构"></a>4.1.1-整体架构</h4><p>LinkedBlockingQueue 中文叫做链表阻塞队列，这个命名很好，从命名上就知道其底层数据结构是链表，并且队列是可阻塞的。接下来，我们就从整体结构上看看 LinkedBlockingQueue。</p><h5 id="1-类图"><a href="#1-类图" class="headerlink" title="1.类图"></a>1.类图</h5><p>首先我们来看下 LinkedBlockingQueue 类图，如下：</p><p>![LinkedBlockingQueue 类图](LinkedBlockingQueue 类图.jpeg)</p><p>从类图中，我们大概可以看出两条路径：</p><ol><li>AbstractQueue -&gt; AbstractCollection -&gt; Collection -&gt;Iterable 这条路径依赖，主要是想复用 Collection 和 迭代器的一些操作，这些我们在说集合的时候，都知道这些类是干什么，能干什么，就不细说了；</li><li>BlockingQueue -&gt; Queue -&gt; Collection，BlockingQueue 和 Queue 是新出来的两个接口，我们重点说一下。</li></ol><p>Queue 是最基础的接口，几乎所有的队列实现类都会实现这个接口，该接口定义出了队列的三大类操作：</p><p>新增操作：</p><ol><li>add 队列满的时候抛出异常；</li><li>offer 队列满的时候返回 false。</li></ol><p>查看并删除操作：</p><ol><li>remove 队列空的时候抛异常；</li><li>poll 队列空的时候返回 null。</li></ol><p>只查看不删除操作：</p><ol><li>element 队列空的时候抛异常；</li><li>peek 队列空的时候返回 null。</li></ol><p>一共 6 种方法，除了以上分类方法，也可以分成两类：</p><ol><li>遇到队列满或空的时候，抛异常，如 add、remove、element；</li><li>遇到队列满或空的时候，返回特殊值，如 offer、poll、peek。</li></ol><p>实际上，这些都比较难记忆。每次需要使用的时候，我都会看会源码，才能想起这个方法是抛异常还是返回特殊值。</p><p>BlockingQueue 在 Queue 的基础上加上了阻塞的概念，比如一直阻塞，还是阻塞一段时间。为了方便记忆，我们画一个表格，如下：</p><table><thead><tr><th align="left"></th><th align="left">抛异常</th><th align="left">特殊值</th><th align="left">一直阻塞</th><th align="left">阻塞一段时间</th></tr></thead><tbody><tr><td align="left">新增操作–队列满</td><td align="left">add</td><td align="left">offer 返回 false</td><td align="left">put</td><td align="left">offer 过超时时间返回 false</td></tr><tr><td align="left">查看并删除操作–队列空</td><td align="left">remove</td><td align="left">poll 返回 null</td><td align="left">take</td><td align="left">poll 过超时时间返回 null</td></tr><tr><td align="left">只查看不删除操作–队列空</td><td align="left">element</td><td align="left">peek 返回 null</td><td align="left">暂无</td><td align="left">暂无</td></tr></tbody></table><p>PS: remove 方法，BlockingQueue 类注释中定义的是抛异常，但 LinkedBlockingQueue 中 remove 方法实际是返回 false。<br>从表格中可以看到，在新增和查看并删除两大类操作上，BlockingQueue 增加了阻塞的功能，而且可以选择一直阻塞，或者阻塞一段时间后，返回特殊值。</p><h5 id="2-类注释"><a href="#2-类注释" class="headerlink" title="2.类注释"></a>2.类注释</h5><p>我们看看从 LinkedBlockingQueue 的类注释中能得到那些信息：</p><ol><li>基于链表的阻塞队列，其底层的数据结构是链表；</li><li>链表维护先入先出队列，新元素被放在队尾，获取元素从队头部拿；</li><li>链表大小在初始化的时候可以设置，默认是 Integer 的最大值；</li><li>可以使用 Collection 和 Iterator 两个接口的所有操作，因为实现了两者的接口。</li></ol><h5 id="3-内部构成"><a href="#3-内部构成" class="headerlink" title="3.内部构成"></a>3.内部构成</h5><p>LinkedBlockingQueue 内部构成简单来说，分成三个部分：链表存储 + 锁 + 迭代器，我们来看下源码。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 链表结构 begin</span><span class="token comment" spellcheck="true">//链表的元素</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    E item<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//当前元素的下一个，为空表示当前节点是最后一个</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span> item <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//链表的容量，默认 Integer.MAX_VALUE</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//链表已有元素大小，使用 AtomicInteger，所以是线程安全的</span><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//链表头</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//链表尾</span><span class="token keyword">private</span> <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 链表结构 end</span><span class="token comment" spellcheck="true">// 锁 begin</span><span class="token comment" spellcheck="true">//take 时的锁</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// take 的条件队列，condition 可以简单理解为基于 ASQ 同步机制建立的条件队列</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty <span class="token operator">=</span> takeLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// put 时的锁，设计两把锁的目的，主要为了 take 和 put 可以同时进行</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// put 的条件队列</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull <span class="token operator">=</span> putLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 锁 end</span><span class="token comment" spellcheck="true">// 迭代器 </span><span class="token comment" spellcheck="true">// 实现了自己的迭代器</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>………………<span class="token punctuation">}</span></code></pre><p>从代码上来看，结构是非常清晰的，三种结构各司其职：</p><ol><li>链表的作用是为了保存当前节点，节点中的数据可以是任意东西，是一个泛型，比如说队列被应用到线程池时，节点就是线程，比如队列被应用到消息队列中，节点就是消息，节点的含义主要看队列被使用的场景；</li><li>锁有 take 锁和 put 锁，是为了保证队列操作时的线程安全，设计两种锁，是为了 take 和 put 两种操作可以同时进行，互不影响。</li></ol><h5 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4.初始化"></a>4.初始化</h5><p>初始化有三种方式：</p><ol><li>指定链表容量大小；</li><li>不指定链表容量大小，默认是 Integer 的最大值；</li><li>对已有集合数据进行初始化。</li></ol><p>源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 不指定容量，默认 Integer 的最大值</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 指定链表容量大小，链表头尾相等，节点值（item）都是 null</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    last <span class="token operator">=</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 已有集合数据进行初始化</span><span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    putLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Never contended, but necessary for visibility</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>E e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 集合内的元素不能为空</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// capacity 代表链表的大小，在这里是 Integer 的最大值</span>            <span class="token comment" spellcheck="true">// 如果集合类的大小大于 Integer 的最大值，就会报错</span>            <span class="token comment" spellcheck="true">// 其实这个判断完全可以放在 for 循环外面，这样可以减少 Integer 的最大值次循环(最坏情况)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> capacity<span class="token punctuation">)</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        count<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>对于初始化源码，我们说明两点：</p><ol><li>初始化时，容量大小是不会影响性能的，只影响在后面的使用，因为初始化队列太小，容易导致没有放多少就会报队列已满的错误；</li><li>在对给定集合数据进行初始化时，源码给了一个不优雅的示范，我们不反对在每次 for 循环的时候，都去检查当前链表的大小是否超过容量，但我们希望在 for 循环开始之前就做一步这样的工作。举个列子，给定集合大小是 1 w，链表大小是 9k，按照现在代码实现，只能在 for 循环 9k 次时才能发现，原来给定集合的大小已经大于链表大小了，导致 9k 次循环都是在浪费资源，还不如在 for 循环之前就 check 一次，如果 1w &gt; 9k，直接报错即可。</li></ol><h4 id="4-1-2-阻塞新增"><a href="#4-1-2-阻塞新增" class="headerlink" title="4.1.2-阻塞新增"></a>4.1.2-阻塞新增</h4><p>新增有多种方法，如：add、put、offer，三者的区别上文有说。我们拿 put 方法为例，put 方法在碰到队列满的时候，会一直阻塞下去，直到队列不满时，并且自己被唤醒时，才会继续去执行，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 把e新增到队列的尾部。</span><span class="token comment" spellcheck="true">// 如果有可以新增的空间的话，直接新增成功，否则当前线程陷入等待</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// e 为空，抛出异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 预先设置 c 为 -1，约定负数为新增失败</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置可中断锁</span>    putLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 队列满了</span>        <span class="token comment" spellcheck="true">// 当前线程阻塞，等待其他线程的唤醒(其他线程 take 成功后就会唤醒此处被阻塞的线程)</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// await 无限等待</span>            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 队列没有满，直接新增到队列的尾部</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 新增计数赋值,注意这里 getAndIncrement 返回的是旧值</span>        <span class="token comment" spellcheck="true">// 这里的 c 是比真实的 count 小 1 的</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果链表现在的大小 小于链表的容量，说明队列未满</span>        <span class="token comment" spellcheck="true">// 可以尝试唤醒一个 put 的等待线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 释放锁</span>        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// c==0，代表队列里面有一个元素</span>    <span class="token comment" spellcheck="true">// 会尝试唤醒一个take的等待线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 入队，把新元素放到队尾</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    last <span class="token operator">=</span> last<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码中我们可以总结以下几点：</p><ol><li>往队列新增数据，第一步是上锁，所以新增数据是线程安全的；</li><li>队列新增数据，简单的追加到链表的尾部即可；</li><li>新增时，如果队列满了，当前线程是会被阻塞的，阻塞的底层使用是锁的能力，底层实现其它也和队列相关，原理我们在锁章节会说到；</li><li>新增数据成功后，在适当时机，会唤起 put 的等待线程（队列不满时），或者 take 的等待线程（队列不为空时），这样保证队列一旦满足 put 或者 take 条件时，立马就能唤起阻塞线程，继续运行，保证了唤起的时机不被浪费。</li></ol><p>以上就是 put 方法的原理，至于 offer 方法阻塞超过一端时间后，仍未成功，就会直接返回默认值的实现，和 put 方法相比只修改了几行代码，如下截图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/LinkedBlockingQueue-put%E5%92%8Coffer.jpeg" alt="LinkedBlockingQueue-put和offer"></p><h4 id="4-1-3-阻塞删除"><a href="#4-1-3-阻塞删除" class="headerlink" title="4.1.3-阻塞删除"></a>4.1.3-阻塞删除</h4><p>删除的方法也很多，我们主要看两个关键问题：</p><ol><li>删除的原理是怎样的；</li><li>查看并删除和只查看不删除两种的区别是如何实现的。</li></ol><p>首先我们来看第一个问题，我们以 take 方法为例，说明一下查看并删除的底层源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 阻塞拿数据</span><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    E x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 默认负数，代表失败</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// count 代表当前链表数据的真实大小</span>    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>    takeLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 空队列时，阻塞，等待其他线程唤醒</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 非空队列，从队列的头部拿一个出来</span>        x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 减一计算，注意 getAndDecrement 返回的值是旧值</span>        <span class="token comment" spellcheck="true">// c 比真实的 count 大1</span>        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果队列里面有值，从 take 的等待线程里面唤醒一个。</span>        <span class="token comment" spellcheck="true">// 意思是队列里面有值啦,唤醒之前被阻塞的线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 释放锁</span>        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果队列空闲还剩下一个，尝试从 put 的等待线程中唤醒一个</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>        <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 队头中取数据</span><span class="token keyword">private</span> E <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    h<span class="token punctuation">.</span>next <span class="token operator">=</span> h<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>    head <span class="token operator">=</span> first<span class="token punctuation">;</span>    E x <span class="token operator">=</span> first<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    first<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 头节点指向 null，删除</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>整体流程和 put 很相似，都是先上锁，然后从队列的头部拿出数据，如果队列为空，会一直阻塞到队列有值为止。</p><p>而查看不删除元素更加简单，直接把队列头的数据拿出来即可，我们以 peek 为例，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 查看并不删除元素，如果队列为空，返回 null</span><span class="token keyword">public</span> E <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// count 代表队列实际大小，队列为空，直接返回 null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>    takeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 拿到队列头</span>        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 判断队列头是否为空，并返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token keyword">return</span> first<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看出，查看并删除，和查看不删除两者从队头拿数据的逻辑不太一致，从而导致一个会删除，一个不会删除队头数据。</p><h4 id="4-1-4-总结"><a href="#4-1-4-总结" class="headerlink" title="4.1.4-总结"></a>4.1.4-总结</h4><p>本文通过 LinkedBlockingQueue 的源码，来介绍了下链表队列，当队列满和空的场景下，新增和删除数据时，队列有啥变化。</p><p>队列本身就是一个阻塞工具，我们可以把这个工具应用到各种阻塞场景中，比如说队列应用到线程池，当线程池跑满时，我们把新的请求都放到阻塞队列中等待；队列应用到消息队列，当消费者处理能力有限时，我们可以把消息放到队列中等待，让消费者慢慢消费；每应用到一个新的场景中，都是一个新的技术工具，所以学好队列，用处很大。</p><h3 id="4-2-SynchronousQueue-源码解析"><a href="#4-2-SynchronousQueue-源码解析" class="headerlink" title="4.2-SynchronousQueue 源码解析"></a>4.2-SynchronousQueue 源码解析</h3><p>SynchronousQueue 是比较独特的队列，其本身是没有容量大小，比如我放一个数据到队列中，我是不能够立马返回的，我必须等待别人把我放进去的数据消费掉了，才能够返回。SynchronousQueue 在消息队列技术中间件中被大量使用，本文就来从底层实现来看下 SynchronousQueue 到底是如何做到的。</p><h4 id="4-2-1-整体架构"><a href="#4-2-1-整体架构" class="headerlink" title="4.2.1-整体架构"></a>4.2.1-整体架构</h4><p>SynchronousQueue 的整体设计比较抽象，在内部抽象出了两种算法实现，一种是先入先出的队列，一种是后入先出的堆栈，两种算法被两个内部类实现，而直接对外的 put，take 方法的实现就非常简单，都是直接调用两个内部类的 transfer 方法进行实现，整体的调用关系如下图所示：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/SynchronousQueue-put%E5%92%8Ctake.jpeg" alt="SynchronousQueue-put和take"></p><h5 id="1-类注释-3"><a href="#1-类注释-3" class="headerlink" title="1.类注释"></a>1.类注释</h5><p>源码的类注释往往能给我带来很多疑问和有用的信息，我们来看下类注释都说了什么：</p><ol><li>队列不存储数据，所以没有大小，也无法迭代；</li><li>插入操作的返回必须等待另一个线程完成对应数据的删除操作，反之亦然；</li><li>队列由两种数据结构组成，分别是后入先出的堆栈和先入先出的队列，堆栈是非公平的，队列是公平的。</li></ol><p>看到类注释，大家是不是有一些疑问，比如第二点是如何做到的？堆栈又是如何实现的呢？接下来我们一点一点揭晓。</p><h5 id="2-类图"><a href="#2-类图" class="headerlink" title="2.类图"></a>2.类图</h5><p>SynchronousQueue 整体类图和 LinkedBlockingQueue 相似，都是实现了 BlockingQueue 接口，但因为其不储存数据结构，有一些方法是没有实现的，比如说 isEmpty、size、contains、remove 和迭代等方法，这些方法都是默认实现，如下截图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/SynchronousQueue%E7%9A%84%E6%96%B9%E6%B3%95.jpeg" alt="SynchronousQueue的方法"></p><h5 id="3-结构细节"><a href="#3-结构细节" class="headerlink" title="3.结构细节"></a>3.结构细节</h5><p>SynchronousQueue 底层结构和其它队列完全不同，有着独特的两种数据结构：队列和堆栈，我们一起来看下数据结构：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 堆栈和队列共同的接口</span>    <span class="token comment" spellcheck="true">// 负责执行 put or take</span>    <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Transferer</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// e 为空的，会直接返回特殊值，不为空会传递给消费者</span>        <span class="token comment" spellcheck="true">// timed 为 true，说明会有超时时间</span>        <span class="token keyword">abstract</span> E <span class="token function">transfer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 堆栈 后入先出 非公平</span>    <span class="token comment" spellcheck="true">// Scherer-Scott 算法</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TransferStack</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Transferer</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 队列 先入先出 公平</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TransferQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Transferer</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Transferer<span class="token operator">&lt;</span>E<span class="token operator">></span> transferer<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 无参构造器默认为非公平的</span>    <span class="token keyword">public</span> <span class="token function">SynchronousQueue</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>        transferer <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TransferQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">TransferStack</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>从源码中我们可以得到几点：</p><ol><li>堆栈和队列都有一个共同的接口，叫做 Transferer，该接口有个方法：transfer，该方法很神奇，会承担 take 和 put 的双重功能；</li><li>在我们初始化的时候，是可以选择是使用堆栈还是队列的，如果你不选择，默认的就是堆栈，类注释中也说明了这一点，堆栈的效率比队列更高。</li></ol><p>接下来我们来看下堆栈和队列的具体实现。</p><h4 id="4-2-2-非公平的堆栈"><a href="#4-2-2-非公平的堆栈" class="headerlink" title="4.2.2-非公平的堆栈"></a>4.2.2-非公平的堆栈</h4><h5 id="1-堆栈的结构"><a href="#1-堆栈的结构" class="headerlink" title="1.堆栈的结构"></a>1.堆栈的结构</h5><p>首先我们来介绍下堆栈的整体结构，如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E5%A0%86%E6%A0%88%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.jpeg" alt="堆栈的整体结构"></p><p>从上图中我们可以看到，我们有一个大的堆栈池，池的开口叫做堆栈头，put 的时候，就往堆栈池中放数据。take 的时候，就从堆栈池中拿数据，两者操作都是在堆栈头上操作数据，从图中可以看到，越靠近堆栈头，数据越新，所以每次 take 的时候，都会拿到堆栈头的最新数据，这就是我们说的后入先出，也就是非公平的。</p><p>图中 SNode 就是源码中栈元素的表示，我们看下源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SNode</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 栈的下一个，就是被当前栈压在下面的栈元素</span>    <span class="token keyword">volatile</span> SNode next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 节点匹配，用来判断阻塞栈元素能被唤醒的时机</span>    <span class="token comment" spellcheck="true">// 比如我们先执行 take，此时队列中没有数据，take 被阻塞了，栈元素为 SNode1</span>    <span class="token comment" spellcheck="true">// 当有 put 操作时，会把当前 put 的栈元素赋值给 SNode1 的 match 属性，并唤醒 take 操作</span>    <span class="token comment" spellcheck="true">// 当 take 被唤醒，发现 SNode1 的 match 属性有值时，就能拿到 put 进来的数据，从而返回</span>    <span class="token keyword">volatile</span> SNode match<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 栈元素的阻塞是通过线程阻塞来实现的，waiter 为阻塞的线程</span>    <span class="token keyword">volatile</span> Thread waiter<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 未投递的消息，或者未消费的消息</span>    Object item<span class="token punctuation">;</span>             <span class="token punctuation">}</span> </code></pre><h5 id="2-入栈和出栈"><a href="#2-入栈和出栈" class="headerlink" title="2.入栈和出栈"></a>2.入栈和出栈</h5><p>入栈指的是使用 put 等方法，把数据放到堆栈池中，出栈指的使用 take 等方法，把数据从堆栈池中拿出来，操作的对象都是堆栈头，虽然两者的一个是从堆栈头拿数据，一个是放数据，但底层实现的方法却是同一个，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// transfer 方法思路比较复杂，因为 take 和 put 两个方法都揉在了一起</span><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>E <span class="token function">transfer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    SNode s <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// constructed/reused as needed</span>    <span class="token comment" spellcheck="true">// e 为空，说明是 take 方法，不为空是 put 方法</span>    <span class="token keyword">int</span> mode <span class="token operator">=</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> REQUEST <span class="token operator">:</span> DATA<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 自旋</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 拿出头节点，有几种情况</span>        <span class="token comment" spellcheck="true">// 1：头节点为空，说明队列中还没有数据</span>        <span class="token comment" spellcheck="true">// 2：头节点不为空，并且是 take 类型的，说明头节点线程正等着拿数据。</span>        <span class="token comment" spellcheck="true">// 3：头节点不为空，并且是 put 类型的，说明头节点线程正等着放数据。</span>        SNode h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 栈头为空，说明队列中还没有数据。</span>        <span class="token comment" spellcheck="true">// 栈头不为空，并且栈头的类型和本次操作一致，比如都是 put，那么就把</span>        <span class="token comment" spellcheck="true">// 本次 put 操作放到该栈头的前面即可，让本次 put 能够先执行</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> null <span class="token operator">||</span> h<span class="token punctuation">.</span>mode <span class="token operator">==</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// empty or same-mode</span>            <span class="token comment" spellcheck="true">// 设置了超时时间，并且 e 进栈或者出栈要超时了，</span>            <span class="token comment" spellcheck="true">// 就会丢弃本次操作，返回 null 值。</span>            <span class="token comment" spellcheck="true">// 如果栈头此时被取消了，丢弃栈头，取下一个节点继续消费</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// can't wait</span>                <span class="token comment" spellcheck="true">// 栈头操作被取消</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span><span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 丢弃栈头，把栈头后一个元素作为栈头</span>                    <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// pop cancelled node</span>                <span class="token comment" spellcheck="true">//栈头是空的，直接返回 null</span>                <span class="token keyword">else</span>                    <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 没有超时，直接把 e 作为新的栈头</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token function">snode</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e<span class="token punctuation">,</span> h<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// e 等待出栈，一种是空队列 take，一种是 put</span>                SNode m <span class="token operator">=</span> <span class="token function">awaitFulfill</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> timed<span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// wait was cancelled</span>                    <span class="token function">clean</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> null<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 本来 s 是栈头的，现在 s 不是栈头了，s 后面又来了一个数，把新的数据作为栈头</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>next <span class="token operator">==</span> s<span class="token punctuation">)</span>                    <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> s<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// help s's fulfiller</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">==</span> REQUEST<span class="token punctuation">)</span> <span class="token operator">?</span> m<span class="token punctuation">.</span>item <span class="token operator">:</span> s<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 栈头正在等待其他线程 put 或 take</span>        <span class="token comment" spellcheck="true">// 比如栈头正在阻塞，并且是 put 类型，而此次操作正好是 take 类型，走此处</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isFulfilling</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// try to fulfill</span>            <span class="token comment" spellcheck="true">// 栈头已经被取消，把下一个元素作为栈头</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// already cancelled</span>                <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// pop and retry</span>            <span class="token comment" spellcheck="true">// snode 方法第三个参数 h 代表栈头，赋值给 s 的 next 属性</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token function">snode</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e<span class="token punctuation">,</span> h<span class="token punctuation">,</span> FULFILLING<span class="token operator">|</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// loop until matched or waiters disappear</span>                    <span class="token comment" spellcheck="true">// m 就是栈头，通过上面 snode 方法刚刚赋值</span>                    SNode m <span class="token operator">=</span> s<span class="token punctuation">.</span>next<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// m is s's match</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// all waiters are gone</span>                        <span class="token function">casHead</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// pop fulfill node</span>                        s <span class="token operator">=</span> null<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// use new node next time</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// restart main loop</span>                    <span class="token punctuation">}</span>                    SNode mn <span class="token operator">=</span> m<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// tryMatch 非常重要的方法，两个作用：</span>                     <span class="token comment" spellcheck="true">// 1 唤醒被阻塞的栈头 m，2 把当前节点 s 赋值给 m 的 match 属性</span>                     <span class="token comment" spellcheck="true">// 这样栈头 m 被唤醒时，就能从 m.match 中得到本次操作 s</span>                     <span class="token comment" spellcheck="true">// 其中 s.item 记录着本次的操作节点，也就是记录本次操作的数据</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">tryMatch</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token function">casHead</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// pop both s and m</span>                        <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">==</span> REQUEST<span class="token punctuation">)</span> <span class="token operator">?</span> m<span class="token punctuation">.</span>item <span class="token operator">:</span> s<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span>                  <span class="token comment" spellcheck="true">// lost match</span>                        s<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// help unlink</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// help a fulfiller</span>            SNode m <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// m is h's match</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> null<span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true">// waiter is gone</span>                <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// pop fulfilling node</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                SNode mn <span class="token operator">=</span> m<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">tryMatch</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// help match</span>                    <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// pop both h and m</span>                <span class="token keyword">else</span>                        <span class="token comment" spellcheck="true">// lost match</span>                    h<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// help unlink</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从源码中密密麻麻的注释，我们就可以看出来此方法比较复杂，我们总结一下大概的操作思路：</p><ol><li>判断是 put 方法还是 take 方法；</li><li>判断栈头数据是否为空，如果为空或者栈头的操作和本次操作一致，是的话走 3，否则走 5；</li><li>判断操作有无设置超时时间，如果设置了超时时间并且已经超时，返回 null，否则走 4；</li><li>如果栈头为空，把当前操作设置成栈头，或者栈头不为空，但栈头的操作和本次操作相同，也把当前操作设置成栈头，并看看其它线程能否满足自己，不能满足则阻塞自己。比如当前操作是 take，但队列中没有数据，则阻塞自己；</li><li>如果栈头已经是阻塞住的，需要别人唤醒的，判断当前操作能否唤醒栈头，可以唤醒走 6，否则走 4；</li><li>把自己当作一个节点，赋值到栈头的 match 属性上，并唤醒栈头节点；</li><li>栈头被唤醒后，拿到 match 属性，就是把自己唤醒的节点的信息，返回。</li></ol><p>在整个过程中，有一个节点阻塞的方法，实现原理如下：</p><pre class=" language-java"><code class="language-java">SNode <span class="token function">awaitFulfill</span><span class="token punctuation">(</span>SNode s<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// deadline 死亡时间，如果设置了超时时间的话，死亡时间等于当前时间 + 超时时间，否则就是 0</span>    <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> 0L<span class="token punctuation">;</span>    Thread w <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 自旋的次数，如果设置了超时时间，会自旋 32 次，否则自旋 512 次。</span>    <span class="token comment" spellcheck="true">// 比如本次操作是 take 操作，自选次数后，仍没有其他线程 put 数据进来</span>    <span class="token comment" spellcheck="true">// 就会阻塞，有超时时间的，会阻塞固定的时间，否则一致阻塞下去</span>    <span class="token keyword">int</span> spins <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">shouldSpin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">?</span>                 <span class="token punctuation">(</span>timed <span class="token operator">?</span> maxTimedSpins <span class="token operator">:</span> maxUntimedSpins<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当前线程有无被打断，如果过了超时时间，当前线程就会被打断</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            s<span class="token punctuation">.</span><span class="token function">tryCancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SNode m <span class="token operator">=</span> s<span class="token punctuation">.</span>match<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> m<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span>            nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 超时了，取消当前线程的等待操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span>                s<span class="token punctuation">.</span><span class="token function">tryCancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 自选次数减少 1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>spins <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>            spins <span class="token operator">=</span> <span class="token function">shouldSpin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>spins<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把当前线程设置成 waiter，主要是通过线程来完成阻塞和唤醒</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>waiter <span class="token operator">==</span> null<span class="token punctuation">)</span>            s<span class="token punctuation">.</span>waiter <span class="token operator">=</span> w<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// establish waiter so can park next iter</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 通过 park 进行阻塞，这个我们在锁章节中会说明</span>            LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">></span> spinForTimeoutThreshold<span class="token punctuation">)</span>            LockSupport<span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从节点阻塞代码中，我们可以发现，其阻塞的策略，并不是一上来就阻塞住，而是在自旋一定次数后，仍然没有其它线程来满足自己的要求时，才会真正的阻塞住。</p><h4 id="4-2-3-公平的队列"><a href="#4-2-3-公平的队列" class="headerlink" title="4.2.3-公平的队列"></a>4.2.3-公平的队列</h4><p>首先我们来看一下队列中的每个元素的组成：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 队列头 */</span><span class="token keyword">transient</span> <span class="token keyword">volatile</span> QNode head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 队列尾 */</span><span class="token keyword">transient</span> <span class="token keyword">volatile</span> QNode tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 队列的元素</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">QNode</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当前元素的下一个元素</span>    <span class="token keyword">volatile</span> QNode next<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// 当前元素的值，如果当前元素被阻塞住了，等其他线程来唤醒自己时，其他线程</span>    <span class="token comment" spellcheck="true">// 会把自己 set 到 item 里面</span>    <span class="token keyword">volatile</span> Object item<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// CAS'ed to or from null</span>    <span class="token comment" spellcheck="true">// 可以阻塞住的当前线程</span>    <span class="token keyword">volatile</span> Thread waiter<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// to control park/unpark</span>    <span class="token comment" spellcheck="true">// true 是 put，false 是 take</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> isData<span class="token punctuation">;</span><span class="token punctuation">}</span>  </code></pre><p>公平的队列主要使用的是 TransferQueue 内部类的 transfer 方法，我们一起来看下源码：</p><pre class=" language-java"><code class="language-java">E <span class="token function">transfer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>    QNode s <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// constructed/reused as needed</span>    <span class="token comment" spellcheck="true">// true 是 put，false 是 get</span>    <span class="token keyword">boolean</span> isData <span class="token operator">=</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 队列头和尾的临时变量,队列是空的时候，t=h</span>        QNode t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        QNode h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// tail 和 head 没有初始化时，无限循环</span>        <span class="token comment" spellcheck="true">// 虽然这种 continue 非常耗cpu，但感觉不会碰到这种情况</span>        <span class="token comment" spellcheck="true">// 因为 tail 和 head 在 TransferQueue 初始化的时候，就已经被赋值空节点了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null <span class="token operator">||</span> h <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 首尾节点相同，说明是空队列</span>        <span class="token comment" spellcheck="true">// 或者尾节点的操作和当前节点操作一致</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> t <span class="token operator">||</span> t<span class="token punctuation">.</span>isData <span class="token operator">==</span> isData<span class="token punctuation">)</span> <span class="token punctuation">{</span>            QNode tn <span class="token operator">=</span> t<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 当 t 不是 tail 时，说明 tail 已经被修改过了</span>            <span class="token comment" spellcheck="true">// 因为 tail 没有被修改的情况下，t 和 tail 必然相等</span>            <span class="token comment" spellcheck="true">// 因为前面刚刚执行赋值操作： t = tail</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> tail<span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 队尾后面的值还不为空，t 还不是队尾，直接把 tn 赋值给 t，这是一步加强校验。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>tn <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">advanceTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> tn<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//超时直接返回 null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// can't wait</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//构造node节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null<span class="token punctuation">)</span>                s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> isData<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果把 e 放到队尾失败，继续递归放进去</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// failed to link in</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token function">advanceTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// swing tail and wait</span>            <span class="token comment" spellcheck="true">// 阻塞住自己</span>            Object x <span class="token operator">=</span> <span class="token function">awaitFulfill</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e<span class="token punctuation">,</span> timed<span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">// wait was cancelled</span>                <span class="token function">clean</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">isOffList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// not already unlinked</span>                <span class="token function">advanceHead</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// unlink if head</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null<span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">// and forget fields</span>                    s<span class="token punctuation">.</span>item <span class="token operator">=</span> s<span class="token punctuation">;</span>                s<span class="token punctuation">.</span>waiter <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span>x <span class="token operator">:</span> e<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 队列不为空，并且当前操作和队尾不一致</span>        <span class="token comment" spellcheck="true">// 也就是说当前操作是队尾是对应的操作</span>        <span class="token comment" spellcheck="true">// 比如说队尾是因为 take 被阻塞的，那么当前操作必然是 put</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// complementary-mode</span>            <span class="token comment" spellcheck="true">// 如果是第一次执行，此处的 m 代表就是 tail</span>            <span class="token comment" spellcheck="true">// 也就是这行代码体现出队列的公平，每次操作时，从头开始按照顺序进行操作</span>            QNode m <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// node to fulfill</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> tail <span class="token operator">||</span> m <span class="token operator">==</span> null <span class="token operator">||</span> h <span class="token operator">!=</span> head<span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// inconsistent read</span>            Object x <span class="token operator">=</span> m<span class="token punctuation">.</span>item<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>isData <span class="token operator">==</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">||</span>    <span class="token comment" spellcheck="true">// m already fulfilled</span>                x <span class="token operator">==</span> m <span class="token operator">||</span>                   <span class="token comment" spellcheck="true">// m cancelled</span>                <span class="token comment" spellcheck="true">// m 代表栈头</span>                <span class="token comment" spellcheck="true">// 这里把当前的操作值赋值给阻塞住的 m 的 item 属性</span>                <span class="token comment" spellcheck="true">// 这样 m 被释放时，就可得到此次操作的值</span>                <span class="token operator">!</span>m<span class="token punctuation">.</span><span class="token function">casItem</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// lost CAS</span>                <span class="token function">advanceHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// dequeue and retry</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 当前操作放到队头</span>            <span class="token function">advanceHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// successfully fulfilled</span>            <span class="token comment" spellcheck="true">// 释放队头阻塞节点</span>            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>waiter<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span>x <span class="token operator">:</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>源码比较复杂，我们需要搞清楚的是，线程被阻塞住后，当前线程是如何把自己的数据传给阻塞线程的。为了方便说明，我们假设线程 1 往队列中 take 数据 ，被阻塞住了，变成阻塞线程 A ，然后线程 2 开始往队列中 put 数据 B，大致的流程是这样的：</p><ol><li>线程 1 从队列中拿数据，发现队列中没有数据，于是被阻塞，成为 A ；</li><li>线程 2 往队尾 put 数据，会从队尾往前找到第一个被阻塞的节点，假设此时能找到的就是节点 A，然后线程 B 把将 put 的数据放到节点 A 的 item 属性里面，并唤醒线程 1；</li><li>线程 1 被唤醒后，就能从 A.item 里面拿到线程 2 put 的数据了，线程 1 成功返回。</li></ol><p>从这个过程中，我们能看出公平主要体现在，每次 put 数据的时候，都 put 到队尾上，而每次拿数据时，并不是直接从堆头拿数据，而是从队尾往前寻找第一个被阻塞的线程，这样就会按照顺序释放被阻塞的线程。</p><h4 id="4-2-4-总结"><a href="#4-2-4-总结" class="headerlink" title="4.2.4-总结"></a>4.2.4-总结</h4><p>SynchronousQueue 源码比较复杂，建议大家进行源码的 debug 来学习源码，为大家准备了调试类：SynchronousQueueDemo，大家可以下载源码自己调试一下，这样学起来应该会更加轻松一点。</p><h3 id="4-3-DelayQueue-源码解析"><a href="#4-3-DelayQueue-源码解析" class="headerlink" title="4.3-DelayQueue 源码解析"></a>4.3-DelayQueue 源码解析</h3><p>之前我们说的阻塞队列，都是资源足够时立马执行。本章我们说的队列比较特殊，是一种延迟队列，意思是延迟执行，并且可以设置延迟多久之后执行，比如设置过 5 秒钟之后再执行，在一些延迟执行的场景被大量使用，比如说延迟对账等等。</p><h4 id="4-3-1-整体架构"><a href="#4-3-1-整体架构" class="headerlink" title="4.3.1-整体架构"></a>4.3.1-整体架构</h4><p>DelayQueue 延迟队列底层使用的是锁的能力，比如说要在当前时间往后延迟 5 秒执行，那么当前线程就会沉睡 5 秒，等 5 秒后线程被唤醒时，如果能获取到资源的话，线程即可立马执行。原理上似乎很简单，但内部实现却很复杂，有很多难点，比如当运行资源不够，多个线程同时被唤醒时，如何排队等待？比如说在何时阻塞？何时开始执行等等？接下来我们从源码角度来看下是如何实现的。</p><h5 id="1-类注释-4"><a href="#1-类注释-4" class="headerlink" title="1.类注释"></a>1.类注释</h5><p>类注释上比较简单，只说了三个概念：</p><ol><li>队列中元素将在过期时被执行，越靠近队头，越早过期；</li><li>未过期的元素不能够被 take；</li><li>不允许空元素。</li></ol><p>这三个概念，其实就是三个问题，下文我们会一一看下这三点是如何实现的。</p><h5 id="2-类图-1"><a href="#2-类图-1" class="headerlink" title="2.类图"></a>2.类图</h5><p>DelayQueue 的类图和之前的队列一样，不多说，关键是 DelayQueue 类上是有泛型的，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayQueue</span><span class="token operator">&lt;</span>E <span class="token keyword">extends</span> <span class="token class-name">Delayed</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span>    <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span></code></pre><p>从泛型中可以看出，DelayQueue 中的元素必须是 Delayed 的子类，Delayed 是表达延迟能力的关键接口，其继承了 Comparable 接口，并定义了还剩多久过期的方法，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Delayed</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Delayed<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> <span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>也就是说 DelayQueue 队列中的元素必须是实现 Delayed 接口和 Comparable 接口的，并覆写了 getDelay 方法和 compareTo 的方法才行，不然在编译时，编译器就会提醒我们元素必须强制实现 Delayed 接口。</p><p>除此之外 DelayQueue 还大量使用了 PriorityQueue 队列的大量功能，这个和 SynchronousQueue 队列很像，大量复用了其它基础类的逻辑，代码示例如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/DelayQueue-poll.jpeg" alt="DelayQueue-poll"></p><p>PriorityQueue 中文叫做优先级队列，在此处的作用就是可以根据过期时间做优先级排序，让先过期的可以先执行，用来实现类注释中的第一点。</p><p>这里的复用的思想还是蛮重要的，我们在源码中经常会遇到这种思想，比如说 LinkedHashMap 复用 HashMap 的能力，Set 复用 Map 的能力，还有此处的 DelayQueue 复用 PriorityQueue 的能力。小结一下，如果想要复用需要做到哪些：</p><ol><li>需要把能遇见可复用的功能尽量抽象，并开放出可扩展的地方，比如说 HashMap 在操作数组的方法中，都给 LinkedHashMap 开放出很多 after 开头的方法，便于 LinkedHashMap 进行排序、删除等等；</li><li>采用组合或继承两种手段进行复用，比如 LinkedHashMap 采用的继承、 Set 和 DelayQueue 采用的组合，组合的意思就是把可复用的类给依赖进来。</li></ol><h5 id><a href="#" class="headerlink" title></a></h5><h4 id="4-3-2-演示"><a href="#4-3-2-演示" class="headerlink" title="4.3.2-演示"></a>4.3.2-演示</h4><p>为了方便大家理解，写了一个演示的 demo，演示了一下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayQueueDemo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 队列消息的生产者</span>  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue queue<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Product</span><span class="token punctuation">(</span>BlockingQueue queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"begin put"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> beginTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DelayedDTO</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> 2000L<span class="token punctuation">,</span>beginTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延迟 2 秒执行</span>        queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DelayedDTO</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> 5000L<span class="token punctuation">,</span>beginTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延迟 5 秒执行</span>        queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DelayedDTO</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> 1000L <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">,</span>beginTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延迟 10 秒执行</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"end put"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 队列的消费者</span>  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue queue<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>BlockingQueue queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Consumer begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>DelayedDTO<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>DelayedDTO<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>DelayedDTO<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Consumer end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Data</span>  <span class="token comment" spellcheck="true">// 队列元素，实现了 Delayed 接口</span>  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DelayedDTO</span> <span class="token keyword">implements</span> <span class="token class-name">Delayed</span> <span class="token punctuation">{</span>    Long s<span class="token punctuation">;</span>    Long beginTime<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">DelayedDTO</span><span class="token punctuation">(</span>Long s<span class="token punctuation">,</span>Long beginTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>s <span class="token operator">=</span> s<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>beginTime <span class="token operator">=</span>beginTime<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> unit<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>s <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Delayed o<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span> <span class="token operator">-</span> o<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"现在已经过了{}秒钟"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> beginTime<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// demo 运行入口</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    BlockingQueue q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelayQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    DelayQueueDemo<span class="token punctuation">.</span>Product p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelayQueueDemo<span class="token punctuation">.</span>Product</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    DelayQueueDemo<span class="token punctuation">.</span>Consumer c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelayQueueDemo<span class="token punctuation">.</span>Consumer</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>打印出来的结果如下：<span class="token number">06</span><span class="token operator">:</span><span class="token number">57</span><span class="token operator">:</span><span class="token number">50.544</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">]</span> Consumer begin<span class="token number">06</span><span class="token operator">:</span><span class="token number">57</span><span class="token operator">:</span><span class="token number">50.544</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> begin put<span class="token number">06</span><span class="token operator">:</span><span class="token number">57</span><span class="token operator">:</span><span class="token number">50.551</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> end put<span class="token number">06</span><span class="token operator">:</span><span class="token number">57</span><span class="token operator">:</span><span class="token number">52.554</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">]</span> 延迟了<span class="token number">2</span>秒钟才执行<span class="token number">06</span><span class="token operator">:</span><span class="token number">57</span><span class="token operator">:</span><span class="token number">55.555</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">]</span> 延迟了<span class="token number">5</span>秒钟才执行<span class="token number">06</span><span class="token operator">:</span><span class="token number">58</span><span class="token operator">:</span><span class="token number">00.555</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">]</span> 延迟了<span class="token number">10</span>秒钟才执行<span class="token number">06</span><span class="token operator">:</span><span class="token number">58</span><span class="token operator">:</span><span class="token number">00.556</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">]</span> Consumer end</code></pre><p>写这个代码的目的主要想演示一下延迟执行的例子，我们大概的思路是：</p><ol><li>新建队列的元素，如 DelayedDTO，必须实现 Delayed 接口，我们在 getDelay 方法中实现了现在离过期时间还剩多久的方法。</li><li>定义队列元素的生产者，和消费者，对应着代码中的 Product 和 Consumer。</li><li>对生产者和消费者就行初始化和管理，对应着我们的 main 方法。</li></ol><p>虽然这只是一个简单的 demo，但实际工作中，我们使用 DelayQueue 基本上就是这种思想，只不过写代码的时候会更加通用和周全，接下来我们来看下 DelayQueue 是如何实现 put 和 take 的。</p><h4 id="4-3-3-放数据"><a href="#4-3-3-放数据" class="headerlink" title="4.3.3-放数据"></a>4.3.3-放数据</h4><p>我们以 put 为例，put 调用的是 offer 的方法，offer 的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 上锁</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用 PriorityQueue 的扩容，排序等能力</span>        q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果恰好刚放进去的元素正好在队列头</span>        <span class="token comment" spellcheck="true">// 立马唤醒 take 的阻塞线程，执行 take 操作</span>        <span class="token comment" spellcheck="true">// 如果元素需要延迟执行的话，可以使其更快的沉睡计时</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            leader <span class="token operator">=</span> null<span class="token punctuation">;</span>            available<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 释放锁</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到其实底层使用到的是 PriorityQueue 的 offer 方法，我们来看下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 新增元素</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果是空元素的话，抛异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 队列实际大小大于容量时，进行扩容</span>    <span class="token comment" spellcheck="true">// 扩容策略是：如果老容量小于 64，2 倍扩容，如果大于 64，50 % 扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        <span class="token function">grow</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    size <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果队列为空，当前元素正好处于队头</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token comment" spellcheck="true">// 如果队列不为空，需要根据优先级进行排序</span>        <span class="token function">siftUp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 按照从小到大的顺序排列</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUpComparable</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> key <span class="token operator">=</span> <span class="token punctuation">(</span>Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// k 是当前队列实际大小的位置</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 对 k 进行减倍</span>            <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>            Object e <span class="token operator">=</span> queue<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 x 比 e 大，退出，把 x 放在 k 位置上</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span> e<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// x 比 e 小，继续循环，直到找到 x 比队列中元素大的位置</span>            queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            k <span class="token operator">=</span> parent<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>可以看到，PriorityQueue 的 offer 方法主要做了三件事情：</p><ol><li>对新增元素进行判空；</li><li>对队列进行扩容，扩容策略和集合的扩容策略很相近；</li><li>根据元素的 compareTo 方法进行排序，我们希望最终排序的结果是从小到大的，因为我们想让队头的都是过期的数据，我们需要在 compareTo 方法里面实现：通过每个元素的过期时间进行排序，如下：</li></ol><pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span> <span class="token operator">-</span> o<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这样便可实现越快过期的元素越能排到队头。</p><p>可以看到，新增数据时，只是使用到了 compareTo 方法，来对队列中的元素进行排序，接下来我们看下，取数据时，是如何操作的。</p><h4 id="4-3-4-取数据"><a href="#4-3-4-取数据" class="headerlink" title="4.3.4-取数据"></a>4.3.4-取数据</h4><p>取数据时，如果发现有元素的过期时间到了，就能拿出数据来，如果没有过期元素，那么线程就会一直阻塞，我们以 take 为例子，来看一下核心源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 从队头中拿数据出来</span>    E first <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果为空，说明队列中，没有数据，阻塞住</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> null<span class="token punctuation">)</span>        available<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取队头数据的过期时间</span>        <span class="token keyword">long</span> delay <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果过期了，直接返回队头数据</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 引用置为 null ，便于 gc，这样可以让线程等待时，回收 first 变量</span>        first <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// leader 不为空的话，表示当前队列元素之前已经被设置过阻塞时间了</span>        <span class="token comment" spellcheck="true">// 直接阻塞当前线程等待。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">!=</span> null<span class="token punctuation">)</span>            available<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 之前没有设置过阻塞时间，按照一定的时间进行阻塞</span>            Thread thisThread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            leader <span class="token operator">=</span> thisThread<span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 进行阻塞</span>                available<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">==</span> thisThread<span class="token punctuation">)</span>                    leader <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到阻塞等待的功能底层使用的是锁的能力，这个我们在后面章节中会说到。</p><p>以上演示的 take 方法是会无限阻塞，直到队头的过期时间到了才会返回，如果不想无限阻塞，可以尝试 poll 方法，设置超时时间，在超时时间内，队头元素还没有过期的话，就会返回 null。</p><h5 id="4-3-5-总结"><a href="#4-3-5-总结" class="headerlink" title="4.3.5-总结"></a>4.3.5-总结</h5><p>DelayQueue 是非常有意思的队列，底层使用了排序和超时阻塞实现了延迟队列，排序使用的是 PriorityQueue 排序能力，超时阻塞使用得是锁的等待能力，可以看出 DelayQueue 其实就是为了满足延迟执行的场景，在已有 API 的基础上进行了封装，我们在工作中，可以学习这种思想，对已有的功能能复用的尽量复用，减少开发的工作量。</p><h3 id="4-4-ArrayBlockingQueue-源码解析"><a href="#4-4-ArrayBlockingQueue-源码解析" class="headerlink" title="4.4-ArrayBlockingQueue 源码解析"></a>4.4-ArrayBlockingQueue 源码解析</h3><p>本小节我们来介绍本章最后一个队列：ArrayBlockingQueue。按照字面翻译，中文叫做数组阻塞队列，从名称上看，我们就比较清楚此阻塞队列底层使用的是数组。一说到数组，大家可能会想到 ArrayList 和 HashMap，举新增场景来说 ArrayList 通过 size ++ 找到新增的数组下标位置，HashMap 通过 hash 算法计算出下标位置，那么 ArrayBlockingQueue 是不是也是这两种方法呢？都不是，ArrayBlockingQueue 使用的是一种非常奇妙的方式，我们一起拭目以待。</p><p>全文为了方便说明，队头的说法就是数组头，队尾的说法就是数组尾。</p><h4 id="4-4-1-整体架构"><a href="#4-4-1-整体架构" class="headerlink" title="4.4.1-整体架构"></a>4.4.1-整体架构</h4><p>我们从类注释上可以得到一些有用的信息：</p><h5 id="1-类注释-5"><a href="#1-类注释-5" class="headerlink" title="1.类注释"></a>1.类注释</h5><ol><li>有界的阻塞数组，容量一旦创建，后续大小无法修改；</li><li>元素是有顺序的，按照先入先出进行排序，从队尾插入数据数据，从队头拿数据；</li><li>队列满时，往队列中 put 数据会被阻塞，队列空时，往队列中拿数据也会被阻塞。</li></ol><p>从类注释上可以看出 ArrayBlockingQueue 和一般的数组结构的类不太一样，是不能够动态扩容的，如果队列满了或者空时，take 和 put 都会被阻塞。</p><h5 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 队列存放在 object 的数组里面</span><span class="token comment" spellcheck="true">// 数组大小必须在初始化的时候手动设置，没有默认大小</span><span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 下次拿数据的时候的索引位置</span><span class="token keyword">int</span> takeIndex<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 下次放数据的索引位置</span><span class="token keyword">int</span> putIndex<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 当前已有元素的大小</span><span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 可重入的锁</span><span class="token keyword">final</span> ReentrantLock lock<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// take的队列</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// put的队列</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull<span class="token punctuation">;</span></code></pre><p>以上代码有两个关键的字段，takeIndex 和 putIndex，分别表示下次拿数据和放数据的索引位置。所以说在新增数据和拿数据时，都无需计算，就能知道应该新增到什么位置，应该从什么位置拿数据。</p><h4 id="4-4-2-初始化"><a href="#4-4-2-初始化" class="headerlink" title="4.4.2-初始化"></a>4.4.2-初始化</h4><p>初始化时，有两个重要的参数：数组的大小、是否是公平，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 队列不为空 Condition，在 put 成功时使用</span>    notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 队列不满 Condition，在 take 成功时使用</span>    notFull <span class="token operator">=</span>  lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码中我们可以看出，第二个参数是否公平，主要用于读写锁是否公平，如果是公平锁，那么在锁竞争时，就会按照先来先到的顺序，如果是非公平锁，锁竞争时随机的。</p><p>对于锁公平和非公平，我们举个例子：比如说现在队列是满的，还有很多线程执行 put 操作，必然会有很多线程阻塞等待，当有其它线程执行 take 时，会唤醒等待的线程，如果是公平锁，会按照阻塞等待的先后顺序，依次唤醒阻塞的线程，如果是非公平锁，会随机唤醒沉睡的线程。</p><p>所以说队列满很多线程执行 put 操作时，如果是公平锁，数组元素新增的顺序就是阻塞线程被释放的先后顺序，是有顺序的，而非公平锁，由于阻塞线程被释放的顺序是随机的，所以元素插入到数组的顺序也就不会按照插入的顺序了。</p><p>队列空时，也是一样的道理。</p><p>ArrayBlockingQueue 通过锁的公平和非公平，轻松实现了数组元素的插入顺序的问题。如果要实现这个功能，你会怎么做呢？会想到利用锁的功能么？其实这种思想我们在文中多次提到，当我们需要完成一件事情时，首先看看已有的 API 能不能满足，如果可以的话，通过继承和组合的方式来实现，ArrayBlockingQueue 就是组合了锁的功能。</p><p>初始化时，如果给定了原始数据的话，一定要注意原始数据的大小一定要小于队列的容量，否则会抛异常，如下图所示：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayBlockingQueue%E6%8A%9B%E5%BC%82%E5%B8%B8.jpeg" alt="ArrayBlockingQueue抛异常"></p><p>我们写了一个 demo，报错如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E6%B5%8B%E8%AF%95ArrayBlockingQueue%E6%8A%9B%E5%BC%82%E5%B8%B8.jpeg" alt="测试ArrayBlockingQueue抛异常"></p><h4 id="4-4-3-新增数据"><a href="#4-4-3-新增数据" class="headerlink" title="4.4.3-新增数据"></a>4.4.3-新增数据</h4><p>数据新增都会按照 putIndex 的位置进行新增，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 新增，如果队列满，无限阻塞</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 元素不能为空</span>    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 队列如果是满的，就无限等待</span>        <span class="token comment" spellcheck="true">// 一直等待队列中有数据被拿走时，自己被唤醒</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// assert lock.getHoldCount() == 1; 同一时刻只能一个线程进行操作此方法</span>    <span class="token comment" spellcheck="true">// assert items[putIndex] == null;</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// putIndex 为本次插入的位置</span>    items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ++ putIndex 计算下次插入的位置</span>    <span class="token comment" spellcheck="true">// 如果下次插入的位置，正好等于队尾，下次插入就从 0 开始</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        putIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    count<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 唤醒因为队列空导致的等待线程</span>    notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码中，我们可以看出，其实新增就两种情况：</p><ol><li><p>本次新增的位置居中，直接新增，下图演示的是 putIndex 在数组下标为 5 的位置，还不到队尾，那么可以直接新增，计算下次新增的位置应该是 6；</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayBlockingQueue-%E6%96%B0%E5%A2%9E1.jpeg" alt="ArrayBlockingQueue-新增1"></p></li><li><p>新增的位置到队尾了，那么下次新增时就要从头开始了，示意图如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayBlockingQueue-%E6%96%B0%E5%A2%9E2.jpeg" alt="ArrayBlockingQueue-新增2"></p></li></ol><p>上面这张图演示的就是这行代码：<code>if (++putIndex == items.length) putIndex = 0;</code></p><p>可以看到当新增到队尾时，下次新增会重新从队头重新开始。</p><h4 id="4-4-4-取数据"><a href="#4-4-4-取数据" class="headerlink" title="4.4.4-取数据"></a>4.4.4-取数据</h4><p>拿数据都是从队头开始拿数据，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果队列为空，无限等待</span>        <span class="token comment" spellcheck="true">// 直到队列中有数据被 put 后，自己被唤醒</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从队列中拿数据</span>        <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> E <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// takeIndex 代表本次拿数据的位置，是上一次拿数据时计算好的</span>    E x <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 帮助 gc</span>    items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ++ takeIndex 计算下次拿数据的位置</span>    <span class="token comment" spellcheck="true">// 如果正好等于队尾的话，下次就从 0 开始拿数据</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 队列实际大小减 1</span>    count<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> null<span class="token punctuation">)</span>        itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 唤醒被队列满所阻塞的线程</span>    notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码中可以看出，每次拿数据的位置就是 takeIndex 的位置，在找到本次该拿的数据之后，会把 takeIndex 加 1，计算下次拿数据时的索引位置，有个特殊情况是，如果本次拿数据的位置已经是队尾了，那么下次拿数据的位置就要从头开始，就是从 0 开始了。</p><h4 id="4-4-5-删除数据"><a href="#4-4-5-删除数据" class="headerlink" title="4.4.5-删除数据"></a>4.4.5-删除数据</h4><p>删除数据很有意思，我们一起来看下核心源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 一共有两种情况：</span><span class="token comment" spellcheck="true">// 1：删除位置和 takeIndex 的关系：删除位置和 takeIndex 一样，比如 takeIndex 是 2， 而要删除的位置正好也是 2，那么就把位置 2 的数据置为 null ,并重新计算 takeIndex 为 3。</span><span class="token comment" spellcheck="true">// 2：找到要删除元素的下一个，计算删除元素和 putIndex 的关系</span><span class="token comment" spellcheck="true">// 如果下一个元素不是 putIndex，就把下一个元素往前移动一位</span><span class="token comment" spellcheck="true">// 如果下一个元素是 putIndex，把 putIndex 的值修改成删除的位置</span><span class="token keyword">void</span> <span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> removeIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 情况1 如果删除位置正好等于下次要拿数据的位置</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>removeIndex <span class="token operator">==</span> takeIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 下次要拿数据的位置直接置空</span>        items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 要拿数据的位置往后移动一位</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当前数组的大小减一</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> null<span class="token punctuation">)</span>            itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 情况 2</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> putIndex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putIndex<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> removeIndex<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 找到要删除元素的下一个</span>            <span class="token keyword">int</span> next <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>                next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 下一个元素不是 putIndex</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> putIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 下一个元素往前移动一位</span>                items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 下一个元素是 putIndex</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 删除元素</span>                items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 下次放元素时，应该从本次删除的元素放</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>putIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> null<span class="token punctuation">)</span>            itrs<span class="token punctuation">.</span><span class="token function">removedAt</span><span class="token punctuation">(</span>removeIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>删除数据的情况比较复杂，一共有两种情况，第一种情况是 <code>takeIndex == removeIndex</code>，我们画个示意图来看下处理方式：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayBlockingQueue-%E5%88%A0%E9%99%A41.jpeg" alt="ArrayBlockingQueue-删除1"></p><p>第二种情况又分两种：</p><ol><li><p>如果 removeIndex + 1 != putIndex 的话，就把下一个元素往前移动一位，示意图如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayBlockingQueue-%E5%88%A0%E9%99%A42.jpeg" alt="ArrayBlockingQueue-删除2"></p></li><li><p>如果 removeIndex + 1 == putIndex 的话，就把 putIndex 的值修改成删除的位置，示意图如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayBlockingQueue-%E5%88%A0%E9%99%A43.jpeg" alt="ArrayBlockingQueue-删除3"></p></li></ol><p>ArrayBlockingQueue 的删除方法其实还蛮复杂的，需要考虑到很多特殊的场景。</p><h4 id="4-4-6-总结"><a href="#4-4-6-总结" class="headerlink" title="4.4.6-总结"></a>4.4.6-总结</h4><p>ArrayBlockingQueue 底层是有界的数组，整体来说，和其它队列差别不多，需要注意的是，当 takeIndex、putIndex 到队尾的时候，都会重新从 0 开始循环，这点是比较特殊的，在我们学习源码时，需要特别注意。</p><h3 id="4-5-队列在源码方面的面试题"><a href="#4-5-队列在源码方面的面试题" class="headerlink" title="4.5-队列在源码方面的面试题"></a>4.5-队列在源码方面的面试题</h3><p>队列在源码方面的面试题，一般面试官会从锁，线程池等知识点作为问题入口，慢慢的问到队列，由于锁、线程池咱们还没有学习到，所以本章就直奔主题，从队列入手，看看队列都有哪些面试题（队列种类很多，本文在说队列的通用特征时，都是在说其大部分队列的通用特征，如有某种队列特征不符，不在一一说明）。</p><h4 id="4-5-1-面试题"><a href="#4-5-1-面试题" class="headerlink" title="4.5.1-面试题"></a>4.5.1-面试题</h4><h5 id="1-说说你对队列的理解，队列和集合的区别。"><a href="#1-说说你对队列的理解，队列和集合的区别。" class="headerlink" title="1.说说你对队列的理解，队列和集合的区别。"></a>1.说说你对队列的理解，队列和集合的区别。</h5><p>答：对队列的理解：</p><ol><li>首先队列本身也是个容器，底层也会有不同的数据结构，比如 LinkedBlockingQueue 是底层是链表结构，所以可以维持先入先出的顺序，比如 DelayQueue 底层可以是队列或堆栈，所以可以保证先入先出，或者先入后出的顺序等等，底层的数据结构不同，也造成了操作实现不同；</li><li>部分队列（比如 LinkedBlockingQueue ）提供了暂时存储的功能，我们可以往队列里面放数据，同时也可以从队列里面拿数据，两者可以同时进行；</li><li>队列把生产数据的一方和消费数据的一方进行解耦，生产者只管生产，消费者只管消费，两者之间没有必然联系，队列就像生产者和消费者之间的数据通道一样，如 LinkedBlockingQueue；</li><li>队列还可以对消费者和生产者进行管理，比如队列满了，有生产者还在不停投递数据时，队列可以使生产者阻塞住，让其不再能投递，比如队列空时，有消费者过来拿数据时，队列可以让消费者 hodler 住，等有数据时，唤醒消费者，让消费者拿数据返回，如 ArrayBlockingQueue；</li><li>队列还提供阻塞的功能，比如我们从队列拿数据，但队列中没有数据时，线程会一直阻塞到队列有数据可拿时才返回。</li></ol><p>队列和集合的区别：</p><ol><li>和集合的相同点，队列（部分例外）和集合都提供了数据存储的功能，底层的储存数据结构是有些相似的，比如说 LinkedBlockingQueue 和 LinkedHashMap 底层都使用的是链表，ArrayBlockingQueue 和 ArrayList 底层使用的都是数组。</li><li>和集合的区别：<ul><li>部分队列和部分集合底层的存储结构很相似的，但两者为了完成不同的事情，提供的 API 和其底层的操作实现是不同的。</li><li>队列提供了阻塞的功能，能对消费者和生产者进行简单的管理，队列空时，会阻塞消费者，有其他线程进行 put 操作后，会唤醒阻塞的消费者，让消费者拿数据进行消费，队列满时亦然。</li><li>解耦了生产者和消费者，队列就像是生产者和消费者之间的管道一样，生产者只管往里面丢，消费者只管不断消费，两者之间互不关心。</li></ul></li></ol><h5 id="2-哪些队列具有阻塞的功能，大概是如何阻塞的？"><a href="#2-哪些队列具有阻塞的功能，大概是如何阻塞的？" class="headerlink" title="2.哪些队列具有阻塞的功能，大概是如何阻塞的？"></a>2.哪些队列具有阻塞的功能，大概是如何阻塞的？</h5><p>答：队列主要提供了两种阻塞功能，如下：</p><ol><li>LinkedBlockingQueue 链表阻塞队列和 ArrayBlockingQueue 数组阻塞队列是一类，前者容量是 Integer 的最大值，后者数组大小固定，两个阻塞队列都可以指定容量大小，当队列满时，如果有线程 put 数据，线程会阻塞住，直到有其他线程进行消费数据后，才会唤醒阻塞线程继续 put，当队列空时，如果有线程 take 数据，线程会阻塞到队列不空时，继续 take。</li><li>SynchronousQueue 同步队列，当线程 put 时，必须有对应线程把数据消费掉，put 线程才能返回，当线程 take 时，需要有对应线程进行 put 数据时，take 才能返回，反之则阻塞，举个例子，线程 A put 数据 A1 到队列中了，此时并没有任何的消费者，线程 A 就无法返回，会阻塞住，直到有线程消费掉数据 A1 时，线程 A 才能返回。</li></ol><h5 id="3-底层是如何实现阻塞的？"><a href="#3-底层是如何实现阻塞的？" class="headerlink" title="3.底层是如何实现阻塞的？"></a>3.底层是如何实现阻塞的？</h5><p>答：队列本身并没有实现阻塞的功能，而是利用 Condition 的等待唤醒机制，阻塞底层实现就是更改线程的状态为沉睡，细节我们在锁小节会说到。</p><h5 id="4-LinkedBlockingQueue-和-ArrayBlockingQueue-有啥区别。"><a href="#4-LinkedBlockingQueue-和-ArrayBlockingQueue-有啥区别。" class="headerlink" title="4.LinkedBlockingQueue 和 ArrayBlockingQueue 有啥区别。"></a>4.LinkedBlockingQueue 和 ArrayBlockingQueue 有啥区别。</h5><p>答：相同点：</p><ol><li>两者的阻塞机制大体相同，比如在队列满、空时，线程都会阻塞住。</li></ol><p>不同点：</p><ol><li>LinkedBlockingQueue 底层是链表结构，容量默认是 Interge 的最大值，ArrayBlockingQueue 底层是数组，容量必须在初始化时指定。</li><li>两者的底层结构不同，所以 take、put、remove 的底层实现也就不同。</li></ol><h5 id="5-往队列里面-put-数据是线程安全的么？为什么？"><a href="#5-往队列里面-put-数据是线程安全的么？为什么？" class="headerlink" title="5.往队列里面 put 数据是线程安全的么？为什么？"></a>5.往队列里面 put 数据是线程安全的么？为什么？</h5><p>答：是线程安全的，在 put 之前，队列会自动加锁，put 完成之后，锁会自动释放，保证了同一时刻只会有一个线程能操作队列的数据，以 LinkedBlockingQueue 为例子，put 时，会加 put 锁，并只对队尾 tail 进行操作，take 时，会加 take 锁，并只对队头 head 进行操作，remove 时，会同时加 put 和 take 锁，所以各种操作都是线程安全的，我们工作中可以放心使用。</p><h5 id="6-take-的时候也会加锁么？既然-put-和-take-都会加锁，是不是同一时间只能运行其中一个方法。"><a href="#6-take-的时候也会加锁么？既然-put-和-take-都会加锁，是不是同一时间只能运行其中一个方法。" class="headerlink" title="6.take 的时候也会加锁么？既然 put 和 take 都会加锁，是不是同一时间只能运行其中一个方法。"></a>6.take 的时候也会加锁么？既然 put 和 take 都会加锁，是不是同一时间只能运行其中一个方法。</h5><p>答：</p><ol><li><p>是的，take 时也会加锁的，像 LinkedBlockingQueue 在执行 take 方法时，在拿数据的同时，会把当前数据删除掉，就改变了链表的数据结构，所以需要加锁来保证线程安全。</p></li><li><p>这个需要看情况而言，对于 LinkedBlockingQueue 来说，队列的 put 和 take 都会加锁，但两者的锁是不一样的，所以两者互不影响，可以同时进行的，对于 ArrayBlockingQueue 而言，put 和 take 是同一个锁，所以同一时刻只能运行一个方法。</p></li></ol><h5 id="7-工作中经常使用队列的-put、take-方法有什么危害，如何避免。"><a href="#7-工作中经常使用队列的-put、take-方法有什么危害，如何避免。" class="headerlink" title="7.工作中经常使用队列的 put、take 方法有什么危害，如何避免。"></a>7.工作中经常使用队列的 put、take 方法有什么危害，如何避免。</h5><p>答：当队列满时，使用 put 方法，会一直阻塞到队列不满为止。</p><p>当队列空时，使用 take 方法，会一直阻塞到队列有数据为止。</p><p>两个方法都是无限（永远、没有超时时间的意思）阻塞的方法，容易使得线程全部都阻塞住，大流量时，导致机器无线程可用，所以建议在流量大时，使用 offer 和 poll 方法来代替两者，我们只需要设置好超时阻塞时间，这两个方法如果在超时时间外，还没有得到数据的话，就会返回默认值（LinkedBlockingQueue 为例），这样就不会导致流量大时，所有的线程都阻塞住了。</p><p>这个也是生产事故常常发生的原因之一，尝试用 put 和 take 方法，在平时自测中根本无法发现，对源码不熟悉的同学也不会意识到会有问题，当线上大流量打进来时，很有可能会发生故障，所以我们平时工作中使用队列时，需要谨慎再谨慎。</p><h5 id="8-把数据放入队列中后，有木有办法让队列过一会儿再执行？"><a href="#8-把数据放入队列中后，有木有办法让队列过一会儿再执行？" class="headerlink" title="8.把数据放入队列中后，有木有办法让队列过一会儿再执行？"></a>8.把数据放入队列中后，有木有办法让队列过一会儿再执行？</h5><p>答：可以的，DelayQueue 提供了这种机制，可以设置一段时间之后再执行，该队列有个唯一的缺点，就是数据保存在内存中，在重启和断电的时候，数据容易丢失，所以定时的时间我们都不会设置很久，一般都是几秒内，如果定时的时间需要设置很久的话，可以考虑采取延迟队列中间件（这种中间件对数据会进行持久化，不怕断电的发生）进行实现。</p><h5 id="9-DelayQueue-对元素有什么要求么，我把-String-放到队列中去可以么？"><a href="#9-DelayQueue-对元素有什么要求么，我把-String-放到队列中去可以么？" class="headerlink" title="9.DelayQueue 对元素有什么要求么，我把 String 放到队列中去可以么？"></a>9.DelayQueue 对元素有什么要求么，我把 String 放到队列中去可以么？</h5><p>答：DelayQueue 要求元素必须实现 Delayed 接口，Delayed 本身又实现了 Comparable 接口，Delayed 接口的作用是定义还剩下多久就会超时，给使用者定制超时时间的，Comparable 接口主要用于对元素之间的超时时间进行排序的，两者结合，就可以让越快过期的元素能够排在前面。</p><p>所以把 String 放到 DelayQueue 中是不行的，编译都无法通过，DelayQueue 类在定义的时候，是有泛型定义的，泛型类型必须是 Delayed 接口的子类才行。</p><h5 id="10-DelayQueue-如何让快过期的元素先执行的？"><a href="#10-DelayQueue-如何让快过期的元素先执行的？" class="headerlink" title="10.DelayQueue 如何让快过期的元素先执行的？"></a>10.DelayQueue 如何让快过期的元素先执行的？</h5><p>答：DelayQueue 中的元素都实现 Delayed 和 Comparable 接口的，其内部会使用 Comparable 的 compareTo 方法进行排序，我们可以利用这个功能，在 compareTo 方法中实现过期时间和当前时间的差，这样越快过期的元素，计算出来的差值就会越小，就会越先被执行。</p><h5 id="11-如何查看-SynchronousQueue-队列的大小？"><a href="#11-如何查看-SynchronousQueue-队列的大小？" class="headerlink" title="11.如何查看 SynchronousQueue 队列的大小？"></a>11.如何查看 SynchronousQueue 队列的大小？</h5><p>答：此题是个陷进题，题目首先设定了 SynchronousQueue 是可以查看大小的，实际上 SynchronousQueue 本身是没有容量的，所以也无法查看其容量的大小，其内部的 size 方法都是写死的返回 0。</p><h5 id="12-SynchronousQueue-底层有几种数据结构，两者有何不同？"><a href="#12-SynchronousQueue-底层有几种数据结构，两者有何不同？" class="headerlink" title="12.SynchronousQueue 底层有几种数据结构，两者有何不同？"></a>12.SynchronousQueue 底层有几种数据结构，两者有何不同？</h5><p>答：底层有两种数据结构，分别是队列和堆栈。</p><p>两者不同点：</p><ol><li>队列维护了先入先出的顺序，所以最先进去队列的元素会最先被消费，我们称为公平的，而堆栈则是先入后出的顺序，最先进入堆栈中的数据可能会最后才会被消费，我们称为不公平的。</li><li>两者的数据结构不同，导致其 take 和 put 方法有所差别，具体的可以看 《 SynchronousQueue 源码解析 》章节。</li></ol><h5 id="13-假设-SynchronousQueue-底层使用的是堆栈，线程-1-执行-take-操作阻塞住了，然后有线程-2-执行-put-操作，问此时线程-2-是如何把-put-的数据传递给-take-的？"><a href="#13-假设-SynchronousQueue-底层使用的是堆栈，线程-1-执行-take-操作阻塞住了，然后有线程-2-执行-put-操作，问此时线程-2-是如何把-put-的数据传递给-take-的？" class="headerlink" title="13.假设 SynchronousQueue 底层使用的是堆栈，线程 1 执行 take 操作阻塞住了，然后有线程 2 执行 put 操作，问此时线程 2 是如何把 put 的数据传递给 take 的？"></a>13.假设 SynchronousQueue 底层使用的是堆栈，线程 1 执行 take 操作阻塞住了，然后有线程 2 执行 put 操作，问此时线程 2 是如何把 put 的数据传递给 take 的？</h5><p>答：这是一个好问题，也是理解 SynchronousQueue 的核心问题。</p><p>首先线程 1 被阻塞住，此时堆栈头就是线程 1 了，此时线程 2 执行 put 操作，会把 put 的数据赋值给堆栈头的 match 属性，并唤醒线程 1，线程 1 被唤醒后，拿到堆栈头中的 match 属性，就能够拿到 put 的数据了。</p><p>严格上说并不是 put 操作直接把数据传递给了 take，而是 put 操作改变了堆栈头的数据，从而 take 可以从堆栈头上直接拿到数据，堆栈头是 take 和 put 操作之间的沟通媒介。</p><h5 id="14-如果想使用固定大小的队列，有几种队列可以选择，有何不同？"><a href="#14-如果想使用固定大小的队列，有几种队列可以选择，有何不同？" class="headerlink" title="14.如果想使用固定大小的队列，有几种队列可以选择，有何不同？"></a>14.如果想使用固定大小的队列，有几种队列可以选择，有何不同？</h5><p>答：可以使用 LinkedBlockingQueue 和 ArrayBlockingQueue 两种队列。</p><p>前者是链表，后者是数组，链表新增时，只要建立起新增数据和链尾数据之间的关联即可，数组新增时，需要考虑到索引的位置（takeIndex 和 putIndex 分别记录着下次拿数据、放数据的索引位置），如果增加到了数组最后一个位置，下次就要重头开始新增。</p><h5 id="15-ArrayBlockingQueue-可以动态扩容么？用到数组最后一个位置时怎么办？"><a href="#15-ArrayBlockingQueue-可以动态扩容么？用到数组最后一个位置时怎么办？" class="headerlink" title="15.ArrayBlockingQueue 可以动态扩容么？用到数组最后一个位置时怎么办？"></a>15.ArrayBlockingQueue 可以动态扩容么？用到数组最后一个位置时怎么办？</h5><p>答：不可以的，虽然 ArrayBlockingQueue 底层是数组，但不能够动态扩容的。</p><p>假设 put 操作用到了数组的最后一个位置，那么下次 put 就需要从数组 0 的位置重新开始了。</p><p>假设 take 操作用到数组的最后一个位置，那么下次 take 的时候也会从数组 0 的位置重新开始。</p><h5 id="16-ArrayBlockingQueue-take-和-put-都是怎么找到索引位置的？是利用-hash-算法计算得到的么？"><a href="#16-ArrayBlockingQueue-take-和-put-都是怎么找到索引位置的？是利用-hash-算法计算得到的么？" class="headerlink" title="16.ArrayBlockingQueue take 和 put 都是怎么找到索引位置的？是利用 hash 算法计算得到的么？"></a>16.ArrayBlockingQueue take 和 put 都是怎么找到索引位置的？是利用 hash 算法计算得到的么？</h5><p>答：ArrayBlockingQueue 有两个属性，为 takeIndex 和 putIndex，分别标识下次 take 和 put 的位置，每次 take 和 put 完成之后，都会往后加一，虽然底层是数组，但和 HashMap 不同，并不是通过 hash 算法计算得到的。</p><h4 id="4-5-2-总结"><a href="#4-5-2-总结" class="headerlink" title="4.5.2-总结"></a>4.5.2-总结</h4><p>队列是锁、线程池等复杂 API 的基础，很多面试官都会在问这些 API 时冷不防的问你队列的知识，如果你回答不好，面试官可能会认为你仅仅是用过锁和线程池，但却对其底层的原理和实现了解的不够全面，所以说队列还是蛮重要的，但队列的源码比较复杂，建议大家可以尝试 debug 的方式来理解源码。</p><h3 id="4-6-举一反三：队列在-Java-其它源码中的应用"><a href="#4-6-举一反三：队列在-Java-其它源码中的应用" class="headerlink" title="4.6-举一反三：队列在 Java 其它源码中的应用"></a>4.6-举一反三：队列在 Java 其它源码中的应用</h3><p>队列除了提供 API 供开发者使用外，自身也和 Java 中其他 API 紧密结合，比如线程池和锁，线程池直接使用了队列的 API，锁借鉴了队列的思想，重新实现了队列，线程池和锁都是我们工作中经常使用的 API，也是面试官常问的 API，队列在两者的实现上发挥着至关重要的作用，接下来我们一起来看下。</p><h4 id="4-6-1-队列和线程池的结合"><a href="#4-6-1-队列和线程池的结合" class="headerlink" title="4.6.1-队列和线程池的结合"></a>4.6.1-队列和线程池的结合</h4><h5 id="1-队列在线程池中的作用"><a href="#1-队列在线程池中的作用" class="headerlink" title="1.队列在线程池中的作用"></a>1.队列在线程池中的作用</h5><p>线程池大家应该都使用过，比如我们想新建一个固定大小的线程池，并让运行的线程打印一句话出来，我们会这么写代码：</p><pre class=" language-java"><code class="language-java">ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// submit 是提交任务的意思</span><span class="token comment" spellcheck="true">// Thread.currentThread() 得到当前线程</span>executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" is run"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 打印结果(我们打印出了当前线程的名字)：</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> is run</code></pre><p>代码中的 Executors 是并发的工具类，主要是为了帮助我们更方便的构造线程池的，其中 newFixedThreadPool 方法表示会构造出固定大小的线程池，我们给的入参是 10，代表线程池最大可以构造 10 个线程出来。</p><p>在实际的工作中，我们对流量的大小是无法控制的，这里我们设定的最大是 10 个线程，但如果一下子来了 100 个请求，这时候 10 个线程肯定是忙不过来了，那么剩余的 90 个请求怎么办呢？</p><p>这时候就需要队列出马了，我们会把线程无法消化的数据放到队列中去，让数据在队列中排队，等线程有能力消费了，再从队列中拿出来慢慢去消费。</p><p>我们画一个图释义一下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97.jpeg" alt="线程池中的队列"></p><p>上图右边表示 10 个线程正在全力消费请求，左边表示剩余请求正在队列中排队，等待消费。</p><p>由此可见，队列在线程池中占有很重要的地位，当线程池中的线程忙不过来的时候，请求都可以在队列中等待，从而慢慢地消费。</p><p>接下来我们来看下，线程池到底用到了那几种队列类型，分别起的什么作用。</p><h5 id="2-线程池中使用到的队列的类型"><a href="#2-线程池中使用到的队列的类型" class="headerlink" title="2.线程池中使用到的队列的类型"></a>2.线程池中使用到的队列的类型</h5><ul><li><h6 id="LinkedBlockingQueue-队列的使用"><a href="#LinkedBlockingQueue-队列的使用" class="headerlink" title="LinkedBlockingQueue 队列的使用"></a>LinkedBlockingQueue 队列的使用</h6><p>刚刚我们说的 newFixedThreadPool 是一种固定大小的线程池，意思是当线程池初始化好后，线程池里面的线程大小是不会变的了（线程池默认设置是不会回收核心线程数的），我们来看下 newFixedThreadPool 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ThreadPoolExecutor 初始化时，第一个参数表示 coreSize，第二个参数是 maxSize，coreSize == maxSize,</span><span class="token comment" spellcheck="true">// 表示线程池初始化时，线程大小已固定，所以叫做固定(Fixed)线程池。 </span><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>                                  0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>源码中可以看到初始化了 ThreadPoolExecutor，ThreadPoolExecutor 是线程池的 API，我们在线程池章节会细说，它的第五个构造参数就是队列，线程池根据场景会选择不同的队列，此处使用的是 LinkedBlockingQueue，并且是默认参数的 Queue，这说明此阻塞队列的最大容量是 Integer 的最大值，也就是说当线程池的处理能力有限时，阻塞队列中最大可以存放 Integer 最大值个任务。</p><p>但我们在实际工作中，常常不建议直接使用 newFixedThreadPool，主要是因为其使用的是 LinkedBlockingQueue 的默认构造器，队列容量太大了，在要求实时响应的请求中，队列容量太大往往危害也很大。</p><p>比如说我们用上述的线程池，线程 10 个，队列是 Integer 的最大值，当并发流量很大时，比如来了 1w/qps 请求，这时候 10 个线程根本消费不完，就会有很多请求被阻塞在队列中，虽然 10 个线程仍然在不断地消费，但需要消费完队列中的所有数据是需要时间的，假设需要 3 秒才能全部消费完，而这些实时请求都是有超时时间的，默认超时时间是 2 秒，当时间到达 2 秒时，请求已经超时了，返回报错，可这时候队列中的任务还有很多都在等待消费呢，即使后来消费完成，也无法返回给调用方了。</p><p>以上情况就会造成，调用方看到接口是超时报错返回的，但服务端的任务其实还在排队执行，过了 3 秒后，服务端的任务可能都会执行成功，但调用方已经无法感知了，调用方再次调用时，就会发现其实这笔请求已经成功了。</p><p>如果调用方是从页面发起的，那么体验就会更差，页面上第一次调用页面报错，用户重新刷新页面时，页面显示上次的请求已经成功了，这个就是很不好的体验了。</p><p>所以我们希望队列的大小不要设置成那么大，可以根据实际的消费情况来设置队列的大小，这样就可以保证在接口超时前，队列中排队的请求可以执行完。</p><p>场景比较复杂，为了方便理解，我们画了一个图，把整个流程释义一下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%BD%BF%E7%94%A8LinkedBlockingQueue.jpeg" alt="线程池中使用LinkedBlockingQueue"></p><p>这种问题，在实际工作中已经属于非常严重的生产事故了，我们使用时一定要小心。</p><p>和 newFixedThreadPool 相同的是，newSingleThreadExecutor 方法底层使用的也是 LinkedBlockingQueue，newSingleThreadExecutor 线程池底层线程只会有一个，这代表着这个线程池一次只能处理一个请求，其余的请求都会在队列中排队等待执行，我们看下 newSingleThreadExecutor 的源码实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FinalizableDelegatedExecutorService</span>        <span class="token comment" spellcheck="true">// 前两个参数规定了这个线程池一次只能消费一个线程</span>        <span class="token comment" spellcheck="true">// 第五个参数使用的是 LinkedBlockingQueue,说明当请求超过单线程消费能力时，就会排队</span>        <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>                                0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到，底层使用的也是 LinkedBlockingQueue 的默认参数，也就是说排队的最大值是 Integer 的最大值。</p></li><li><h6 id="SynchronousQueue-队列"><a href="#SynchronousQueue-队列" class="headerlink" title="SynchronousQueue 队列"></a>SynchronousQueue 队列</h6><p>除了 newFixedThreadPool 方法，在线程池新建时，还有其他的几个方法也对应着不同的队列，我们一起来看下 newCachedThreadPool，newCachedThreadPool 底层对应的是 SynchronousQueue 队列，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 第五个参数是 SynchronousQueue</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span>                                  60L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                                  <span class="token keyword">new</span> <span class="token class-name">SynchronousQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>SynchronousQueue 队列是没有大小限制的，请求多少队列都能承受的住，可以说这是他的优点，缺点就是每次往队列里面 put 数据时，并不能立马返回，而是需要等待有线程 take 数据之后，才能正常返回，如果请求量大，而消费能力较差时，就会导致大量请求被 hodler 住，必须等到慢慢消费完成之后才能被释放，所以在平时工作使用中也需要慎重。</p></li><li><h6 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h6><p>newScheduledThreadPool 代表定时任务线程池，底层源码如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/newScheduledThreadPool.jpeg" alt="newScheduledThreadPool"></p><p>截图从左往右我们可以看到，底层队列使用的是 DelayedWorkQueue 延迟队列，说明线程池底层延时的功能就是 DelayedWorkQueue 队列提供的，新的延迟请求都先到队列中去，延迟时间到了，线程池自然就能从队列中拿出线程进行执行了。</p><p>newSingleThreadScheduledExecutor 方法也是和 newScheduledThreadPool 一样的，使用 DelayedWorkQueue 的延迟功能，只不过前者是单个线程执行。</p></li></ul><h5 id="3-小结-4"><a href="#3-小结-4" class="headerlink" title="3.小结"></a>3.小结</h5><p>从线程池的源码中，我们可以看到：</p><ol><li>队列在线程池的设计中，起着缓冲数据，延迟执行数据的作用，当线程池消费能力有限时，可以让请求进行排队，让线程池可以慢慢消费。</li><li>线程池根据不同的场景，选择使用了 DelayedWorkQueue、SynchronousQueue、LinkedBlockingQueue 多种队列，从而实现自己不同的功能，比如使用 DelayedWorkQueue 的延迟功能来实现定时执行线程池。</li></ol><h4 id="4-6-2-队列和锁的结合"><a href="#4-6-2-队列和锁的结合" class="headerlink" title="4.6.2-队列和锁的结合"></a>4.6.2-队列和锁的结合</h4><p>我们平时写锁代码的时候都这么写：</p><pre class=" language-java"><code class="language-java">ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span><span class="token punctuation">{</span>    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// do something</span><span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//throw Exception;</span><span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>    lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>初始化锁 -&gt; 加锁 -&gt; 执行业务逻辑 -&gt; 释放锁，这是正常的流程，但我们知道同一时刻只能有一个线程才能获得锁的，那么此时其他获取不到锁的线程该怎么办呢？</p><p>等待，其他获取不到锁的线程，都会到一个等待队列中去等待，等待锁被释放掉时，再去竞争锁，我们画一个示意图。</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E9%98%9F%E5%88%97%E5%92%8C%E9%94%81.jpeg" alt="队列和锁"></p><p>图中红色标识的就是同步队列，获取不到锁的线程都会到同步队列中去排队，当锁被释放后，同步队列中的线程就又开始去竞争锁。</p><p>可以看出队列在锁中起的作用之一，就是帮助管理获取不到锁的线程，让这些线程可以耐心的等待。</p><p>同步队列并没有使用现有的队列的 API 去实现，但底层的结构，思想和目前队列是一致的，所以我们学好队列章节，对理解锁的同步队列，用处非常大。</p><h4 id="4-6-3-总结"><a href="#4-6-3-总结" class="headerlink" title="4.6.3-总结"></a>4.6.3-总结</h4><p>队列的数据结构真的很重要，在线程池和锁两个重量级 API 中起着非常重要的作用，我们要非常清楚队列底层的大体的数据结构，了解数据是如何入队的，如何出队的，队列这章也是比较复杂的，建议大家多多 debug，我们 github 上也提供了一些 debug 的 demo，大家可以尝试调试起来。</p><h3 id="4-7-整体设计：队列设计思想、工作中使用场景"><a href="#4-7-整体设计：队列设计思想、工作中使用场景" class="headerlink" title="4.7-整体设计：队列设计思想、工作中使用场景"></a>4.7-整体设计：队列设计思想、工作中使用场景</h3><p>本章我们学习了 LinkedBlockingQueue、ArrayBlockingQueue、SynchronousQueue、DelayQueue 四种队列，四种队列底层数据结构各不相同，使用场景也不相同，本章我们从设计思想和使用场景两个大的方向做一些对比和总结。</p><h4 id="4-7-1-设计思想"><a href="#4-7-1-设计思想" class="headerlink" title="4.7.1-设计思想"></a>4.7.1-设计思想</h4><p>首先我们画出队列的总体设计图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E9%98%9F%E5%88%97%E7%9A%84%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1%E5%9B%BE.jpeg" alt="队列的总体设计图"></p><p>从图中我们可以看出几点：</p><ol><li>队列解耦了生产者和消费者，提供了生产者和消费者间关系的多种形式，比如 LinkedBlockingQueue、ArrayBlockingQueue 两种队列就把解耦了生产者和消费者，比如 SynchronousQueue 这种就把生产者和消费者相互对应（生产者的消息被消费者开始消费之后，生产者才能返回，为了方便理解，使用相互对应这个词）；</li><li>不同的队列有着不同的数据结构，有链表（LinkedBlockingQueue）、数组（ArrayBlockingQueue）、堆栈（SynchronousQueue）等；</li><li>不同的数据结构，决定了入队和出队的姿势是不同的。</li></ol><p>接下来我们分别按照这几个方面来总结分析一下。</p><h5 id="1-队列的数据结构"><a href="#1-队列的数据结构" class="headerlink" title="1.队列的数据结构"></a>1.队列的数据结构</h5><p>链表结构的队列就是 LinkedBlockingQueue，其特征如下：</p><ol><li>初始大小默认是 Integer 的最大值，也可以设置初始大小；</li><li>链表元素通过 next 属性关联下一个元素；</li><li>新增是从链表的尾部新增，拿是从链表头开始拿。</li></ol><p>数组结构的队列是 ArrayBlockingQueue，特征如下：</p><ol><li>容量大小是固定的，不能动态扩容；</li><li>有 takeIndex 和 putIndex 两个索引记录下次拿和新增的位置；</li><li>当 takeIndex 和 putIndex 到达数组的最后一个位置时，下次都是从 0 开始循环。</li></ol><p>SynchronousQueue 有着两种数据结构，分别是队列和堆栈，特征如下：</p><ol><li>队列保证了先入先出的数据结构，体现了公平性；</li><li>堆栈是先入后出的数据结构，是不公平的，但性能高于先入先出。</li></ol><h5 id="2-入队和出队的方式"><a href="#2-入队和出队的方式" class="headerlink" title="2.入队和出队的方式"></a>2.入队和出队的方式</h5><p>不同的队列有着不同的数据结构，导致其入队和出队的方式也不同：</p><ol><li>链表是入队是直接追加到队尾，出队是从链表头拿数据；</li><li>数组是有 takeIndex 和 putIndex 两个索引位置记录下次拿和取的位置，如总体设计图，入队直接指向了 putIndex，出队指向了 takeIndex；</li><li>堆栈主要都是围绕栈头进行入栈和出栈的。</li></ol><h5 id="3-生产者和消费者之间的通信机制"><a href="#3-生产者和消费者之间的通信机制" class="headerlink" title="3.生产者和消费者之间的通信机制"></a>3.生产者和消费者之间的通信机制</h5><p>从四种队列我们可以看出来生产者和消费者之间有两种通信机制，一种是强关联，一种是无关联。</p><p>强关联主要是指 SynchronousQueue 队列，生产者往队列中 put 数据，如果这时候没有消费者消费的话，生产者就会一直阻塞住，是无法返回的；消费者来队列里取数据，如果这时候队列中没有数据，消费者也会一直阻塞住，所以 SynchronousQueue 队列模型中，生产者和消费者是强关联的，如果只有其中一方存在，只会阻塞，是无法传递数据的。</p><p>无关联主要是说有数据存储功能的队列，比如说 LinkedBlockingQueue 和 ArrayBlockingQueue，只要队列容器不满，生产者就能放成功，生产者就可以直接返回，和有无消费者一点关系都没有，生产者和消费者完全解耦，通过队列容器的储存功能进行解耦。</p><h4 id="4-7-2-工作中的使用场景"><a href="#4-7-2-工作中的使用场景" class="headerlink" title="4.7.2-工作中的使用场景"></a>4.7.2-工作中的使用场景</h4><p>在日常工作中，我们需要根据队列的特征来匹配业务场景，从而决定使用哪种队列，我们总结下各个队列适合使用的场景：</p><h5 id="1-LinkedBlockingQueue"><a href="#1-LinkedBlockingQueue" class="headerlink" title="1.LinkedBlockingQueue"></a>1.LinkedBlockingQueue</h5><p>适合对生产的数据大小不定（时高时低），数据量较大的场景，比如说我们在淘宝上买东西，点击下单按钮时，对应着后台的系统叫做下单系统，下单系统会把下单请求都放到一个线程池里面，这时候我们初始化线程池时，一般会选择 LinkedBlockingQueue，并且设置一个合适的大小，此时选择 LinkedBlockingQueue 主要原因在于：在不高于我们设定的阈值内，队列里面的大小可大可小，不会有任何性能损耗，正好符合下单流量的特点，时大时小。</p><p>一般工作中，我们大多数都会选择 LinkedBlockingQueue 队列，但会设置 LinkedBlockingQueue 的最大容量，如果初始化时直接使用默认的 Integer 的最大值，当流量很大，而消费者处理能力很差时，大量请求都会在队列中堆积，会大量消耗机器的内存，就会降低机器整体性能甚至引起宕机，一旦宕机，在队列中的数据都会消失，因为队列的数据是保存在内存中的，一旦机器宕机，内存中的数据都会消失的，所以使用 LinkedBlockingQueue 队列时，建议还是要根据日常的流量设置合适的队列的大小。</p><h5 id="2-ArrayBlockingQueue"><a href="#2-ArrayBlockingQueue" class="headerlink" title="2.ArrayBlockingQueue"></a>2.ArrayBlockingQueue</h5><p>一般用于生产数据固定的场景，比如说系统每天会进行对账，对账完成之后，会固定的产生 100 条对账结果，因为对账结果固定，我们就可以使用 ArrayBlockingQueue 队列，大小可以设置成 100。</p><h5 id="3-DelayQueue"><a href="#3-DelayQueue" class="headerlink" title="3.DelayQueue"></a>3.DelayQueue</h5><p>延迟队列，在工作中经常遇到，主要用于任务不想立马执行，想等待一段时间才执行的场景。</p><p>比如说延迟对账，我们在工作中曾经遇到过这样的场景：我们在淘宝上买东西，弹出支付宝付款页面，在我们输入指纹的瞬间，流程主要是前端 -》交易后端 -》支付后端，交易后端调用支付后端主要是为了把我们支付宝的钱划给商家，而交易调用支付的过程中，有小概率的情况，因为网络抖动会发生超时的情况，这时候就需要通过及时的对账来解决这个事情（对账只是解决这个问题的手段之一），我们简单画一个流程图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E5%BB%B6%E8%BF%9F%E5%AF%B9%E8%B4%A6%E6%B5%81%E7%A8%8B.jpeg" alt="延迟对账流程"></p><p>这是一个真实场景，为了方便描述，已经大大简化了，再说明几点：</p><ol><li>交易调用支付的接口，这个接口的作用就是为了把小美的 800 元转给商家小明；</li><li>接口调用超时，此时交易系统并不知道 800 有没有成功转给小明，当然想知道的方式有很多，我们选择了对账的方式，对账的目的就是为了知道当前 800 元有没有成功转给小明；</li><li>延迟对账的目的，因为支付系统把 800 元转给商家小明也是需要时间的，如果超时之后立马对账，可能转账的动作还在进行中，导致对账的结果不准确，所以需要延迟几秒后再去对账；</li><li>对账之后的结果有几种，比如已经成功的把 800 元转给小明了，这时候需要把对账结果告诉交易系统，交易系统更新数据，前端就能够显示转账成功了。</li></ol><p>在这个案列中，延迟对账的核心技术就是 DelayQueue，我们大概这么做的：新建对账任务，设置 3 秒之后执行，把任务放到 DelayQueue 中，过了 3 秒之后，就会自动执行对账任务了。</p><p>DelayQueue 延迟执行的功能就在这个场景中得到应用。</p><h4 id="4-7-3-总结"><a href="#4-7-3-总结" class="headerlink" title="4.7.3-总结"></a>4.7.3-总结</h4><p>我们不会为了阅读源码而读源码，我们读源码的最初目的，是为了提高我们的技术深度，最终目的是为了在不同的场景中，能够选择合适的技术进行落地，本章中解释的一些队列的场景，我们在工作中其实都会遇到，特别是在使用线程池时，使用哪种队列是我们必须思考的一个问题，所以本章先比较了各个队列的适合使用场景，然后举了几个案列进行具体分析，希望大家也能把技术具体落地到实际工作中，使技术推动、辅助业务。</p><h3 id="4-8-惊叹面试官：由浅入深手写队列"><a href="#4-8-惊叹面试官：由浅入深手写队列" class="headerlink" title="4.8-惊叹面试官：由浅入深手写队列"></a>4.8-惊叹面试官：由浅入深手写队列</h3><p>现在不少大厂面试的时候会要求手写代码，我曾经看过一个大厂面试时，要求在线写代码，题目就是：在不使用 Java 现有队列 API 的情况下，手写出一个队列的实现出来，队列的数据结构，入队和出队方式都自己定义。</p><p>这题其实考察的有几个点：</p><ol><li>考察你对队列的内部结构熟不熟悉；</li><li>考察你定义 API 的功底；</li><li>考察写代码的基本功，代码风格。</li></ol><p>本章就和大家一起，结合以上几点，手写一个队列出来，一起来熟悉一下思路和过程</p><h4 id="4-8-1-接口定义"><a href="#4-8-1-接口定义" class="headerlink" title="4.8.1-接口定义"></a>4.8.1-接口定义</h4><p>在实现队列之前，我们首先需要定义出队列的接口，就是我们常说的 API，API 是我们队列的门面，定义时主要原则就是简单和好用。</p><p>我们这次实现的队列只定义放数据和拿数据两个功能，接口定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 定义队列的接口，定义泛型，可以让使用者放任意类型到队列中去* author  wenhe* date 2019/9/1*/</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Queue</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/**   * 放数据   * @param item 入参   * @return true 成功、false 失败   */</span>  <span class="token keyword">boolean</span> <span class="token function">put</span><span class="token punctuation">(</span>T item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 拿数据，返回一个泛型值   * @return   */</span>  T <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 队列中元素的基本结构</span>  <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 数据本身</span>    T item<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 下一个元素</span>    Node<span class="token operator">&lt;</span>T<span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 构造器</span>    <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>T item<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> item<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>有几点我们说明下：</p><ol><li><p>定义接口时，一定要写注释，接口的注释，方法的注释等等，这样别人看我们的接口时，会轻松很多‘；</p></li><li><p>定义接口时，要求命名简洁明了，最好让别人一看见命名就知道这个接口是干啥的，比如我们命名为 Queue，别人一看就清楚这个接口是和队列相关的；</p></li><li><p>用好泛型，因为我们不清楚放进队列中的到底都是那些值，所以我们使用了泛型 T，表示可以在队列中放任何值；</p></li><li><p>接口里面无需给方法写上 public 方法，因为接口中的方法默认都是 public 的，你写上编译器也会置灰，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89.jpeg" alt="接口定义"></p></li><li><p>我们在接口中定义了基础的元素 Node，这样队列子类如果想用的话，可以直接使用，增加了复用的可能性。</p></li></ol><h4 id="4-8-2-队列子类实现"><a href="#4-8-2-队列子类实现" class="headerlink" title="4.8.2-队列子类实现"></a>4.8.2-队列子类实现</h4><p>接着我们就要开始写子类实现了，我们准备写个最常用的链表数据结构的队列。</p><h5 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h5><p>底层数据结构我们采用链表，一说到链表，大家应该马上就会想到三个关键要素：链表头、链表尾和链表元素，我们也实现了，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 队列头 */</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> Node<span class="token operator">&lt;</span>T<span class="token operator">></span> head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 队列尾 */</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> Node<span class="token operator">&lt;</span>T<span class="token operator">></span> tail<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 自定义队列元素 */</span><span class="token keyword">class</span> <span class="token class-name">DIYNode</span> <span class="token keyword">extends</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token function">DIYNode</span><span class="token punctuation">(</span>T item<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>除了这些元素之外，我们还有队列容器的容量大小、队列目前的使用大小、放数据锁、拿数据锁等等，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 队列的大小，使用 AtomicInteger 来保证其线程安全 */</span><span class="token keyword">private</span> AtomicInteger size <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 容量 */</span><span class="token keyword">private</span> <span class="token keyword">final</span> Integer capacity<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 放数据锁 */</span><span class="token keyword">private</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 拿数据锁 */</span><span class="token keyword">private</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2.初始化"></a>2.初始化</h5><p>我们提供了使用默认容量（Integer 的最大值）和指定容量两种方式，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 无参数构造器，默认最大容量是 Integer.MAX_VALUE */</span><span class="token keyword">public</span> <span class="token function">DIYQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  capacity <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>  head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DIYNode</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 有参数构造器，可以设定容量的大小 * @param capacity */</span><span class="token keyword">public</span> <span class="token function">DIYQueue</span><span class="token punctuation">(</span>Integer capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 进行边界的校验</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>null <span class="token operator">==</span> capacity <span class="token operator">||</span> capacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>  head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DIYNode</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="3-put-方法的实现"><a href="#3-put-方法的实现" class="headerlink" title="3.put 方法的实现"></a>3.put 方法的实现</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">put</span><span class="token punctuation">(</span>T item<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 禁止空数据</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>null <span class="token operator">==</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">try</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 尝试加锁，500 毫秒未获得锁直接被打断</span>    <span class="token keyword">boolean</span> lockSuccess <span class="token operator">=</span> putLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>lockSuccess<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 校验队列大小</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>size<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> capacity<span class="token punctuation">)</span><span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"queue is full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 追加到队尾</span>    tail <span class="token operator">=</span> tail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DIYNode</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计数</span>    size<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"tryLock 500 timeOut"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"put error"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>put 方法的实现有几点我们需要注意的是：</p><ol><li>注意 try catch finally 的节奏，catch 可以捕捉多种类型的异常，我们这里就捕捉了超时异常和未知异常，在 finally 里面一定记得要释放锁，不然锁不会自动释放的，这个一定不能用错，体现了我们代码的准确性；</li><li>必要的逻辑检查还是需要的，比如入参是否为空的空指针检查，队列是否满的临界检查，这些检查代码可以体现出我们逻辑的严密性；</li><li>在代码的关键地方加上日志和注释，这点也是非常重要的，我们不希望关键逻辑代码注释和日志都没有，不利于阅读代码和排查问题；</li><li>注意线程安全，此处实现我们除了加锁之外，对于容量的大小（size）我们选择线程安全的计数类：AtomicInteger，来保证了线程安全；</li><li>加锁的时候，我们最好不要使用永远阻塞的方法，我们一定要用带有超时时间的阻塞方法，此处我们设置的超时时间是 300 毫秒，也就是说如果 300 毫秒内还没有获得锁，put 方法直接返回 false，当然时间大小你可以根据情况进行设置；</li><li>根据不同的情况设置不同的返回值，put 方法返回的是 false，在发生异常时，我们可以选择返回 false，或者直接抛出异常；</li><li>put 数据时追加到队尾的，所以我们只需要把新数据转化成 DIYNode，放到队列的尾部即可。</li></ol><h5 id="4-take-方法的实现"><a href="#4-take-方法的实现" class="headerlink" title="4.take 方法的实现"></a>4.take 方法的实现</h5><p>take 方法和 put 方法的实现非常类似，只不过 take 是从头部拿取数据，代码实现如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 队列是空的，返回 null</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>size<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 拿数据我们设置的超时时间更短</span>    <span class="token keyword">boolean</span> lockSuccess <span class="token operator">=</span> takeLock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>lockSuccess<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"加锁失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 把头结点的下一个元素拿出来</span>    Node expectHead <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把头结点的值拿出来</span>    T result <span class="token operator">=</span> head<span class="token punctuation">.</span>item<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 把头结点的值置为 null，帮助 gc</span>    head<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 重新设置头结点的值</span>    head <span class="token operator">=</span> <span class="token punctuation">(</span>DIYNode<span class="token punctuation">)</span> expectHead<span class="token punctuation">;</span>    size<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回头结点的值</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">" tryLock 200 timeOut"</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">" take error "</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>      takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过以上几步，我们的队列已经写完了。</p><h4 id="4-8-3-测试"><a href="#4-8-3-测试" class="headerlink" title="4.8.3-测试"></a>4.8.3-测试</h4><p>API 写好了，接下来我们要针对 API 写一些场景测试和单元测试，我们先写个场景测试，看看 API 能否跑通，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DIYQueueDemo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 我们需要测试的队列</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Queue<span class="token operator">&lt;</span>String<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DIYQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 生产者</span>  <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> String message<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Product</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> success <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>          log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"put {} success"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"put {} fail"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"put {} fail"</span><span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 消费者</span>  <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        String message <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"consumer message :{}"</span><span class="token punctuation">,</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"consumer message fail"</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 场景测试</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDIYQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    ThreadPoolExecutor executor <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                               <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 是偶数的话，就提交一个生产者，奇数的话提交一个消费者</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>代码测试的场景比较简单，从 0 开始循环到 1000，如果是偶数，就让生产者去生产数据，并放到队列中，如果是奇数，就让消费者去队列中拿数据出来进行消费，运行之后的结果如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E6%89%8B%E5%86%99%E9%98%9F%E5%88%97%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpeg" alt="手写队列测试结果"></p><p>从显示的结果来看，咱们写的 DIYQueue 没有太大的问题，当然如果想大规模的使用，还需要详细的单元测试和性能测试。</p><h4 id="4-8-4-总结"><a href="#4-8-4-总结" class="headerlink" title="4.8.4-总结"></a>4.8.4-总结</h4><p>通过本章的学习，不知道你有没有一种队列很简单的感觉，其实队列本身就很简单，没有想象的那么复杂。</p><p>只要我们懂得了队列的基本原理，清楚几种常用的数据结构，手写队列问题其实并不大，你也赶紧来试一试吧。</p><h2 id="5-线程"><a href="#5-线程" class="headerlink" title="5-线程"></a>5-线程</h2><h3 id="5-1-Thread-源码解析"><a href="#5-1-Thread-源码解析" class="headerlink" title="5.1-Thread 源码解析"></a>5.1-Thread 源码解析</h3><p>从本章开始我们开始学习线程的知识，线程是非常有趣的一个章节，大多数同学对于线程 API，属于不用就忘，到用时需要百度的情况，希望通过本小节的源码阅读，能够加深对线程的印象。</p><p>本小节主要三章，本章主要说线程的基本概念、使用姿势、Thread 和 Runnable 的源码；Future、ExecutorService 源码解析章节主要说异步线程执行；押宝线程源码面试题章节主要说说常遇到的源码面试题。</p><p>由于线程的概念很多，所以本章会先介绍很多线程的基本概念，说清楚后再解析源码。</p><h4 id="5-1-1-类注释"><a href="#5-1-1-类注释" class="headerlink" title="5.1.1-类注释"></a>5.1.1-类注释</h4><h5 id="1-Thread"><a href="#1-Thread" class="headerlink" title="1.Thread"></a>1.Thread</h5><ol><li><p>每个线程都有优先级，高优先级的线程可能会优先执行；</p></li><li><p>父线程创建子线程后，优先级、是否是守护线程等属性父子线程是一致的；</p></li><li><p>JVM 启动时，通常都启动 MAIN 非守护线程，以下任意一个情况发生时，线程就会停止：</p><p>退出方法被调用，并且安全机制允许这么做（比如调用 Thread.interrupt 方法）；</p><p>所有非守护线程都消亡，或者从运行的方法正常返回，或者运行的方法抛出了异常；</p></li><li><p>每个线程都有名字，多个线程可能具有相同的名字，Thread 有的构造器如果没有指定名字，会自动生成一个名字。</p></li></ol><h4 id="5-1-2-线程的基本概念"><a href="#5-1-2-线程的基本概念" class="headerlink" title="5.1.2-线程的基本概念"></a>5.1.2-线程的基本概念</h4><p>我们接下来介绍一下线程的基本概念：</p><h5 id="1-线程的状态"><a href="#1-线程的状态" class="headerlink" title="1.线程的状态"></a>1.线程的状态</h5><p>网上有各种介绍线程状态的文章，我们这里说线程的状态是从源码的角度，源码中一共列举了六种状态，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.jpeg" alt="线程的状态"></p><p>我们解析一下这个图：</p><ol><li>NEW 表示线程创建成功，但没有运行，在 new Thread 之后，没有 start 之前，线程的状态都是 NEW；</li><li>当我们运行 strat 方法，子线程被创建成功之后，子线程的状态变成 RUNNABLE，RUNNABLE 表示线程正在运行中；</li><li>子线程运行完成、被打断、被中止，状态都会从 RUNNABLE 变成 TERMINATED，TERMINATED 表示线程已经运行结束了；</li><li>如果线程正好在等待获得 monitor lock 锁，比如在等待进入 synchronized 修饰的代码块或方法时，会从 RUNNABLE 变成 BLOCKED，BLOCKED 表示阻塞的意思；</li><li>WAITING 和 TIMED_WAITING 类似，都表示在遇到 Object#wait、Thread#join、LockSupport#park 这些方法时，线程就会等待另一个线程执行完特定的动作之后，才能结束等待，只不过 TIMED_WAITING 是带有等待时间的（可以看下面的 join 方法的 demo）。</li></ol><p>再次重申，这 6 种状态并不是线程所有的状态，只是在 Java 源码中列举出的 6 种状态， Java 线程的处理方法都是围绕这 6 种状态的。</p><h5 id="2-优先级"><a href="#2-优先级" class="headerlink" title="2.优先级"></a>2.优先级</h5><p>优先级代表线程执行的机会的大小，优先级高的可能先执行，低的可能后执行，在 Java 源码中，优先级从低到高分别是 1 到 10，线程默认 new 出来的优先级都是 5，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 最低优先级</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> MIN_PRIORITY <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 普通优先级，也是默认的</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> NORM_PRIORITY <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 最大优先级</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> MAX_PRIORITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></code></pre><h5 id="3-守护线程"><a href="#3-守护线程" class="headerlink" title="3.守护线程"></a>3.守护线程</h5><p>我们默认创建的线程都是非守护线程。创建守护线程时，需要将 Thread 的 daemon 属性设置成 true，守护线程的优先级很低，当 JVM 退出时，是不关心有无守护线程的，即使还有很多守护线程，JVM 仍然会退出，我们在工作中，可能会写一些工具做一些监控的工作，这时我们都是用守护子线程去做，这样即使监控抛出异常，但因为是子线程，所以也不会影响到业务主线程，因为是守护线程，所以 JVM 也无需关注监控是否正在运行，该退出就退出，所以对业务不会产生任何影响。</p><h5 id="4-ClassLoader"><a href="#4-ClassLoader" class="headerlink" title="4.ClassLoader"></a>4.ClassLoader</h5><p>ClassLoader 我们可以简单理解成类加载器，就是把类从文件、二进制数组、URL 等位置加载成可运行 Class。</p><h4 id="5-1-3-线程的两种初始化方式"><a href="#5-1-3-线程的两种初始化方式" class="headerlink" title="5.1.3-线程的两种初始化方式"></a>5.1.3-线程的两种初始化方式</h4><p>无返回值的线程主要有两种初始化方式：</p><h5 id="1-继承-Thread，成为-Thread-的子类"><a href="#1-继承-Thread，成为-Thread-的子类" class="headerlink" title="1.继承 Thread，成为 Thread 的子类"></a>1.继承 Thread，成为 Thread 的子类</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 继承 Thread，实现其 run 方法</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token comment" spellcheck="true">// 调用 start 方法即可，会自动调用到 run 方法的</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">extendThreadInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上述代码打印出的线程名称是：Thread-0，而主线程的名字是：Thread [main,5,main]，由此可见，的确是开了一个子线程来执行打印的操作。</p><p>我们一起来看下 start 的底层源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 该方法可以创建一个新的线程出来</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果没有初始化，抛异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    group<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// started 是个标识符，我们在做一些事情的时候，经常这么写</span>    <span class="token comment" spellcheck="true">// 动作发生之前标识符是 false，发生完成之后变成 true</span>    <span class="token keyword">boolean</span> started <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这里会创建一个新的线程，执行完成之后，新的线程已经在运行了，既 target 的内容已经在运行了</span>        <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里执行的还是主线程</span>        started <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果失败，把线程从线程组中删除</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>started<span class="token punctuation">)</span> <span class="token punctuation">{</span>                group<span class="token punctuation">.</span><span class="token function">threadStartFailed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>         <span class="token comment" spellcheck="true">// Throwable 可以捕捉一些 Exception 捕捉不到的异常，比如说子线程抛出的异常</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/* do nothing. If start0 threw a Throwable then              it will be passed up the call stack */</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 开启新线程使用的是 native 方法</span><span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">start0</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="2-实现-Runnable-接口，作为-Thread-的入参"><a href="#2-实现-Runnable-接口，作为-Thread-的入参" class="headerlink" title="2.实现 Runnable 接口，作为 Thread 的入参"></a>2.实现 Runnable 接口，作为 Thread 的入参</h5><pre class=" language-java"><code class="language-java">Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} begin run"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 开一个子线程去执行</span>thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 不会新起线程，是在当前主线程上继续运行</span>thread<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这种就是实现 Runnable 的接口，并作为 Thread 构造器的入参，我们调用时使用了两种方式，可以根据情况选择使用 start 或 run 方法，使用 start 会开启子线程来执行 run 里面的内容，使用 run 方法执行的还是主线程。</p><p>我们来看下 run 方法的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 简单的运行，不会新起线程，target 是 Runnable</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        target<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>源码中的 target 就是在 new Thread 时，赋值的 Runnable。</p><h4 id="5-1-4-线程初始化"><a href="#5-1-4-线程初始化" class="headerlink" title="5.1.4-线程初始化"></a>5.1.4-线程初始化</h4><p>线程初始化的源码有点长，我们只看比较重要的代码 (不重要的被我删掉了)，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 无参构造器，线程名字自动生成</span><span class="token keyword">public</span> <span class="token function">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">init</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token string">"Thread-"</span> <span class="token operator">+</span> <span class="token function">nextThreadNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// g 代表线程组，线程组可以对组内的线程进行批量的操作，比如批量的打断 interrupt</span><span class="token comment" spellcheck="true">// target 是我们要运行的对象</span><span class="token comment" spellcheck="true">// name 我们可以自己传，如果不传默认是 "Thread-" + nextThreadNum()，nextThreadNum 方法返回的是自增的数字</span><span class="token comment" spellcheck="true">// stackSize 可以设置堆栈的大小</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>ThreadGroup g<span class="token punctuation">,</span> Runnable target<span class="token punctuation">,</span> String name<span class="token punctuation">,</span>                  <span class="token keyword">long</span> stackSize<span class="token punctuation">,</span> AccessControlContext acc<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>name <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"name cannot be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前线程作为父线程</span>    Thread parent <span class="token operator">=</span> <span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>group <span class="token operator">=</span> g<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 子线程会继承父线程的守护属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>daemon <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 子线程继承父线程的优先级属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>priority <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// classLoader</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>security <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token function">isCCLOverridden</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>contextClassLoader <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>contextClassLoader <span class="token operator">=</span> parent<span class="token punctuation">.</span>contextClassLoader<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>inheritedAccessControlContext <span class="token operator">=</span>            acc <span class="token operator">!=</span> null <span class="token operator">?</span> acc <span class="token operator">:</span> AccessController<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token function">setPriority</span><span class="token punctuation">(</span>priority<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当父线程的 inheritableThreadLocals 的属性值不为空时</span>    <span class="token comment" spellcheck="true">// 会把 inheritableThreadLocals 里面的值全部传递给子线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">!=</span> null<span class="token punctuation">)</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">=</span>            ThreadLocal<span class="token punctuation">.</span><span class="token function">createInheritedMap</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>inheritableThreadLocals<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>stackSize <span class="token operator">=</span> stackSize<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* Set thread ID */</span>    <span class="token comment" spellcheck="true">// 线程 id 自增</span>    tid <span class="token operator">=</span> <span class="token function">nextThreadID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从初始化源码中可以看到，很多属性，子线程都是直接继承父线程的，包括优先性、守护线程、inheritableThreadLocals 里面的值等等。</p><h4 id="5-1-5-线程其他操作"><a href="#5-1-5-线程其他操作" class="headerlink" title="5.1.5-线程其他操作"></a>5.1.5-线程其他操作</h4><h5 id="1-join"><a href="#1-join" class="headerlink" title="1. join"></a>1. join</h5><p>join 的意思就是当前线程等待另一个线程执行完成之后，才能继续操作，我们写了一个 demo，如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>  Thread main <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} is run。"</span><span class="token punctuation">,</span>main<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} begin run"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>30000L<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} end run"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 开一个子线程去执行</span>  thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 当前主线程等待子线程执行完成之后再执行</span>  thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} is end"</span><span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>执行的结果，就是主线程在执行 thread.join (); 代码后会停住，会等待子线程沉睡 30 秒后再执行，这里的 join 的作用就是让主线程等待子线程执行完成，我们画一个图示意一下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Thread-join%E8%BF%87%E7%A8%8B.jpeg" alt="Thread-join过程"></p><p>从图中可以看出，主线程一直等待子线程沉睡 30s 后才继续执行，在等待期间，主线程的状态也是 TIMED_WAITING。</p><h5 id="2-yield"><a href="#2-yield" class="headerlink" title="2.yield"></a>2.yield</h5><p>yield 是个 native 方法，底层代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>意思是当前线程做出让步，放弃当前 cpu，让 cpu 重新选择线程，避免线程过度使用 cpu，我们在写 while 死循环的时候，预计短时间内 while 死循环可以结束的话，可以在循环里面使用 yield 方法，防止 cpu 一直被 while 死循环霸占。</p><p>有点需要说明的是，让步不是绝不执行，重新竞争时，cpu 也有可能重新选中自己。</p><h5 id="3-sleep"><a href="#3-sleep" class="headerlink" title="3.sleep"></a>3.sleep</h5><p>sleep 也是 native 方法，可以接受毫秒的一个入参，也可以接受毫秒和纳秒的两个入参，意思是当前线程会沉睡多久，沉睡时不会释放锁资源，所以沉睡时，其它线程是无法得到锁的。</p><p>接受毫秒和纳秒两个入参时，如果给定纳秒大于等于 0.5 毫秒，算一个毫秒，否则不算。</p><h5 id="4-interrupt"><a href="#4-interrupt" class="headerlink" title="4.interrupt"></a>4.interrupt</h5><p>interrupt 中文是打断的意思，意思是可以打断中止正在运行的线程，比如：</p><ol><li>Object#wait ()、Thread#join ()、Thread#sleep (long) 这些方法运行后，线程的状态是 WAITING 或 TIMED_WAITING，这时候打断这些线程，就会抛出 InterruptedException 异常，使线程的状态直接到 TERMINATED；</li><li>如果 I/O 操作被阻塞了，我们主动打断当前线程，连接会被关闭，并抛出 ClosedByInterruptException 异常；</li></ol><p>我们举一个例子来说明如何打断 WAITING 的线程，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>  Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} begin run"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"子线程开始沉睡 30 s"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>30000L<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"子线程被打断"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} end run"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 开一个子线程去执行</span>  thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"主线程等待 1s 后，发现子线程还没有运行成功，打断子线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  thread<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>例子主要说的是，主线程会等待子线程执行 1s，如果 1s 内子线程还没有执行完，就会打断子线程，子线程被打断后，会抛出 InterruptedException 异常，执行结束，运行的结果如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E6%8A%9B%E5%BC%82%E5%B8%B8.jpeg" alt="线程中断抛异常"></p><h4 id="5-1-6-总结"><a href="#5-1-6-总结" class="headerlink" title="5.1.6-总结"></a>5.1.6-总结</h4><p>本章主要介绍了线程的基本概念、状态、无返回值线程的初始化方式和线程的常用操作，这些知识也是工作中常用的，也是大家都必须了解的，为后面的学习打下基础。</p><h3 id="5-2-Future、ExecutorService-源码解析"><a href="#5-2-Future、ExecutorService-源码解析" class="headerlink" title="5.2-Future、ExecutorService 源码解析"></a>5.2-Future、ExecutorService 源码解析</h3><p>本章和大家一起看下有返回值的线程如何创建，两种线程 API 之间如何关联，介绍一下和线程相关的其余 API。</p><h4 id="5-2-1-整体架构"><a href="#5-2-1-整体架构" class="headerlink" title="5.2.1-整体架构"></a>5.2.1-整体架构</h4><p>画了一个关于线程 API 之间关系的依赖图，如下：</p><p>![线程 API 关系依赖图](线程 API 关系依赖图.jpeg)</p><p>在上一章节，我们说了 Thread 和 Runnable，本小节我们按照这个图把剩下的几个 API 也说完，然后把 API 之间的关系理清楚。</p><p>为了方便大家更好的理解，我们首先看一个 demo，这个场景说的是我们往线程池里面提交一个有返回值的线程，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 首先我们创建了一个线程池</span>ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> 0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                                     <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// futureTask 我们叫做线程任务，构造器的入参是 Callable</span>FutureTask futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回一句话</span>    <span class="token keyword">return</span> <span class="token string">"我是子线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 把任务提交到线程池中，线程池会分配线程帮我们执行任务</span>executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 得到任务执行的结果</span>String result <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"result is {}"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>从上面这个 demo 中，我们大概可以看出各个 API 的作用：</p><ol><li>Callable 定义我们需要做的事情，是可以有返回值的；</li><li>FutureTask 我们叫做任务，入参是 Callable，是对 Callable 的包装，方便线程池的使用；</li><li>最后通过 FutureTask.get() 得到子线程的计算结果。</li></ol><p>接着我们分别来看看各种 API 的底层实现。</p><h4 id="5-2-2-Callable"><a href="#5-2-2-Callable" class="headerlink" title="5.2.2-Callable"></a>5.2.2-Callable</h4><p>Callable 是一个接口，约定了线程要做的事情，和 Runnable 一样，不过这个线程任务是有返回值的，我们来看下接口定义：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    V <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>返回值是一个泛型，可以定义成任何类型，但我们使用的时候，都不会直接使用 Callable，而是会结合 FutureTask 一起使用。</p><h4 id="5-2-3-FutureTask"><a href="#5-2-3-FutureTask" class="headerlink" title="5.2.3-FutureTask"></a>5.2.3-FutureTask</h4><p>FutureTask 我们可以当做是线程运行的具体任务，从上图中，我们可以看到 FutureTask 实现了 RunnableFuture 接口，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>而 RunnableFuture 又实现了 Runnable, Future 两个接口，接下来我们先看 Future，再看 RunnableFuture，最后看 FutureTask。</p><h5 id="1-Future"><a href="#1-Future" class="headerlink" title="1.Future"></a>1.Future</h5><p>我们刚才说 Callable 是可以返回子线程执行结果的，在获取结果的时候，就需要用到 Future 接口了。</p><p>Future 接口注释上写了这些：</p><ol><li>定义了异步计算的接口，提供了计算是否完成的 check、等待完成和取回等多种方法；</li><li>如果想得到结果可以使用 get 方法，此方法(无参方法)会一直阻塞到异步任务计算完成；</li><li>取消可以使用 cancel 方法，但一旦任务计算完成，就无法被取消了。</li></ol><p>Future 接口定义了这些方法：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果任务已经成功了，或已经取消了，是无法再取消的，会直接返回取消成功(true)</span><span class="token comment" spellcheck="true">// 如果任务还没有开始进行时，发起取消，是可以取消成功的。</span><span class="token comment" spellcheck="true">// 如果取消时，任务已经在运行了，mayInterruptIfRunning 为 true 的话，就可以打断运行中的线程</span><span class="token comment" spellcheck="true">// mayInterruptIfRunning 为 false，表示不能打断直接返回</span><span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 返回线程是否已经被取消了，true 表示已经被取消了</span><span class="token comment" spellcheck="true">// 如果线程已经运行结束了，isCancelled 和 isDone 返回的都是 true</span><span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 线程是否已经运行结束了</span><span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等待结果返回</span><span class="token comment" spellcheck="true">// 如果任务被取消了，抛 CancellationException 异常</span><span class="token comment" spellcheck="true">// 如果等待过程中被打断了，抛 InterruptedException 异常</span>V <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 等待，但是带有超时时间的，如果超时时间外仍然没有响应，抛 TimeoutException 异常</span>V <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">,</span> TimeoutException<span class="token punctuation">;</span></code></pre><p>从接口上可以看出，Future 定义了各种方法对任务进行了管理，比如说取消任务，得到任务的计算结果等等。</p><h5 id="2-RunnableFuture"><a href="#2-RunnableFuture" class="headerlink" title="2.RunnableFuture"></a>2.RunnableFuture</h5><p>RunnableFuture 也是一个接口，定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Runnable</span><span class="token punctuation">,</span> Future<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>RunnableFuture 接口的最大目的，是让 Future 可以对 Runnable 进行管理，可以取消 Runnable，查看 Runnable 是否完成等等。</p><h5 id="3-统一-Callable-和-Runnable"><a href="#3-统一-Callable-和-Runnable" class="headerlink" title="3.统一 Callable 和 Runnable"></a>3.统一 Callable 和 Runnable</h5><p>我们现在清楚了，新建任务有两种方式，一种是无返回值的 Runnable，一种是有返回值的 Callable，但对 Java 其他 API 来说使用起来并不是很方便，没有一个统一的接口，比如说线程池在提交任务时，是不是应该针对 Runnable 和 Callable 两种情况提供不同的实现思路呢？所以 FutureTask 出现了，FutureTask 实现了 RunnableFuture 接口，又集合了 Callable（Callable 是 FutureTask 的属性），还提供了两者一系列的转化方法，这样 FutureTask 就统一了 Callable 和 Runnable，我们一起来细看下。</p><ul><li><h6 id="FutureTask-的类定义"><a href="#FutureTask-的类定义" class="headerlink" title="FutureTask 的类定义"></a>FutureTask 的类定义</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">RunnableFuture</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>从类定义上可以看出来 FutureTask 实现了 RunnableFuture 接口，也就是说间接实现了 Runnnable 接口（RunnableFuture 实现了 Runnnable 接口），就是说 FutureTask 本身就是个 Runnnable，同时 FutureTask 也实现了 Future，也就是说 FutureTask 具备对任务进行管理的功能（Future 具备对任务进行管理的功能）。</p></li><li><h6 id="FutureTask-的属性"><a href="#FutureTask-的属性" class="headerlink" title="FutureTask 的属性"></a>FutureTask 的属性</h6><p>我们一起来看下 FutureTask 有哪些重要属性：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 任务状态</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NEW          <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//线程任务创建</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COMPLETING   <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务执行中</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NORMAL       <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务执行结束</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCEPTIONAL  <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务异常</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED    <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务取消成功</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTING <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务正在被打断中</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INTERRUPTED  <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务被打断成功</span><span class="token comment" spellcheck="true">// 组合了 Callable </span><span class="token keyword">private</span> Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 异步线程返回的结果</span><span class="token keyword">private</span> Object outcome<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 当前任务所运行的线程</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> Thread runner<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 记录调用 get 方法时被等待的线程</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> WaitNode waiters<span class="token punctuation">;</span></code></pre><p>从属性上我们明显看到 Callable 是作为 FutureTask 的属性之一，这也就让 FutureTask 具备了转化 Callable 和 Runnable 的功能，接着我们看下 FutureTask 的构造器，看看两者是如何转化的。</p></li><li><h6 id="FutureTask-的构造器"><a href="#FutureTask-的构造器" class="headerlink" title="FutureTask 的构造器"></a>FutureTask 的构造器</h6><p>FutureTask 有两个构造器，分别接受 Callable 和 Runnable，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 Callable 进行初始化</span><span class="token keyword">public</span> <span class="token function">FutureTask</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>callable <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> callable<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 任务状态初始化</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// ensure visibility of callable</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用 Runnable 初始化，并传入 result 作为返回结果。</span><span class="token comment" spellcheck="true">// Runnable 是没有返回值的，所以 result 一般没有用，置为 null 就好了</span><span class="token keyword">public</span> <span class="token function">FutureTask</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">,</span> V result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Executors.callable 方法把 runnable 适配成 RunnableAdapter，RunnableAdapter 实现了 callable，所以也就是把 runnable 直接适配成了 callable。</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>callable <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">callable</span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> NEW<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// ensure visibility of callable</span><span class="token punctuation">}</span></code></pre><p>Runnable 的两个构造器，只有一个目的，就是把入参都转化成 Callable，那么为什么不都转化成 Runnnable 呢？主要是因为 Callable 的功能比 Runnnable 丰富，Callable 有返回值，而 Runnnable 没有。</p><p>我们注意到入参是 Runnable 的构造器，会使用 Executors.callable 方法来把 Runnnable 转化成 Callable，Runnnable 和 Callable 两者都是接口，两者之间是无法进行转化的，所以 Java 新建了一个转化类：RunnableAdapter 来进行转化，我们来看下转化的逻辑：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 转化 Runnable 成 Callable 的工具类</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">RunnableAdapter</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Runnable task<span class="token punctuation">;</span>    <span class="token keyword">final</span> T result<span class="token punctuation">;</span>    <span class="token function">RunnableAdapter</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">,</span> T result<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>task <span class="token operator">=</span> task<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>result <span class="token operator">=</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们可以看到：</p><ol><li>首先 RunnableAdapter 实现了 Callable，所以 RunnableAdapter 就是 Callable；</li><li>其次 Runnable 是 RunnableAdapter 的一个属性，在构造 RunnableAdapter 的时候会传进来，并且在 call 方法里面调用 Runnable 的 run 方法。</li></ol><p>这是一个典型的适配模型，我们要把 Runnable 适配成 Callable，首先要实现 Callable 的接口，接着在 Callable 的 call 方法里面调用被适配对象（Runnable）的方法。</p><p>FutureTask 构造器设计很巧妙，将 Runnable 和 Callable 灵活的打通，向内和向外只提供功能更加丰富的 Callable 接口，值得我们学习。</p></li><li><h6 id="FutureTask-对-Future-接口方法的实现"><a href="#FutureTask-对-Future-接口方法的实现" class="headerlink" title="FutureTask 对 Future 接口方法的实现"></a>FutureTask 对 Future 接口方法的实现</h6><p>我们主要看几个关键的方法实现源码。</p><ul><li><p>get</p><p>get 有无限阻塞和带超时时间两种方法，我们通常建议使用带超时时间的方法，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">,</span> TimeoutException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>unit <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果任务已经在执行中了，并且等待一定的时间后，仍然在执行中，直接抛出异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&lt;=</span> COMPLETING <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>s <span class="token operator">=</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> COMPLETING<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 任务执行成功，返回执行的结果</span>    <span class="token keyword">return</span> <span class="token function">report</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等待任务执行完成</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">awaitDone</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算等待终止时间，如果一直等待的话，终止时间为 0</span>    <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> 0L<span class="token punctuation">;</span>    WaitNode q <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 不排队</span>    <span class="token keyword">boolean</span> queued <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 无限循环</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果线程已经被打断了，删除，抛异常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 当前任务状态</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当前任务已经执行完了，返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> COMPLETING<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 当前任务的线程置空</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">!=</span> null<span class="token punctuation">)</span>                q<span class="token punctuation">.</span>thread <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果正在执行，当前线程让出 cpu，重新竞争，防止 cpu 飙高</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> COMPLETING<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// cannot time out yet</span>            Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果第一次运行，新建 waitNode，当前线程就是 waitNode 的属性</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>q <span class="token operator">==</span> null<span class="token punctuation">)</span>            q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WaitNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 默认第一次都会执行这里，执行成功之后，queued 就为 true，就不会再执行了</span>            <span class="token comment" spellcheck="true">// 把当前 waitNode 当做 waiters 链表的第一个</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>queued<span class="token punctuation">)</span>            queued <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> waitersOffset<span class="token punctuation">,</span>                                                 q<span class="token punctuation">.</span>next <span class="token operator">=</span> waiters<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果设置了超时时间，并过了超时时间的话，从 waiters 链表中删除当前 wait</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span>            nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">removeWaiter</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> state<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 没有过超时时间，线程进入 TIMED_WAITING 状态</span>            LockSupport<span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 没有设置超时时间，进入 WAITING 状态</span>        <span class="token keyword">else</span>            LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>get 方法虽然名字叫做 get，但却做了很多 wait 的事情，当发现任务还在进行中，没有完成时，就会阻塞当前进程，等待任务完成后再返回结果值。阻塞底层使用的是 LockSupport.park 方法，使当前线程进入 WAITING 或 TIMED_WAITING 状态。</p></li><li><p>run</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * run 方法可以直接被调用 * 也可以开启新的线程进行调用 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 状态不是任务创建，或者当前任务已经有线程在执行了，直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> NEW <span class="token operator">||</span>        <span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> runnerOffset<span class="token punctuation">,</span>                                     null<span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> c <span class="token operator">=</span> callable<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Callable 不为空，并且已经初始化完成</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V result<span class="token punctuation">;</span>            <span class="token keyword">boolean</span> ran<span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 调用执行</span>                result <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> null<span class="token punctuation">;</span>                ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 给 outcome 赋值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ran<span class="token punctuation">)</span>                <span class="token function">set</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        runner <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> INTERRUPTING<span class="token punctuation">)</span>            <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>run 方法我们再说明几点：</p><ol><li>run 方法是没有返回值的，通过给 outcome 属性赋值（set(result)），get 时就能从 outcome 属性中拿到返回值；</li><li>FutureTask 两种构造器，最终都转化成了 Callable，所以在 run 方法执行的时候，只需要执行 Callable 的 call 方法即可，在执行 c.call() 代码时，如果入参是 Runnable 的话， 调用路径为 c.call() -&gt; RunnableAdapter.call() -&gt; Runnable.run()，如果入参是 Callable 的话，直接调用。</li></ol></li><li><p>cancel</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 取消任务，如果正在运行，尝试去打断</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> mayInterruptIfRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>state <span class="token operator">==</span> NEW <span class="token operator">&amp;&amp;</span><span class="token comment" spellcheck="true">//任务状态不是创建 并且不能把 new 状态置为取消，直接返回 false</span>          UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> NEW<span class="token punctuation">,</span>              mayInterruptIfRunning <span class="token operator">?</span> INTERRUPTING <span class="token operator">:</span> CANCELLED<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 进行取消操作，打断可能会抛出异常，选择 try finally 的结构</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// in case call to interrupt throws exception</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mayInterruptIfRunning<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread t <span class="token operator">=</span> runner<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// final state</span>                <span class="token comment" spellcheck="true">//状态设置成已打断</span>                UNSAFE<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> stateOffset<span class="token punctuation">,</span> INTERRUPTED<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 清理线程</span>        <span class="token function">finishCompletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul><h4 id="5-2-4-总结"><a href="#5-2-4-总结" class="headerlink" title="5.2.4-总结"></a>5.2.4-总结</h4><p>大家现在可以回头看看一开始我们贴出来的图，看看自己照着图能否想起来各个 API 的作用，比如 Callable 是干啥的，FutureTask 又有什么作用，Runnable 和 Calllable 之间又是如何关联起来，几个 API 之间的关系的确很复杂，FutureTask 是关键，通过 FutureTask 把 Runnnable、Callable、Future 都串起来了，使 FutureTask 具有三者的功能，统一了 Runnnable 和 Callable，更方便使用。</p><h3 id="5-3-线程源码面试题"><a href="#5-3-线程源码面试题" class="headerlink" title="5.3-线程源码面试题"></a>5.3-线程源码面试题</h3><p>关于线程方面的面试题，大部分都是概念题，我们需要大概的清楚这些概念，和面试官达成共识即可，本章我们一起来看下这些面试题，对前两章的学习进行巩固。</p><h4 id="5-3-1-面试题"><a href="#5-3-1-面试题" class="headerlink" title="5.3.1-面试题"></a>5.3.1-面试题</h4><h5 id="1-创建子线程时，子线程是得不到父线程的-ThreadLocal，有什么办法可以解决这个问题？"><a href="#1-创建子线程时，子线程是得不到父线程的-ThreadLocal，有什么办法可以解决这个问题？" class="headerlink" title="1.创建子线程时，子线程是得不到父线程的 ThreadLocal，有什么办法可以解决这个问题？"></a>1.创建子线程时，子线程是得不到父线程的 ThreadLocal，有什么办法可以解决这个问题？</h5><p>答：这道题主要考察线程的属性和创建过程，可以这么回答。</p><p>可以使用 InheritableThreadLocal 来代替 ThreadLocal，ThreadLocal 和 InheritableThreadLocal 都是线程的属性，所以可以做到线程之间的数据隔离，在多线程环境下我们经常使用，但在有子线程被创建的情况下，父线程 ThreadLocal 是无法传递给子线程的，但 InheritableThreadLocal 可以，主要是因为在线程创建的过程中，会把</p><p>InheritableThreadLocal 里面的所有值传递给子线程，具体代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 当父线程的 inheritableThreadLocals 的值不为空时</span><span class="token comment" spellcheck="true">// 会把 inheritableThreadLocals 里面的值全部传递给子线程</span><span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">!=</span> null<span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>inheritableThreadLocals <span class="token operator">=</span>        ThreadLocal<span class="token punctuation">.</span><span class="token function">createInheritedMap</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>inheritableThreadLocals<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="2-线程创建有几种实现方式？"><a href="#2-线程创建有几种实现方式？" class="headerlink" title="2.线程创建有几种实现方式？"></a>2.线程创建有几种实现方式？</h5><p>答：主要有三种，分成两大类，第一类是子线程没有返回值，第二类是子线程有返回值。</p><p>无返回值的线程有两种写法，第一种是继承 Thread，可以这么写：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">extendThreadInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>第二种是实现 Runnable 接口，并作为 Thread 构造器的入参，代码如下：</p><pre class=" language-java"><code class="language-java">Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} begin run"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 开一个子线程去执行</span>thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这两种都会开一个子线程去执行任务，并且是没有返回值的，如果需要子线程有返回值，需要使用 Callable 接口，但 Callable 接口是无法直接作为 Thread 构造器的入参的，必须结合 FutureTask 一起使用，可以这样写代码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testThreadByCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> ExecutionException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>  FutureTask futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>      Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      String result <span class="token operator">=</span> <span class="token string">"我是子线程"</span><span class="token operator">+</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"子线程正在运行：{}"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"返回的结果是 {}"</span><span class="token punctuation">,</span>futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>把 FutureTask 作为 Thread 的入参就可以了，FutureTask 组合了 Callable ，使我们可以使用 Callable，并且 FutureTask 实现了 Runnable 接口，使其可以作为 Thread 构造器的入参，还有 FutureTask 实现了 Future，使其对任务有一定的管理功能。</p><h5 id="3-线程-1-去等待子线程-2-执行完成之后才能执行，如何去实现？"><a href="#3-线程-1-去等待子线程-2-执行完成之后才能执行，如何去实现？" class="headerlink" title="3.线程 1 去等待子线程 2 执行完成之后才能执行，如何去实现？"></a>3.线程 1 去等待子线程 2 执行完成之后才能执行，如何去实现？</h5><p>答：这里考察的就是 Thread.join 方法，我们可以这么做：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testJoin2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>  Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"我是子线程 2,开始沉睡"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>2000L<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"我是子线程 2，执行完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"我是子线程 1，开始运行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"我是子线程 1，我在等待子线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 这里是代码关键  </span>      thread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"我是子线程 1，子线程 2 执行完成，我继续执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"我是子线程 1，执行完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>子线程 1 需要等待子线程 2，只需要子线程 1 运行的时候，调用子线程 2 的 join 方法即可，这样线程 1 执行到 join 代码时，就会等待线程 2 执行完成之后，才会继续执行。</p><h5 id="4-守护线程和非守护线程的区别？如果我想在项目启动的时候收集代码信息，请问是守护线程好，还是非守护线程好，为什么？"><a href="#4-守护线程和非守护线程的区别？如果我想在项目启动的时候收集代码信息，请问是守护线程好，还是非守护线程好，为什么？" class="headerlink" title="4.守护线程和非守护线程的区别？如果我想在项目启动的时候收集代码信息，请问是守护线程好，还是非守护线程好，为什么？"></a>4.守护线程和非守护线程的区别？如果我想在项目启动的时候收集代码信息，请问是守护线程好，还是非守护线程好，为什么？</h5><p>答：两者的主要区别是，在 JVM 退出时，JVM 是不会管守护线程的，只会管非守护线程，如果非守护线程还有在运行的，JVM 就不会退出，如果没有非守护线程了，但还有守护线程的，JVM 直接退出。</p><p>如果需要在项目启动的时候收集代码信息，就需要看收集工作是否重要了，如果不太重要，又很耗时，就应该选择守护线程，这样不会妨碍 JVM 的退出，如果收集工作非常重要的话，那么就需要非守护进程，这样即使启动时发生未知异常，JVM 也会等到代码收集信息线程结束后才会退出，不会影响收集工作。</p><h5 id="5-线程-start-和-run-之间的区别。"><a href="#5-线程-start-和-run-之间的区别。" class="headerlink" title="5.线程 start 和 run 之间的区别。"></a>5.线程 start 和 run 之间的区别。</h5><p>答：调用 Thread.start 方法会开一个新的线程，run 方法不会。</p><h5 id="6-Thread、Runnable、Callable-三者之间的区别。"><a href="#6-Thread、Runnable、Callable-三者之间的区别。" class="headerlink" title="6.Thread、Runnable、Callable 三者之间的区别。"></a>6.Thread、Runnable、Callable 三者之间的区别。</h5><p>答：Thread 实现了 Runnable，本身就是 Runnable，但同时负责线程创建、线程状态变更等操作。</p><p>Runnable 是无返回值任务接口，Callable 是有返回值任务接口，如果任务需要跑起来，必须需要 Thread 的支持才行，Runnable 和 Callable 只是任务的定义，具体执行还需要靠 Thread。</p><h5 id="6-Thread、Runnable、Callable-三者之间的区别。-1"><a href="#6-Thread、Runnable、Callable-三者之间的区别。-1" class="headerlink" title="6.Thread、Runnable、Callable 三者之间的区别。"></a>6.Thread、Runnable、Callable 三者之间的区别。</h5><p>答：Thread 实现了 Runnable，本身就是 Runnable，但同时负责线程创建、线程状态变更等操作。</p><p>Runnable 是无返回值任务接口，Callable 是有返回值任务接口，如果任务需要跑起来，必须需要 Thread 的支持才行，Runnable 和 Callable 只是任务的定义，具体执行还需要靠 Thread。</p><h5 id="7-线程池-submit-有两个方法，方法一可接受-Runnable，方法二可接受-Callable，但两个方法底层的逻辑却是同一套，这是如何适配的。"><a href="#7-线程池-submit-有两个方法，方法一可接受-Runnable，方法二可接受-Callable，但两个方法底层的逻辑却是同一套，这是如何适配的。" class="headerlink" title="7.线程池 submit 有两个方法，方法一可接受 Runnable，方法二可接受 Callable，但两个方法底层的逻辑却是同一套，这是如何适配的。"></a>7.线程池 submit 有两个方法，方法一可接受 Runnable，方法二可接受 Callable，但两个方法底层的逻辑却是同一套，这是如何适配的。</h5><p>答：问题考察点在于 Runnable 和 Callable 之间是如何转化的，可以这么回答。</p><p>Runnable 和 Callable 是通过 FutureTask 进行统一的，FutureTask 有个属性是 Callable，同时也实现了 Runnable 接口，两者的统一转化是在 FutureTask 的构造器里实现的，FutureTask 的最终目标是把 Runnable 和 Callable 都转化成 Callable，Runnable 转化成 Callable 是通过 RunnableAdapter 适配器进行实现的。</p><p>线程池的 submit 底层的逻辑只认 FutureTask，不认 Runnable 和 Callable 的差异，所以只要都转化成 FutureTask，底层实现都会是同一套。</p><p>具体 Runnable 转化成 Callable 的代码和逻辑可以参考上一章，有非常详细的描述。</p><h5 id="8-Callable-能否丢给-Thread-去执行？"><a href="#8-Callable-能否丢给-Thread-去执行？" class="headerlink" title="8.Callable 能否丢给 Thread 去执行？"></a>8.Callable 能否丢给 Thread 去执行？</h5><p>答：可以的，可以新建 Callable，并作为 FutureTask 的构造器入参，然后把 FutureTask 丢给 Thread 去执行即可。</p><h5 id="9-FutureTask-有什么作用-谈谈对-FutureTask-的理解-。"><a href="#9-FutureTask-有什么作用-谈谈对-FutureTask-的理解-。" class="headerlink" title="9.FutureTask 有什么作用(谈谈对 FutureTask 的理解)。"></a>9.FutureTask 有什么作用(谈谈对 FutureTask 的理解)。</h5><p>答：作用如下：</p><ol><li>组合了 Callable，实现了 Runnable，把 Callable 和 Runnnable 串联了起来。</li><li>统一了有参任务和无参任务两种定义方式，方便了使用。</li><li>实现了 Future 的所有方法，对任务有一定的管理功能，比如说拿到任务执行结果，取消任务，打断任务等等。</li></ol><h5 id="10-聊聊对-FutureTask-的-get、cancel-方法的理解"><a href="#10-聊聊对-FutureTask-的-get、cancel-方法的理解" class="headerlink" title="10.聊聊对 FutureTask 的 get、cancel 方法的理解"></a>10.聊聊对 FutureTask 的 get、cancel 方法的理解</h5><p>答：get 方法主要作用是得到 Callable 异步任务执行的结果，无参 get 会一直等待任务执行完成之后才返回，有参 get 方法可以设定固定的时间，在设定的时间内，如果任务还没有执行成功，直接返回异常，在实际工作中，建议多多使用 get 有参方法，少用 get 无参方法，防止任务执行过慢时，多数线程都在等待，造成线程耗尽的问题。</p><p>cancel 方法主要用来取消任务，如果任务还没有执行，是可以取消的，如果任务已经在执行过程中了，你可以选择不取消，或者直接打断执行中的任务。</p><p>两个方法具体的执行步骤和原理见上一章节源码解析。</p><h5 id="11-Thread-yield-方法在工作中有什么用？"><a href="#11-Thread-yield-方法在工作中有什么用？" class="headerlink" title="11.Thread.yield 方法在工作中有什么用？"></a>11.Thread.yield 方法在工作中有什么用？</h5><p>答：yield 方法表示当前线程放弃 cpu，重新参与到 cpu 的竞争中去，再次竞争时，自己有可能得到 cpu 资源，也有可能得不到，这样做的好处是防止当前线程一直霸占 cpu。</p><p>我们在工作中可能会写一些 while 自旋的代码，如果我们一直 while 自旋，不采取任何手段，我们会发现 cpu 一直被当前 while 循环占用，如果能预见 while 自旋时间很长，我们会设置一定的判断条件，让当前线程陷入阻塞，如果能预见 while 自旋时间很短，我们通常会使用 Thread.yield 方法，使当前自旋线程让步，不一直霸占 cpu，比如这样：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> stop <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>stop<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// dosomething</span>  Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="12-wait-和sleep-的相同点和区别"><a href="#12-wait-和sleep-的相同点和区别" class="headerlink" title="12.wait()和sleep()的相同点和区别?"></a>12.wait()和sleep()的相同点和区别?</h5><p>答：相同点：</p><ol><li>两者都让线程进入到 TIMED_WAITING 状态，并且可以设置等待的时间。</li></ol><p>不同点：</p><ol><li>wait 是 Object 类的方法，sleep 是 Thread 类的方法。</li><li>sleep 不会释放锁，沉睡的时候，其它线程是无法获得锁的，但 wait 会释放锁。</li></ol><h5 id="13-写一个简单的死锁-demo"><a href="#13-写一个简单的死锁-demo" class="headerlink" title="13.写一个简单的死锁 demo"></a>13.写一个简单的死锁 demo</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 共享变量 1</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object share1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 共享变量 2</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object share2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDeadLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 初始化线程 1，线程 1 需要在锁定 share1 共享资源的情况下再锁定 share2</span>  Thread thread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>share1<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>share2<span class="token punctuation">)</span><span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} is run"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 初始化线程 2，线程 2 需要在锁定 share2 共享资源的情况下再锁定 share1</span>  Thread thread2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>share2<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>share1<span class="token punctuation">)</span><span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{} is run"</span><span class="token punctuation">,</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 当线程 1、2 启动后，都在等待对方锁定的资源，但都得不到，造成死锁</span>  thread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  thread2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="5-3-2-总结"><a href="#5-3-2-总结" class="headerlink" title="5.3.2-总结"></a>5.3.2-总结</h4><p>线程章节算是中等难度，我们需要清楚线程的概念，线程如何初始化，线程的状态变更等等问题，这些知识点都是线程池、锁的基础，学好线程后，再学习线程池和锁就会轻松很多。</p><h2 id="6-锁"><a href="#6-锁" class="headerlink" title="6-锁"></a>6-锁</h2><h3 id="6-1-AbstractQueuedSynchronizer-源码解析"><a href="#6-1-AbstractQueuedSynchronizer-源码解析" class="headerlink" title="6.1-AbstractQueuedSynchronizer 源码解析"></a>6.1-AbstractQueuedSynchronizer 源码解析</h3><p>AbstractQueuedSynchronizer 中文翻译叫做同步器，简称 AQS，是各种各样锁的基础，比如说 ReentrantLock、CountDownLatch 等等，这些我们经常用的锁底层实现都是 AQS，所以学好 AQS 对于后面理解锁的实现是非常重要的。</p><p>ps：本章内容需要大量队列基础知识，没有看过第四章节队列的同学，建议先阅读下队列章节。</p><h4 id="6-1-1-整体架构"><a href="#6-1-1-整体架构" class="headerlink" title="6.1.1-整体架构"></a>6.1.1-整体架构</h4><p>首先我们来看一下 AQS 的整体架构图，如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/AbstractQueuedSynchronizer%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.jpeg" alt="AbstractQueuedSynchronizer整体架构"></p><p>这个图总结了 AQS 整体架构的组成，和部分场景的动态流向，图中两个点说明一下，方便大家观看。</p><ol><li>AQS 中队列只有两个：同步队列 + 条件队列，底层数据结构两者都是链表；</li><li>图中有四种颜色的线代表四种不同的场景，1、2、3 序号代表看的顺序。</li></ol><p>AQS 本身就是一套锁的框架，它定义了获得锁和释放锁的代码结构，所以如果要新建锁，只要继承 AQS，并实现相应方法即可。</p><p>接下来我们一起来看下这个图中各个细节点。</p><h5 id="1-类注释-6"><a href="#1-类注释-6" class="headerlink" title="1.类注释"></a>1.类注释</h5><p>首先我们来看一下，从 AQS 类注释上，我们可以得到哪些信息：</p><ol><li>提供了一种框架，自定义了先进先出的同步队列，让获取不到锁的线程能进入同步队列中排队；</li><li>同步器有个状态字段，我们可以通过状态字段来判断能否得到锁，此时设计的关键在于依赖安全的 atomic value 来表示状态（虽然注释是这个意思，但实际上是通过把状态声明为 volatile，在锁里面修改状态值来保证线程安全的）；</li><li>子类可以通过给状态 CAS 赋值来决定能否拿到锁，可以定义那些状态可以获得锁，哪些状态表示获取不到锁（比如定义状态值是 0 可以获得锁，状态值是 1 就获取不到锁）；</li><li>子类可以新建非 public 的内部类，用内部类来继承 AQS，从而实现锁的功能；</li><li>AQS 提供了排它模式和共享模式两种锁模式。排它模式下：只有一个线程可以获得锁，共享模式可以让多个线程获得锁，子类 ReadWriteLock 实现了两种模式；</li><li>内部类 ConditionObject 可以被用作 Condition，我们通过 new ConditionObject () 即可得到条件队列；</li><li>AQS 实现了锁、排队、锁队列等框架，至于如何获得锁、释放锁的代码并没有实现，比如 tryAcquire、tryRelease、tryAcquireShared、tryReleaseShared、isHeldExclusively 这些方法，AQS 中默认抛 UnsupportedOperationException 异常，都是需要子类去实现的；</li><li>AQS 继承 AbstractOwnableSynchronizer 是为了方便跟踪获得锁的线程，可以帮助监控和诊断工具识别是哪些线程持有了锁；</li><li>AQS 同步队列和条件队列，获取不到锁的节点在入队时是先进先出，但被唤醒时，可能并不会按照先进先出的顺序执行。</li></ol><p>AQS 的注释还有很多很多，以上 9 点是挑选出来稍微比较重要的注释总结。</p><h5 id="2-类定义"><a href="#2-类定义" class="headerlink" title="2.类定义"></a>2.类定义</h5><p>AQS 类定义代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractQueuedSynchronizer</span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractOwnableSynchronizer</span>    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span> <span class="token punctuation">{</span></code></pre><p>可以看出两点：</p><ol><li><p>AQS 是个抽象类，就是给各种锁子类继承用的，AQS 定义了很多如何获得锁，如何释放锁的抽象方法，目的就是为了让子类去实现；</p></li><li><p>继承了 AbstractOwnableSynchronizer，AbstractOwnableSynchronizer 的作用就是为了知道当前是那个线程获得了锁，方便监控用的，代码如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/AbstractOwnableSynchronizer.jpeg" alt="AbstractOwnableSynchronizer"></p></li></ol><h5 id="3-基本属性"><a href="#3-基本属性" class="headerlink" title="3.基本属性"></a>3.基本属性</h5><p>AQS 的属性可简单分为四类：同步器简单属性、同步队列属性、条件队列属性、公用 Node。</p><ul><li><h6 id="简单属性"><a href="#简单属性" class="headerlink" title="简单属性"></a>简单属性</h6><p>首先我们来看一下简单属性有哪些：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 同步器的状态，子类会根据状态字段进行判断是否可以获得锁</span><span class="token comment" spellcheck="true">// 比如 CAS 成功给 state 赋值 1 算得到锁，赋值失败为得不到锁， CAS 成功给 state 赋值 0 算释放锁，赋值失败为释放失败</span><span class="token comment" spellcheck="true">// 可重入锁，每次获得锁 +1，每次释放锁 -1</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 自旋超时阀值，单位纳秒</span><span class="token comment" spellcheck="true">// 当设置等待时间时才会用到这个属性</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> spinForTimeoutThreshold <span class="token operator">=</span> 1000L<span class="token punctuation">;</span></code></pre><p>最重要的就是 state 属性，是 int 属性的，所有继承 AQS 的锁都是通过这个字段来判断能不能获得锁，能不能释放锁。</p></li><li><h6 id="同步队列属性"><a href="#同步队列属性" class="headerlink" title="同步队列属性"></a>同步队列属性</h6><p>首先我们介绍以下同步队列：当多个线程都来请求锁时，某一时刻有且只有一个线程能够获得锁（排它锁），那么剩余获取不到锁的线程，都会到同步队列中去排队并阻塞自己，当有线程主动释放锁时，就会从同步队列头开始释放一个排队的线程，让线程重新去竞争锁。</p><p>所以同步队列的主要作用阻塞获取不到锁的线程，并在适当时机释放这些线程。</p><p>同步队列底层数据结构是个双向链表，我们从源码中可以看到链表的头尾，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 同步队列的头。</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node head<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同步队列的尾</span><span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Node tail<span class="token punctuation">;</span></code></pre><p>源码中的 Node 是同步队列中的元素，但 Node 被同步队列和条件队列公用，所以我们在说完条件队列之后再说 Node。</p></li><li><h6 id="条件队列的属性"><a href="#条件队列的属性" class="headerlink" title="条件队列的属性"></a>条件队列的属性</h6><p>首先我们介绍下条件队列：条件队列和同步队列的功能一样，管理获取不到锁的线程，底层数据结构也是链表队列，但条件队列不直接和锁打交道，但常常和锁配合使用，是一定的场景下，对锁功能的一种补充。</p><p>条件队列的属性如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 条件队列，从属性上可以看出是链表结构</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConditionObject</span> <span class="token keyword">implements</span> <span class="token class-name">Condition</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1173984872572414699L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 条件队列中第一个 node</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> Node firstWaiter<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 条件队列中最后一个 node</span>    <span class="token keyword">private</span> <span class="token keyword">transient</span> Node lastWaiter<span class="token punctuation">;</span><span class="token punctuation">}</span>  </code></pre><p>ConditionObject 我们就称为条件队列，我们需要使用时，直接 new ConditionObject () 即可。</p><p>ConditionObject 是实现 Condition 接口的，Condition 接口相当于 Object 的各种监控方法，比如 Object#wait ()、Object#notify、Object#notifyAll 这些方法，我们可以先这么理解，后面会细说。</p></li><li><h6 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h6><p>Node 非常重要，即是同步队列的节点，又是条件队列的节点，在入队的时候，我们用 Node 把线程包装一下，然后把 Node 放入两个队列中，我们看下 Node 的数据结构，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 同步队列单独的属性     */</span>    <span class="token comment" spellcheck="true">//node 是共享模式</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Node SHARED <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//node 是排它模式</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Node EXCLUSIVE <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前节点的前节点</span>    <span class="token comment" spellcheck="true">// 节点 acquire 成功后就会变成head</span>    <span class="token comment" spellcheck="true">// head 节点不能被 cancelled</span>    <span class="token keyword">volatile</span> Node prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前节点的下一个节点</span>    <span class="token keyword">volatile</span> Node next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 两个队列共享的属性     */</span>    <span class="token comment" spellcheck="true">// 表示当前节点的状态，通过节点的状态来控制节点的行为</span>    <span class="token comment" spellcheck="true">// 普通同步节点，就是 0 ，条件节点是 CONDITION -2</span>    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// waitStatus 的状态有以下几种</span>    <span class="token comment" spellcheck="true">// 被取消</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED <span class="token operator">=</span>  <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// SIGNAL 状态的意义：同步队列中的节点在自旋获取锁的时候，如果前一个节点的状态是 SIGNAL，那么自己就可以阻塞休息了，否则自己一直自旋尝试获得锁</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 表示当前 node 正在条件队列中，当有节点从同步队列转移到条件队列时，状态就会被更改成 CONDITION</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CONDITION <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 无条件传播,共享模式下，该状态的进程处于可运行状态</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PROPAGATE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前节点的线程</span>    <span class="token keyword">volatile</span> Thread thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在同步队列中，nextWaiter 并不真的是指向其下一个节点，我们用 next 表示同步队列的下一个节点，nextWaiter 只是表示当前 Node 是排它模式还是共享模式</span>    <span class="token comment" spellcheck="true">// 但在条件队列中，nextWaiter 就是表示下一个节点元素</span>    Node nextWaiter<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从 Node 的结构中，我们需要重点关注 waitStatus 字段，Node 的很多操作都是围绕着 waitStatus 字段进行的。</p><p>Node 的 pre、next 属性是同步队列中的链表前后指向字段，nextWaiter 是条件队列中下一个节点的指向字段，但在同步队列中，nextWaiter 只是一个标识符，表示当前节点是共享还是排它模式。</p></li><li><h6 id="共享锁和排它锁的区别"><a href="#共享锁和排它锁的区别" class="headerlink" title="共享锁和排它锁的区别"></a>共享锁和排它锁的区别</h6><p>排它锁的意思是同一时刻，只能有一个线程可以获得锁，也只能有一个线程可以释放锁。</p><p>共享锁可以允许多个线程获得同一个锁，并且可以设置获取锁的线程数量。</p></li></ul><h5 id="4-Condition"><a href="#4-Condition" class="headerlink" title="4.Condition"></a>4.Condition</h5><p>刚才我们看条件队列 ConditionObject 时，发现其是实现 Condition 接口的，现在我们一起来看下 Condition 接口，其类注释上是这么写的：</p><ol><li>当 lock 代替 synchronized 来加锁时，Condition 就可以用来代替 Object 中相应的监控方法了，比如 Object#wait ()、Object#notify、Object#notifyAll 这些方法；</li><li>提供了一种线程协作方式：一个线程被暂停执行，直到被其它线程唤醒；</li><li>Condition 实例是绑定在锁上的，通过 Lock#newCondition 方法可以产生该实例；</li><li>除了特殊说明外，任意空值作为方法的入参，都会抛出空指针；</li><li>Condition 提供了明确的语义和行为，这点和 Object 监控方法不同。</li></ol><p>类注释上甚至还给我们举了一个例子：</p><p>假设我们有一个有界边界的队列，支持 put 和 take 方法，需要满足：<br>1：如果试图往空队列上执行 take，线程将会阻塞，直到队列中有可用的元素为止；<br>2：如果试图往满的队列上执行 put，线程将会阻塞，直到队列中有空闲的位置为止。</p><p>1、2 中线程阻塞都会到条件队列中去阻塞。</p><p>take 和 put 两种操作如果依靠一个条件队列，那么每次只能执行一种操作，所以我们可以新建两个条件队列，这样就可以分别执行操作了，看了这个需求，是不是觉得很像我们第三章学习的队列？实际上注释上给的 demo 就是我们学习过的队列，篇幅有限，感兴趣的可以看看 ConditionDemo 这个测试类。</p><p>除了类注释，Condition 还定义出一些方法，这些方法奠定了条件队列的基础，方法主要有：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span></code></pre><p>这个方法的主要作用是：使当前线程一直等待，直到被 signalled 或被打断。</p><p>当以下四种情况发生时，条件队列中的线程将被唤醒</p><ol><li>有线程使用了 signal 方法，正好唤醒了条件队列中的当前线程；</li><li>有线程使用了 signalAll 方法；</li><li>其它线程打断了当前线程，并且当前线程支持被打断；</li><li>被虚假唤醒 (即使没有满足以上 3 个条件，wait 也是可能被偶尔唤醒，虚假唤醒定义可以参考： <a href="https://en.wikipedia.org/wiki/Spurious_wakeup)。" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Spurious_wakeup)。</a></li></ol><p>被唤醒时，有一点需要注意的是：线程从条件队列中苏醒时，必须重新获得锁，才能真正被唤醒，这个我们在说源码的时候，也会强调这个。</p><p>await 方法还有带等待超时时间的，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 返回的 long 值表示剩余的给定等待时间，如果返回的时间小于等于 0 ，说明等待时间过了</span><span class="token comment" spellcheck="true">// 选择纳秒是为了避免计算剩余等待时间时的截断误差</span><span class="token keyword">long</span> <span class="token function">awaitNanos</span><span class="token punctuation">(</span><span class="token keyword">long</span> nanosTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 虽然入参可以是任意单位的时间，但底层仍然转化成纳秒</span><span class="token keyword">boolean</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span></code></pre><p>除了等待方法，还是唤醒线程的两个方法，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 唤醒条件队列中的一个线程，在被唤醒前必须先获得锁</span><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 唤醒条件队列中的所有线程</span><span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>至此，AQS 基本的属性就已经介绍完了，接着让我们来看一看 AQS 的重要方法。</p><h4 id="6-1-2-同步器的状态"><a href="#6-1-2-同步器的状态" class="headerlink" title="6.1.2-同步器的状态"></a>6.1.2-同步器的状态</h4><p>在同步器中，我们有两个状态，一个叫做 state，一个叫做 waitStatus，两者是完全不同的概念：</p><ol><li>state 是锁的状态，是 int 类型，子类继承 AQS 时，都是要根据 state 字段来判断有无得到锁，比如当前同步器状态是 0，表示可以获得锁，当前同步器状态是 1，表示锁已经被其他线程持有，当前线程无法获得锁；</li><li>waitStatus 是节点（Node）的状态，种类很多，一共有初始化 (0)、CANCELLED (1)、SIGNAL (-1)、CONDITION (-2)、PROPAGATE (-3)，各个状态的含义可以见上文。</li></ol><p>这两个状态我们需要牢记，不要混淆了。</p><h4 id="6-1-3-获取锁"><a href="#6-1-3-获取锁" class="headerlink" title="6.1.3-获取锁"></a>6.1.3-获取锁</h4><p>获取锁最直观的感受就是使用 Lock.lock () 方法来获得锁，最终目的是想让线程获得对资源的访问权。</p><p>Lock 一般是 AQS 的子类，lock 方法根据情况一般会选择调用 AQS 的 acquire 或 tryAcquire 方法。</p><p>acquire 方法 AQS 已经实现了，tryAcquire 方法是等待子类去实现，acquire 方法制定了获取锁的框架，先尝试使用 tryAcquire 方法获取锁，获取不到时，再入同步队列中等待锁。tryAcquire 方法 AQS 中直接抛出一个异常，表明需要子类去实现，子类可以根据同步器的 state 状态来决定是否能够获得锁，接下来我们详细看下 acquire 的源码解析。</p><p>acquire 也分两种，一种是排它锁，一种是共享锁，我们一一来看下：</p><h5 id="1-acquire-排它锁"><a href="#1-acquire-排它锁" class="headerlink" title="1.acquire 排它锁"></a>1.acquire 排它锁</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 排它模式下，尝试获得锁</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// tryAcquire 方法是需要实现类去实现的，实现思路一般都是 cas 给 state 赋值来决定是否能获得锁</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token comment" spellcheck="true">// addWaiter 入参代表是排他模式</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span>Node<span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>以上代码的主要步骤是（流程见整体架构图中红色场景）：</p><ol><li>尝试执行一次 tryAcquire，如果成功直接返回，失败走 2；</li><li>线程尝试进入同步队列，首先调用 addWaiter 方法，把当前线程放到同步队列的队尾；</li><li>接着调用 acquireQueued 方法，两个作用，1：阻塞当前节点，2：节点被唤醒时，使其能够获得锁；</li><li>如果 2、3 失败了，打断线程。</li></ol><ul><li><h6 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h6><p>代码很少，每个方法都是关键，接下来我们先来看下 addWaiter 的源码实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 方法主要目的：node 追加到同步队列的队尾</span><span class="token comment" spellcheck="true">// 入参 mode 表示 Node 的模式（排它模式还是共享模式）</span><span class="token comment" spellcheck="true">// 出参是新增的 node</span><span class="token comment" spellcheck="true">// 主要思路：</span><span class="token comment" spellcheck="true">// 新 node.pre = 队尾</span><span class="token comment" spellcheck="true">// 队尾.next = 新 node</span><span class="token keyword">private</span> Node <span class="token function">addWaiter</span><span class="token punctuation">(</span>Node mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 初始化 Node</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这里的逻辑和 enq 一致，enq 的逻辑仅仅多了队尾是空，初始化的逻辑</span>    <span class="token comment" spellcheck="true">// 这个思路在 java 源码中很常见，先简单的尝试放一下，成功立马返回，如果不行，再 while 循环</span>    <span class="token comment" spellcheck="true">// 很多时候，这种算法可以帮忙解决大部分的问题，大部分的入队可能一次都能成功，无需自旋</span>    Node pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//自旋保证node加入到队尾</span>    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 线程加入同步队列中方法，追加到队尾</span><span class="token comment" spellcheck="true">// 这里需要重点注意的是，返回值是添加 node 的前一个节点</span><span class="token keyword">private</span> Node <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 得到队尾节点</span>        Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果队尾为空，说明当前同步队列都没有初始化，进行初始化</span>        <span class="token comment" spellcheck="true">// tail = head = new Node();</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 队尾不为空，将当前节点追加到队尾</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// node 追加到队尾</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果之前学习过队列的同学，对这个方法应该感觉毫不吃力，就是把新的节点追加到同步队列的队尾。</p><p>其中有一点值得我们学习的地方，是在 addWaiter 方法中，并没有进入方法后立马就自旋，而是先尝试一次追加到队尾，如果失败才自旋，因为大部分操作可能一次就会成功，这种思路在我们写自旋的时候可以借鉴。</p></li><li><h6 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h6><p>下一步就是要阻塞当前线程了，是 acquireQueued 方法来实现的，我们来看下源码实现：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 主要做两件事情：</span><span class="token comment" spellcheck="true">// 1：通过不断的自旋尝试使自己前一个节点的状态变成 signal，然后阻塞自己。</span><span class="token comment" spellcheck="true">// 2：获得锁的线程执行完成之后，释放锁时，会把阻塞的 node 唤醒,node 唤醒之后再次自旋，尝试获得锁</span><span class="token comment" spellcheck="true">// 返回 false 表示获得锁成功，返回 true 表示失败</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 自旋</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 选上一个节点</span>            <span class="token keyword">final</span> Node p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 有两种情况会走到 p == head：</span>            <span class="token comment" spellcheck="true">// 1:node 之前没有获得锁，进入 acquireQueued 方法时，才发现他的前置节点就是头节点，于是尝试获得一次锁；</span>            <span class="token comment" spellcheck="true">// 2:node 之前一直在阻塞沉睡，然后被唤醒，此时唤醒 node 的节点正是其前一个节点，也能走到 if</span>            <span class="token comment" spellcheck="true">// 如果自己 tryAcquire 成功，就立马把自己设置成 head，把上一个节点移除</span>            <span class="token comment" spellcheck="true">// 如果 tryAcquire 失败，尝试进入同步队列</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 获得锁，设置成 head 节点</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//p被回收</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// shouldParkAfterFailedAcquire 把 node 的前一个节点状态置为 SIGNAL</span>            <span class="token comment" spellcheck="true">// 只要前一个节点状态是 SIGNAL了，那么自己就可以阻塞(park)了</span>            <span class="token comment" spellcheck="true">// parkAndCheckInterrupt 阻塞当前线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token comment" spellcheck="true">// 线程是在这个方法里面阻塞的，醒来的时候仍然在无限 for 循环里面，就能再次自旋尝试获得锁</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果获得node的锁失败，将 node 从队列中移除</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>此方法的注释还是很清楚的，我们接着看下此方法的核心：shouldParkAfterFailedAcquire，这个方法的主要目的就是把前一个节点的状态置为 SIGNAL，只要前一个节点的状态是 SIGNAL，当前节点就可以阻塞了（parkAndCheckInterrupt 就是使节点阻塞的方法），源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 当前线程可以安心阻塞的标准，就是前一个节点线程状态是 SIGNAL 了。</span><span class="token comment" spellcheck="true">// 入参 pred 是前一个节点，node 是当前节点。</span><span class="token comment" spellcheck="true">// 关键操作：</span><span class="token comment" spellcheck="true">// 1：确认前一个节点是否有效，无效的话，一直往前找到状态不是取消的节点。</span><span class="token comment" spellcheck="true">// 2: 把前一个节点状态置为 SIGNAL。</span><span class="token comment" spellcheck="true">// 1、2 两步操作，有可能一次就成功，有可能需要外部循环多次才能成功（外面是个无限的 for 循环），但最后一定是可以成功的</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>Node pred<span class="token punctuation">,</span> Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果前一个节点 waitStatus 状态已经是 SIGNAL 了，直接返回，不需要在自旋了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">/*         * This node has already set status asking a release         * to signal it, so it can safely park.         */</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果当前节点状态已经被取消了。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*         * Predecessor was cancelled. Skip over predecessors and         * indicate retry.         */</span>        <span class="token comment" spellcheck="true">// 找到前一个状态不是取消的节点，因为把当前 node 挂在有效节点身上</span>        <span class="token comment" spellcheck="true">// 因为节点状态是取消的话，是无效的，是不能作为 node 的前置节点的，所以必须找到 node 的有效节点才行</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 否则直接把节点状态置 为SIGNAL</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*         * waitStatus must be 0 or PROPAGATE.  Indicate that we         * need a signal, but don't park yet.  Caller will need to         * retry to make sure it cannot acquire before parking.         */</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>acquire 整个过程非常长，代码也非常多，但注释很清楚，可以一行一行仔细看看代码。</p><p>总结一下，acquire 方法大致分为三步：</p><ol><li>使用 tryAcquire 方法尝试获得锁，获得锁直接返回，获取不到锁的走 2；</li><li>把当前线程组装成节点（Node），追加到同步队列的尾部（addWaiter）；</li><li>自旋，使同步队列中当前节点的前置节点状态为 signal 后，然后阻塞自己。</li></ol><p>整体的代码结构比较清晰，一些需要注意的点，都用注释表明了，强烈建议阅读下源码。</p></li></ul><h5 id="2-acquireShared-获取共享锁"><a href="#2-acquireShared-获取共享锁" class="headerlink" title="2.acquireShared 获取共享锁"></a>2.acquireShared 获取共享锁</h5><p>acquireShared 整体流程和 acquire 相同，代码也很相似，重复的源码就不贴了，我们就贴出来不一样的代码来，也方便大家进行比较：</p><ol><li><p>第一步尝试获得锁的地方，有所不同，排它锁使用的是 tryAcquire 方法，共享锁使用的是 tryAcquireShared 方法，如下图：</p><p>![acquireShared 获取共享锁1](acquireShared 获取共享锁1.jpeg)</p></li><li><p>第二步不同，在于节点获得排它锁时，仅仅把自己设置为同步队列的头节点即可（setHead 方法），但如果是共享锁的话，还会去唤醒自己的后续节点，一起来获得该锁（setHeadAndPropagate 方法），不同之处如下（左边排它锁，右边共享锁）：</p><p>![acquireShared 获取共享锁2](acquireShared 获取共享锁2.jpeg)</p></li></ol><p>接下来我们一起来看下 setHeadAndPropagate 方法的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 主要做两件事情</span><span class="token comment" spellcheck="true">// 1:把当前节点设置成头节点</span><span class="token comment" spellcheck="true">// 2:看看后续节点有无正在等待，并且也是共享模式的，有的话唤醒这些节点</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>Node node<span class="token punctuation">,</span> <span class="token keyword">int</span> propagate<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node h <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Record old head for check below</span>    <span class="token comment" spellcheck="true">// 当前节点设置成头节点</span>    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/*     * Try to signal next queued node if:     *   Propagation was indicated(表示指示) by caller,     *     or was recorded (as h.waitStatus either before     *     or after setHead) by a previous operation     *     (note: this uses sign-check of waitStatus because     *      PROPAGATE status may transition to SIGNAL.)     * and     *   The next node is waiting in shared mode,     *     or we don't know, because it appears null     *     * The conservatism(保守) in both of these checks may cause     * unnecessary wake-ups, but only when there are multiple     * racing acquires/releases, so most need signals now or soon     * anyway.     */</span>    <span class="token comment" spellcheck="true">// propagate > 0 表示已经有节点获得共享锁了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>propagate <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> h <span class="token operator">==</span> null <span class="token operator">||</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        <span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//共享模式，还唤醒头节点的后置节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 释放后置共享节点</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * Ensure that a release propagates, even if there are other     * in-progress acquires/releases.  This proceeds in the usual     * way of trying to unparkSuccessor of head if it needs     * signal. But if it does not, status is set to PROPAGATE to     * ensure that upon release, propagation continues.     * Additionally, we must loop in case a new node is added     * while we are doing this. Also, unlike other uses of     * unparkSuccessor, we need to know if CAS to reset status     * fails, if so rechecking.     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 还没有到队尾，此时队列中至少有两个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果队列状态是 SIGNAL ，说明后续节点都需要唤醒</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// CAS 保证只有一个节点可以运行唤醒的操作</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// loop to recheck cases</span>                <span class="token comment" spellcheck="true">// 进行唤醒操作</span>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                     <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> Node<span class="token punctuation">.</span>PROPAGATE<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// loop on failed CAS</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 第一种情况，头节点没有发生移动，结束。</span>        <span class="token comment" spellcheck="true">// 第二种情况，因为此方法可以被两处调用，一次是获得锁的地方，一处是释放锁的地方，</span>        <span class="token comment" spellcheck="true">// 加上共享锁的特性就是可以多个线程获得锁，也可以释放锁，这就导致头节点可能会发生变化，</span>        <span class="token comment" spellcheck="true">// 如果头节点发生了变化，就继续循环，一直循环到头节点不变化时，结束循环。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span>                   <span class="token comment" spellcheck="true">// loop if head changed</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个就是共享锁独特的地方，当一个线程获得锁后，它就会去唤醒排在它后面的其它节点，让其它节点也能够获得锁。</p><h4 id="6-1-4-释放锁"><a href="#6-1-4-释放锁" class="headerlink" title="6.1.4-释放锁"></a>6.1.4-释放锁</h4><p>释放锁的触发时机就是我们常用的 Lock.unLock () 方法，目的就是让线程释放对资源的访问权（流程见整体架构图紫色路线）。</p><p>释放锁也是分为两类，一类是排它锁的释放，一类是共享锁的释放，我们分别来看下。</p><h5 id="1-释放排它锁-release"><a href="#1-释放排它锁-release" class="headerlink" title="1.释放排它锁 release"></a>1.释放排它锁 release</h5><p>排它锁的释放就比较简单了，从队头开始，找它的下一个节点，如果下一个节点是空的，就会从尾开始，一直找到状态不是取消的节点，然后释放该节点，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// unlock 的基础方法</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// tryRelease 交给实现类去实现，一般就是用当前同步器状态减去 arg，如果返回 true 说明成功释放锁。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 头节点不为空，并且非初始化状态</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 从头开始唤醒等待锁的节点</span>            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 很有意思的方法，当线程释放锁成功后，从 node 开始唤醒同步队列中的节点</span><span class="token comment" spellcheck="true">// 通过唤醒机制,保证线程不会一直在同步队列中阻塞等待</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// node 节点是当前释放锁的节点，也是同步队列的头节点</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果节点已经被取消了，把节点的状态置为初始化</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拿出 node 节点的后面一个节点</span>    Node s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// s 为空，表示 node 的后一个节点为空</span>    <span class="token comment" spellcheck="true">// s.waitStatus 大于0，代表 s 节点已经被取消了</span>    <span class="token comment" spellcheck="true">// 遇到以上这两种情况，就从队尾开始，向前遍历，找到第一个 waitStatus 字段不是被取消的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        s <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 这里从尾迭代，而不是从头开始迭代是有原因的。</span>        <span class="token comment" spellcheck="true">// 主要是因为节点被阻塞的时候，是在 acquireQueued 方法里面被阻塞的，唤醒时也一定会在 acquireQueued 方法里面被唤醒，唤醒之后的条件是，判断当前节点的前置节点是否是头节点，这里是判断当前节点的前置节点，所以这里必须使用从尾到头的迭代顺序才行，目的就是为了过滤掉无效的前置节点，不然节点被唤醒时，发现其前置节点还是无效节点，就又会陷入阻塞。</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// t.waitStatus &lt;= 0 说明 t 没有被取消，肯定还在等待被唤醒</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                s <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 唤醒以上代码找到的线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-释放共享锁-releaseShared"><a href="#2-释放共享锁-releaseShared" class="headerlink" title="2.释放共享锁 releaseShared"></a>2.释放共享锁 releaseShared</h5><p>释放共享锁的方法是 releaseShared，主要分成两步：</p><ol><li>tryReleaseShared 尝试释放当前共享锁，失败返回 false，成功走 2；</li><li>唤醒当前节点的后续阻塞节点，这个方法我们之前看过了，线程在获得共享锁的时候，就会去唤醒其后面的节点，方法名称为：doReleaseShared。</li></ol><p>我们一起来看下 releaseShared 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 共享模式下，释放当前线程的共享锁</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这个方法就是线程在获得锁时，唤醒后续节点时调用的方法</span>        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="6-1-5-条件队列的重要方法"><a href="#6-1-5-条件队列的重要方法" class="headerlink" title="6.1.5-条件队列的重要方法"></a>6.1.5-条件队列的重要方法</h4><p>在看条件队列的方法之前，我们先得弄明白为什么有了同步队列，还需要条件队列？</p><p>主要是因为并不是所有场景一个同步队列就可以搞定的，在遇到锁 + 队列结合的场景时，就需要 Lock + Condition 配合才行，先使用 Lock 来决定哪些线程可以获得锁，哪些线程需要到同步队列里面排队阻塞；获得锁的多个线程在碰到队列满或者空的时候，可以使用 Condition 来管理这些线程，让这些线程阻塞等待，然后在合适的时机后，被正常唤醒。</p><p>同步队列 + 条件队列联手使用的场景，最多被使用到锁 + 队列的场景中。</p><p>所以说条件队列也是不可或缺的一环。</p><p>接下来我们来看一下条件队列一些比较重要的方法，以下方法都在 ConditionObject 内部类中。</p><h5 id="1-入队列等待-await"><a href="#1-入队列等待-await" class="headerlink" title="1.入队列等待 await"></a>1.入队列等待 await</h5><p>获得锁的线程，如果在碰到队列满或空的时候，就会阻塞住，这个阻塞就是用条件队列实现的，这个动作我们叫做入条件队列，方法名称为 await，流程见整体架构图中深绿色箭头流向，我们一起来看下 await 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 线程入条件队列</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 加入到条件队列的队尾</span>    Node node <span class="token operator">=</span> <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 标记位置 A</span>    <span class="token comment" spellcheck="true">// 加入条件队列后，会释放 lock 时申请的资源，唤醒同步队列队列头的节点</span>    <span class="token comment" spellcheck="true">// 自己马上就要阻塞了，必须马上释放之前 lock 的资源，不然自己不被唤醒的话，别的线程永远得不到该共享资源了</span>    <span class="token keyword">int</span> savedState <span class="token operator">=</span> <span class="token function">fullyRelease</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> interruptMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 确认node不在同步队列上，再阻塞，如果 node 在同步队列上，是不能够上锁的</span>    <span class="token comment" spellcheck="true">// 目前想到的只有两种可能：</span>    <span class="token comment" spellcheck="true">// 1:node 刚被加入到条件队列中，立马就被其他线程 signal 转移到同步队列中去了</span>    <span class="token comment" spellcheck="true">// 2:线程之前在条件队列中沉睡，被唤醒后加入到同步队列中去</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isOnSyncQueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// this = AbstractQueuedSynchronizer$ConditionObject</span>        <span class="token comment" spellcheck="true">// 阻塞在条件队列上</span>        LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>interruptMode <span class="token operator">=</span> <span class="token function">checkInterruptWhileWaiting</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 标记位置 B</span>    <span class="token comment" spellcheck="true">// 其他线程通过 signal 已经把 node 从条件队列中转移到同步队列中的数据结构中去了</span>    <span class="token comment" spellcheck="true">// 所以这里节点苏醒了，直接尝试 acquireQueued</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">acquireQueued</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> savedState<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> interruptMode <span class="token operator">!=</span> THROW_IE<span class="token punctuation">)</span>        interruptMode <span class="token operator">=</span> REINTERRUPT<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>nextWaiter <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// clean up if cancelled</span>        <span class="token comment" spellcheck="true">// 如果状态不是CONDITION，就会自动删除</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>interruptMode <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">reportInterruptAfterWait</span><span class="token punctuation">(</span>interruptMode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>await 方法有几点需要特别注意：</p><ol><li>上述代码标记位置 A 处，节点在准备进入条件队列之前，一定会先释放当前持有的锁，不然自己进去条件队列了，其余的线程都无法获得锁了；</li><li>上述代码标记位置 B 处，此时节点是被 Condition.signal 或者 signalAll 方法唤醒的，此时节点已经成功的被转移到同步队列中去了（整体架构图中蓝色流程），所以可以直接执行 acquireQueued 方法；</li><li>Node 在条件队列中的命名，源码喜欢用 Waiter 来命名，所以我们在条件队列中看到 Waiter，其实就是 Node。</li></ol><p>await 方法中有两个重要方法：addConditionWaiter 和 unlinkCancelledWaiters，我们一一看下。</p><ul><li><h6 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter"></a>addConditionWaiter</h6><p>addConditionWaiter 方法主要是把节点放到条件队列中，方法源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 增加新的 waiter 到队列中，返回新添加的 waiter</span><span class="token comment" spellcheck="true">// 如果尾节点状态不是 CONDITION 状态，删除条件队列中所有状态不是 CONDITION 的节点</span><span class="token comment" spellcheck="true">// 如果队列为空，新增节点作为队列头节点，否则追加到尾节点上</span><span class="token keyword">private</span> Node <span class="token function">addConditionWaiter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// If lastWaiter is cancelled, clean out.</span>    <span class="token comment" spellcheck="true">// 如果尾部的 waiter 不是 CONDITION 状态了，删除</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t <span class="token operator">=</span> lastWaiter<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 新建条件队列 node</span>    Node node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 队列是空的，直接放到队列头</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span>        firstWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 队列不为空，直接到队列尾部</span>    <span class="token keyword">else</span>        t<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    lastWaiter <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>整体过程比较简单，就是追加到队列的尾部，其中有个重要方法叫做 unlinkCancelledWaiters，这个方法会删除掉条件队列中状态不是 CONDITION 的所有节点，我们来看下 unlinkCancelledWaiters 方法的源码，如下：</p></li><li><h6 id="unlinkCancelledWaiters"><a href="#unlinkCancelledWaiters" class="headerlink" title="unlinkCancelledWaiters"></a>unlinkCancelledWaiters</h6><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 会检查尾部的 waiter 是不是已经不是CONDITION状态了</span><span class="token comment" spellcheck="true">// 如果不是，删除这些 waiter</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unlinkCancelledWaiters</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node t <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// trail 表示上一个状态,这个字段作用非常大，可以把状态都是 CONDITION 的 node 串联起来，即使 node 之间有其他节点都可以</span>    Node trail <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node next <span class="token operator">=</span> t<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当前node的状态不是CONDITION，删除自己</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//删除当前node</span>            t<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 trail 是空的，咱们循环又是从头开始的，说明从头到当前节点的状态都不是 CONDITION</span>            <span class="token comment" spellcheck="true">// 都已经被删除了，所以移动队列头节点到当前节点的下一个节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>trail <span class="token operator">==</span> null<span class="token punctuation">)</span>                firstWaiter <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果找到上次状态是CONDITION的节点的话，先把当前节点删掉，然后把自己挂到上一个状态是 CONDITION 的节点上</span>            <span class="token keyword">else</span>                trail<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 遍历结束，最后一次找到的CONDITION节点就是尾节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                lastWaiter <span class="token operator">=</span> trail<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 状态是 CONDITION 的 Node</span>        <span class="token keyword">else</span>            trail <span class="token operator">=</span> t<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 继续循环，循环顺序从头到尾</span>        t <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>为了方便大家理解这个方法，画了一个释义图，如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/unlinkCancelledWaiters.jpeg" alt="unlinkCancelledWaiters"></p></li></ul><h5 id="2-单个唤醒-signal"><a href="#2-单个唤醒-signal" class="headerlink" title="2.单个唤醒 signal"></a>2.单个唤醒 signal</h5><p>signal 方法是唤醒的意思，比如之前队列满了，有了一些线程因为 take 操作而被阻塞进条件队列中，突然队列中的元素被线程 A 消费了，线程 A 就会调用 signal 方法，唤醒之前阻塞的线程，会从条件队列的头节点开始唤醒（流程见整体架构图中蓝色部分），源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 唤醒阻塞在条件队列中的节点</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从头节点开始唤醒</span>    Node first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> null<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// doSignal 方法会把条件队列中的节点转移到同步队列中去</span>        <span class="token function">doSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 把条件队列头节点转移到同步队列去</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignal</span><span class="token punctuation">(</span>Node first<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// nextWaiter为空，说明到队尾了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token punctuation">(</span>firstWaiter <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>            lastWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从队列头部开始唤醒，所以直接把头节点.next 置为 null，这种操作其实就是把 node 从条件队列中移除了</span>        <span class="token comment" spellcheck="true">// 这里有个重要的点是，每次唤醒都是从队列头部开始唤醒，所以把 next 置为 null 没有关系，如果唤醒是从任意节点开始唤醒的话，就会有问题，容易造成链表的割裂</span>        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// transferForSignal 方法会把节点转移到同步队列中去</span>        <span class="token comment" spellcheck="true">// 通过 while 保证 transferForSignal 能成功</span>        <span class="token comment" spellcheck="true">// 等待队列的 node 不用管他，在 await 的时候，会自动清除状态不是 Condition 的节点(通过 unlinkCancelledWaiters 方法)</span>        <span class="token comment" spellcheck="true">// (first = firstWaiter) != null  = true 的话，表示还可以继续循环， = false 说明队列中的元素已经循环完了</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>             <span class="token punctuation">(</span>first <span class="token operator">=</span> firstWaiter<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>   </code></pre><p>我们来看下最关键的方法：transferForSignal。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 返回 true 表示转移成功， false 失败</span><span class="token comment" spellcheck="true">// 大概思路：</span><span class="token comment" spellcheck="true">// 1. node 追加到同步队列的队尾</span><span class="token comment" spellcheck="true">// 2. 将 node 的前一个节点状态置为 SIGNAL，成功直接返回，失败直接唤醒</span><span class="token comment" spellcheck="true">// 可以看出来 node 的状态此时是 0 了</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">transferForSignal</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*     * If cannot change waitStatus, the node has been cancelled.     */</span>    <span class="token comment" spellcheck="true">// 将 node 的状态从 CONDITION 修改成初始化，失败返回 false</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>CONDITION<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前队列加入到同步队列，返回的 p 是 node 在同步队列中的前一个节点</span>    <span class="token comment" spellcheck="true">// 看命名是 p，实际是 pre 单词的缩写</span>    Node p <span class="token operator">=</span> <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> p<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 状态修改成 SIGNAL，如果成功直接返回</span>    <span class="token comment" spellcheck="true">// 把当前节点的前一个节点修改成 SIGNAL 的原因，是因为 SIGNAL 本身就表示当前节点后面的节点都是需要被唤醒的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> Node<span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 如果 p 节点被取消，或者状态不能修改成SIGNAL，直接唤醒</span>        LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>整个源码下来，我们可以看到，唤醒条件队列中的节点，实际上就是把条件队列中的节点转移到同步队列中，并把其前置节点状态置为 SIGNAL。</p><h5 id="3-全部唤醒-signalAll"><a href="#3-全部唤醒-signalAll" class="headerlink" title="3.全部唤醒 signalAll"></a>3.全部唤醒 signalAll</h5><p>signalAll 的作用是唤醒条件队列中的全部节点，源码如下：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 拿到头节点</span>        Node first <span class="token operator">=</span> firstWaiter<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 从头节点开始唤醒条件队列中所有的节点</span>            <span class="token function">doSignalAll</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 把条件队列所有节点依次转移到同步队列去</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignalAll</span><span class="token punctuation">(</span>Node first<span class="token punctuation">)</span> <span class="token punctuation">{</span>        lastWaiter <span class="token operator">=</span> firstWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 拿出条件队列队列头节点的下一个节点</span>            Node next <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 把头节点从条件队列中删除</span>            first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 头节点转移到同步队列中去</span>            <span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 开始循环头节点的下一个节点</span>            first <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>从源码中可以看出，其本质就是 for 循环调用 transferForSignal 方法，将条件队列中的节点循环转移到同步队列中去。</p><h4 id="6-1-6-总结"><a href="#6-1-6-总结" class="headerlink" title="6.1.6-总结"></a>6.1.6-总结</h4><p>AQS 源码终于说完了，你都懂了么，可以在默默回忆一下 AQS 架构图，看看这张图现在能不能看懂了。</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/AQS%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg" alt="AQS架构图"></p><h3 id="6-2-ReentrantLock-源码解析"><a href="#6-2-ReentrantLock-源码解析" class="headerlink" title="6.2-ReentrantLock 源码解析"></a>6.2-ReentrantLock 源码解析</h3><p>本章我们就要来学习一下第一个 AQS 的实现类：ReentrantLock，看看其底层是如何组合 AQS ，实现了自己的那些功能。</p><p>本章的描述思路是先描述清楚 ReentrantLock 的构成组件，然后使用加锁和释放锁的方法把这些组件串起来。</p><h4 id="6-2-1-类注释"><a href="#6-2-1-类注释" class="headerlink" title="6.2.1-类注释"></a>6.2.1-类注释</h4><p>ReentrantLock 中文我们习惯叫做可重入互斥锁，可重入的意思是同一个线程可以对同一个共享资源重复的加锁或释放锁，互斥就是 AQS 中的排它锁的意思，只允许一个线程获得锁。</p><p>我们来一起来看下类注释上都有哪些重要信息：</p><ol><li>可重入互斥锁，和 synchronized 锁具有同样的功能语义，但更有扩展性；</li><li>构造器接受 fairness 的参数，fairness 是 ture 时，保证获得锁时的顺序，false 不保证；</li><li>公平锁的吞吐量较低，获得锁的公平性不能代表线程调度的公平性；</li><li>tryLock() 无参方法没有遵循公平性，是非公平的（lock 和 unlock 都有公平和非公平，而 tryLock 只有公平锁，所以单独拿出来说一说）。</li></ol><p>我们补充一下第二点，ReentrantLock 的公平和非公平，是针对获得锁来说的，如果是公平的，可以保证同步队列中的线程从头到尾的顺序依次获得锁，非公平的就无法保证，在释放锁的过程中，我们是没有公平和非公平的说法的。</p><h4 id="6-2-2-类结构"><a href="#6-2-2-类结构" class="headerlink" title="6.2.2-类结构"></a>6.2.2-类结构</h4><p>ReentrantLock 类本身是不继承 AQS 的，实现了 Lock 接口，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReentrantLock</span> <span class="token keyword">implements</span> <span class="token class-name">Lock</span><span class="token punctuation">,</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>Lock 接口定义了各种加锁，释放锁的方法，接口有如下几个：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获得锁方法，获取不到锁的线程会到同步队列中阻塞排队</span><span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 获取可中断的锁</span><span class="token keyword">void</span> <span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 尝试获得锁，如果锁空闲，立马返回 true，否则返回 false</span><span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 带有超时等待时间的锁，如果超时时间到了，仍然没有获得锁，返回 false</span><span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 释放锁</span><span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 得到新的 Condition</span>Condition <span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>ReentrantLock 就负责实现这些接口，我们使用时，直接面对的也是这些方法，这些方法的底层实现都是交给 Sync 内部类去实现的，Sync 类的定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>Sync 继承了 AbstractQueuedSynchronizer ，所以 Sync 就具有了锁的框架，根据 AQS 的框架，Sync 只需要实现 AQS 预留的几个方法即可，但 Sync 也只是实现了部分方法，还有一些交给子类 NonfairSync 和 FairSync 去实现了，NonfairSync 是非公平锁，FairSync 是公平锁，定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 同步器 Sync 的两个子类锁</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">FairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NonfairSync</span> <span class="token keyword">extends</span> <span class="token class-name">Sync</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>几个类整体的结构如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ReentrantLock%E7%B1%BB%E7%BB%93%E6%9E%84.jpeg" alt="ReentrantLock类结构"></p><p>图中 Sync、NonfairSync、FairSync 都是静态内部类的方式实现的，这个也符合 AQS 框架定义的实现标准。</p><h4 id="6-2-3-构造器"><a href="#6-2-3-构造器" class="headerlink" title="6.2.3-构造器"></a>6.2.3-构造器</h4><p>ReentrantLock 构造器有两种，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 无参数构造器，相当于 ReentrantLock(false)，默认是非公平的</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">ReentrantLock</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">FairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">NonfairSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>无参构造器默认构造是非公平的锁，有参构造器可以选择。</p><p>从构造器中可以看出，公平锁是依靠 FairSync 实现的，非公平锁是依靠 NonfairSync 实现的。</p><h4 id="6-2-4-Sync-同步器"><a href="#6-2-4-Sync-同步器" class="headerlink" title="6.2.4-Sync 同步器"></a>6.2.4-Sync 同步器</h4><p>Sync 表示同步器，继承了 AQS，UML 图如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ReentrantLock%E5%90%8C%E6%AD%A5%E5%99%A8.jpeg" alt="ReentrantLock同步器"></p><p>从 UML 图中可以看出，lock 方法是个抽象方法，留给 FairSync 和 NonfairSync 两个子类去实现，我们一起来看下剩余重要的几个方法。</p><h5 id="1-nonfairTryAcquire"><a href="#1-nonfairTryAcquire" class="headerlink" title="1.nonfairTryAcquire"></a>1.nonfairTryAcquire</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 尝试获得非公平锁</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 同步器的状态是 0，表示同步器的锁没有人持有</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当前线程持有锁</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 标记当前持有锁的线程是谁</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果当前线程已经持有锁了，同一个线程可以对同一个资源重复加锁，代码实现的是可重入锁</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当前线程持有锁的数量 + acquires</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// int 是有最大值的，&lt;0 表示持有锁的数量超过了 int 的最大值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//否则线程进入同步队列</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>以上代码有三点需要注意：</p><ol><li>通过判断 AQS 的 state 的状态来决定是否可以获得锁，0 表示锁是空闲的；</li><li>else if 的代码体现了可重入加锁，同一个线程对共享资源重入加锁，底层实现就是把 state + 1，并且可重入的次数是有限制的，为 Integer 的最大值；</li><li>这个方法是非公平的，所以只有非公平锁才会用到，公平锁是另外的实现。</li></ol><p>无参的 tryLock 方法调用的就是此方法，tryLock 的方法源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 入参数是 1 表示尝试获得一次锁</span>    <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="2-tryRelease"><a href="#2-tryRelease" class="headerlink" title="2.tryRelease"></a>2.tryRelease</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 释放锁方法，非公平和公平锁都使用</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当前同步器的状态减去释放的个数，releases 一般为 1</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前线程根本都不持有锁，报错</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 c 为 0，表示当前线程持有的锁都释放了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果 c 不为 0，那么就是可重入锁，并且锁没有释放完，用 state 减去 releases 即可，无需做其他操作</span>    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> free<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>tryRelease 方法是公平锁和非公平锁都公用的，在锁释放的时候，是没有公平和非公平的说法的。</p><p>从代码中可以看到，锁最终被释放的标椎是 state 的状态为 0，在重入加锁的情况下，需要重入解锁相应的次数后，才能最终把锁释放，比如线程 A 对共享资源 B 重入加锁 5 次，那么释放锁的话，也需要释放 5 次之后，才算真正的释放该共享资源了。</p><h4 id="6-2-5-FairSync-公平锁"><a href="#6-2-5-FairSync-公平锁" class="headerlink" title="6.2.5-FairSync 公平锁"></a>6.2.5-FairSync 公平锁</h4><p>FairSync 公平锁只实现了 lock 和 tryAcquire 两个方法，lock 方法非常简单，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// acquire 是 AQS 的方法，表示先尝试获得锁，失败之后进入同步队列阻塞等待</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>tryAcquire 方法是 AQS 在 acquire 方法中留给子类实现的抽象方法，FairSync 中实现的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Thread current <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// hasQueuedPredecessors 是实现公平的关键</span>        <span class="token comment" spellcheck="true">// 会判断当前线程是不是属于同步队列的头节点的下一个节点(头节点是释放锁的节点)</span>        <span class="token comment" spellcheck="true">// 如果是(返回false)，符合先进先出的原则，可以获得锁</span>        <span class="token comment" spellcheck="true">// 如果不是(返回true)，则继续等待</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasQueuedPredecessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 可重入锁</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Maximum lock count exceeded"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>代码和 Sync 的 nonfairTryAcquire 方法实现类似，唯一不同的是在获得锁时使用 hasQueuedPredecessors 方法体现了其公平性。</p><h4 id="6-2-6-NonfairSync-非公平锁"><a href="#6-2-6-NonfairSync-非公平锁" class="headerlink" title="6.2.6-NonfairSync 非公平锁"></a>6.2.6-NonfairSync 非公平锁</h4><p>NonfairSync 底层实现了 lock 和 tryAcquire 两个方法，如下:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 加锁</span><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// cas 给 state 赋值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// cas 赋值成功，代表拿到当前锁，记录拿到锁的线程</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">// acquire 是抽象类AQS的方法,</span>        <span class="token comment" spellcheck="true">// 会再次尝试获得锁，失败会进入到同步队列中</span>        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 直接使用的是 Sync.nonfairTryAcquire 方法 </span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span>acquires<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="6-2-7-如何串起来"><a href="#6-2-7-如何串起来" class="headerlink" title="6.2.7-如何串起来"></a>6.2.7-如何串起来</h4><p>以上内容主要说了 ReentrantLock 的基本结构，比较零散，那么这些零散的结构如何串联起来呢？我们是通过 lock、tryLock、unlock 这三个 API 将以上几个类串联起来，我们来一一看下。</p><h5 id="1-lock-加锁"><a href="#1-lock-加锁" class="headerlink" title="1.lock 加锁"></a>1.lock 加锁</h5><p>lock 的代码实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其底层的调用关系(只是简单表明调用关系，并不是完整分支图)如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/lock%E5%BA%95%E5%B1%82%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB.jpeg" alt="lock底层的调用关系"></p><h5 id="2-tryLock-尝试加锁"><a href="#2-tryLock-尝试加锁" class="headerlink" title="2.tryLock 尝试加锁"></a>2.tryLock 尝试加锁</h5><p>tryLock 有两个方法，一种是无参的，一种提供了超时时间的入参，两种内部是不同的实现机制，代码分别如下:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 无参构造器</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// timeout 为超时的时间，在时间内，仍没有得到锁，会返回 false</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>        <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接着我们一起看下两个 tryLock 的调用关系图，下图显示的是无参 tryLock 的调用关系图，如下：</p><p>![tryLock 的调用关系图](tryLock 的调用关系图.jpeg)</p><p>我们需要注意的是 tryLock 无参方法底层走的就是非公平锁实现，没有公平锁的实现。</p><p>下图展示的是带有超时时间的有参 tryLock 的调用实现图：</p><p>![tryLock 的调用实现图](tryLock 的调用实现图.jpeg)</p><h5 id="3-unlock-释放锁"><a href="#3-unlock-释放锁" class="headerlink" title="3.unlock 释放锁"></a>3.unlock 释放锁</h5><p>unlock 释放锁的方法，底层调用的是 Sync 同步器的 release 方法，release 是 AQS 的方法，分成两步：</p><ol><li>尝试释放锁，如果释放失败，直接返回 false；</li><li>释放成功，从同步队列的头节点的下一个节点开始唤醒，让其去竞争锁。</li></ol><p>第一步就是我们上文中 Sync 的 tryRelease 方法（4.1），第二步 AQS 已经实现了。</p><p>unLock 的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 释放锁</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="4-Condition-1"><a href="#4-Condition-1" class="headerlink" title="4.Condition"></a>4.Condition</h5><p>ReentrantLock 对 Condition 并没有改造，直接使用 AQS 的 ConditionObject 即可。</p><h4 id="6-2-8-总结"><a href="#6-2-8-总结" class="headerlink" title="6.2.8-总结"></a>6.2.8-总结</h4><p>这就是我们在研究完 AQS 源码之后，碰到的第一个锁，是不是感觉很简单，AQS 搭建了整个锁架构，子类锁只需要根据场景，实现 AQS 对应的方法即可，不仅仅是 ReentrantLock 是这样，JUC 中的其它锁也都是这样，只要对 AQS 了如指掌，锁其实非常简单。</p><h3 id="6-3-CountDownLatch、Atomic-等其它源码解析"><a href="#6-3-CountDownLatch、Atomic-等其它源码解析" class="headerlink" title="6.3-CountDownLatch、Atomic 等其它源码解析"></a>6.3-CountDownLatch、Atomic 等其它源码解析</h3><p>本小节和大家一起来看看 CountDownLatch 和 Atomic 打头的原子操作类，CountDownLatch 的源码非常少，看起来比较简单，但 CountDownLatch 的实际应用却不是很容易；Atomic 原子操作类就比较好理解和应用，接下来我们分别来看一下。</p><h4 id="6-3-1-CountDownLatch"><a href="#6-3-1-CountDownLatch" class="headerlink" title="6.3.1-CountDownLatch"></a>6.3.1-CountDownLatch</h4><p>CountDownLatch 中文有的叫做计数器，也有翻译为计数锁，其最大的作用不是为了加锁，而是通过计数达到等待的功能，主要有两种形式的等待：</p><ol><li>让一组线程在全部启动完成之后，再一起执行（先启动的线程需要阻塞等待后启动的线程，直到一组线程全部都启动完成后，再一起执行）；</li><li>主线程等待另外一组线程都执行完成之后，再继续执行。</li></ol><p>我们会举一个示例来演示这两种情况，但在这之前，我们先来看看 CountDownLatch 的底层源码实现，这样就会清晰一点，不然一开始就来看示例，估计很难理解。</p><p>CountDownLatch 有两个比较重要的 API，分别是 await 和 countDown，管理着线程能否获得锁和锁的释放（也可以称为对 state 的计数增加和减少）。</p><h5 id="1-await"><a href="#1-await" class="headerlink" title="1.await"></a>1.await</h5><p>await 我们可以叫做等待，也可以叫做加锁，有两种不同入参的方法，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 带有超时时间的，最终都会转化成毫秒</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">tryAcquireSharedNanos</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>两个方法底层使用的都是 sync，sync 是一个同步器，是 CountDownLatch 的内部类实现的，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>可以看出来 Sync 继承了 AbstractQueuedSynchronizer，具备了同步器的通用功能。</p><p>无参 await 底层使用的是 acquireSharedInterruptibly 方法，有参的使用的是 tryAcquireSharedNanos 方法，这两个方法都是 AQS 的方法，底层实现很相似，主要分成两步：</p><ol><li>使用子类的 tryAcquireShared 方法尝试获得锁，如果获取了锁直接返回，获取不到锁走 2；</li><li>获取不到锁，用 Node 封装一下当前线程，追加到同步队列的尾部，等待在合适的时机去获得锁。</li></ol><p>第二步是 AQS 已经实现了，第一步 tryAcquireShared 方法是交给 Sync 实现的，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果当前同步器的状态是 0 的话，表示可获得锁</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>获得锁的代码也很简单，直接根据同步器的 state 字段来进行判断，但还是有两点需要注意一下：</p><ol><li>获得锁时，state 的值不会发生变化，像 ReentrantLock 在获得锁时，会把 state + 1，但 CountDownLatch 不会；</li><li>CountDownLatch 的 state 并不是 AQS 的默认值 0，而是可以赋值的，是在 CountDownLatch 初始化的时候赋值的，代码如下：</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 初始化,count 代表 state 的初始化值</span><span class="token keyword">public</span> <span class="token function">CountDownLatch</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"count &lt; 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// new Sync 底层代码是 state = count;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里的初始化的 count 和一般的锁意义不太一样，count 表示我们希望等待的线程数，在两种不同的等待场景中，count 有不同的含义：</p><ol><li>让一组线程在全部启动完成之后，再一起执行的等待场景下， count 代表一组线程的个数；</li><li>主线程等待另外一组线程都执行完成之后，再继续执行的等待场景下，count 代表一组线程的个数。</li></ol><p>所以我们可以把 count 看做我们希望等待的一组线程的个数，可能我们是等待一组线程全部启动完成，可能我们是等待一组线程全部执行完成。</p><h5 id="2-countDown"><a href="#2-countDown" class="headerlink" title="2.countDown"></a>2.countDown</h5><p>countDown 中文翻译为倒计时，每调用一次，都会使 state 减一，底层调用的方法如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>releaseShared 是 AQS 定义的方法，方法主要分成两步：</p><ol><li>尝试释放锁（tryReleaseShared），锁释放失败直接返回，释放成功走 2；</li><li>释放当前节点的后置等待节点。</li></ol><p>第二步 AQS 已经实现了，第一步是 Sync 实现的，我们一起来看下 tryReleaseShared 方法的实现源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对 state 进行递减，直到 state 变成 0；</span><span class="token comment" spellcheck="true">// state 递减为 0 时，返回 true，其余返回 false</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 自旋保证 CAS 一定可以成功</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// state 已经是 0 了，直接返回 false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 对 state 进行递减</span>        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从源码中可以看到，只有到 count 递减到 0 时，countDown 才会返回 true。</p><h5 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h5><p>看完 CountDownLatch 两个重要 API 后，我们来实现文章开头说的两个功能：</p><ol><li>让一组线程在全部启动完成之后，再一起执行；</li><li>主线程等待另外一组线程都执行完成之后，再继续执行。</li></ol><p>代码在 CountDownLatchDemo 类中，大家可以调试看看，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDownLatchDemo</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 线程任务</span>  <span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 定义计数锁用来实现功能 1</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> CountDownLatch startSignal<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 定义计数锁用来实现功能 2</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> CountDownLatch doneSignal<span class="token punctuation">;</span>    <span class="token function">Worker</span><span class="token punctuation">(</span>CountDownLatch startSignal<span class="token punctuation">,</span> CountDownLatch doneSignal<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>startSignal <span class="token operator">=</span> startSignal<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>doneSignal <span class="token operator">=</span> doneSignal<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 子线程做的事情</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// await 时有两点需要注意：await 时 state 不会发生变化，2：startSignal 的state初始化是 1，所以所有子线程都是获取不到锁的，都需要到同步队列中去等待，达到先启动的子线程等待后面启动的子线程的结果</span>        startSignal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// countDown 每次会使 state 减一，doneSignal 初始化为 9，countDown 前 8 次执行都会返回 false (releaseShared 方法)，执行第 9 次时，state 递减为 0，会 countDown 成功，表示所有子线程都执行完了，会释放 await 在 doneSignal 上的主线程</span>        doneSignal<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// return;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"sleep 5s …………"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>5000l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// state 初始化为 1 很关键，子线程是不断的 await，await 时 state 是不会变化的，并且发现 state 都是 1，所有线程都获取不到锁</span>    <span class="token comment" spellcheck="true">// 造成所有线程都到同步队列中去等待，当主线程执行 countDown 时，就会一起把等待的线程给释放掉</span>    CountDownLatch startSignal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// state 初始化成 9，表示有 9 个子线程执行完成之后，会唤醒主线程</span>    CountDownLatch doneSignal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// create and start threads</span>    <span class="token punctuation">{</span>      <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>startSignal<span class="token punctuation">,</span> doneSignal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main thread begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这行代码唤醒 9 个子线程，开始执行(因为 startSignal 锁的状态是 1，所以调用一次 countDown 方法就可以释放9个等待的子线程)</span>    startSignal<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这行代码使主线程陷入沉睡，等待 9 个子线程执行完成之后才会继续执行(就是等待子线程执行 doneSignal.countDown())</span>    doneSignal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main thread end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>执行结果：Thread<span class="token operator">-</span><span class="token number">0</span> beginThread<span class="token operator">-</span><span class="token number">1</span> beginThread<span class="token operator">-</span><span class="token number">2</span> beginThread<span class="token operator">-</span><span class="token number">3</span> beginThread<span class="token operator">-</span><span class="token number">4</span> beginThread<span class="token operator">-</span><span class="token number">5</span> beginThread<span class="token operator">-</span><span class="token number">6</span> beginThread<span class="token operator">-</span><span class="token number">7</span> beginThread<span class="token operator">-</span><span class="token number">8</span> beginmain thread beginThread<span class="token operator">-</span>0sleep 5s …………Thread<span class="token operator">-</span>1sleep 5s …………Thread<span class="token operator">-</span>4sleep 5s …………Thread<span class="token operator">-</span>3sleep 5s …………Thread<span class="token operator">-</span>2sleep 5s …………Thread<span class="token operator">-</span>8sleep 5s …………Thread<span class="token operator">-</span>7sleep 5s …………Thread<span class="token operator">-</span>6sleep 5s …………Thread<span class="token operator">-</span>5sleep 5s …………Thread<span class="token operator">-</span><span class="token number">0</span> endThread<span class="token operator">-</span><span class="token number">1</span> endThread<span class="token operator">-</span><span class="token number">4</span> endThread<span class="token operator">-</span><span class="token number">3</span> endThread<span class="token operator">-</span><span class="token number">2</span> endThread<span class="token operator">-</span><span class="token number">8</span> endThread<span class="token operator">-</span><span class="token number">7</span> endThread<span class="token operator">-</span><span class="token number">6</span> endThread<span class="token operator">-</span><span class="token number">5</span> endmain thread end</code></pre><p>从执行结果中，可以看出已经实现了以上两个功能，实现比较绕，大家可以根据注释，debug 看一看。</p><h4 id="6-3-2-Atomic-原子操作类"><a href="#6-3-2-Atomic-原子操作类" class="headerlink" title="6.3.2-Atomic 原子操作类"></a>6.3.2-Atomic 原子操作类</h4><p>Atomic 打头的原子操作类有很多，涉及到 Java 常用的数字类型的，基本都有相应的 Atomic 原子操作类，如下图所示：</p><p>![Atomic 原子操作类](Atomic 原子操作类.jpeg)</p><p>Atomic 打头的原子操作类，在高并发场景下，都是线程安全的，我们可以放心使用。</p><p>我们以 AtomicInteger 为例子，来看下主要的底层实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始化</span><span class="token keyword">public</span> <span class="token function">AtomicInteger</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    value <span class="token operator">=</span> initialValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 得到当前值</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 自增 1，并返回自增之前的值    </span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 自减 1，并返回自增之前的值    </span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码中，我们可以看到，线程安全的操作方法，底层都是使用 unsafe 方法实现，以上几个 unsafe 方法不是使用 Java 实现的，都是线程安全的。</p><p>AtomicInteger 是对 int 类型的值进行自增自减，那如果 Atomic 的对象是个自定义类怎么办呢，Java 也提供了自定义对象的原子操作类，叫做 AtomicReference。AtomicReference 类可操作的对象是个泛型，所以支持自定义类，其底层是没有自增方法的，操作的方法可以作为函数入参传递，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对 x 执行 accumulatorFunction 操作</span><span class="token comment" spellcheck="true">// accumulatorFunction 是个函数，可以自定义想做的事情</span><span class="token comment" spellcheck="true">// 返回老值</span><span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getAndAccumulate</span><span class="token punctuation">(</span>V x<span class="token punctuation">,</span>                                BinaryOperator<span class="token operator">&lt;</span>V<span class="token operator">></span> accumulatorFunction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// prev 是老值，next 是新值</span>    V prev<span class="token punctuation">,</span> next<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 自旋 + CAS 保证一定可以替换老值</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        prev <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 执行自定义操作</span>        next <span class="token operator">=</span> accumulatorFunction<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> prev<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="6-3-3-总结"><a href="#6-3-3-总结" class="headerlink" title="6.3.3-总结"></a>6.3.3-总结</h4><p>CountDownLatch 的源码实现简单，但真的要用好还是不简单的，其使用场景比较复杂，建议同学们可以 debug 一下 CountDownLatchDemo，在增加实战能力基础上，增加底层的理解能力。</p><h3 id="6-4-只求问倒：连环相扣系列锁面试题"><a href="#6-4-只求问倒：连环相扣系列锁面试题" class="headerlink" title="6.4-只求问倒：连环相扣系列锁面试题"></a>6.4-只求问倒：连环相扣系列锁面试题</h3><p>面试中，问锁主要是两方面：锁的日常使用场景 + 锁原理，锁的日常使用场景主要考察对锁 API 的使用熟练度，看看你是否真的使用过这些 API，而不是纸上谈兵，锁原理主要就是问 AQS 底层的源码原理了，如果问得更加深入的话，可能会现场让你实现一个简单的锁，简单要求的会让你直接使用 AQS API，复杂要求的可能需要重新实现 AQS。</p><p>接下来我们一起看一看关于锁的常见源码面试题。</p><h4 id="6-4-1-AQS-相关面试题"><a href="#6-4-1-AQS-相关面试题" class="headerlink" title="6.4.1-AQS 相关面试题"></a>6.4.1-AQS 相关面试题</h4><h5 id="1-说说自己对-AQS-的理解？"><a href="#1-说说自己对-AQS-的理解？" class="headerlink" title="1.说说自己对 AQS 的理解？"></a>1.说说自己对 AQS 的理解？</h5><p>答：回答这样的问题的时候，面试官主要考察的是你对 AQS 的知识有没有系统的整理，建议回答的方向是由大到小，由全到细，由使用到原理。</p><p>如果和面试官面对面的话，可以边说边画出我们在 AQS 源码解析上中画出的整体架构图，并且可以这么说：</p><ol><li>AQS 是一个锁框架，它定义了锁的实现机制，并开放出扩展的地方，让子类去实现，比如我们在 lock 的时候，AQS 开放出 state 字段，让子类可以根据 state 字段来决定是否能够获得锁，对于获取不到锁的线程 AQS 会自动进行管理，无需子类锁关心，这就是 lock 时锁的内部机制，封装的很好，又暴露出子类锁需要扩展的地方；</li><li>AQS 底层是由同步队列 + 条件队列联手组成，同步队列管理着获取不到锁的线程的排队和释放，条件队列是在一定场景下，对同步队列的补充，比如获得锁的线程从空队列中拿数据，肯定是拿不到数据的，这时候条件队列就会管理该线程，使该线程阻塞；</li><li>AQS 围绕两个队列，提供了四大场景，分别是：获得锁、释放锁、条件队列的阻塞，条件队列的唤醒，分别对应着 AQS 架构图中的四种颜色的线的走向。</li></ol><p>以上三点都是 AQS 全局方面的描述，接着你可以问问面试官要不要说细一点，可以的话，按照 AQS 源码解析上下两篇，把四大场景都说一下就好了。</p><p>这样说的好处是很多的：</p><ol><li>面试的主动权把握在自己手里，而且都是自己掌握的知识点；</li><li>由全到细的把 AQS 全部说完，会给面试官一种你对 AQS 了如指掌的感觉，再加上全部说完耗时会很久，面试时间又很有限，面试官就不会再问关于 AQS 一些刁钻的问题了，这样 AQS 就可以轻松过关。</li></ol><p>当然如果你对 AQS 了解的不是很深，那么就大概回答下 AQS 的大体架构就好了，就不要说的特别细，免得给自己挖坑。</p><h5 id="2-多个线程通过锁请求共享资源，获取不到锁的线程怎么办？"><a href="#2-多个线程通过锁请求共享资源，获取不到锁的线程怎么办？" class="headerlink" title="2.多个线程通过锁请求共享资源，获取不到锁的线程怎么办？"></a>2.多个线程通过锁请求共享资源，获取不到锁的线程怎么办？</h5><p>答：加锁(排它锁)主要分为以下四步：</p><ol><li>尝试获得锁，获得锁了直接返回，获取不到锁的走到 2；</li><li>用 Node 封装当前线程，追加到同步队列的队尾，追加到队尾时，又有两步，如 3 和 4；</li><li>自旋 + CAS 保证前一个节点的状态置为 signal；</li><li>阻塞自己，使当前线程进入等待状态。</li></ol><p>获取不到锁的线程会进行 2、3、4 步，最终会陷入等待状态，这个描述的是排它锁。</p><h5 id="3-问题-1-2-中，排它锁和共享锁的处理机制是一样的么？"><a href="#3-问题-1-2-中，排它锁和共享锁的处理机制是一样的么？" class="headerlink" title="3.问题 1.2 中，排它锁和共享锁的处理机制是一样的么？"></a>3.问题 1.2 中，排它锁和共享锁的处理机制是一样的么？</h5><p>答：排它锁和共享锁在问题 1.2 中的 2、3、4 步骤都是一样的， 不同的是在于第一步，线程获得排它锁的时候，仅仅把自己设置为同步队列的头节点即可，但如果是共享锁的话，还会去唤醒自己的后续节点，一起来获得该锁。</p><h5 id="4-共享锁和排它锁的区别？"><a href="#4-共享锁和排它锁的区别？" class="headerlink" title="4.共享锁和排它锁的区别？"></a>4.共享锁和排它锁的区别？</h5><p>答：排它锁的意思是同一时刻，只能有一个线程可以获得锁，也只能有一个线程可以释放锁。</p><p>共享锁可以允许多个线程获得同一个锁，并且可以设置获取锁的线程数量，共享锁之所以能够做到这些，是因为线程一旦获得共享锁，把自己设置成同步队列的头节点后，会自动的去释放头节点后等待获取共享锁的节点，让这些等待节点也一起来获得共享锁，而排它锁就不会这么干。</p><h5 id="5-排它锁和共享锁说的是加锁时的策略，那么锁释放时有排它锁和共享锁的策略么？"><a href="#5-排它锁和共享锁说的是加锁时的策略，那么锁释放时有排它锁和共享锁的策略么？" class="headerlink" title="5.排它锁和共享锁说的是加锁时的策略，那么锁释放时有排它锁和共享锁的策略么？"></a>5.排它锁和共享锁说的是加锁时的策略，那么锁释放时有排它锁和共享锁的策略么？</h5><p>答：是的，排它锁和共享锁，主要体现在加锁时，多个线程能否获得同一个锁。</p><p>但在锁释放时，是没有排它锁和共享锁的概念和策略的，概念仅仅针对锁获取。</p><h5 id="6-描述下同步队列？"><a href="#6-描述下同步队列？" class="headerlink" title="6.描述下同步队列？"></a>6.描述下同步队列？</h5><p>答：同步队列底层的数据结构就是双向的链表，节点叫做 Node，头节点叫做 head，尾节点叫做 tail，节点和节点间的前后指向分别叫做 prev、next，如果是面对面面试的话，可以画一下 AQS 整体架构图中的同步队列。</p><p>同步队列的作用：阻塞获取不到锁的线程，并在适当时机释放这些线程。</p><p>实现的大致过程：当多个线程都来请求锁时，某一时刻有且只有一个线程能够获得锁（排它锁），那么剩余获取不到锁的线程，都会到同步队列中去排队并阻塞自己，当有线程主动释放锁时，就会从同步队列中头节点开始释放一个排队的线程，让线程重新去竞争锁。</p><h5 id="7-描述下线程入、出同步队列的时机和过程？"><a href="#7-描述下线程入、出同步队列的时机和过程？" class="headerlink" title="7.描述下线程入、出同步队列的时机和过程？"></a>7.描述下线程入、出同步队列的时机和过程？</h5><p>答：(排它锁为例)从 AQS 整体架构图中，可以看出同步队列入队和出队都是有两个箭头指向，所以入队和出队的时机各有两个。</p><p>同步队列入队时机：</p><ol><li>多个线程请求锁，获取不到锁的线程需要到同步队列中排队阻塞；</li><li>条件队列中的节点被唤醒，会从条件队列中转移到同步队列中来。</li></ol><p>同步队列出队时机：</p><ol><li>锁释放时，头节点出队；</li><li>获得锁的线程，进入条件队列时，会释放锁，同步队列头节点开始竞争锁。</li></ol><p>四个时机的过程可以参考 AQS 源码解析，1 参考 acquire 方法执行过程，2 参考 signal 方法，3 参考 release 方法，4 参考 await 方法。</p><h5 id="8-为什么-AQS-有了同步队列之后，还需要条件队列？"><a href="#8-为什么-AQS-有了同步队列之后，还需要条件队列？" class="headerlink" title="8.为什么 AQS 有了同步队列之后，还需要条件队列？"></a>8.为什么 AQS 有了同步队列之后，还需要条件队列？</h5><p>答：的确，一般情况下，我们只需要有同步队列就好了，但在上锁后，需要操作队列的场景下，一个同步队列就搞不定了，需要条件队列进行功能补充，比如当队列满时，执行 put 操作的线程会进入条件队列等待，当队列空时，执行 take 操作的线程也会进入条件队列中等待，从一定程度上来看，条件队列是对同步队列的场景功能补充。</p><h5 id="9-描述一下条件队列中的元素入队和出队的时机和过程？"><a href="#9-描述一下条件队列中的元素入队和出队的时机和过程？" class="headerlink" title="9.描述一下条件队列中的元素入队和出队的时机和过程？"></a>9.描述一下条件队列中的元素入队和出队的时机和过程？</h5><p>答：入队时机：执行 await 方法时，当前线程会释放锁，并进入到条件队列。</p><p>出队时机：执行 signal、signalAll 方法时，节点会从条件队列中转移到同步队列中。</p><p>具体的执行过程，可以参考源码解析中 await 和 signal 方法。</p><h5 id="10-描述一下条件队列中的节点转移到同步队列中去的时机和过程？"><a href="#10-描述一下条件队列中的节点转移到同步队列中去的时机和过程？" class="headerlink" title="10.描述一下条件队列中的节点转移到同步队列中去的时机和过程？"></a>10.描述一下条件队列中的节点转移到同步队列中去的时机和过程？</h5><p>答：时机：当有线程执行 signal、signalAll 方法时，从条件队列的头节点开始，转移到同步队列中去。</p><p>过程主要是以下几步：</p><ol><li>找到条件队列的头节点，头节点 next 属性置为 null，从条件队列中移除了；</li><li>头节点追加到同步队列的队尾；</li><li>头节点状态（waitStatus）从 CONDITION 修改成 0（初始化状态）；</li><li>将节点的前一个节点状态置为 SIGNAL。</li></ol><h5 id="11-线程入条件队列时，为什么需要释放持有的锁？"><a href="#11-线程入条件队列时，为什么需要释放持有的锁？" class="headerlink" title="11.线程入条件队列时，为什么需要释放持有的锁？"></a>11.线程入条件队列时，为什么需要释放持有的锁？</h5><p>答：原因很简单，如果当前线程不释放锁，一旦跑去条件队里中阻塞了，后续所有的线程都无法获得锁，正确的场景应该是：当前线程释放锁，到条件队列中去阻塞后，其他线程仍然可以获得当前锁。</p><h4 id="6-4-2-AQS-子类锁面试题"><a href="#6-4-2-AQS-子类锁面试题" class="headerlink" title="6.4.2-AQS 子类锁面试题"></a>6.4.2-AQS 子类锁面试题</h4><h5 id="1-你在工作中如何使用锁的，写一个看一看？"><a href="#1-你在工作中如何使用锁的，写一个看一看？" class="headerlink" title="1.你在工作中如何使用锁的，写一个看一看？"></a>1.你在工作中如何使用锁的，写一个看一看？</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConditionDemo</span> <span class="token punctuation">{</span>  <span class="token keyword">final</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">final</span> Condition notFull  <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">final</span> Condition notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> putptr<span class="token punctuation">,</span> takeptr<span class="token punctuation">,</span> count<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>Object x<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      items<span class="token punctuation">[</span>putptr<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putptr <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        putptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token operator">++</span>count<span class="token punctuation">;</span>      notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> Object <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      Object x <span class="token operator">=</span> items<span class="token punctuation">[</span>takeptr<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeptr <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        takeptr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token operator">--</span>count<span class="token punctuation">;</span>      notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> x<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>      lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="2-如果我要自定义锁，大概的实现思路是什么样子的？"><a href="#2-如果我要自定义锁，大概的实现思路是什么样子的？" class="headerlink" title="2.如果我要自定义锁，大概的实现思路是什么样子的？"></a>2.如果我要自定义锁，大概的实现思路是什么样子的？</h5><p>答：现在有很多类似的问题，比如让你自定义队列，自定义锁等等，面试官其实并不是想让我们重新造一个轮子，而是想考察一下我们对于队列、锁理解的深度，我们只需要选择自己最熟悉的 API 描述一下就好了，所以这题我们可以选择 ReentrantLock 来描述一下实现思路：</p><ol><li>新建内部类继承 AQS，并实现 AQS 的 tryAcquire 和 tryRelease 两个方法，在 tryAcquire 方法里面实现控制能否获取锁，比如当同步器状态 state 是 0 时，即可获得锁，在 tryRelease 方法里面控制能否释放锁，比如将同步器状态递减到 0 时，即可释放锁；</li><li>对外提供 lock、release 两个方法，lock 表示获得锁的方法，底层调用 AQS 的 acquire 方法，release 表示释放锁的方法，底层调用 AQS 的 release 方法。</li></ol><h5 id="3-描述-ReentrantLock-两大特性：可重入性和公平性？底层分别如何实现的？"><a href="#3-描述-ReentrantLock-两大特性：可重入性和公平性？底层分别如何实现的？" class="headerlink" title="3.描述 ReentrantLock 两大特性：可重入性和公平性？底层分别如何实现的？"></a>3.描述 ReentrantLock 两大特性：可重入性和公平性？底层分别如何实现的？</h5><p>答：可重入性说的是线程可以对共享资源重复加锁，对应的，释放时也可以重复释放，对于 ReentrantLock 来说，在获得锁的时候，state 会加 1，重复获得锁时，不断的对 state 进行递增即可，比如目前 state 是 4，表示线程已经对共享资源加锁了 4 次，线程每次释放共享资源的锁时，state 就会递减 1，直到递减到 0 时，才算真正释放掉共享资源。</p><p>公平性和非公平指的是同步队列中的线程得到锁的机制，如果同步队列中的线程按照阻塞的顺序得到锁，我们称之为公平的，反之是非公平的，公平的底层实现是 ReentrantLock 的 tryAcquire 方法（调用的是 AQS 的 hasQueuedPredecessors 方法）里面实现的，要释放同步队列的节点时（或者获得锁时），判断当前线程节点是不是同步队列的头节点的后一个节点，如果是就释放，不是则不能释放，通过这种机制，保证同步队列中的线程得到锁时，是按照从头到尾的顺序的。</p><h5 id="4-如果一个线程需要等待一组线程全部执行完之后再继续执行，有什么好的办法么？是如何实现的？"><a href="#4-如果一个线程需要等待一组线程全部执行完之后再继续执行，有什么好的办法么？是如何实现的？" class="headerlink" title="4.如果一个线程需要等待一组线程全部执行完之后再继续执行，有什么好的办法么？是如何实现的？"></a>4.如果一个线程需要等待一组线程全部执行完之后再继续执行，有什么好的办法么？是如何实现的？</h5><p>答：CountDownLatch 就提供了这样的机制，比如一组线程有 5 个，只需要在初始化 CountDownLatch 时，给同步器的 state 赋值为 5，主线程执行 CountDownLatch.await ，子线程都执行 CountDownLatch.countDown 即可。</p><h5 id="5-Atomic-原子操作类可以保证线程安全，如果操作的对象是自定义的类的话，要如何做呢？"><a href="#5-Atomic-原子操作类可以保证线程安全，如果操作的对象是自定义的类的话，要如何做呢？" class="headerlink" title="5.Atomic 原子操作类可以保证线程安全，如果操作的对象是自定义的类的话，要如何做呢？"></a>5.Atomic 原子操作类可以保证线程安全，如果操作的对象是自定义的类的话，要如何做呢？</h5><p>答： Java 为这种情况提供了一个 API：AtomicReference，AtomicReference 类可操作的对象是个泛型，所以支持自定义类。</p><h4 id="6-4-3-总结"><a href="#6-4-3-总结" class="headerlink" title="6.4.3-总结"></a>6.4.3-总结</h4><p>关于 AQS 和锁场景的面试题，其实网上也很多，各个大厂出的题目也都不一样，但考察问题的本质都是一致的，如果把 AQS 架构图中，AQS 的组成和四种颜色箭头的发起时机，调用过程都弄清楚了，回答 AQS 的各种问题都会游刃有余。</p><h3 id="6-5-经验总结：各种锁在工作中使用场景和细节"><a href="#6-5-经验总结：各种锁在工作中使用场景和细节" class="headerlink" title="6.5-经验总结：各种锁在工作中使用场景和细节"></a>6.5-经验总结：各种锁在工作中使用场景和细节</h3><p>本章主要说一说锁在工作中的使用场景，主要以 synchronized 和 CountDownLatch 为例，会分别描述一下这两种锁的使用场景和姿势。</p><h4 id="6-5-1-synchronized"><a href="#6-5-1-synchronized" class="headerlink" title="6.5.1-synchronized"></a>6.5.1-synchronized</h4><p>synchronized 是可重入的排它锁，和 ReentrantLock 锁功能相似，任何使用 synchronized 的地方，几乎都可以使用 ReentrantLock 来代替，两者最大的相似点就是：可重入 + 排它锁，两者的区别主要有这些：</p><ol><li>ReentrantLock 的功能更加丰富，比如提供了 Condition，可以打断的加锁 API、能满足锁 + 队列的复杂场景等等；</li><li>ReentrantLock 有公平锁和非公平锁之分，而 synchronized 都是非公平锁；</li><li>两者的使用姿势也不同，ReentrantLock 需要申明，有加锁和释放锁的 API，而 synchronized 会自动对代码块进行加锁释放锁的操作，synchronized 使用起来更加方便。</li></ol><p>synchronized 和 ReentrantLock 功能相近，所以我们就以 synchronized 举例。</p><h5 id="1-共享资源初始化"><a href="#1-共享资源初始化" class="headerlink" title="1.共享资源初始化"></a>1.共享资源初始化</h5><p>在分布式的系统中，我们喜欢把一些死的配置资源在项目启动的时候加锁到 JVM 内存里面去，这样请求在拿这些共享配置资源时，就可直接从内存里面拿，不必每次都从数据库中拿，减少了时间开销。</p><p>一般这样的共享资源有：死的业务流程配置 + 死的业务规则配置。</p><p>共享资源初始化的步骤一般为：项目启动 -&gt; 触发初始化动作 -&gt;单线程从数据库中捞取数据 -&gt; 组装成我们需要的数据结构 -&gt; 放到 JVM 内存中。</p><p>在项目启动时，为了防止共享资源被多次加载，我们往往会加上排它锁，让一个线程加载共享资源完成之后，另外一个线程才能继续加载，此时的排它锁我们可以选择 synchronized 或者 ReentrantLock，我们以 synchronized 为例，写了 mock 的代码，如下：</p><pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">// 共享资源</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> SHARED_MAP <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 有无初始化完成的标志位</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> loaded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 初始化共享资源   */</span>  <span class="token annotation punctuation">@PostConstruct</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>loaded<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 再次 check</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>loaded<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"SynchronizedDemo init begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 从数据库中捞取数据，组装成 SHARED_MAP 的数据格式</span>      loaded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"SynchronizedDemo init end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>不知道大家有没有从上述代码中发现 @PostConstruct 注解，@PostConstruct 注解的作用是在 Spring 容器初始化时，再执行该注解打上的方法，也就是说上图说的 init 方法触发的时机，是在 Spring 容器启动的时候。</p><p>大家可以下载演示代码，找到 DemoApplication 启动文件，在 DemoApplication 文件上右击 run，就可以启动整个 Spring Boot 项目，在 init 方法上打上断点就可以调试了。</p><p>我们在代码中使用了 synchronized 来保证同一时刻，只有一个线程可以执行初始化共享资源的操作，并且我们加了一个共享资源加载完成的标识位（loaded），来判断是否加载完成了，如果加载完成，那么其它加载线程直接返回。</p><p>如果把 synchronized 换成 ReentrantLock 也是一样的实现，只不过需要显示的使用 ReentrantLock 的 API 进行加锁和释放锁，使用 ReentrantLock 有一点需要注意的是，我们需要在 try 方法块中加锁，在 finally 方法块中释放锁，这样保证即使 try 中加锁后发生异常，在 finally 中也可以正确的释放锁。</p><p>有的同学可能会问，不是可以直接使用了 ConcurrentHashMap 么，为什么还需要加锁呢？的确 ConcurrentHashMap 是线程安全的，但它只能够保证 Map 内部数据操作时的线程安全，是无法保证多线程情况下，查询数据库并组装数据的整个动作只执行一次的，我们加 synchronized 锁住的是整个操作，保证整个操作只执行一次。</p><p>完整 demo 如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 共享资源初始化、注册、动态刷新等场景 * 演示使用 synchronized 防止并发 */</span><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedDemo</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 共享资源</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> SHARED_MAP <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 有无加锁完成的标志位</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> loaded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 初始化、注册   */</span>  <span class="token annotation punctuation">@PostConstruct</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>loaded<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>loaded<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"SynchronizedDemo init begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 从数据库中捞取数据，组装成 SHARED_MAP 的数据格式</span>      loaded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"SynchronizedDemo init end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * 刷新   */</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    SHARED_MAP<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SHARED_MAP<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="6-5-2-CountDownLatch"><a href="#6-5-2-CountDownLatch" class="headerlink" title="6.5.2-CountDownLatch"></a>6.5.2-CountDownLatch</h4><h5 id="1-场景"><a href="#1-场景" class="headerlink" title="1.场景"></a>1.场景</h5><ol><li><p>小明在淘宝上买了一个商品，觉得不好，把这个商品退掉(商品还没有发货，只退钱)，我们叫做单商品退款，单商品退款在后台系统中运行时，整体耗时 30 毫秒。</p></li><li><p>双 11，小明在淘宝上买了 40 个商品，生成了同一个订单（实际可能会生成多个订单，为了方便描述，我们说成一个），第二天小明发现其中 30 个商品是自己冲动消费的，需要把 30 个商品一起退掉。</p></li></ol><h5 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h5><p>此时后台只有单商品退款的功能，没有批量商品退款的功能（30 个商品一次退我们称为批量），为了快速实现这个功能，同学 A 按照这样的方案做的：for 循环调用 30 次单商品退款的接口，在 qa 环境测试的时候发现，如果要退款 30 个商品的话，需要耗时：30 * 30 = 900 毫秒，再加上其它的逻辑，退款 30 个商品差不多需要 1 秒了，这个耗时其实算很久了，当时同学 A 提出了这个问题，希望大家帮忙看看如何优化整个场景的耗时。</p><p>同学 B 当时就提出，你可以使用线程池进行执行呀，把任务都提交到线程池里面去，假如机器的 CPU 是 4 核的，最多同时能有 4 个单商品退款可以同时执行，同学 A 觉得很有道理，于是准备修改方案，为了便于理解，我们把两个方案都画出来，对比一下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/CountDownLatch%E5%95%86%E5%93%81%E9%80%80%E6%AC%BE.jpeg" alt="CountDownLatch商品退款"></p><p>同学 A 于是就按照演变的方案去写代码了，过了一天，抛出了一个问题：向线程池提交了 30 个任务后，主线程如何等待 30 个任务都执行完成呢？因为主线程需要收集 30 个子任务的执行情况，并汇总返回给前端。</p><p>大家可以先不往下看，自己先思考一下，我们前几章说的那种锁可以帮助解决这个问题？</p><p>CountDownLatch 可以的，CountDownLatch 具有这种功能，让主线程去等待子任务全部执行完成之后才继续执行。</p><p>此时还有一个关键，我们需要知道子线程执行的结果，所以我们用 Runnable 作为线程任务就不行了，因为 Runnable 是没有返回值的，我们需要选择 Callable 作为任务。</p><p>我们写了一个 demo，首先我们来看一下单个商品退款的代码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 单商品退款，耗时 30 毫秒，退款成功返回 true，失败返回 false</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RefundDemo</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/**   * 根据商品 ID 进行退款   * @param itemId   * @return   */</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">refundByItem</span><span class="token punctuation">(</span>Long itemId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 线程沉睡 30 毫秒，模拟单个商品退款过程</span>      Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"refund success,itemId is {}"</span><span class="token punctuation">,</span> itemId<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"refundByItemError,itemId is {}"</span><span class="token punctuation">,</span> itemId<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接着我们看下 30 个商品的批量退款，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BatchRefundDemo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 定义线程池</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ExecutorService EXECUTOR_SERVICE <span class="token operator">=</span>      <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> 0L<span class="token punctuation">,</span>                                TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>                                <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">batchRefund</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// state 初始化为 30 </span>    CountDownLatch countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    RefundDemo refundDemo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RefundDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 准备 30 个商品</span>    List<span class="token operator">&lt;</span>Long<span class="token operator">></span> items <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayListWithCapacity</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      items<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Long<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 准备开始批量退款</span>    List<span class="token operator">&lt;</span>Future<span class="token operator">></span> futures <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayListWithCapacity</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Long item <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 使用 Callable，因为我们需要等到返回值</span>      Future<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> future <span class="token operator">=</span> EXECUTOR_SERVICE<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Boolean<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Boolean <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>          <span class="token keyword">boolean</span> result <span class="token operator">=</span> refundDemo<span class="token punctuation">.</span><span class="token function">refundByItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 每个子线程都会执行 countDown，使 state -1 ，但只有最后一个才能真的唤醒主线程</span>          countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 收集批量退款的结果</span>      futures<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"30 个商品已经在退款中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使主线程阻塞，一直等待 30 个商品都退款完成，才能继续执行</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"30 个商品已经退款完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 拿到所有结果进行分析</span>    List<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> result <span class="token operator">=</span> futures<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>fu<span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// get 的超时时间设置的是 1 毫秒，是为了说明此时所有的子线程都已经执行完成了</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>Boolean<span class="token punctuation">)</span> fu<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">TimeoutException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打印结果统计</span>    <span class="token keyword">long</span> success <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>r<span class="token operator">-</span><span class="token operator">></span>r<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"执行结果成功{},失败{}"</span><span class="token punctuation">,</span>success<span class="token punctuation">,</span>result<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>success<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述代码只是大概的底层思路，真实的项目会在此思路之上加上请求分组，超时打断等等优化措施。</p><p>我们来看一下执行的结果:</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/CountDownLatch%E5%95%86%E5%93%81%E9%80%80%E6%AC%BE%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.jpeg" alt="CountDownLatch商品退款执行结果"></p><p>从执行的截图中，我们可以明显的看到 CountDownLatch 已经发挥出了作用，主线程会一直等到 30 个商品的退款结果之后才会继续执行。</p><p>接着我们做了一个不严谨的实验（把以上代码执行很多次，求耗时平均值），通过以上代码，30 个商品退款完成之后，整体耗时大概在 200 毫秒左右。</p><p>而通过 for 循环单商品进行退款，大概耗时在 1 秒左右，前后性能相差 5 倍左右，for 循环退款的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">long</span> begin1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Long item <span class="token operator">:</span> items<span class="token punctuation">)</span> <span class="token punctuation">{</span>  refundDemo<span class="token punctuation">.</span><span class="token function">refundByItem</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"for 循环单个退款耗时{}"</span><span class="token punctuation">,</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>begin1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>性能的巨大提升是线程池 + 锁两者结合的功劳。</p><h4 id="6-5-3-总结"><a href="#6-5-3-总结" class="headerlink" title="6.5.3-总结"></a>6.5.3-总结</h4><p>本章举了实际工作中的两个小案列，看到了 CountDownLatch 和 synchronized（ReentrantLock） 是如何结合实际需求进行落地的，特别是 CountDownLatch 的案列，使用线程池 + 锁结合的方式大大提高了生产效率，所以在工作中如果你也遇到相似的场景，可以毫不犹豫地用起来。</p><h3 id="6-6-从容不迫：重写锁的设计结构和细节"><a href="#6-6-从容不迫：重写锁的设计结构和细节" class="headerlink" title="6.6-从容不迫：重写锁的设计结构和细节"></a>6.6-从容不迫：重写锁的设计结构和细节</h3><p>有的面试官喜欢让同学在说完锁的原理之后，让你重写一个新的锁，要求现场在白板上写出大概的思路和代码逻辑，这种面试题目，蛮难的，我个人觉得其侧重点主要是两个部分：</p><ol><li>考察一下你对锁原理的理解是如何来的，如果你对源码没有解读过的话，只是看看网上的文章，或者背面试题，也是能够说出大概的原理，但你很难现场写出一个锁的实现代码，除非你真的看过源码，或者有和锁相关的项目经验；</li><li>我们不需要创造，我们只需要模仿 Java 锁中现有的 API 进行重写即可。</li></ol><p>如果你看过源码，这道题真的很简单，你可以挑选一个你熟悉的锁进行模仿。</p><p>在锁章节中我们之前说的都是排它锁，这小节我们以共享锁作为案列，自定义一个共享锁。</p><h4 id="6-6-1-需求"><a href="#6-6-1-需求" class="headerlink" title="6.6.1-需求"></a>6.6.1-需求</h4><p>一般自定义锁的时候，我们都是根据需求来进行定义的，不可能凭空定义出锁来，说到共享锁，大家可能会想到很多场景，比如说对于共享资源的读锁可以是共享的，比如对于数据库链接的共享访问，比如对于 Socket 服务端的链接数是可以共享的，场景有很多，我们选择共享访问数据库链接这个场景来定义一个锁。</p><h4 id="6-6-2-详细设计"><a href="#6-6-2-详细设计" class="headerlink" title="6.6.2-详细设计"></a>6.6.2-详细设计</h4><p>假定(以下设想都为假定)我们的数据库是单机 mysql，只能承受 10 个链接，创建数据库链接时，我们是通过最原始 JDBC 的方式，我们用一个接口把用 JDBC 创建链接的过程进行了封装，这个接口我们命名为：创建链接接口。</p><p>共享访问数据库链接的整体要求如下：所有请求加在一起的 mysql 链接数，最大不能超过 10（包含 10），一旦超过 10，直接报错。</p><p>在这个背景下，我们进行了下图的设计：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%81%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1.jpeg" alt="自定义锁详细设计"></p><p>这个设计最最关键的地方，就是我们通过能否获得锁，来决定是否可以得到 mysql 链接，如果能获得锁，那么就能得到链接，否则直接报错。</p><p>接着我们一起来看下落地的代码：</p><h5 id="1-定义锁"><a href="#1-定义锁" class="headerlink" title="1.定义锁"></a>1.定义锁</h5><p>首先我们需要定义一个锁出来，定义时需要有两个元素：</p><ol><li>锁的定义：同步器 Sync；</li><li>锁对外提供的加锁和解锁的方法。</li></ol><p>共享锁的代码实现如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 共享不公平锁</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShareLock</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 同步器</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> Sync sync<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 用于确保不能超过最大值</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> maxCount<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 初始化时给同步器 sync 赋值   * count 代表可以获得共享锁的最大值   */</span>  <span class="token keyword">public</span> <span class="token function">ShareLock</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    maxCount <span class="token operator">=</span> count<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * 获得锁   * @return true 表示成功获得锁，false 表示失败   */</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">acquireByShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * 释放锁   * @return true 表示成功释放锁，false 表示失败   */</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">unLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><p>从上述代码中可以看出，加锁和释放锁的实现，都依靠同步器 Sync 的底层实现。</p><p>唯一需要注意的是，锁需要规定好 API 的规范，主要是两方面：</p><ol><li>API 需要什么，就是锁在初始化的时候，你需要传哪些参数给我，在 ShareLock 初始化时，需要传最大可共享锁的数目；</li><li>需要定义自身的能力，即定义每个方法的入参和出参。在 ShareLock 的实现中，加锁和释放锁的入参都没有，是方法里面写死的 1，表示每次方法执行，只能加锁一次或释放锁一次，出参是布尔值，true 表示加锁或释放锁成功，false 表示失败，底层使用的都是 Sync 非公平锁。</li></ol><p>以上这种思考方式是有方法论的，就是我们在思考一个问题时，可以从两个方面出发：API 是什么？API 有什么能力？</p><h5 id="2-定义同步器-Sync"><a href="#2-定义同步器-Sync" class="headerlink" title="2.定义同步器 Sync"></a>2.定义同步器 Sync</h5><p>Sync 直接继承 AQS ，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 表示最多有 count 个共享锁可以获得</span>  <span class="token keyword">public</span> <span class="token function">Sync</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setState</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 获得 i 个锁</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">acquireByShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 自旋保证 CAS 一定可以成功</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">int</span> state <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 如果没有锁可以获得，直接返回 false</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>state <span class="token operator">&lt;=</span><span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">int</span> expectState <span class="token operator">=</span> state <span class="token operator">-</span> i<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 如果要得到的锁不够了，直接返回 false</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>expectState <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// CAS 尝试得到锁,CAS 成功获得锁，失败继续 for 循环</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span>expectState<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 释放 i 个锁</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>arg<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">int</span> state <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> expectState <span class="token operator">=</span> state <span class="token operator">+</span> arg<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 超过了 int 的最大值，或者 expectState 超过了我们的最大预期</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>expectState <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> expectState <span class="token operator">></span> maxCount<span class="token punctuation">)</span><span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"state 超过预期，当前 state is {},计算出的 state is {}"</span><span class="token punctuation">,</span>state        <span class="token punctuation">,</span>expectState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> expectState<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>整个代码比较清晰，我们需要注意的是：</p><ol><li>边界的判断，比如入参是否非法，释放锁时，会不会出现预期的 state 非法等边界问题，对于此类问题我们都需要加以判断，体现出思维的严谨性；</li><li>加锁和释放锁，需要用 for 自旋 + CAS 的形式，来保证当并发加锁或释放锁时，可以重试成功。写 for 自旋时，我们需要注意在适当的时机要 return，不要造成死循环，CAS 的方法 AQS 已经提供了，不要自己写，我们自己写的 CAS 方法是无法保证原子性的。</li></ol><h5 id="3-通过能否获得锁来决定能否得到链接"><a href="#3-通过能否获得锁来决定能否得到链接" class="headerlink" title="3.通过能否获得锁来决定能否得到链接"></a>3.通过能否获得锁来决定能否得到链接</h5><p>锁定义好了，我们需要把锁和获取 Mysql 链接结合起来，我们写了一个 Mysql 链接的工具类，叫做 MysqlConnection，其主要负责两大功能：</p><ol><li>通过 JDBC 建立和 Mysql 的链接；</li><li>结合锁，来防止请求过大时，Mysql 的总链接数不能超过 10 个。</li></ol><p>首先我们看下 MysqlConnection 初始化的代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MysqlConnection</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> ShareLock lock<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// maxConnectionSize 表示最大链接数</span>  <span class="token keyword">public</span> <span class="token function">MysqlConnection</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxConnectionSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShareLock</span><span class="token punctuation">(</span>maxConnectionSize<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们可以看到，在初始化时，需要制定最大的链接数是多少，然后把这个数值传递给锁，因为最大的链接数就是 ShareLock 锁的 state 值。</p><p>接着为了完成 1，我们写了一个 private 的方法：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 得到一个 mysql 链接，底层实现省略</span><span class="token keyword">private</span> Connection <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>然后我们实现 2，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对外获取 mysql 链接的接口</span><span class="token comment" spellcheck="true">// 这里不用try finally 的结构，获得锁实现底层不会有异常</span><span class="token comment" spellcheck="true">// 即使出现未知异常，也无需释放锁</span><span class="token keyword">public</span> Connection <span class="token function">getLimitConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 对外释放 mysql 链接的接口</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">releaseLimitConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> lock<span class="token punctuation">.</span><span class="token function">unLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>逻辑也比较简单，加锁时，如果获得了锁，就能返回 Mysql 的链接，释放锁时，在链接关闭成功之后，调用 releaseLimitConnection 方法即可，此方法会把锁的 state 状态加一，表示链接被释放了。</p><p>以上步骤，针对 Mysql 链接限制的场景锁就完成了。</p><h4 id="6-6-3-测试"><a href="#6-6-3-测试" class="headerlink" title="6.6.3-测试"></a>6.6.3-测试</h4><p>锁写好了，接着我们来测试一下，我们写了一个测试的 demo，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"模仿开始获得 mysql 链接"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  MysqlConnection mysqlConnection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MysqlConnection</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"初始化 Mysql 链接最大只能获取 10 个"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">12</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> mysqlConnection<span class="token punctuation">.</span><span class="token function">getLimitConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"获得第{}个数据库链接成功"</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"获得第{}个数据库链接失败：数据库连接池已满"</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"模仿开始释放 mysql 链接"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">12</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>mysqlConnection<span class="token punctuation">.</span><span class="token function">releaseLimitConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"释放第{}个数据库链接成功"</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"释放第{}个数据库链接失败"</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"模仿结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>以上代码逻辑如下：</p><ol><li>获得 Mysql 链接逻辑：for 循环获取链接，1<del>10 都可以获得链接，11</del>12 获取不到链接，因为链接被用完了；</li><li>释放锁逻辑：for 循环释放链接，1<del>10 都可以释放成功，11</del>12 释放失败。</li></ol><p>我们看下运行结果，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%81%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpeg" alt="自定义锁测试结果"></p><p>从运行的结果，可以看出，我们实现的 ShareLock 锁已经完成了 Mysql 链接共享的场景了。</p><h4 id="6-6-4-总结"><a href="#6-6-4-总结" class="headerlink" title="6.6.4-总结"></a>6.6.4-总结</h4><p>同学们阅读到这里不知道有没有两点感受：</p><ol><li>重写锁真的很简单，最关键的是要和场景完美贴合，能满足业务场景的锁才是好锁；</li><li>锁其实只是来满足业务场景的，本质都是 AQS，所以只要 AQS 学会了，在了解清楚场景的情况下，重写锁都不难的。</li></ol><p>锁章节最核心的就是 AQS 源码解析的两章，只要我们把 AQS 弄懂了，其余锁的实现，只要稍微看下源码实现，几乎马上就能知道其底层实现的原理，大多数都是通过操作 state 来完成不同的场景需求，所以还是建议大家多看 AQS 源码，多 debug AQS 源码，只要 AQS 弄清楚了，锁都很简单。</p><h2 id="7-线程池"><a href="#7-线程池" class="headerlink" title="7-线程池"></a>7-线程池</h2><h3 id="7-1-ThreadPoolExecutor-源码解析"><a href="#7-1-ThreadPoolExecutor-源码解析" class="headerlink" title="7.1-ThreadPoolExecutor 源码解析"></a>7.1-ThreadPoolExecutor 源码解析</h3><p>线程池我们在工作中经常会用到。在请求量大时，使用线程池，可以充分利用机器资源，增加请求的处理速度，本章节我们就和大家一起来学习线程池。</p><p>本章的基础是第四章队列和第五章线程，没有看过这两章的同学可以先看一看。</p><p>本章的顺序，先说源码，弄懂原理，接着看一看面试题，最后看看实际工作中是如何运用线程池的。</p><h4 id="7-1-1-整体架构"><a href="#7-1-1-整体架构" class="headerlink" title="7.1.1-整体架构"></a>7.1.1-整体架构</h4><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.jpeg" alt="线程池的整体架构"></p><p>本小节主要就按照这个图来进行 ThreadPoolExecutor 源码的讲解，大家在看各个方法时，可以结合这个图一起看。</p><h5 id="1-类结构"><a href="#1-类结构" class="headerlink" title="1.类结构"></a>1.类结构</h5><p>首先我们来看一下 ThreadPoolExecutor 的类结构，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ThreadPoolExecutor%E7%B1%BB%E7%BB%93%E6%9E%84.jpeg" alt="ThreadPoolExecutor类结构"></p><p>从上图中，我们从命名上来看，都有 Executor 的共同命名，Executor 的中文意思为执行的意思，表示对提供的任务进行执行，我们在第五章线程中学习到了几种任务：Runnable、Callable、FutureTask，之前我们都是使用 Thread 来执行这些任务的，除了 Thread，这些 Executor 命名的类和接口也是可以执行这几种任务的，接下来我们大概的看下这几个类的大概含义：</p><ol><li><p>Executor：定义 execute 方法来执行任务，入参是 Runnable，无出参：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Executor.jpeg" alt="Executor"></p></li><li><p>ExecutorService：Executor 的功能太弱，ExecutorService 丰富了对任务的执行和管理的功能，主要代码如下：</p></li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 关闭，不会接受新的任务，也不会等待未完成的任务</span><span class="token comment" spellcheck="true">// 如果需要等待未完成的任务，可以使用 awaitTermination 方法</span><span class="token keyword">void</span> <span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// executor 是否已经关闭了，返回值 true 表示已关闭</span><span class="token keyword">boolean</span> <span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 所有的任务是否都已经终止，是的话，返回 true</span><span class="token keyword">boolean</span> <span class="token function">isTerminated</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 在超时时间内，等待剩余的任务终止</span><span class="token keyword">boolean</span> <span class="token function">awaitTermination</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 提交有返回值的任务，使用 get 方法可以阻塞等待任务的执行结果返回</span><span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 提交没有返回值的任务，如果使用 get 方法的话，任务执行完之后得到的是 null 值</span>Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 给定任务集合，返回已经执行完成的 Future 集合，每个返回的 Future 都是 isDone = true 的状态</span><span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>Future<span class="token operator">&lt;</span>T<span class="token operator">>></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 给定任务中有一个执行成功就返回，如果抛异常，其余未完成的任务将被取消</span><span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">invokeAny</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>T<span class="token operator">>></span> tasks<span class="token punctuation">)</span>    <span class="token keyword">throws</span> InterruptedException<span class="token punctuation">,</span> ExecutionException<span class="token punctuation">;</span></code></pre><ol><li>AbstractExecutorService 是一个抽象类，封装了 Executor 的很多通用功能，比如：</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 把 Runnable 转化成 RunnableFuture</span><span class="token comment" spellcheck="true">// RunnableFuture 是一个接口，实现了 Runnable 和 Future</span><span class="token comment" spellcheck="true">// FutureTask 是 RunnableFuture 的实现类，主要是对任务进行各种管理</span><span class="token comment" spellcheck="true">// Runnable + Future => RunnableFuture => FutureTask</span><span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>Runnable runnable<span class="token punctuation">,</span> T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>runnable<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">protected</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> callable<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 提交无返回值的任务</span><span class="token keyword">public</span> Future<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ftask 其实是 FutureTask</span>    RunnableFuture<span class="token operator">&lt;</span>Void<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 提交有返回值的任务</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ftask 其实是 FutureTask</span>    RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>有几个点需要注意下：</p><ol><li>FutureTask 我们在第五章有说，其本身就是一个任务，而且具备对任务管理的功能，比如可以通过 get 方法拿到任务的执行结果；</li><li>submit 方法是我们平时使用线程池时提交任务的方法，支持 Runable 和 Callable 两种任务的提交，方法中 execute 方法是其子类 ThreadPoolExecutor 实现的，不管是那种任务入参，execute 方法最终执行的任务都是 FutureTask；</li><li>ThreadPoolExecutor 继承了 AbstractExecutorService 抽象类，具备以上三个类的所有功能。</li></ol><h5 id="2-类注释-1"><a href="#2-类注释-1" class="headerlink" title="2.类注释"></a>2.类注释</h5><p>ThreadPoolExecutor 的类注释有很多，我们选取关键的注释如下：</p><ol><li>ExecutorService 使用线程池中的线程执行提交的任务，线程池我们可以使用 Executors 进行配置；</li><li>线程池解决两个问题：1：通过减少任务间的调度开销 (主要是通过线程池中的线程被重复使用的方式)，来提高大量任务时的执行性能；2：提供了一种方式来管理线程和消费，维护基本数据统计等工作，比如统计已完成的任务数；</li><li>Executors 为常用的场景设定了可直接初始化线程池的方法，比如 Executors#newCachedThreadPool 无界的线程池，并且可以自动回收；Executors#newFixedThreadPool 固定大小线程池；Executors#newSingleThreadExecutor 单个线程的线程池；</li><li>为了在各种上下文中使用线程池，线程池提供可供扩展的参数设置：1：coreSize：当新任务提交时，发现运行的线程数小于 coreSize，一个新的线程将被创建，即使这时候其它工作线程是空闲的，可以通过 getCorePoolSize 方法获得 coreSize；2：maxSize: 当任务提交时，coreSize &lt; 运行线程数 &lt;= maxSize，但队列没有满时，任务提交到队列中，如果队列满了，在 maxSize 允许的范围内新建线程；</li><li>一般来说，coreSize 和 maxSize 在线程池初始化时就已经设定了，但我们也可以通过 setCorePoolSize、setMaximumPoolSize 方法动态的修改这两个值；</li><li>默认的，core threads 需要到任务提交后才创建的，但我们可以分别使用 prestartCoreThread、prestartAllCoreThreads 两个方法来提前创建一个、所有的 core threads；</li><li>新的线程被默认 ThreadFactory 创建时，优先级会被限制成 NORM_PRIORITY，默认会被设置成非守护线程，这个和新建线程的继承是不同的；</li><li>Keep-alive times 参数的作用：1：如果当前线程池中有超过 coreSize 的线程；2：并且线程空闲的时间超过 keepAliveTime，当前线程就会被回收，这样可以避免线程没有被使用时的资源浪费；</li><li>通过 setKeepAliveTime 方法可以动态的设置 keepAliveTime 的值；</li><li>如果设置 allowCoreThreadTimeOut 为 ture 的话，core thread 空闲时间超过 keepAliveTime 的话，也会被回收；</li><li>线程池新建时，有多种队列可供选择，比如：1：SynchronousQueue，为了避免任务被拒绝，要求线程池的 maxSize 无界，缺点是当任务提交的速度超过消费的速度时，可能出现无限制的线程增长；2：LinkedBlockingQueue，无界队列，未消费的任务可以在队列中等待；3：ArrayBlockingQueue，有界队列，可以防止资源被耗尽；</li><li>队列的维护：提供了 getQueue () 方法方便我们进行监控和调试，严禁用于其他目的，remove 和 purge 两个方法可以对队列中的元素进行操作；</li><li>在 Executor 已经关闭或对最大线程和最大队列都使用饱和时，可以使用 RejectedExecutionHandler 类进行异常捕捉，有如下四种处理策略：ThreadPoolExecutor.AbortPolicy、ThreadPoolExecutor.DiscardPolicy、ThreadPoolExecutor.CallerRunsPolicy、ThreadPoolExecutor.DiscardOldestPolicy；</li><li>线程池提供了很多可供扩展的钩子函数，比如有：1：提供在每个任务执行之前 beforeExecute 和执行之后 afterExecute 的钩子方法，主要用于操作执行环境，比如初始化 ThreadLocals、收集统计数据、添加日志条目等；2: 如果在执行器执行完成之后想干一些事情，可以实现 terminated 方法，如果钩子方法执行时发生异常，工作线程可能会失败并立即终止。</li></ol><p>可以看到 ThreadPoolExecutor 的注释是非常多的，也是非常重要的，我们很多面试的题目，在注释上都能找到答案。</p><h5 id="3-ThreadPoolExecutor-重要属性"><a href="#3-ThreadPoolExecutor-重要属性" class="headerlink" title="3.ThreadPoolExecutor 重要属性"></a>3.ThreadPoolExecutor 重要属性</h5><p>接下来我们来看一看 ThreadPoolExecutor 都有哪些重要属性，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//ctl 线程池状态控制字段，由两部分组成：</span><span class="token comment" spellcheck="true">//1:workerCount  wc 工作线程数，我们限制 workerCount 最大到(2^29)-1，大概 5 亿个线程</span><span class="token comment" spellcheck="true">//2:runState rs 线程池的状态，提供了生命周期的控制，源码中有很多关于状态的校验，状态枚举如下：</span><span class="token comment" spellcheck="true">//RUNNING（-536870912）：接受新任务或者处理队列里的任务。</span><span class="token comment" spellcheck="true">//SHUTDOWN（0）：不接受新任务，但仍在处理已经在队列里面的任务。</span><span class="token comment" spellcheck="true">//STOP（-536870912）：不接受新任务，也不处理队列中的任务，对正在执行的任务进行中断。</span><span class="token comment" spellcheck="true">//TIDYING（1073741824）： 所以任务都被中断，workerCount 是 0，整理状态</span><span class="token comment" spellcheck="true">//TERMINATED（1610612736）： terminated() 已经完成的时候</span><span class="token comment" spellcheck="true">//runState 之间的转变过程：</span><span class="token comment" spellcheck="true">//RUNNING -> SHUTDOWN：调用 shudown(),finalize()</span><span class="token comment" spellcheck="true">//(RUNNING or SHUTDOWN) -> STOP：调用shutdownNow()</span><span class="token comment" spellcheck="true">//SHUTDOWN -> TIDYING -> workerCount ==0</span><span class="token comment" spellcheck="true">//STOP -> TIDYING -> workerCount ==0</span><span class="token comment" spellcheck="true">//TIDYING -> TERMINATED -> terminated() 执行完成之后</span><span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> COUNT_BITS <span class="token operator">=</span> Integer<span class="token punctuation">.</span>SIZE <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 29</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CAPACITY   <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// =(2^29)-1=536870911</span><span class="token comment" spellcheck="true">// Packing and unpacking ctl</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">ctlOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> rs<span class="token punctuation">,</span> <span class="token keyword">int</span> wc<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> rs <span class="token operator">|</span> wc<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span>     <span class="token punctuation">{</span> <span class="token keyword">return</span> c <span class="token operator">&amp;</span> <span class="token operator">~</span>CAPACITY<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// runState is stored in the high-order bits</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//-536870912</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//0</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//-536870912</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1073741824</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//1610612736</span><span class="token comment" spellcheck="true">// 已完成任务的计数</span><span class="token keyword">volatile</span> <span class="token keyword">long</span> completedTasks<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 线程池最大容量</span><span class="token keyword">private</span> <span class="token keyword">int</span> largestPoolSize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 已经完成的任务数</span><span class="token keyword">private</span> <span class="token keyword">long</span> completedTaskCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 用户可控制的参数都是 volatile 修饰的</span><span class="token comment" spellcheck="true">// 可以使用 threadFactory 创建 thread</span><span class="token comment" spellcheck="true">// 创建失败一般不抛出异常，只有在 OutOfMemoryError 时候才会</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> ThreadFactory threadFactory<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 饱和或者运行中拒绝任务的 handler 处理类</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> RejectedExecutionHandler handler<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 线程存活时间设置</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设置 true 的话，核心线程空闲 keepAliveTime 时间后，也会被回收</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> allowCoreThreadTimeOut<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// coreSize</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> corePoolSize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// maxSize 最大限制 (2^29)-1</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 默认的拒绝策略</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> RejectedExecutionHandler defaultHandler <span class="token operator">=</span>    <span class="token keyword">new</span> <span class="token class-name">AbortPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 队列会 hold 住任务，并且利用队列的阻塞的特性，来保持线程的存活周期</span><span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 大多数情况下是控制对 workers 的访问权限</span><span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> Condition termination <span class="token operator">=</span> mainLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 包含线程池中所有的工作线程</span><span class="token keyword">private</span> <span class="token keyword">final</span> HashSet<span class="token operator">&lt;</span>Worker<span class="token operator">></span> workers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>Worker<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>属性也是非常多，为了方便理解线程池的状态扭转，画了一个图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81%E6%89%AD%E8%BD%AC.jpeg" alt="线程池的状态扭转"></p><p>Worker 我们可以理解成线程池中任务运行的最小单元，Worker 的大致结构如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 线程池中任务执行的最小单元</span><span class="token comment" spellcheck="true">// Worker 继承 AQS，具有锁功能</span><span class="token comment" spellcheck="true">// Worker 实现 Runnable，本身是一个可执行的任务</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Worker</span>    <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span>    <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 任务运行的线程</span>    <span class="token keyword">final</span> Thread thread<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 需要执行的任务</span>    Runnable firstTask<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 非常巧妙的设计,Worker本身是个 Runnable,把自己作为任务传递给 thread</span>    <span class="token comment" spellcheck="true">// 内部有个属性又设置了 Runnable</span>    <span class="token function">Worker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// inhibit interrupts until runWorker</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>firstTask <span class="token operator">=</span> firstTask<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把 Worker 自己作为 thread 运行的任务</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thread <span class="token operator">=</span> <span class="token function">getThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">/** Worker 本身是 Runnable，run 方法是 Worker 执行的入口， runWorker 是外部的方法 */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6138294804551838833L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Lock methods</span>    <span class="token comment" spellcheck="true">// 0 代表没有锁住，1 代表锁住</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 尝试加锁，CAS 赋值为 1，表示锁住</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 尝试释放锁，释放锁没有 CAS 校验，可以任意的释放锁</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> unused<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">tryLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">interruptIfStarted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">=</span> thread<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                t<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SecurityException</span> ignore<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>理解 Worker 非常关键，主要有以下几点：</p><ol><li>Worker 很像是任务的代理，在线程池中，最小的执行单位就是 Worker，所以 Worker 实现了 Runnable 接口，实现了 run 方法；</li><li>在 Worker 初始化时 this.thread = getThreadFactory ().newThread (this) 这行代码比较关键，它把当前 Worker 作为线程的构造器入参，我们在后续的实现中会发现这样的代码：Thread t = w.thread;t.start ()，此时的 w 是 Worker 的引用申明，此处 t.start 实际上执行的就是 Worker 的 run 方法；</li><li>Worker 本身也实现了 AQS，所以其本身也是一个锁，其在执行任务的时候，会锁住自己，任务执行完成之后，会释放自己。</li></ol><h4 id="7-1-2-线程池的任务提交"><a href="#7-1-2-线程池的任务提交" class="headerlink" title="7.1.2-线程池的任务提交"></a>7.1.2-线程池的任务提交</h4><p>线程池的任务提交从 submit 方法说起，submit 方法是 AbstractExecutorService 抽象类定义的，主要做了两件事情：</p><ol><li>把 Runnable 和 Callable 都转化成 FutureTask，这个我们之前看过源码了；</li><li>使用 execute 方法执行 FutureTask。</li></ol><p>execute 方法是 ThreadPoolExecutor 中的方法，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 工作的线程小于核心线程数，创建新的线程，成功返回，失败不抛异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 线程池状态可能发生变化</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 工作的线程大于等于核心线程数，或者新建线程失败</span>    <span class="token comment" spellcheck="true">// 线程池状态正常，并且可以入队的话，尝试入队列</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果线程池状态异常 尝试从队列中移除任务，可以移除的话就拒绝掉任务</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 发现可运行的线程数是 0，就初始化一个线程，这里是个极限情况，入队的时候，突然发现</span>        <span class="token comment" spellcheck="true">// 可用线程都被回收了</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// Runnable是空的，不会影响新增线程，但是线程在 start 的时候不会运行</span>            <span class="token comment" spellcheck="true">// Thread.run() 里面有判断</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 队列满了，开启线程到 maxSize，如果失败直接拒绝,</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>execute 方法执行的就是整体架构图的左半边的逻辑，其中多次调用 addWorker 方法，addWorker 方法的作用是新建一个 Worker，我们一起来看下源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 结合线程池的情况看是否可以添加新的 worker</span><span class="token comment" spellcheck="true">// firstTask 不为空可以直接执行，为空执行不了，Thread.run()方法有判断，Runnable为空不执行</span><span class="token comment" spellcheck="true">// core 为 true 表示线程最大新增个数是 coresize，false 表示最大新增个数是 maxsize</span><span class="token comment" spellcheck="true">// 返回 true 代表成功，false 失败</span><span class="token comment" spellcheck="true">// break retry 跳到retry处，且不再进入循环</span><span class="token comment" spellcheck="true">// continue retry 跳到retry处，且再次进入循环</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>Runnable firstTask<span class="token punctuation">,</span> <span class="token keyword">boolean</span> core<span class="token punctuation">)</span> <span class="token punctuation">{</span>    retry<span class="token operator">:</span>    <span class="token comment" spellcheck="true">// 先是各种状态的校验</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Check if queue empty only if necessary.</span>        <span class="token comment" spellcheck="true">// rs >= SHUTDOWN 说明线程池状态不正常</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>            <span class="token operator">!</span> <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span>               firstTask <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>               <span class="token operator">!</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 工作中的线程数大于等于容量，或者大于等于 coreSize or maxSize</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>wc <span class="token operator">>=</span> CAPACITY <span class="token operator">||</span>                wc <span class="token operator">>=</span> <span class="token punctuation">(</span>core <span class="token operator">?</span> corePoolSize <span class="token operator">:</span> maximumPoolSize<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndIncrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// break 结束 retry 的 for 循环</span>                <span class="token keyword">break</span> retry<span class="token punctuation">;</span>            c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Re-read ctl</span>            <span class="token comment" spellcheck="true">// 线程池状态被更改</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> rs<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 跳转到retry位置</span>                <span class="token keyword">continue</span> retry<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// else CAS failed due to workerCount change; retry inner loop</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> workerStarted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> workerAdded <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Worker w <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 巧妙的设计，Worker 本身是个 Runnable.</span>        <span class="token comment" spellcheck="true">// 在初始化的过程中，会把 worker 丢给 thread 去初始化</span>        w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>firstTask<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Thread t <span class="token operator">=</span> w<span class="token punctuation">.</span>thread<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> ReentrantLock mainLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mainLock<span class="token punctuation">;</span>            mainLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Recheck while holding lock.</span>                <span class="token comment" spellcheck="true">// Back out on ThreadFactory failure or if</span>                <span class="token comment" spellcheck="true">// shut down before lock acquired.</span>                <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">&lt;</span> SHUTDOWN <span class="token operator">||</span>                    <span class="token punctuation">(</span>rs <span class="token operator">==</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> firstTask <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// precheck that t is startable</span>                        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalThreadStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    workers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">int</span> s <span class="token operator">=</span> workers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> largestPoolSize<span class="token punctuation">)</span>                        largestPoolSize <span class="token operator">=</span> s<span class="token punctuation">;</span>                    workerAdded <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                mainLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>workerAdded<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 启动线程，实际上去执行 Worker.run 方法</span>                t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                workerStarted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> workerStarted<span class="token punctuation">)</span>            <span class="token function">addWorkerFailed</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> workerStarted<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>addWorker 方法首先是执行了一堆校验，然后使用 new Worker (firstTask) 新建了 Worker，最后使用 t.start () 执行 Worker，上文我们说了 Worker 在初始化时的关键代码：<code>this.thread = getThreadFactory ().newThread (this)，Worker（this） 是作为新建线程的构造器入参的，所以 t.start ()</code> 会执行到 Worker 的 run 方法上，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">runWorker</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>runWorker 方法是非常重要的方法，我们一起看下源码实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runWorker</span><span class="token punctuation">(</span>Worker w<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread wt <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Runnable task <span class="token operator">=</span> w<span class="token punctuation">.</span>firstTask<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//帮助gc回收</span>    w<span class="token punctuation">.</span>firstTask <span class="token operator">=</span> null<span class="token punctuation">;</span>    w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// allow interrupts</span>    <span class="token keyword">boolean</span> completedAbruptly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// task 为空的情况：</span>        <span class="token comment" spellcheck="true">// 1：任务入队列了，极限情况下，发现没有运行的线程，于是新增一个线程；</span>        <span class="token comment" spellcheck="true">// 2：线程执行完任务执行，再次回到 while 循环。</span>        <span class="token comment" spellcheck="true">// 如果 task 为空，会使用 getTask 方法阻塞从队列中拿数据，如果拿不到数据，会阻塞住</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>task <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>task <span class="token operator">=</span> <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//锁住 worker</span>            w<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 线程池 stop 中,但是线程没有到达中断状态，帮助线程中断</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                  <span class="token function">runStateAtLeast</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> STOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token operator">!</span>wt<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                wt<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//执行 before 钩子函数</span>                <span class="token function">beforeExecute</span><span class="token punctuation">(</span>wt<span class="token punctuation">,</span> task<span class="token punctuation">)</span><span class="token punctuation">;</span>                Throwable thrown <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//同步执行任务</span>                    task<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Error</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> x<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    thrown <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//执行 after 钩子函数,如果这里抛出异常，会覆盖 catch 的异常</span>                    <span class="token comment" spellcheck="true">//所以这里异常最好不要抛出来</span>                    <span class="token function">afterExecute</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> thrown<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//任务执行完成，计算解锁</span>                task <span class="token operator">=</span> null<span class="token punctuation">;</span>                w<span class="token punctuation">.</span>completedTasks<span class="token operator">++</span><span class="token punctuation">;</span>                w<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        completedAbruptly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//做一些抛出异常的善后工作</span>        <span class="token function">processWorkerExit</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> completedAbruptly<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个方法执行的逻辑是架构图中的标红部分：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4.jpeg" alt="线程池的任务提交"></p><p>我们聚焦一下这行代码：task.run () 此时的 task 是什么呢？此时的 task 是 FutureTask 类，所以我们继续追索到 FutureTask 类的 run 方法的源码，如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * run 方法可以直接被调用 * 也可以由线程池进行调用 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 状态不是任务创建，或者当前任务已经有线程在执行了</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">!=</span> NEW <span class="token operator">||</span>        <span class="token operator">!</span>UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> runnerOffset<span class="token punctuation">,</span>                                     null<span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> c <span class="token operator">=</span> callable<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Callable 不为空，并且已经初始化完成</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> state <span class="token operator">==</span> NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V result<span class="token punctuation">;</span>            <span class="token keyword">boolean</span> ran<span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 调用执行</span>                result <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                ran <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> null<span class="token punctuation">;</span>                ran <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token function">setException</span><span class="token punctuation">(</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 给 outcome 赋值</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ran<span class="token punctuation">)</span>                <span class="token function">set</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// runner must be non-null until state is settled to</span>        <span class="token comment" spellcheck="true">// prevent concurrent calls to run()</span>        runner <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// state must be re-read after nulling runner to prevent</span>        <span class="token comment" spellcheck="true">// leaked interrupts</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> state<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> INTERRUPTING<span class="token punctuation">)</span>            <span class="token function">handlePossibleCancellationInterrupt</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>run 方法中有两行关键代码：</p><ol><li>result = c.call () 这行代码是真正执行业务代码的地方；</li><li>set (result) 这里是给 outCome 赋值，这样 Future.get 方法执行时，就可以从 outCome 中拿值，这个我们在《Future、ExecutorService 源码解析》章节中都有说到。</li></ol><p>至此，submit 方法就执行完成了，整体流程比较复杂，我们画一个图释义一下任务提交执行的流程：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E6%B5%81%E7%A8%8B.jpeg" alt="任务提交执行的流程"></p><h4 id="7-1-3-线程执行完任务之后都在干啥"><a href="#7-1-3-线程执行完任务之后都在干啥" class="headerlink" title="7.1.3-线程执行完任务之后都在干啥"></a>7.1.3-线程执行完任务之后都在干啥</h4><p>线程执行完任务之后，是消亡还是干什么呢？这是一个值得思考的问题，我们可以从源码中找到答案，从 ThreadPoolExecutor 的 runWorker 方法中，不知道有没有同学注意到一个 while 循环，我们截图释义一下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E4%BB%BB%E5%8A%A1%E4%B9%8B%E5%90%8E.jpeg" alt="线程执行完任务之后"></p><p>这个 while 循环有个 getTask 方法，getTask 的主要作用是阻塞从队列中拿任务出来，如果队列中有任务，那么就可以拿出来执行，如果队列中没有任务，这个线程会一直阻塞到有任务为止（或者超时阻塞），下面我们一起来看下 getTask 方法，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 从阻塞队列中拿任务</span><span class="token keyword">private</span> Runnable <span class="token function">getTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Did the last poll() time out?</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rs <span class="token operator">=</span> <span class="token function">runStateOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//线程池关闭 &amp;&amp; 队列为空，不需要在运行了，直接放回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> SHUTDOWN <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>rs <span class="token operator">>=</span> STOP <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">decrementWorkerCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> wc <span class="token operator">=</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Are workers subject to culling?</span>        <span class="token comment" spellcheck="true">// true  运行的线程数大于 coreSize || 核心线程也可以被灭亡</span>        <span class="token keyword">boolean</span> timed <span class="token operator">=</span> allowCoreThreadTimeOut <span class="token operator">||</span> wc <span class="token operator">></span> corePoolSize<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 队列以 LinkedBlockingQueue 为例，timedOut 为 true 的话说明下面 poll 方法执行返回的是 null</span>        <span class="token comment" spellcheck="true">// 说明在等待 keepAliveTime 时间后，队列中仍然没有数据</span>        <span class="token comment" spellcheck="true">// 说明此线程已经空闲了 keepAliveTime 了</span>        <span class="token comment" spellcheck="true">// 再加上 wc > 1 || workQueue.isEmpty() 的判断</span>        <span class="token comment" spellcheck="true">// 所以使用 compareAndDecrementWorkerCount 方法使线程池数量减少 1</span>        <span class="token comment" spellcheck="true">// 并且直接 return，return 之后，此空闲的线程会自动被回收</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>wc <span class="token operator">></span> maximumPoolSize <span class="token operator">||</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> timedOut<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>wc <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">||</span> workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndDecrementWorkerCount</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 从队列中阻塞拿 worker</span>            Runnable r <span class="token operator">=</span> timed <span class="token operator">?</span>                workQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">)</span> <span class="token operator">:</span>                workQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置已超时，说明此时队列没有数据</span>            timedOut <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> retry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            timedOut <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>代码有两处关键：</p><ol><li>使用队列的 poll 或 take 方法从队列中拿数据，根据队列的特性，队列中有任务可以返回，队列中无任务会阻塞；</li><li>方法中的第二个 if 判断，说的是在满足一定条件下（条件看注释），会减少空闲的线程，减少的手段是使可用线程数减一，并且直接 return，直接 return 后，该线程就执行结束了，JVM 会自动回收该线程。</li></ol><h4 id="7-1-4-总结"><a href="#7-1-4-总结" class="headerlink" title="7.1.4-总结"></a>7.1.4-总结</h4><p>本章节主要以 submit 方法为主线阐述了 ThreadPoolExecutor 的整体架构和底层源码，只要有队列和线程的基础知识的话，理解 ThreadPoolExecutor 并不复杂。ThreadPoolExecutor 还有一些其他的源码，比如说拒绝请求的策略、得到各种属性、设置各种属性等等方法，这些方法都比较简单，感兴趣的同学可以自己去看一看。</p><h3 id="7-2-线程池源码面试题"><a href="#7-2-线程池源码面试题" class="headerlink" title="7.2-线程池源码面试题"></a>7.2-线程池源码面试题</h3><p>线程池在日常面试中占比很大，主要是因为线程池内容涉及的知识点较广，比如涉及到队列、线程、锁等等，所以很多面试官喜欢把线程池作为问题的起点，然后延伸到其它内容，由于我们专栏已经说过队列、线程、锁面试题了，所以本章面试题还是以线程池为主。</p><h5 id="1-说说你对线程池的理解？"><a href="#1-说说你对线程池的理解？" class="headerlink" title="1.说说你对线程池的理解？"></a>1.说说你对线程池的理解？</h5><p>答：答题思路从大到小，从全面到局部，总的可以这么说，线程池结合了锁、线程、队列等元素，在请求量较大的环境下，可以多线程的处理请求，充分的利用了系统的资源，提高了处理请求的速度，细节可以从以下几个方面阐述：</p><ol><li>ThreadPoolExecutor 类结构；</li><li>ThreadPoolExecutor coreSize、maxSize 等重要属性；</li><li>Worker 的重要作用；</li><li>submit 的整个过程。</li></ol><p>通过以上总分的描述，应该可以说清楚对线程池的理解了，如果是面对面面试的话，可以边说边画出线程池的整体架构图（见《ThreadPoolExecutor 源码解析》）。</p><h5 id="2-hreadPoolExecutor、Executor、ExecutorService、Runnable、Callable、FutureTask-之间的关系？"><a href="#2-hreadPoolExecutor、Executor、ExecutorService、Runnable、Callable、FutureTask-之间的关系？" class="headerlink" title="2.hreadPoolExecutor、Executor、ExecutorService、Runnable、Callable、FutureTask 之间的关系？"></a>2.hreadPoolExecutor、Executor、ExecutorService、Runnable、Callable、FutureTask 之间的关系？</h5><p>答：以上 6 个类可以分成两大类：一种是定义任务类，一种是执行任务类。</p><ol><li>定义任务类：Runnable、Callable、FutureTask。Runnable 是定义无返回值的任务，Callable 是定义有返回值的任务，FutureTask 是对 Runnable 和 Callable 两种任务的统一，并增加了对任务的管理功能；</li><li>执行任务类：ThreadPoolExecutor、Executor、ExecutorService。Executor 定义最基本的运行接口，ExecutorService 是对其功能的补充，ThreadPoolExecutor 提供真正可运行的线程池类，三个类定义了任务的运行机制。</li></ol><p>日常的做法都是先根据定义任务类定义出任务来，然后丢给执行任务类去执行。</p><h5 id="3-说一说队列在线程池中起的作用？"><a href="#3-说一说队列在线程池中起的作用？" class="headerlink" title="3.说一说队列在线程池中起的作用？"></a>3.说一说队列在线程池中起的作用？</h5><p>答：作用如下：</p><ol><li>当请求数大于 coreSize 时，可以让任务在队列中排队，让线程池中的线程慢慢的消费请求，实际工作中，实际线程数不可能等于请求数，队列提供了一种机制让任务可排队，起一个缓冲区的作用；</li><li>当线程消费完所有的线程后，会阻塞的从队列中拿数据，通过队列阻塞的功能，使线程不消亡，一旦队列中有数据产生后，可立马被消费。</li></ol><h5 id="4-结合请求不断增加时，说一说线程池构造器参数的含义和表现？"><a href="#4-结合请求不断增加时，说一说线程池构造器参数的含义和表现？" class="headerlink" title="4.结合请求不断增加时，说一说线程池构造器参数的含义和表现？"></a>4.结合请求不断增加时，说一说线程池构造器参数的含义和表现？</h5><p>答：线程池构造器各个参数的含义如下：</p><ol><li>coreSize 核心线程数；</li><li>maxSize 最大线程数；</li><li>keepAliveTime 线程空闲的最大时间；</li><li>queue 有多种队列可供选择，比如：1：SynchronousQueue，为了避免任务被拒绝，要求线程池的 maxSize 无界，缺点是当任务提交的速度超过消费的速度时，可能出现无限制的线程增长；2：LinkedBlockingQueue，无界队列，未消费的任务可以在队列中等待；3：ArrayBlockingQueue，有界队列，可以防止资源被耗尽；</li><li>线程新建的 ThreadFactory 可以自定义，也可以使用默认的 DefaultThreadFactory，DefaultThreadFactory 创建线程时，优先级会被限制成 NORM_PRIORITY，默认会被设置成非守护线程；</li><li>在 Executor 已经关闭或对最大线程和最大队列都使用饱和时，可以使用 RejectedExecutionHandler 类进行异常捕捉，有如下四种处理策略：ThreadPoolExecutor.AbortPolicy、ThreadPoolExecutor.DiscardPolicy、ThreadPoolExecutor.CallerRunsPolicy、ThreadPoolExecutor.DiscardOldestPolicy。</li></ol><p>当请求不断增加时，各个参数起的作用如下：</p><ol><li>请求数 &lt; coreSize：创建新的线程来处理任务；</li><li>coreSize &lt;= 请求数 &amp;&amp; 能够成功入队列：任务进入到队列中等待被消费；</li><li>队列已满 &amp;&amp; 请求数 &lt; maxSize：创建新的线程来处理任务；</li><li>队列已满 &amp;&amp; 请求数 &gt;= maxSize：使用 RejectedExecutionHandler 类拒绝请求。</li></ol><h5 id="5-coreSize-和-maxSize-可以动态设置么，有没有规则限制？"><a href="#5-coreSize-和-maxSize-可以动态设置么，有没有规则限制？" class="headerlink" title="5.coreSize 和 maxSize 可以动态设置么，有没有规则限制？"></a>5.coreSize 和 maxSize 可以动态设置么，有没有规则限制？</h5><p>答：一般来说，coreSize 和 maxSize 在线程池初始化时就已经设定了，但我们也可以通过 setCorePoolSize、setMaximumPoolSize 方法动态的修改这两个值。</p><p>setCorePoolSize 的限制见如下源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果新设置的值小于 coreSize,多余的线程在空闲时会被回收（不保证一定可以回收成功）</span><span class="token comment" spellcheck="true">// 如果大于 coseSize，会新创建线程</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> delta <span class="token operator">=</span> corePoolSize <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 活动的线程大于新设置的核心线程数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> corePoolSize<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 尝试将可以获得锁的 worker 中断，只会循环一次</span>        <span class="token comment" spellcheck="true">// 最后并不能保证活动的线程数一定小于核心线程数</span>        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置的核心线程数大于原来的核心线程数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 并不清楚应该新增多少线程，取新增核心线程数和等待队列数据的最小值，够用就好</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>delta<span class="token punctuation">,</span> workQueue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 新增线程直到k，如果期间等待队列空了也不会再新增</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>k<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>setMaximumPoolSize 的限制见如下源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果 maxSize 大于原来的值，直接设置。</span><span class="token comment" spellcheck="true">// 如果 maxSize 小于原来的值，尝试干掉一些 worker</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMaximumPoolSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> maximumPoolSize <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> maximumPoolSize<span class="token punctuation">)</span>        <span class="token function">interruptIdleWorkers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="6-说一说对于线程空闲回收的理解，源码中如何体现的？"><a href="#6-说一说对于线程空闲回收的理解，源码中如何体现的？" class="headerlink" title="6.说一说对于线程空闲回收的理解，源码中如何体现的？"></a>6.说一说对于线程空闲回收的理解，源码中如何体现的？</h5><p>答：空闲线程回收的时机：如果线程超过 keepAliveTime 时间后，还从阻塞队列中拿不到任务（这种情况我们称为线程空闲），当前线程就会被回收，如果 allowCoreThreadTimeOut 设置成 true，core thread 也会被回收，直到还剩下一个线程为止，如果 allowCoreThreadTimeOut 设置成 false，只会回收非 core thread 的线程。</p><p>线程在任务执行完成之后，之所有没有消亡，是因为阻塞的从队列中拿任务，在 keepAliveTime 时间后都没有拿到任务的话，就会打断阻塞，线程直接返回，线程的生命周期就结束了，JVM 会回收掉该线程对象，所以我们说的线程回收源码体现就是让线程不在队列中阻塞，直接返回了，可以见 ThreadPoolExecutor 源码解析章节第三小节的源码解析。</p><h5 id="7-如果我想在线程池任务执行之前和之后，做一些资源清理的工作，可以么，如何做？"><a href="#7-如果我想在线程池任务执行之前和之后，做一些资源清理的工作，可以么，如何做？" class="headerlink" title="7.如果我想在线程池任务执行之前和之后，做一些资源清理的工作，可以么，如何做？"></a>7.如果我想在线程池任务执行之前和之后，做一些资源清理的工作，可以么，如何做？</h5><p>答：可以的，ThreadPoolExecutor 提供了一些钩子函数，我们只需要继承 ThreadPoolExecutor 并实现这些钩子函数即可。在线程池任务执行之前实现 beforeExecute 方法，执行之后实现 afterExecute 方法。</p><h5 id="8-线程池中的线程创建，拒绝请求可以自定义实现么？如何自定义？"><a href="#8-线程池中的线程创建，拒绝请求可以自定义实现么？如何自定义？" class="headerlink" title="8.线程池中的线程创建，拒绝请求可以自定义实现么？如何自定义？"></a>8.线程池中的线程创建，拒绝请求可以自定义实现么？如何自定义？</h5><p>答：可以自定义的，线程创建默认使用的是 DefaultThreadFactory，自定义话的只需要实现 ThreadFactory 接口即可；拒绝请求也是可以自定义的，实现 RejectedExecutionHandler 接口即可；在 ThreadPoolExecutor 初始化时，将两个自定义类作为构造器的入参传递给 ThreadPoolExecutor 即可。</p><h5 id="9-说你对-Worker-的理解？"><a href="#9-说你对-Worker-的理解？" class="headerlink" title="9.说你对 Worker 的理解？"></a>9.说你对 Worker 的理解？</h5><p>答：详见《ThreadPoolExecutor 源码解析》</p><h5 id="10-说一说-submit-方法执行的过程？"><a href="#10-说一说-submit-方法执行的过程？" class="headerlink" title="10.说一说 submit 方法执行的过程？"></a>10.说一说 submit 方法执行的过程？</h5><p>答：详见《ThreadPoolExecutor 源码解析》</p><h5 id="11-说一说线程执行任务之后，都在干啥？"><a href="#11-说一说线程执行任务之后，都在干啥？" class="headerlink" title="11.说一说线程执行任务之后，都在干啥？"></a>11.说一说线程执行任务之后，都在干啥？</h5><p>答：线程执行任务完成之后，有两种结果：</p><ol><li>线程会阻塞从队列中拿任务，没有任务的话无限阻塞；</li><li>线程会阻塞从队列中拿任务，没有任务的话阻塞一段时间后，线程返回，被 JVM 回收。</li></ol><h5 id="12-keepAliveTime-设置成负数或者是-0，表示无限阻塞？"><a href="#12-keepAliveTime-设置成负数或者是-0，表示无限阻塞？" class="headerlink" title="12.keepAliveTime 设置成负数或者是 0，表示无限阻塞？"></a>12.keepAliveTime 设置成负数或者是 0，表示无限阻塞？</h5><p>答：这种是不对的，如果 keepAliveTime 设置成负数，在线程池初始化时，就会直接报 IllegalArgumentException 的异常，而设置成 0，队列如果是 LinkedBlockingQueue 的话，执行 workQueue.poll (keepAliveTime, TimeUnit.NANOSECONDS) 方法时，如果队列中没有任务，会直接返回 null，导致线程立马返回，不会无限阻塞。</p><p>如果想无限阻塞的话，可以把 keepAliveTime 设置的很大，把 TimeUnit 也设置的很大，接近于无限阻塞。</p><h5 id="13-说一说-Future-get-方法是如何拿到线程的执行结果的？"><a href="#13-说一说-Future-get-方法是如何拿到线程的执行结果的？" class="headerlink" title="13.说一说 Future.get 方法是如何拿到线程的执行结果的？"></a>13.说一说 Future.get 方法是如何拿到线程的执行结果的？</h5><p>答：我们需要明确几点：</p><ol><li>submit 方法的返回结果实际上是 FutureTask，我们平时都是针对接口编程，所以使用的是 Future.get 来拿到线程的执行结果，实际上是 FutureTask.get ，其方法底层是从 FutureTask 的 outcome 属性拿值的；</li><li>《ThreadPoolExecutor 源码解析》中 2 小节中详细说明了 submit 方法最终会把线程的执行结果赋值给 outcome。</li></ol><p>结合 1、2，当线程执行完成之后，自然就可以从 FutureTask 的 outcome 属性中拿到值。</p><h3 id="7-3-经验总结：不同场景，如何使用线程池"><a href="#7-3-经验总结：不同场景，如何使用线程池" class="headerlink" title="7.3-经验总结：不同场景，如何使用线程池"></a>7.3-经验总结：不同场景，如何使用线程池</h3><p>ThreadPoolExecutor 初始化时，主要有如下几个参数：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                          TimeUnit unit<span class="token punctuation">,</span>                          BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                          ThreadFactory threadFactory<span class="token punctuation">,</span>                          RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span></code></pre><p>大家对这几个参数应该都很熟悉了，虽然参数很少，但实际工作中却有很多门道，大多数的问题主要集中在线程大小的设置，队列大小的设置两方面上，接下来我们一起看看工作中，如何初始化 ThreadPoolExecutor。</p><h4 id="7-3-1-coreSize-maxSize"><a href="#7-3-1-coreSize-maxSize" class="headerlink" title="7.3.1-coreSize == maxSize"></a>7.3.1-coreSize == maxSize</h4><p>我相信很多人都看过，或自己写过这样的代码：</p><pre class=" language-java"><code class="language-java">ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> 600000L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">,</span>                                                     <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这行代码主要展示了在初始化 ThreadPoolExecutor 的时候，coreSize 和 maxSize 是相等的，这样设置的话，随着请求的不断增加，会是这样的现象：</p><ol><li>请求数 &lt; coreSize 时，新增线程；</li><li>请求数 &gt;= coreSize &amp;&amp; 队列不满时，添加任务入队；</li><li>队列满时，此时因为 coreSize 和 maxSize 相等，任务会被直接拒绝。</li></ol><p>这么写的最大目的：是想让线程一下子增加到 maxSize，并且不要回收线程，防止线程回收，避免不断增加回收的损耗，一般来说业务流量都有波峰低谷，在流量低谷时，线程不会被回收；流量波峰时，maxSize 的线程可以应对波峰，不需要慢慢初始化到 maxSize 的过程。</p><p>这样设置有两个前提条件：</p><ol><li>allowCoreThreadTimeOut 我们采取默认 false，而不会主动设置成 true，allowCoreThreadTimeOut 是 false 的话，当线程空闲时，就不会回收核心线程；</li><li>keepAliveTime 和 TimeUnit 我们都会设置很大，这样线程空闲的时间就很长，线程就不会轻易的被回收。</li></ol><p>我们现在机器的资源都是很充足的，我们不用去担心线程空闲会浪费机器的资源，所以这种写法目前是很常见的。</p><h4 id="7-3-2-maxSize-无界-SynchronousQueue"><a href="#7-3-2-maxSize-无界-SynchronousQueue" class="headerlink" title="7.3.2-maxSize 无界 + SynchronousQueue"></a>7.3.2-maxSize 无界 + SynchronousQueue</h4><p>在线程池选择队列时，我们也会看到有同学选择 SynchronousQueue，SynchronousQueue 我们在 《SynchronousQueue 源码解析》章节有说过，其内部有堆栈和队列两种形式，默认是堆栈的形式，其内部是没有存储的容器的，放元素和拿元素是一一对应的，比如我使用 put 方法放元素，如果此时没有对应的 take 操作的话，put 操作就会阻塞，需要有线程过来执行 take 操作后，put 操作才会返回。</p><p>基于此特点，如果要使用 SynchronousQueue 的话，我们需要尽量将 maxSize 设置大一点，这样就可以接受更多的请求。</p><p>假设我们设置 maxSize 是 10 的话，选择 SynchronousQueue 队列，假设所有请求都执行 put 操作，没有请求执行 take 操作，前 10 个 put 请求会消耗 10 个线程，都阻塞在 put 操作上，第 11 个请求过来后，请求就会被拒绝，所以我们才说尽量把 maxSize 设置大一点，防止请求被拒绝。</p><p>maxSize 无界 + SynchronousQueue 这样的组合方式优缺点都很明显：</p><p>优点：当任务被消费时，才会返回，这样请求就能够知道当前请求是已经在被消费了，如果是其他的队列的话，我们只知道任务已经被提交成功了，但无法知道当前任务是在被消费中，还是正在队列中堆积。</p><p>缺点：</p><ol><li>比较消耗资源，大量请求到来时，我们会新建大量的线程来处理请求；</li><li>如果请求的量难以预估的话，maxSize 的大小也很难设置。</li></ol><h4 id="7-3-3-maxSize-有界-Queue-无界"><a href="#7-3-3-maxSize-有界-Queue-无界" class="headerlink" title="7.3.3-maxSize 有界 + Queue 无界"></a>7.3.3-maxSize 有界 + Queue 无界</h4><p>在一些对实时性要求不大，但流量忽高忽低的场景下，可以使用 maxSize 有界 + Queue 无界的组合方式。</p><p>比如我们设置 maxSize 为 20，Queue 选择默认构造器的 LinkedBlockingQueue，这样做的优缺点如下：</p><p>优点：</p><ol><li>电脑 cpu 固定的情况下，每秒能同时工作的线程数是有限的，此时开很多的线程其实也是浪费，还不如把这些请求放到队列中去等待，这样可以减少线程之间的 CPU 的竞争；</li><li>LinkedBlockingQueue 默认构造器构造出来的链表的最大容量是 Integer 的最大值，非常适合流量忽高忽低的场景，当流量高峰时，大量的请求被阻塞在队列中，让有限的线程可以慢慢消费。</li></ol><p>缺点：流量高峰时，大量的请求被阻塞在队列中，对于请求的实时性难以保证，所以当对请求的实时性要求较高的场景，不能使用该组合。</p><h4 id="7-3-4-maxSize-有界-Queue-有界"><a href="#7-3-4-maxSize-有界-Queue-有界" class="headerlink" title="7.3.4-maxSize 有界 + Queue 有界"></a>7.3.4-maxSize 有界 + Queue 有界</h4><p>这种组合是对 3 缺点的补充，我们把队列从无界修改成有界，只要排队的任务在要求的时间内，能够完成任务即可。</p><p>这种组合需要我们把线程和队列的大小进行配合计算，保证大多数请求都可以在要求的时间内，有响应返回。</p><h4 id="7-3-5-keepAliveTime-设置无穷大"><a href="#7-3-5-keepAliveTime-设置无穷大" class="headerlink" title="7.3.5-keepAliveTime 设置无穷大"></a>7.3.5-keepAliveTime 设置无穷大</h4><p>有些场景下我们不想让空闲的线程被回收，于是就把 keepAliveTime 设置成 0，实际上这种设置是错误的，当我们把 keepAliveTime 设置成 0 时，线程使用 poll 方法在队列上进行超时阻塞时，会立马返回 null，也就是空闲线程会立马被回收。</p><p>所以如果我们想要空闲的线程不被回收，我们可以设置 keepAliveTime 为无穷大值，并且设置 TimeUnit 为时间的大单位，比如我们设置 keepAliveTime 为 365，TimeUnit 为 TimeUnit.DAYS，意思是线程空闲 1 年内都不会被回收。</p><p>在实际的工作中，机器的内存一般都够大，我们合理设置 maxSize 后，即使线程空闲，我们也不希望线程被回收，我们常常也会设置 keepAliveTime 为无穷大。</p><h4 id="7-3-6-线程池的公用和独立"><a href="#7-3-6-线程池的公用和独立" class="headerlink" title="7.3.6-线程池的公用和独立"></a>7.3.6-线程池的公用和独立</h4><p>在实际工作中，某一个业务下的所有场景，我们都不会公用一个线程池，一般有以下几个原则：</p><ol><li>查询和写入不公用线程池，互联网应用一般来说，查询量远远大于写入的量，如果查询和写入都要走线程池的话，我们一定不要公用线程池，也就是说查询走查询的线程池，写入走写入的线程池，如果公用的话，当查询量很大时，写入的请求可能会到队列中去排队，无法及时被处理；</li><li>多个写入业务场景看情况是否需要公用线程池，原则上来说，每个业务场景都独自使用自己的线程池，绝不共用，这样在业务治理、限流、熔断方面都比较容易，一旦多个业务场景公用线程池，可能就会造成业务场景之间的互相影响，现在的机器内存都很大，每个写入业务场景独立使用自己的线程池也是比较合理的；</li><li>多个查询业务场景是可以公用线程池的，查询的请求一般来说有几个特点：查询的场景多、rt 时间短、查询的量比较大，如果给每个查询场景都弄一个单独的线程池的话，第一个比较耗资源，第二个很难定义线程池中线程和队列的大小，比较复杂，所以多个相似的查询业务场景是可以公用线程池的。</li></ol><h4 id="7-3-7-如何算线程大小和队列大小"><a href="#7-3-7-如何算线程大小和队列大小" class="headerlink" title="7.3.7-如何算线程大小和队列大小"></a>7.3.7-如何算线程大小和队列大小</h4><p>在实际的工作中，我们使用线程池时，需要慎重考虑线程的大小和队列的大小，主要从几个方面入手：</p><ol><li>根据业务进行考虑，初始化线程池时，我们需要考虑所有业务涉及的线程池，如果目前所有的业务同时都有很大流量，那么在对于当前业务设置线程池时，我们尽量把线程大小、队列大小都设置小，如果所有业务基本上都不会同时有流量，那么就可以稍微设置大一点；</li><li>根据业务的实时性要求，如果实时性要求高的话，我们把队列设置小一点，coreSize == maxSize，并且设置 maxSize 大一点，如果实时性要求低的话，就可以把队列设置大一点。</li></ol><p>假设现在机器上某一时间段只会运行一种业务，业务的实时性要求较高，每个请求的平均 rt 是 200ms，请求超时时间是 2000ms，机器是 4 核 CPU，内存 16G，一台机器的 qps 是 100，这时候我们可以模拟一下如何设置：</p><ol><li>4 核 CPU，假设 CPU 能够跑满，每个请求的 rt 是 200ms，就是 200 ms 能执行 4 条请求，2000ms 内能执行 2000/200 * 4 = 40 条请求；</li><li>200 ms 能执行 4 条请求，实际上 4 核 CPU 的性能远远高于这个，我们可以拍脑袋加 10 条，也就是说 2000ms 内预估能够执行 50 条；</li><li>一台机器的 qps 是 100，此时我们计算一台机器 2 秒内最多处理 50 条请求，所以此时如果不进行 rt 优化的话，我们需要加至少一台机器。</li></ol><p>线程池可以大概这么设置：</p><pre class=" language-java"><code class="language-java">ThreadPoolExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> 365L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">,</span>                                                     <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>线程数最大为 15，队列最大为 35，这样机器差不多可以在 2000ms 内处理最大的请求 50 条，当然根据你机器的性能和实时性要求，你可以调整线程数和队列的大小占比，只要总和小于 50 即可。</p><p>以上只是很粗糙的设置，在实际的工作中，还需要根据实际情况不断的观察和调整。</p><h4 id="7-3-8-总结"><a href="#7-3-8-总结" class="headerlink" title="7.3.8-总结"></a>7.3.8-总结</h4><p>线程池设置非常重要，我们尽量少用 Executors 类提供的各种初始化线程池的方法，多根据业务的量，实时性要求来计算机器的预估承载能力，设置预估的线程和队列大小，并且根据实时请求不断的调整线程池的大小值。</p><h3 id="7-4-打动面试官：线程池流程编排中的运用实战"><a href="#7-4-打动面试官：线程池流程编排中的运用实战" class="headerlink" title="7.4-打动面试官：线程池流程编排中的运用实战"></a>7.4-打动面试官：线程池流程编排中的运用实战</h3><p>在线程池的面试中，面试官除了喜欢问 ThreadPoolExecutor 的底层源码外，还喜欢问你有没有在实际的工作中用过 ThreadPoolExecutor，我们在并发集合类的《场景集合：并发 List、Map 的应用场景》一文中说过一种简单的流程引擎，如果没有看过的同学，可以返回去看一下。</p><p>本章就在流程引擎的基础上运用 ThreadPoolExecutor，使用线程池实现 SpringBean 的异步执行。</p><h4 id="7-4-1-流程引擎关键代码回顾"><a href="#7-4-1-流程引擎关键代码回顾" class="headerlink" title="7.4.1-流程引擎关键代码回顾"></a>7.4.1-流程引擎关键代码回顾</h4><p>《场景集合：并发 List、Map 的应用场景》文中流程引擎执行 SpringBean 的核心代码为：</p><pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">// 批量执行 Spring Bean</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">stageInvoke</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> StageEnum stage<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>DomainAbilityBean<span class="token operator">></span>        domainAbilitys <span class="token operator">=</span>        FlowCenter<span class="token punctuation">.</span>flowMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>stage<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>domainAbilitys<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"找不到该流程对应的领域行为"</span> <span class="token operator">+</span> flowName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>DomainAbilityBean domainAbility <span class="token operator">:</span> domainAbilitys<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 执行 Spring Bean</span>      domainAbility<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p>入参是 flowName（流程名称）、stage（阶段）、content（上下文），其中 stage 中会执行很多 SpringBean，SpringBean 被执行的代码是 domainAbility.invoke(content)。</p><h4 id="7-4-2-异步执行-SpringBean"><a href="#7-4-2-异步执行-SpringBean" class="headerlink" title="7.4.2-异步执行 SpringBean"></a>7.4.2-异步执行 SpringBean</h4><p>从上述代码中，我们可以看到所有的 SpringBean 都是串行执行的，效率较低，我们在实际业务中发现，有的 SpringBean 完全可以异步执行，这样既能完成业务请求，又能减少业务处理的 rt，对于这个需求，我们条件反射的有了两个想法：</p><ol><li>需要新开线程来异步执行 SpringBean，可以使用 Runable 或者 Callable；</li><li>业务请求量很大，我们不能每次来一个请求，就开一个线程，我们应该让线程池来管理异步执行的线程。</li></ol><p>于是我们决定使用线程池来完成这个需求。</p><h4 id="7-4-3-如何区分异步的-SpringBean"><a href="#7-4-3-如何区分异步的-SpringBean" class="headerlink" title="7.4.3-如何区分异步的 SpringBean"></a>7.4.3-如何区分异步的 SpringBean</h4><p>我们的 SpringBean 都是实现 DomainAbilityBean 这个接口的，接口定义如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DomainAbilityBean</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/**   * 领域行为的方法入口   */</span>  FlowContent <span class="token function">invoke</span><span class="token punctuation">(</span>FlowContent content<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从接口定义上来看，没有预留任何地方来标识该 SpringBean 应该是同步执行还是异步执行，这时候我们可以采取注解的方式，我们新建一个注解，只要 SpringBean 上有该注解，表示该 SpringBean 应该异步执行，否则应该同步执行，新建的注解如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 异步 SpringBean 执行注解 * SpringBean 需要异步执行的话，就打上该注解*author  wenhe*date 2019/10/7*/</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 表示该注解应该打在类上</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">AsyncComponent</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>接着我们新建了两个 SpringBean，并在其中一个 SpringBean 上打上异步的注解，并且打印出执行 SpringBean 的线程名称，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E6%96%B0%E5%BB%BASpringBean%E5%B9%B6%E5%8A%A0%E4%B8%8A%E5%BC%82%E6%AD%A5%E6%B3%A8%E8%A7%A3.jpeg" alt="新建SpringBean并加上异步注解"></p><p>图中实现了两个 SpringBean：BeanOne 和 BeanTwo，其中 BeanTwo 被打上了 AsyncComponent 注解，表明 BeanTwo 应该被异步执行，两个 SpringBean 都打印出执行的线程的名称。</p><h4 id="7-4-4-mock-流程引擎数据中心"><a href="#7-4-4-mock-流程引擎数据中心" class="headerlink" title="7.4.4-mock 流程引擎数据中心"></a>7.4.4-mock 流程引擎数据中心</h4><p>《场景集合：并发 List、Map 的应用场景》一文中，我们说可以从数据库中加载出流程引擎需要的数据，此时我们 mock 一下，mock 的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowCenter</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/**   * flowMap 是共享变量，方便访问   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>StageEnum<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>DomainAbilityBean<span class="token operator">>>></span> flowMap      <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * PostConstruct 注解的意思就是   * 在容器启动成功之后，初始化 flowMap   */</span>  <span class="token annotation punctuation">@PostConstruct</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 初始化 flowMap mock</span>    Map<span class="token operator">&lt;</span>StageEnum<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>DomainAbilityBean<span class="token operator">>></span> stageMap <span class="token operator">=</span> flowMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span><span class="token string">"flow1"</span><span class="token punctuation">,</span>Maps<span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>StageEnum value <span class="token operator">:</span> StageEnum<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      List<span class="token operator">&lt;</span>DomainAbilityBean<span class="token operator">></span> domainAbilitys <span class="token operator">=</span> stageMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> Lists<span class="token punctuation">.</span><span class="token function">newCopyOnWriteArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>domainAbilitys<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        domainAbilitys<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>            ApplicationContextHelper<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>BeanOne<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            ApplicationContextHelper<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>BeanTwo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        stageMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>domainAbilitys<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    flowMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"flow1"</span><span class="token punctuation">,</span>stageMap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 打印出加载完成之后的数据结果</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"init success,flowMap is {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>flowMap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="7-4-5-新建线程池"><a href="#7-4-5-新建线程池" class="headerlink" title="7.4.5-新建线程池"></a>7.4.5-新建线程池</h4><p>在以上操作完成之后，只剩下最后一步了，之前我们执行 SpringBean 时，是这行代码：domainAbility.invoke(content);</p><p>现在我们需要区分 SpringBean 是否是异步的，如果是异步的，丢到线程池中去执行，如果是同步的，仍然使用原来的方法进行执行，于是我们把这些逻辑封装到一个工具类中，工具类如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 组件执行器 * author  wenhe * date 2019/10/7 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ComponentExecutor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 我们新建了一个线程池</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> ExecutorService executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span>                                                                   365L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">,</span>                                                                   <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果 SpringBean 上有 AsyncComponent 注解，表示该 SpringBean 需要异步执行，就丢到线程池中去</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span>DomainAbilityBean component<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断类上是否有 AsyncComponent 注解</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>AnnotationUtils<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>AsyncComponent<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> AopUtils<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 提交到线程池中</span>      executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span> component<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 同步 SpringBean 直接执行。</span>    component<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们把原来的执行代码替换成使用组件执行器执行，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E6%96%B0%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B9%B6%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6%E6%89%A7%E8%A1%8C%E5%99%A8%E6%89%A7%E8%A1%8C.jpeg" alt="新建线程池并使用组件执行器执行"></p><h4 id="7-4-6-测试"><a href="#7-4-6-测试" class="headerlink" title="7.4.6-测试"></a>7.4.6-测试</h4><p>以上步骤完成之后，简单的流程引擎就已经完成了，我们简单地在项目启动的时候加上测试，代码如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E6%B1%A0Demo%E6%B5%8B%E8%AF%95.jpeg" alt="线程池Demo测试"></p><p>更严谨的做法，是会写单元测试来测试流程引擎，为了快一点，我们直接在项目启动类上加上了测试代码。</p><p>运行之后的关键结果如下：</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">[</span>main<span class="token punctuation">]</span> demo<span class="token punctuation">.</span>sixth<span class="token punctuation">.</span>SynchronizedDemo<span class="token operator">:</span> SynchronizedDemo init begin<span class="token punctuation">[</span>main<span class="token punctuation">]</span> demo<span class="token punctuation">.</span>sixth<span class="token punctuation">.</span>SynchronizedDemo<span class="token operator">:</span> SynchronizedDemo init end<span class="token punctuation">[</span>main<span class="token punctuation">]</span> demo<span class="token punctuation">.</span>three<span class="token punctuation">.</span>flow<span class="token punctuation">.</span>FlowCenter <span class="token operator">:</span> init success<span class="token punctuation">,</span>flowMap is <span class="token punctuation">{</span><span class="token string">"flow1"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">"PARAM_VALID"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"AFTER_TRANSACTION"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"$ref"</span><span class="token operator">:</span><span class="token string">"$.flow1.PARAM_VALID[0]"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"$ref"</span><span class="token operator">:</span><span class="token string">"$.flow1.PARAM_VALID[1]"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"BUSINESS_VALID"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"$ref"</span><span class="token operator">:</span><span class="token string">"$.flow1.PARAM_VALID[0]"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"$ref"</span><span class="token operator">:</span><span class="token string">"$.flow1.PARAM_VALID[1]"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">"IN_TRANSACTION"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"$ref"</span><span class="token operator">:</span><span class="token string">"$.flow1.PARAM_VALID[0]"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"$ref"</span><span class="token operator">:</span><span class="token string">"$.flow1.PARAM_VALID[1]"</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span>o<span class="token punctuation">.</span>s<span class="token punctuation">.</span>j<span class="token punctuation">.</span>e<span class="token punctuation">.</span>a<span class="token punctuation">.</span>AnnotationMBeanExporter  <span class="token operator">:</span> Registering beans <span class="token keyword">for</span> JMX exposure on startup<span class="token punctuation">[</span>main<span class="token punctuation">]</span> s<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c<span class="token punctuation">.</span>e<span class="token punctuation">.</span>t<span class="token punctuation">.</span>TomcatEmbeddedServletContainer <span class="token operator">:</span> Tomcat started on <span class="token function">port</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">8080</span> <span class="token punctuation">(</span>http<span class="token punctuation">)</span><span class="token punctuation">[</span>main<span class="token punctuation">]</span> demo<span class="token punctuation">.</span>DemoApplication <span class="token operator">:</span> Started DemoApplication in <span class="token number">5.377</span> <span class="token function">seconds</span> <span class="token punctuation">(</span>JVM running <span class="token keyword">for</span> <span class="token number">6.105</span><span class="token punctuation">)</span><span class="token punctuation">[</span>main<span class="token punctuation">]</span> demo<span class="token punctuation">.</span>three<span class="token punctuation">.</span>flow<span class="token punctuation">.</span>BeanOne <span class="token operator">:</span> BeanOne is run<span class="token punctuation">,</span>thread name is main<span class="token punctuation">[</span>main<span class="token punctuation">]</span> demo<span class="token punctuation">.</span>three<span class="token punctuation">.</span>flow<span class="token punctuation">.</span>BeanOne <span class="token operator">:</span> BeanOne is run<span class="token punctuation">,</span>thread name is main<span class="token punctuation">[</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> demo<span class="token punctuation">.</span>three<span class="token punctuation">.</span>flow<span class="token punctuation">.</span>BeanTwo <span class="token operator">:</span> BeanTwo is run<span class="token punctuation">,</span>thread name is pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">[</span>main<span class="token punctuation">]</span> demo<span class="token punctuation">.</span>three<span class="token punctuation">.</span>flow<span class="token punctuation">.</span>BeanOne <span class="token operator">:</span> BeanOne is run<span class="token punctuation">,</span>thread name is main<span class="token punctuation">[</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> demo<span class="token punctuation">.</span>three<span class="token punctuation">.</span>flow<span class="token punctuation">.</span>BeanTwo <span class="token operator">:</span> BeanTwo is run<span class="token punctuation">,</span>thread name is pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">[</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> demo<span class="token punctuation">.</span>three<span class="token punctuation">.</span>flow<span class="token punctuation">.</span>BeanTwo <span class="token operator">:</span> BeanTwo is run<span class="token punctuation">,</span>thread name is pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">[</span>main<span class="token punctuation">]</span> demo<span class="token punctuation">.</span>three<span class="token punctuation">.</span>flow<span class="token punctuation">.</span>BeanOne <span class="token operator">:</span> BeanOne is run<span class="token punctuation">,</span>thread name is main<span class="token punctuation">[</span>pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span> demo<span class="token punctuation">.</span>three<span class="token punctuation">.</span>flow<span class="token punctuation">.</span>BeanTwo <span class="token operator">:</span> BeanTwo is run<span class="token punctuation">,</span>thread name is pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">4</span></code></pre><p>从运行结果中，我们可以看到 BeanTwo 已经被多个不同的线程异步执行了。</p><h4 id="7-4-7-总结"><a href="#7-4-7-总结" class="headerlink" title="7.4.7-总结"></a>7.4.7-总结</h4><p>这是一个线程池在简单流程引擎上的运用实站，虽然这个流程引擎看起来比较简单，但在实际工作中，还是非常好用的，大家可以把代码拉下来，自己尝试一下，调试一下参数，比如当我新增 SpringBean 的时候，流程引擎的表现如何。</p><h2 id="8-Lambda-流"><a href="#8-Lambda-流" class="headerlink" title="8-Lambda 流"></a>8-Lambda 流</h2><h3 id="8-1-突破难点：如何看-Lambda-源码"><a href="#8-1-突破难点：如何看-Lambda-源码" class="headerlink" title="8.1-突破难点：如何看 Lambda 源码"></a>8.1-突破难点：如何看 Lambda 源码</h3><p>大家都知道 Java8 中新增了 Lambda 表达式，使用 Lambda 表达式可以对代码进行大量的优化，用几行代码就可以做很多事情，本章以 Lambda 为例，第一小节说明一下其底层的执行原理，第二小节说明一下 Lambda 流在工作中常用的姿势。</p><h4 id="8-1-1-Demo"><a href="#8-1-1-Demo" class="headerlink" title="8.1.1-Demo"></a>8.1.1-Demo</h4><p>首先我们来看一个 Lambda 表达式的 Demo，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-Demo.jpeg" alt="Lambda-Demo"></p><p>代码比较简单，就是新起一个线程打印一句话，但对于图中 () -&gt; System.out.println ( “ lambda is run “ ) 这种代码，估计很多同学都感觉到很困惑，Java 是怎么识别这种代码的？</p><p>如果我们修改成匿名内部类的写法，就很清楚，大家都能看懂，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-Demo2.jpeg" alt="Lambda-Demo2"></p><p>那是不是说 () -&gt; System.out.println ( “ lambda is run “ ) 这种形式的代码，其实就是建立了内部类呢？其实这就是最简单 Lambda 表达式，我们是无法通过 IDEA 看到源码和其底层结构的，下面我们就来介绍几种可看到其底层实现的方式。</p><h4 id="8-1-2-异常判断法"><a href="#8-1-2-异常判断法" class="headerlink" title="8.1.2-异常判断法"></a>8.1.2-异常判断法</h4><p>我们可以在代码执行中主动抛出异常，打印出堆栈，堆栈会说明其运行轨迹，一般这种方法简单高效，基本上可以看到很多情况下的隐藏代码，我们来试一下，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-Demo3.jpeg" alt="Lambda-Demo3"></p><p>从异常的堆栈中，我们可以看到 JVM 自动给当前类建立了内部类（错误堆栈中出现多次的 $ 表示有内部类），内部类的代码在执行过程中，抛出了异常，但这里显示的代码是 Unknown Source，所以我们也无法 debug 进去，一般情况下，异常都能暴露出代码执行的路径，我们可以打好断点后再次运行，但对于 Lambda 表达式而言，通过异常判断法我们只清楚有内部类，但无法看到内部类中的源码。</p><h4 id="8-1-3-javap-命令法"><a href="#8-1-3-javap-命令法" class="headerlink" title="8.1.3-javap 命令法"></a>8.1.3-javap 命令法</h4><p>javap 是 Java 自带的可以查看 class 字节码文件的工具，安装过 Java 基础环境的电脑都可以直接执行 javap 命令，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/javap.jpeg" alt="javap"></p><p>命令选项中，我们主要是用-v -verbose 这个命令，可以完整输出字节码文件的内容。</p><p>接下来我们使用 javap 命令查看下 Lambda.class 文件，在讲解的过程中，我们会带上一些关于 class 文件的知识。</p><p>我们在命令窗口中找到 Lambda.class 所在的位置，执行命令：javap -verbose Lambda.class，然后你会看到一长串的东西，这些叫做汇编指令，接下来我们来一一讲解下（ 所有的参考资料来自 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">Java 虚拟机规范</a>，不再一一引用说明）：</p><p>汇编指令中我们很容易找到 Constant pool 打头的一长串类型，我们叫做常量池，官方英文叫做 Run-Time Constant Pool，我们简单理解成一个装满常量的 table ，table 中包含编译时明确的数字和文字，类、方法和字段的类型信息等等。table 中的每个元素叫做 cp<em>info，cp</em>info 由唯一标识 ( tag ) + 名称组成，目前 tag 的类型一共有：</p><p>![tag 的类型](tag 的类型.jpeg)</p><p>贴出我们解析出来的部分图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E8%A7%A3%E6%9E%90%E5%87%BA%E6%9D%A5%E7%9A%84%E9%83%A8%E5%88%86.jpeg" alt="解析出来的部分"></p><ol><li><p>图中 Constant pool 字样代表当前信息是常量池；</p></li><li><p>每行都是一个 <code>cp_info</code> ，第一列的 #1 代表是在常量池下标为 1 的位置 ；</p></li><li><p>每行的第二列，是 <code>cp_info</code> 的唯一标识 ( tag ) ，比如 Methodref 对应着上表中的 CONSTANT_Methodref（上上图中表格中 value 对应 10 的 tag），代表当前行是表示方法的描述信息的，比如说方法的名称，入参类型，出参数类型等，具体的含义在 Java 虚拟机规范中都可以查询到，Methodref 的截图如下：</p><p>![Methodref 的截图](Methodref 的截图.jpeg)</p></li><li><p>每行的第三列，如果是具体的值的话，直接显示具体的值，如果是复杂的值的话，会显示 <code>cp_info</code> 的引用，比如说图中标红 2 处，引用两个 13 和 14 位置的 <code>cp_info</code>，13 表示方法名字是 init，14 表示方法无返回值，结合起来表示方法的名称和返回类型，就是一个无参构造器；</p></li><li><p>每行的第四列，就是具体的值了。</p></li></ol><p>对于比较重要的 cp_info 类型我们说明下其含义：</p><ol><li>InvokeDynamic 表示动态的调用方法，后面我们会详细说明；</li><li>Fieldref 表示字段的描述信息，如字段的名称、类型；</li><li>NameAndType 是对字段和方法类型的描述；</li><li>MethodHandle 方法句柄，动态调用方法的统称，在编译时我们不知道具体是那个方法，但运行时肯定会知道调用的是那个方法；</li><li>MethodType 动态方法类型，只有在动态运行时才会知道其方法类型是什么。</li></ol><p>我们从上上图中标红的 3 处，发现 Ljava/lang/invoke/MethodHandles$Lookup，java/lang/invoke/LambdaMetafactory.metafactory 类似这样的代码，MethodHandles 和 LambdaMetafactory 都是 java.lang.invoke 包下面的重要方法，invoke 包主要实现了动态语言的功能，我们知道 java 语言属于静态编译语言，在编译的时候，类、方法、字段等等的类型都已经确定了，而 invoke 实现的是一种动态语言，也就是说编译的时候并不知道类、方法、字段是什么类型，只有到运行的时候才知道。</p><p>比如这行代码：Runnable runnable = () -&gt; System.out.println(“lambda is run”); 在编译器编译的时候 () 这个括号编译器并不知道是干什么的，只有在运行的时候，才会知道原来这代表着的是 Runnable.run() 方法。invoke 包里面很多类，都是为了代表这些 () 的，我们称作为方法句柄（ MethodHandler ），在编译的时候，编译器只知道这里是个方法句柄，并不知道实际上执行什么方法，只有在执行的时候才知道，那么问题来了，JVM 执行的时候，是如何知道 () 这个方法句柄，实际上是执行 Runnable.run() 方法的呢？</p><p>首先我们看下 simple 方法的汇编指令：</p><p>![simple 方法的汇编指令](simple 方法的汇编指令.jpeg)</p><p>从上图中就可以看出 simple 方法中的 () -&gt; System.out.println(“lambda is run”) 代码中的 ()，实际上就是 Runnable.run 方法。</p><p>我们追溯到 # 2 常量池，也就是上上图中标红 1 处，InvokeDynamic 表示这里是个动态调用，调用的是两个常量池的 cp_info，位置是 #0:#37 ，我们往下找 #37 代表着是 // run:()Ljava/lang/Runnable，这里表明了在 JVM 真正执行的时候，需要动态调用 Runnable.run() 方法，从汇编指令上我们可以看出 () 实际上就是 Runnable.run()，下面我们 debug 来证明一下。</p><p>我们在上上图中 3 处发现了 LambdaMetafactory.metafactory 的字样，通过查询官方文档，得知该方法正是执行时， 链接到真正代码的关键，于是我们在 metafactory 方法中打个断点 debug 一下，如下图：</p><p>![metafactory 方法](metafactory 方法.jpeg)</p><p>metafactory 方法入参 caller 代表实际发生动态调用的位置，invokedName 表示调用方法名称，invokedType 表示调用的多个入参和出参，samMethodType 表示具体的实现者的参数，implMethod 表示实际上的实现者，instantiatedMethodType 等同于 implMethod。</p><p>以上内容总结一下：</p><p>1：从汇编指令的 simple 方法中，我们可以看到会执行 Runnable.run 方法；</p><p>2：在实际的运行时，JVM 碰到 simple 方法的 invokedynamic 指令，会动态调用 LambdaMetafactory.metafactory 方法，执行具体的 Runnable.run 方法。</p><p>所以可以把 Lambda 表达值的具体执行归功于 invokedynamic JVM 指令，正是因为这个指令，才可以做到虽然编译时不知道要干啥，但动态运行时却能找到具体要执行的代码。</p><p>接着我们看一下在汇编指令输出的最后，我们发现了异常判断法中发现的内部类，如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E8%BE%93%E5%87%BA.jpeg" alt="汇编指令输出"></p><p>上图中箭头很多，一层一层的表达清楚了当前内部类的所有信息。</p><h4 id="8-1-4-总结"><a href="#8-1-4-总结" class="headerlink" title="8.1.4-总结"></a>8.1.4-总结</h4><p>我们总结一下，Lambda 表达式执行主要是依靠 invokedynamic 的 JVM 指令来实现。</p><h3 id="8-2-常用的-Lambda-表达式使用场景解析和应用"><a href="#8-2-常用的-Lambda-表达式使用场景解析和应用" class="headerlink" title="8.2-常用的 Lambda 表达式使用场景解析和应用"></a>8.2-常用的 Lambda 表达式使用场景解析和应用</h3><p>我们日常工作中，Lambda 使用比较多的场景，就是 List 或 Map 下的 Lambda 流操作，往往几行代码可以帮助我们实现多层 for 循环嵌套的复杂代码，接下来我们把 Lambda 流的常用方法用案列讲解一下。</p><h4 id="8-2-1-数据准备"><a href="#8-2-1-数据准备" class="headerlink" title="8.2.1-数据准备"></a>8.2.1-数据准备</h4><p>首先我们需要准备一些测试的数据，如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token comment" spellcheck="true">// 学生数据结构</span><span class="token keyword">class</span> <span class="token class-name">StudentDTO</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>7716352032236707189L<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">StudentDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token function">StudentDTO</span><span class="token punctuation">(</span>Long id<span class="token punctuation">,</span> String code<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> String sex<span class="token punctuation">,</span> Double scope<span class="token punctuation">,</span>                    List<span class="token operator">&lt;</span>Course<span class="token operator">></span> learningCources<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>scope <span class="token operator">=</span> scope<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>learningCources <span class="token operator">=</span> learningCources<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * id   */</span>  <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 学号 唯一标识   */</span>  <span class="token keyword">private</span> String code<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 学生名字   */</span>  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 性别   */</span>  <span class="token keyword">private</span> String sex<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 分数   */</span>  <span class="token keyword">private</span> Double scope<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 要学习的课程   */</span>  <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Course<span class="token operator">></span> learningCources<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Data</span><span class="token comment" spellcheck="true">// 课程数据结构</span><span class="token keyword">class</span> <span class="token class-name">Course</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 2896201730223729591L<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 课程 ID   */</span>  <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 课程 name   */</span>  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">Course</span><span class="token punctuation">(</span>Long id<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 初始化数据</span><span class="token keyword">private</span> <span class="token keyword">final</span> List<span class="token operator">&lt;</span>StudentDTO<span class="token operator">></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>StudentDTO<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 添加学生数据</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StudentDTO</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span><span class="token string">"W199"</span><span class="token punctuation">,</span><span class="token string">"小美"</span><span class="token punctuation">,</span><span class="token string">"WM"</span><span class="token punctuation">,</span><span class="token number">100D</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Course<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 添加学生学习的课程</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>300L<span class="token punctuation">,</span><span class="token string">"语文"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>301L<span class="token punctuation">,</span><span class="token string">"数学"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>302L<span class="token punctuation">,</span><span class="token string">"英语"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StudentDTO</span><span class="token punctuation">(</span>2L<span class="token punctuation">,</span><span class="token string">"W25"</span><span class="token punctuation">,</span><span class="token string">"小美"</span><span class="token punctuation">,</span><span class="token string">"WM"</span><span class="token punctuation">,</span><span class="token number">100D</span><span class="token punctuation">,</span>Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StudentDTO</span><span class="token punctuation">(</span>3L<span class="token punctuation">,</span><span class="token string">"W3"</span><span class="token punctuation">,</span><span class="token string">"小名"</span><span class="token punctuation">,</span><span class="token string">"M"</span><span class="token punctuation">,</span><span class="token number">90D</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Course<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token punctuation">{</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>300L<span class="token punctuation">,</span><span class="token string">"语文"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>304L<span class="token punctuation">,</span><span class="token string">"体育"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StudentDTO</span><span class="token punctuation">(</span>4L<span class="token punctuation">,</span><span class="token string">"W1"</span><span class="token punctuation">,</span><span class="token string">"小蓝"</span><span class="token punctuation">,</span><span class="token string">"M"</span><span class="token punctuation">,</span><span class="token number">10D</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Course<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token punctuation">{</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>301L<span class="token punctuation">,</span><span class="token string">"数学"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>305L<span class="token punctuation">,</span><span class="token string">"美术"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>请大家稍微看下数据结构，不然看下面案例跑出来的结果会有些吃力。</p><p>代码如下：</p><p>​    </p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LambdaExpressionDemo</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@Data</span>  <span class="token comment" spellcheck="true">// 学生数据结构</span>  <span class="token keyword">class</span> <span class="token class-name">StudentDTO</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>7716352032236707189L<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">StudentDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">StudentDTO</span><span class="token punctuation">(</span>Long id<span class="token punctuation">,</span> String code<span class="token punctuation">,</span> String name<span class="token punctuation">,</span> String sex<span class="token punctuation">,</span> Double scope<span class="token punctuation">,</span>                      List<span class="token operator">&lt;</span>Course<span class="token operator">></span> learningCources<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>scope <span class="token operator">=</span> scope<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>learningCources <span class="token operator">=</span> learningCources<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * id     */</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 学号 唯一标识     */</span>    <span class="token keyword">private</span> String code<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 学生名字     */</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 性别     */</span>    <span class="token keyword">private</span> String sex<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 分数     */</span>    <span class="token keyword">private</span> Double scope<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 要学习的课程     */</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Course<span class="token operator">></span> learningCources<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Data</span>  <span class="token comment" spellcheck="true">// 课程数据结构</span>  <span class="token keyword">class</span> <span class="token class-name">Course</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 2896201730223729591L<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 课程 ID     */</span>    <span class="token keyword">private</span> Long id<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 课程 name     */</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Course</span><span class="token punctuation">(</span>Long id<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 初始化数据</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> List<span class="token operator">&lt;</span>StudentDTO<span class="token operator">></span> students <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>StudentDTO<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 添加学生数据</span>      <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StudentDTO</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span><span class="token string">"W199"</span><span class="token punctuation">,</span><span class="token string">"小美"</span><span class="token punctuation">,</span><span class="token string">"WM"</span><span class="token punctuation">,</span><span class="token number">100D</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Course<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 添加学生学习的课程</span>          <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>300L<span class="token punctuation">,</span><span class="token string">"语文"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>301L<span class="token punctuation">,</span><span class="token string">"数学"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>302L<span class="token punctuation">,</span><span class="token string">"英语"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StudentDTO</span><span class="token punctuation">(</span>2L<span class="token punctuation">,</span><span class="token string">"W25"</span><span class="token punctuation">,</span><span class="token string">"小美"</span><span class="token punctuation">,</span><span class="token string">"WM"</span><span class="token punctuation">,</span><span class="token number">100D</span><span class="token punctuation">,</span>Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StudentDTO</span><span class="token punctuation">(</span>3L<span class="token punctuation">,</span><span class="token string">"W3"</span><span class="token punctuation">,</span><span class="token string">"小名"</span><span class="token punctuation">,</span><span class="token string">"M"</span><span class="token punctuation">,</span><span class="token number">90D</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Course<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">{</span>          <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>300L<span class="token punctuation">,</span><span class="token string">"语文"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>304L<span class="token punctuation">,</span><span class="token string">"体育"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StudentDTO</span><span class="token punctuation">(</span>4L<span class="token punctuation">,</span><span class="token string">"W1"</span><span class="token punctuation">,</span><span class="token string">"小蓝"</span><span class="token punctuation">,</span><span class="token string">"M"</span><span class="token punctuation">,</span><span class="token number">10D</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Course<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">{</span>          <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>301L<span class="token punctuation">,</span><span class="token string">"数学"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Course</span><span class="token punctuation">(</span>305L<span class="token punctuation">,</span><span class="token string">"美术"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> newList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 过滤掉我们希望留下来的值</span>        <span class="token comment" spellcheck="true">// StringUtils.equals(str,"hello") 表示我们希望字符串是 hello 能留下来</span>        <span class="token comment" spellcheck="true">// 其他的过滤掉</span>        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>str <span class="token operator">-</span><span class="token operator">></span> StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// Collectors.toList() 帮助我们构造最后的返回结果</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestFilter result is {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>newList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// map 方法可以让我们进行一些流的转化，比如原来流中的元素是 A，通过 map 操作，可以使返回的流中的元素是 B</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 得到所有学生的学号</span>    <span class="token comment" spellcheck="true">// 这里 students.stream() 中的元素是 StudentDTO，通过 map 转化成 String 的流</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> codes <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//StudentDTO::getCode 是 s->s.getCode() 的简写</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestMap 所有学生的学号为 {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>codes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// mapToInt 固定返回流的类型是 int，还有 mapToLong，mapToDouble</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMapToInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ids <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 一定要有 mapToObj，因为 mapToInt 返回的是 IntStream，因为已经确定是 int 类型了</span>        <span class="token comment" spellcheck="true">// 所有没有泛型的，而 Collectors.toList() 强制要求有泛型的流，所以需要使用 mapToObj</span>        <span class="token comment" spellcheck="true">// 方法返回有泛型的流</span>        <span class="token punctuation">.</span><span class="token function">mapToObj</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestMapToInt result is {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>ids<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算学生总分</span>    Double sumScope <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">mapToDouble</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">.</span><span class="token function">getScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// IntStream 有许多 sum（求和）、min（求最小值）、max（求最大值）、average（求平均值）等方法</span>        <span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestMapToInt 学生总分为： is {}"</span><span class="token punctuation">,</span> sumScope<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// flatMap 方法和 map 方法不同，FlatMap 可以接受入参的类型为 Stream，比如这里的</span>  <span class="token comment" spellcheck="true">// s.getLearningCources().stream() 就是 Stream，可以用下面的 demo 比较一下差异</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFlatMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算学生所有的学习课程，flatMap 返回 List&lt;课程> 格式</span>    List<span class="token operator">&lt;</span>Course<span class="token operator">></span> courses <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">.</span><span class="token function">getLearningCources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestMapToInt flatMap 计算学生的所有学习课程如下 {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>courses<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算学生所有的学习课程，map 返回两层课程嵌套格式</span>    List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Course<span class="token operator">>></span> courses2 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">.</span><span class="token function">getLearningCources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestMapToInt map 计算学生的所有学习课程如下 {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>courses2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Stream<span class="token operator">&lt;</span>Course<span class="token operator">>></span> courses3 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">.</span><span class="token function">getLearningCources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestMapToInt map 计算学生的所有学习课程如下  {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>courses3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 去重</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDistinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 得到学生所有的名字，要求是去重过的</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> beforeNames <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestDistinct 没有去重前的学生名单 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>beforeNames<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> distinctNames <span class="token operator">=</span> beforeNames<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestDistinct 去重后的学生名单 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>distinctNames<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 连起来写</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestDistinct 去重后的学生名单 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 排序</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 学生按照学号排序</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> beforeCodes <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestSorted 按照学号排序之前 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>beforeCodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> sortedCodes <span class="token operator">=</span> beforeCodes<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestSorted 按照学号排序之后 is {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>sortedCodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 直接连起来写</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> codes <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 等同于 .sorted(Comparator.naturalOrder()) 自然排序</span>        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestSorted 按照自然排序 is {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>codes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 自定义排序器</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> codes2 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 反自然排序</span>        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>Comparator<span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestSorted 反自然排序 is {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>codes2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 干任何没有返回值的事情</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testPeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前循环的学号是{}"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 限制</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> beforeCodes <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestLimit 限制之前学生的学号为 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>beforeCodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> limitCodes <span class="token operator">=</span> beforeCodes<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span>2L<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestLimit 限制最大限制 2 个学生的学号 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>limitCodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 直接连起来写</span>    List<span class="token operator">&lt;</span>String<span class="token operator">></span> codes <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span>2L<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestLimit 限制最大限制 2 个学生的学号 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>codes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 计算一下学生的总分数</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算一下学生的总分数</span>    Double sum <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getScope<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// scope1 和 scope2 表示循环中的前后两个数</span>        <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>scope1<span class="token punctuation">,</span>scope2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> scope1<span class="token operator">+</span>scope2<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token number">0D</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"总成绩为 {}"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>    Double sum1 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getScope<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 第一个参数表示成绩的基数，会从 100 开始加</span>        <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">100D</span><span class="token punctuation">,</span><span class="token punctuation">(</span>scope1<span class="token punctuation">,</span>scope2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> scope1<span class="token operator">+</span>scope2<span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"总成绩为 {}"</span><span class="token punctuation">,</span>sum1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 找到第一个叫小美同学的 ID</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFindFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Long id <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"小美"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testFindFirst 小美同学的 ID {}"</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 防止空指针</span>    Long id2 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"小天"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// orElse 表示如果 findFirst 返回 null 的话，就返回 orElse 里的内容</span>        <span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StudentDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testFindFirst 小天同学的 ID {}"</span><span class="token punctuation">,</span>id2<span class="token punctuation">)</span><span class="token punctuation">;</span>    Optional<span class="token operator">&lt;</span>StudentDTO<span class="token operator">></span> student<span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"小天"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// isPresent 为 true 的话，表示 value != null</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testFindFirst 小天同学的 ID {}"</span><span class="token punctuation">,</span>student<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testFindFirst 找不到名为小天的同学"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testListToMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 学生根据名字进行分类</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>StudentDTO<span class="token operator">>></span> map1 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testListToMap groupingBy 学生根据名字进行分类 result is Map&lt;String,List&lt;StudentDTO>> {}"</span><span class="token punctuation">,</span>             JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 统计有没有姓名重名的</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Set<span class="token operator">&lt;</span>String<span class="token operator">>></span> map2 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">,</span>                                       Collectors<span class="token punctuation">.</span><span class="token function">mapping</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">,</span>Collectors<span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testListToMap groupingBy 统计姓名重名结果 is {}"</span><span class="token punctuation">,</span>             JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 学生转化成学号为 key 的 map</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> StudentDTO<span class="token operator">></span> map3 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">,</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testListToMap groupingBy 学生转化成学号为 key 的 map result is{}"</span><span class="token punctuation">,</span>             JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="8-2-2-常用方法"><a href="#8-2-2-常用方法" class="headerlink" title="8.2.2-常用方法"></a>8.2.2-常用方法</h4><h5 id="1-Filter"><a href="#1-Filter" class="headerlink" title="1.Filter"></a>1.Filter</h5><p>Filter 为过滤的意思，只要满足 Filter 表达式的数据就可以留下来，不满足的数据被过滤掉，源码如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-Filter.jpeg" alt="Lambda-Filter"></p><p>我们写了一个 demo，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// list 在下图中进行了初始化</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> newList <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 过滤掉我们希望留下来的值</span>      <span class="token comment" spellcheck="true">// StringUtils.equals(str,"hello") 表示我们希望字符串是 hello 能留下来</span>      <span class="token comment" spellcheck="true">// 其他的过滤掉</span>      <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>str <span class="token operator">-</span><span class="token operator">></span> StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// Collectors.toList() 帮助我们构造最后的返回结果</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestFilter result is {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>newList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>预览</code></pre><p>运行结果如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-Filter%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpeg" alt="Lambda-Filter测试结果"></p><h5 id="2-map"><a href="#2-map" class="headerlink" title="2.map"></a>2.map</h5><p>map 方法可以让我们进行一些流的转化，比如原来流中的元素是 A，通过 map 操作，可以使返回的流中的元素是 B，源码如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-Map.jpeg" alt="Lambda-Map"></p><p>我们写了一个 demo，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 得到所有学生的学号</span>  <span class="token comment" spellcheck="true">// 这里 students.stream() 中的元素是 StudentDTO，通过 map 方法转化成 String 的流</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> codes <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">//StudentDTO::getCode 是 s->s.getCode() 的简写</span>      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestMap 所有学生的学号为 {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>codes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 运行结果为：TestMap 所有学生的学号为 ["W199","W25","W3","W1"]</span></code></pre><h5 id="3-mapToInt"><a href="#3-mapToInt" class="headerlink" title="3.mapToInt"></a>3.mapToInt</h5><p>mapToInt 方法的功能和 map 方法一样，只不过 mapToInt 返回的结果已经没有泛型，已经明确是 int 类型的流了，源码如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-mapToInt.jpeg" alt="Lambda-mapToInt"></p><p>我们写了一个 demo，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testMapToInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ids <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 一定要有 mapToObj，因为 mapToInt 返回的是 IntStream，因为已经确定是 int 类型了</span>      <span class="token comment" spellcheck="true">// 所有没有泛型的，而 Collectors.toList() 强制要求有泛型的流，所以需要使用 mapToObj</span>      <span class="token comment" spellcheck="true">// 方法返回有泛型的流</span>      <span class="token punctuation">.</span><span class="token function">mapToObj</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestMapToInt result is {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>ids<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 计算学生总分</span>  Double sumScope <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">mapToDouble</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">.</span><span class="token function">getScope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// DoubleStream/IntStream 有许多 sum（求和）、min（求最小值）、max（求最大值）、average（求平均值）等方法</span>      <span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestMapToInt 学生总分为： is {}"</span><span class="token punctuation">,</span> sumScope<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果如下：</p><p>TestMapToInt result is [1,2,3,4]<br>TestMapToInt 学生总分为： is 300.0</p><h5 id="4-flatMap"><a href="#4-flatMap" class="headerlink" title="4.flatMap"></a>4.flatMap</h5><p>flatMap 方法也是可以做一些流的转化，和 map 方法不同的是，其明确了 Function 函数的返回值的泛型是流，源码如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-flatMap.jpeg" alt="Lambda-flatMap"></p><p>写了一个 demo，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFlatMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 计算学生所有的学习课程，flatMap 返回 List&lt;课程> 格式</span>  List<span class="token operator">&lt;</span>Course<span class="token operator">></span> courses <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">.</span><span class="token function">getLearningCources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestMapToInt flatMap 计算学生的所有学习课程如下 {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>courses<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 计算学生所有的学习课程，map 返回两层课程嵌套格式</span>  List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Course<span class="token operator">>></span> courses2 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">.</span><span class="token function">getLearningCources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestMapToInt map 计算学生的所有学习课程如下 {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>courses2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  List<span class="token operator">&lt;</span>Stream<span class="token operator">&lt;</span>Course<span class="token operator">>></span> courses3 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">.</span><span class="token function">getLearningCources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestMapToInt map 计算学生的所有学习课程如下  {}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>courses3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-flatMap%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpeg" alt="Lambda-flatMap运行结果"></p><h5 id="5-distinct"><a href="#5-distinct" class="headerlink" title="5.distinct"></a>5.distinct</h5><p>distinct 方法有去重的功能，我们写了一个 demo，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testDistinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 得到学生所有的名字，要求是去重过的</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> beforeNames <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestDistinct 没有去重前的学生名单 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>beforeNames<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> distinctNames <span class="token operator">=</span> beforeNames<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestDistinct 去重后的学生名单 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>distinctNames<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 连起来写</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> names <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestDistinct 去重后的学生名单 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>names<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-distinct%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpeg" alt="Lambda-distinct运行结果"></p><h5 id="6-Sorted"><a href="#6-Sorted" class="headerlink" title="6.Sorted"></a>6.Sorted</h5><p>Sorted 方法提供了排序的功能，并且允许我们自定义排序，demo 如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 学生按照学号排序</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> beforeCodes <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestSorted 按照学号排序之前 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>beforeCodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> sortedCodes <span class="token operator">=</span> beforeCodes<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestSorted 按照学号排序之后 is {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>sortedCodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 直接连起来写</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> codes <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 等同于 .sorted(Comparator.naturalOrder()) 自然排序</span>      <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestSorted 自然排序 is {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>codes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 自定义排序器</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> codes2 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 反自然排序</span>      <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>Comparator<span class="token punctuation">.</span><span class="token function">reverseOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestSorted 反自然排序 is {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>codes2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-Sorted%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpeg" alt="Lambda-Sorted运行结果"></p><h5 id="7-peek"><a href="#7-peek" class="headerlink" title="7.peek"></a>7.peek</h5><p>peek 方法很简单，我们在 peek 方法里面做任意没有返回值的事情，比如打印日志，如下：</p><pre class=" language-java"><code class="language-java">students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前循环的学号是{}"</span><span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="8-limit"><a href="#8-limit" class="headerlink" title="8.limit"></a>8.limit</h5><p>limit 方法会限制输出值个数，入参是限制的个数大小，demo 如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> beforeCodes <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestLimit 限制之前学生的学号为 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>beforeCodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> limitCodes <span class="token operator">=</span> beforeCodes<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span>2L<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestLimit 限制最大限制 2 个学生的学号 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>limitCodes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 直接连起来写</span>  List<span class="token operator">&lt;</span>String<span class="token operator">></span> codes <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span>2L<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TestLimit 限制最大限制 2 个学生的学号 {}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>codes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>输出结果如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-Limit%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpeg" alt="Lambda-Limit运行结果"></p><h5 id="9-reduce"><a href="#9-reduce" class="headerlink" title="9.reduce"></a>9.reduce</h5><p>reduce 方法允许我们在循环里面叠加计算值，我们写了 demo 如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 计算一下学生的总分数</span>  Double sum <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getScope<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// scope1 和 scope2 表示循环中的前后两个数</span>      <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>scope1<span class="token punctuation">,</span>scope2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> scope1<span class="token operator">+</span>scope2<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token number">0D</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"总成绩为 {}"</span><span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>  Double sum1 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getScope<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 第一个参数表示成绩的基数，会从 100 开始加</span>      <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">100D</span><span class="token punctuation">,</span><span class="token punctuation">(</span>scope1<span class="token punctuation">,</span>scope2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> scope1<span class="token operator">+</span>scope2<span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"总成绩为 {}"</span><span class="token punctuation">,</span>sum1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-reduce%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpeg" alt="Lambda-reduce运行结果"></p><p>第二个计算出来的总成绩多了 100，是因为第二个例子中 reduce 是从基数 100 开始累加的。</p><h5 id="10-findFirst"><a href="#10-findFirst" class="headerlink" title="10.findFirst"></a>10.findFirst</h5><p>findFirst 表示匹配到第一个满足条件的值就返回，demo 如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 找到第一个叫小美同学的 ID</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFindFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  Long id <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"小美"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">// 同学中有两个叫小美的，这里匹配到第一个就返回</span>      <span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testFindFirst 小美同学的 ID {}"</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 防止空指针</span>  Long id2 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"小天"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// orElse 表示如果 findFirst 返回 null 的话，就返回 orElse 里的内容</span>      <span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StudentDTO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testFindFirst 小天同学的 ID {}"</span><span class="token punctuation">,</span>id2<span class="token punctuation">)</span><span class="token punctuation">;</span>  Optional<span class="token operator">&lt;</span>StudentDTO<span class="token operator">></span> student<span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>StringUtils<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"小天"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// isPresent 为 true 的话，表示 value != null，即 student.get() != null</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>student<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testFindFirst 小天同学的 ID {}"</span><span class="token punctuation">,</span>student<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testFindFirst 找不到名为小天的同学"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Lambda-findFirst%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpeg" alt="Lambda-findFirst运行结果"></p><h5 id="11-groupingBy-amp-amp-toMap"><a href="#11-groupingBy-amp-amp-toMap" class="headerlink" title="11.groupingBy &amp;&amp; toMap"></a>11.groupingBy &amp;&amp; toMap</h5><p>groupingBy 是能够根据字段进行分组，toMap 是把 List 的数据格式转化成 Map 的格式，我们写了一个 demo，如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testListToMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 学生根据名字进行分类</span>  Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>StudentDTO<span class="token operator">>></span> map1 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testListToMap groupingBy 学生根据名字进行分类 result is Map&lt;String,List&lt;StudentDTO>> {}"</span><span class="token punctuation">,</span>           JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 统计姓名重名的学生有哪些</span>  Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Set<span class="token operator">&lt;</span>String<span class="token operator">>></span> map2 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">,</span>                                  Collectors<span class="token punctuation">.</span><span class="token function">mapping</span><span class="token punctuation">(</span>StudentDTO<span class="token operator">:</span><span class="token operator">:</span>getCode<span class="token punctuation">,</span>Collectors<span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testListToMap groupingBy 统计姓名重名结果 is {}"</span><span class="token punctuation">,</span>           JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 学生转化成学号为 key 的 map</span>  Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> StudentDTO<span class="token operator">></span> map3 <span class="token operator">=</span> students<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">//第一个入参表示 map 中 key 的取值</span>       <span class="token comment" spellcheck="true">//第二个入参表示 map 中 value 的取值</span>       <span class="token comment" spellcheck="true">//第三个入参表示，如果前后的 key 是相同的，是覆盖还是不覆盖，(s1,s2)->s1 表示不覆盖，(s1,s2)->s2 表示覆盖</span>      <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>s<span class="token operator">-</span><span class="token operator">></span>s<span class="token punctuation">,</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"testListToMap groupingBy 学生转化成学号为 key 的 map result is{}"</span><span class="token punctuation">,</span>           JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果如下：</p><p>![Lambda-groupingBy &amp;&amp; toMap运行结果](Lambda-groupingBy &amp;&amp; toMap运行结果.jpeg)</p><h4 id="8-2-3-总结"><a href="#8-2-3-总结" class="headerlink" title="8.2.3-总结"></a>8.2.3-总结</h4><p>本文我们介绍了 12 种 Lambda 表达式常用的方法，大家可以找到 LambdaExpressionDemo 类，自己 debug 下，这样你在工作中遇到复杂数据结构转化时，肯定会得心应手了。</p><h2 id="9-其他"><a href="#9-其他" class="headerlink" title="9-其他"></a>9-其他</h2><h3 id="9-1-ThreadLocal-源码解析"><a href="#9-1-ThreadLocal-源码解析" class="headerlink" title="9.1-ThreadLocal 源码解析"></a>9.1-ThreadLocal 源码解析</h3><p>ThreadLocal 提供了一种方式，让在多线程环境下，每个线程都可以拥有自己独特的数据，并且可以在整个线程执行过程中，从上而下的传递。</p><h4 id="9-1-1-用法演示"><a href="#9-1-1-用法演示" class="headerlink" title="9.1.1-用法演示"></a>9.1.1-用法演示</h4><p>可能很多同学没有使用过 ThreadLocal，我们先来演示下 ThreadLocal 的用法，demo 如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * ThreadLocal 中保存的数据是 Map */</span><span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">>></span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 从上下文中拿出 Map</span>  Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> contextMap <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>contextMap<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    contextMap <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  contextMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">,</span> <span class="token string">"value1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  context<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>contextMap<span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"key1，value1被放到上下文中"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从上下文中拿出刚才放进去的数据</span>  <span class="token function">getFromComtext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> String <span class="token function">getFromComtext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  String value1 <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"key1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"从 ThreadLocal 中取出上下文，key1 对应的值为：{}"</span><span class="token punctuation">,</span> value1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> value1<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//运行结果:</span>demo<span class="token punctuation">.</span>ninth<span class="token punctuation">.</span>ThreadLocalDemo <span class="token operator">-</span> key1，value1被放到上下文中demo<span class="token punctuation">.</span>ninth<span class="token punctuation">.</span>ThreadLocalDemo <span class="token operator">-</span> 从 ThreadLocal 中取出上下文，key1 对应的值为：value1</code></pre><p>从运行结果中可以看到，key1 对应的值已经从上下文中拿到了。</p><p>getFromComtext 方法是没有接受任何入参的，通过 context.get().get(“key1”) 这行代码就从上下文中拿到了 key1 的值，接下来我们一起来看下 ThreadLocal 底层是如何实现上下文的传递的。</p><h4 id="9-1-2-类结构"><a href="#9-1-2-类结构" class="headerlink" title="9.1.2-类结构"></a>9.1.2-类结构</h4><h5 id="1-类泛型"><a href="#1-类泛型" class="headerlink" title="1.类泛型"></a>1.类泛型</h5><p>ThreadLocal 定义类时带有泛型，说明 ThreadLocal 可以储存任意格式的数据，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h5 id="2-关键属性"><a href="#2-关键属性" class="headerlink" title="2.关键属性"></a>2.关键属性</h5><p>ThreadLocal 有几个关键属性，我们一一看下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// threadLocalHashCode 表示当前 ThreadLocal 的 hashCode，用于计算当前 ThreadLocal 在 ThreadLocalMap 中的索引位置</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threadLocalHashCode <span class="token operator">=</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 计算 ThreadLocal 的 hashCode 值(就是递增)</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> nextHashCode<span class="token punctuation">.</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span>HASH_INCREMENT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// static + AtomicInteger 保证了在一台机器中每个 ThreadLocal 的 threadLocalHashCode 是唯一的</span><span class="token comment" spellcheck="true">// 被 static 修饰非常关键，因为一个线程在处理业务的过程中，ThreadLocalMap 是会被 set 多个 ThreadLocal 的，多个 ThreadLocal 就依靠 threadLocalHashCode 进行区分</span><span class="token keyword">private</span> <span class="token keyword">static</span> AtomicInteger nextHashCode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>还有一个重要属性：ThreadLocalMap，当一个线程有多个 ThreadLocal 时，需要一个容器来管理多个 ThreadLocal，ThreadLocalMap 的作用就是这个，管理线程中多个 ThreadLocal。</p><ul><li><h6 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h6><p>ThreadLocalMap 本身就是一个简单的 Map 结构，key 是 ThreadLocal，value 是 ThreadLocal 保存的值，底层是数组的数据结构，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 数组中的每个节点值，WeakReference 是弱引用，当没有引用指向时，会直接被回收</span>        <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 当前 ThreadLocal 关联的值</span>            Object value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// WeakReference 的引用 referent 就是 ThreadLocal</span>            <span class="token function">Entry</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k<span class="token punctuation">,</span> Object v<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>                value <span class="token operator">=</span> v<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 数组的初始化大小</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 存储 ThreadLocal 的数组</span>        <span class="token keyword">private</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 扩容的阈值，默认是数组大小的三分之二</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从源码中看到 ThreadLocalMap 其实就是一个简单的 Map 结构，底层是数组，有初始化大小，也有扩容阈值大小，数组的元素是 Entry，Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值</p></li></ul><h4 id="9-1-3-ThreadLocal-是如何做到线程之间数据隔离的"><a href="#9-1-3-ThreadLocal-是如何做到线程之间数据隔离的" class="headerlink" title="9.1.3-ThreadLocal 是如何做到线程之间数据隔离的"></a>9.1.3-ThreadLocal 是如何做到线程之间数据隔离的</h4><p>ThreadLocal 是线程安全的，我们可以放心使用，主要因为是 ThreadLocalMap 是线程的属性，我们看下线程 Thread 的源码，如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ThreadLocalMap.jpeg" alt="ThreadLocalMap"></p><p>从上图中，我们可以看到 ThreadLocals.ThreadLocalMap 和 InheritableThreadLocals.ThreadLocalMap 分别是线程的属性，所以每个线程的 ThreadLocals 都是隔离独享的。</p><p>父线程在创建子线程的情况下，会拷贝 inheritableThreadLocals 的值，但不会拷贝 threadLocals 的值，源码如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/inheritableThreadLocals.jpeg" alt="inheritableThreadLocals"></p><p>从上图中我们可以看到，在线程创建时，会把父线程的 inheritableThreadLocals 属性值进行拷贝。</p><h4 id="9-1-4-set-方法"><a href="#9-1-4-set-方法" class="headerlink" title="9.1.4-set 方法"></a>9.1.4-set 方法</h4><p>set 方法的主要作用是往当前 ThreadLocal 里面 set 值，假如当前 ThreadLocal 的泛型是 Map，那么就是往当前 ThreadLocal 里面 set map，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// set 操作每个线程都是串行的，不会有线程安全的问题</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前 thradLocal 之前有设置值，直接设置，否则初始化</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化ThreadLocalMap</span>    <span class="token keyword">else</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>代码逻辑比较清晰，我们在一起来看下 ThreadLocalMap.set 的源码，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 计算 key 在数组中的下标，其实就是 ThreadLocal 的 hashCode 和数组大小-1取余</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 整体策略：查看 i 索引位置有没有值，有值的话，索引位置 + 1，直到找到没有值的位置</span>    <span class="token comment" spellcheck="true">// 这种解决 hash 冲突的策略，也导致了其在 get 时查找策略有所不同，体现在 getEntryAfterMiss 中</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         e <span class="token operator">!=</span> null<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// nextIndex 就是让在不超过数组长度的基础上，把数组的索引位置 + 1</span>         e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 找到内存地址一样的 ThreadLocal，直接替换</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 当前 key 是 null，说明 ThreadLocal 被清理了，直接替换掉</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当前 i 位置是无值的，可以被当前 thradLocal 使用</span>    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token operator">++</span>size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当数组大小大于等于扩容阈值(数组大小的三分之二)时，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>        <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面源码我们注意几点：</p><ol><li>是通过递增的 AtomicInteger 作为 ThreadLocal 的 hashCode 的；</li><li>计算数组索引位置的公式是：hashCode 取模数组大小，由于 hashCode 不断自增，所以不同的 hashCode 大概率上会计算到同一个数组的索引位置（但这个不用担心，在实际项目中，ThreadLocal 都很少，基本上不会冲突）；</li><li>通过 hashCode 计算的索引位置 i 处如果已经有值了，会从 i 开始，通过 +1 不断的往后寻找，直到找到索引位置为空的地方，把当前 ThreadLocal 作为 key 放进去。</li></ol><p>好在日常工作中使用 ThreadLocal 时，常常只使用 1~2 个 ThreadLocal，通过 hash 计算出重复的数组的概率并不是很大。</p><p>set 时的解决数组元素位置冲突的策略，也对 get 方法产生了影响，接着我们一起来看一下 get 方法。</p><h4 id="9-1-5-get-方法"><a href="#9-1-5-get-方法" class="headerlink" title="9.1.5-get 方法"></a>9.1.5-get 方法</h4><p>get 方法主要是从 ThreadLocalMap 中拿到当前 ThreadLocal 储存的值，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 因为 threadLocal 属于线程的属性，所以需要先把当前线程拿出来</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 从线程中拿到 ThreadLocalMap</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 从 map 中拿到 entry，由于 ThreadLocalMap 在 set 时的 hash 冲突的策略不同，导致拿的时候逻辑也不太一样</span>        ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果不为空，读取当前 ThreadLocal 中保存的值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>            T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 否则给当前线程的 ThreadLocal 初始化，并返回初始值 null</span>    <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接着我们来看下 ThreadLocalMap 的 getEntry 方法，源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 得到当前 thradLocal 对应的值，值的类型是由 thradLocal 的泛型决定的</span><span class="token comment" spellcheck="true">// 由于 thradLocalMap set 时解决数组索引位置冲突的逻辑，导致 thradLocalMap get 时的逻辑也是对应的</span><span class="token comment" spellcheck="true">// 首先尝试根据 hashcode 取模数组大小-1 = 索引位置 i 寻找，找不到的话，自旋把 i+1，直到找到索引位置不为空为止</span><span class="token keyword">private</span> Entry <span class="token function">getEntry</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 计算索引位置：ThreadLocal 的 hashCode 取模数组大小-1</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Entry e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// e 不为空，并且 e 的 ThreadLocal 的内存地址和 key 相同，直接返回，否则就是没有找到，继续通过 getEntryAfterMiss 方法找</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span>    <span class="token comment" spellcheck="true">// 这个取数据的逻辑，是因为 set 时数组索引位置冲突造成的  </span>        <span class="token keyword">return</span> <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 自旋 i+1，直到找到为止</span><span class="token keyword">private</span> Entry <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> Entry e<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 在大量使用不同 key 的 ThreadLocal 时，其实还蛮耗性能的</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 内存地址一样，表示找到了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 删除没用的 key</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 继续使索引位置 + 1</span>        <span class="token keyword">else</span>            i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>get 逻辑源码中注释已经写的很清楚了，我们就不重复说了。</p><h4 id="9-1-6-扩容"><a href="#9-1-6-扩容" class="headerlink" title="9.1.6-扩容"></a>9.1.6-扩容</h4><p>ThreadLocalMap 中的 ThreadLocal 的个数超过阈值时，ThreadLocalMap 就要开始扩容了，我们一起来看下扩容的逻辑：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//扩容</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 拿出旧的数组</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldLen <span class="token operator">=</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 新数组的大小为老数组的两倍</span>    <span class="token keyword">int</span> newLen <span class="token operator">=</span> oldLen <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化新数组</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newLen<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 老数组的值拷贝到新数组上</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldLen<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Entry e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Help the GC</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 计算 ThreadLocal 在新数组中的位置</span>                <span class="token keyword">int</span> h <span class="token operator">=</span> k<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果索引 h 的位置值不为空，往后+1，直到找到值为空的索引位置</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>newTab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    h <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> newLen<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 给新数组赋值</span>                newTab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 给新数组初始化下次扩容阈值，为数组长度的三分之二</span>    <span class="token function">setThreshold</span><span class="token punctuation">(</span>newLen<span class="token punctuation">)</span><span class="token punctuation">;</span>    size <span class="token operator">=</span> count<span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>源码注解也比较清晰，我们注意两点：</p><ol><li>扩容后数组大小是原来数组的两倍；</li><li>扩容时是绝对没有线程安全问题的，因为 ThreadLocalMap 是线程的一个属性，一个线程同一时刻只能对 ThreadLocalMap 进行操作，因为同一个线程执行业务逻辑必然是串行的，那么操作 ThreadLocalMap 必然也是串行的。</li></ol><h4 id="9-1-7-总结"><a href="#9-1-7-总结" class="headerlink" title="9.1.7-总结"></a>9.1.7-总结</h4><p>ThreadLocal 是非常重要的 API，我们在写一个中间件的时候经常会用到，比如说流程引擎中上下文的传递，调用链ID的传递等等，非常好用，但坑也很多。</p><h3 id="9-2-场景实战：ThreadLocal-在上下文传值场景下的实践"><a href="#9-2-场景实战：ThreadLocal-在上下文传值场景下的实践" class="headerlink" title="9.2-场景实战：ThreadLocal 在上下文传值场景下的实践"></a>9.2-场景实战：ThreadLocal 在上下文传值场景下的实践</h3><p>我们在 《打动面试官：线程池流程编排中的运用实战》一文中将流程引擎简单地完善了一下，本文在其基础上继续进行改造，建议同学可以先看看 GitHub 上的代码，或者看看之前的文章。</p><h4 id="9-2-1-回顾"><a href="#9-2-1-回顾" class="headerlink" title="9.2.1-回顾"></a>9.2.1-回顾</h4><p>流程引擎编排的对象，我们称为组件（就是 SpringBean），之前我们给组件定义了通用的接口，组件实现时就实现这个接口，代码如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/SpringBean%E5%9B%9E%E9%A1%BE.jpeg" alt="SpringBean回顾"></p><p>我们定义了 DomainAbilityBean 接口，入参和出参都是 FlowContent，FlowContent 我们称为上下文。</p><h4 id="9-2-2-ThreadLocal-实现"><a href="#9-2-2-ThreadLocal-实现" class="headerlink" title="9.2.2-ThreadLocal 实现"></a>9.2.2-ThreadLocal 实现</h4><p>上下文传参除了 FlowContent 实现外，ThreadLocal 也是可以实现的，我们来演示一下：</p><h5 id="1-定义-ThreadLocal-上下文工具类"><a href="#1-定义-ThreadLocal-上下文工具类" class="headerlink" title="1.定义 ThreadLocal 上下文工具类"></a>1.定义 ThreadLocal 上下文工具类</h5><p>首先我们使用 ThreadLocal 定义了上下文工具类，并且定义了 put、get 方法，方便使用，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ContextCache</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 2136539028591849277L<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使用 ThreadLocal 缓存上下文信息</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">>></span> CACHE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**   * 放数据   * @param sourceKey   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putAttribute</span><span class="token punctuation">(</span>String sourceKey<span class="token punctuation">,</span>String value<span class="token punctuation">)</span><span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> cacheMap <span class="token operator">=</span> CACHE<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>null <span class="token operator">==</span> cacheMap<span class="token punctuation">)</span><span class="token punctuation">{</span>      cacheMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cacheMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>sourceKey<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    CACHE<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>cacheMap<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * 拿数据   * @param sourceKey   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String <span class="token function">getAttribute</span><span class="token punctuation">(</span>String sourceKey<span class="token punctuation">)</span><span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> cacheMap <span class="token operator">=</span> CACHE<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>null <span class="token operator">==</span> cacheMap<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cacheMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>sourceKey<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果你想往 ThreadLocal 放数据，调用 ContextCache.putAttribute 方法，如果想从 ThreadLocal 拿数据，调用 ContextCache.getAttribute 方法即可。</p><p>我们写了两个组件，一个组件放数据，一个组件拿数据，如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ThreadLocal-Demo1.jpeg" alt="ThreadLocal-Demo1"></p><p>我们把两个 SpringBean 注册到流程注册中心中，让其按照先执行 BeanThree 再执行 BeanFive 的顺序进行执行，运行 DemoApplication 类的 main 方法进行执行，执行结果如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ThreadLocal-Demo2.jpeg" alt="ThreadLocal-Demo2"></p><p>从打印的日志可以看到，在 Spring 容器管理的 SpringBean 中，ThreadLocal 也是可以储存中间缓存值的。</p><h4 id="9-2-3-开启子线程"><a href="#9-2-3-开启子线程" class="headerlink" title="9.2.3-开启子线程"></a>9.2.3-开启子线程</h4><p>我们做一个实验，我们在 BeanFive 中开启子线程，然后再从 ThreadLocal 中拿值，看看能否拿到值，BeanFive 的代码修改成如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E5%BC%80%E5%90%AF%E5%AD%90%E7%BA%BF%E7%A8%8B.jpeg" alt="开启子线程"></p><p>我们再来运行一下，打印的日志如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E5%BC%80%E5%90%AF%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%97%A5%E5%BF%97.jpeg" alt="开启子线程日志"></p><p>从打印的日志中，我们发现在子线程中从 ThreadLocal 取值时，并没有取得值，这个原因主要是我们之前说的，线程在创建的时候，并不会把父线程的 ThreadLocal 中的值拷贝给子线程的 ThreadLocal，解决方案就是把 ThreadLocal 修改成 InheritableThreadLocal，代码修改如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E5%BC%80%E5%90%AF%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9.jpeg" alt="开启子线程代码修改"></p><p>我们再次运行，结果如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E5%BC%80%E5%90%AF%E5%AD%90%E7%BA%BF%E7%A8%8B%E5%86%8D%E6%AC%A1%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpeg" alt="开启子线程再次运行结果"></p><p>从运行结果看，我们成功的在子线程中拿到值。</p><h4 id="9-2-4-线程池-ThreadLocal"><a href="#9-2-4-线程池-ThreadLocal" class="headerlink" title="9.2.4-线程池 + ThreadLocal"></a>9.2.4-线程池 + ThreadLocal</h4><p>如果是拿数据的 springBean 是丢给线程池执行的，我们能够成功的从 ThreadLocal 中拿到数据么？</p><p>首先我们在放数据的 springBean 中，把放的值修改成随机的，接着拿数据的 SpringBean 修改成异步执行，代码修改如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/springBean%E4%BF%AE%E6%94%B9%E5%90%8E.jpeg" alt="springBean修改后"></p><p>为了能快速看到效果，我们把线程池的 coreSize 和 maxSize 全部修改成 3，并让任务沉睡一段时间，这样三个线程肯定消费不完任务，大量任务都会到队列中去排队，我们修改一下测试脚本，如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC.jpeg" alt="修改后的测试脚本"></p><p>我们期望的结果：</p><ol><li>线程池中执行的 BeanFive 可以成功从 ThreadLocal 中拿到数据；</li><li>能够从 ThreadLocal 拿到正确的数据，比如 BeanThree 刚放进 key1，value5，那么期望在 BeanFive 中根据 key1 能拿出 value5，而不是其它值。</li></ol><p>我们运行一下，结果如下：</p><p>![线程池 + ThreadLocal运行结果](线程池 + ThreadLocal运行结果.jpeg)</p><p>从结果中可以看到，并没有符合我们的预期，我们往 ThreadLocal 中 put 进很多值，但最后拿出来的值却很多都是 value379，都为最后 put 到 ThreadLocal 中的值。</p><p>这个原因主要是 ThreadLocal 存储的 HashMap 的引用都是同一个，main 主线程可以修改 HashMap 中的值，子线程从 ThreadLocal 中拿值时，也是从 HashMap 中拿值，从而导致不能把 put 的值通过 ThreadLocal 正确的传递给子线程。</p><p>为了证明是这个原因，我们在从 ThreadLocal 放、拿值的地方，把 HashMap 的内存地址都打印出来，改动代码如下：</p><p>![线程池 + ThreadLocal修改后代码](线程池 + ThreadLocal修改后代码.jpeg)</p><p>我们再次运行测试代码，运行的结果如下：</p><p>![线程池 + ThreadLocal修改后运行结果](线程池 + ThreadLocal修改后运行结果.jpeg)</p><p>从测试结果中可以看到，不管是主线程还是子线程和 ThreadLocal 进行交互时，HashMap 都是同一个，也就是说 ThreadLocal 中保存的 HashMap 是共享的，这就导致了线程安全的问题，子线程读取到的值就会混乱掉。</p><h4 id="9-2-5-解决方案"><a href="#9-2-5-解决方案" class="headerlink" title="9.2.5-解决方案"></a>9.2.5-解决方案</h4><p>针对这个问题，我们提出了一种解决方案，在把任务提交到线程池时，我们进行 HashMap 的拷贝，这样子线程的 HashMap 和 main 线程的 HashMap 就不同了，可以解决上面的问题。</p><p>我们提交任务时， 使用的是 Runnable，要实现 HashMap 的拷贝的话，我们需要把 Runnable 进行一层包装，包装的代码如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BB%A3%E7%A0%81.jpeg" alt="解决方案代码"></p><p>运行结果如下:</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpeg" alt="解决方案运行结果"></p><p>从运行结果中可以看出，线程池拿出来的 value 已经是正确的了。</p><h4 id="9-2-6-总结"><a href="#9-2-6-总结" class="headerlink" title="9.2.6-总结"></a>9.2.6-总结</h4><p>本文通过 ThreadLocal 来改造流程引擎中的上下文传递，希望能够加深大家对 ThreadLocal 的认识和使用技巧，有兴趣的同学可以把我们的代码下载下来，跑跑看。</p><h3 id="9-3-Socket-源码及面试题"><a href="#9-3-Socket-源码及面试题" class="headerlink" title="9.3-Socket 源码及面试题"></a>9.3-Socket 源码及面试题</h3><p>Socket 中文翻译叫套接字，可能很多工作四五年的同学都没有用过这个 API，但只要用到这个 API 时，必然是在重要的工程的核心代码处。</p><p>大家平时基本都在用开源的各种 rpc 框架，比如说 Dubbo、gRPC、Spring Cloud 等等，很少需要手写网络调用，以下三小节可以帮助大家补充这块的内容，当你真正需要的时候，可以作为手册示例。</p><p>本文和《ServerSocket 源码及面试题》一文主要说 Socket 和 ServerSocket 的源码，《工作实战：Socket 结合线程池的使用》这章主要说两个 API 在实际工作中如何落地。</p><h4 id="9-3-1-Socket-整体结构"><a href="#9-3-1-Socket-整体结构" class="headerlink" title="9.3.1-Socket 整体结构"></a>9.3.1-Socket 整体结构</h4><p>Socket 的结构非常简单，Socket 就像一个壳一样，将套接字初始化、创建连接等各种操作包装了一下，其底层实现都是 SocketImpl 实现的，Socket 本身的业务逻辑非常简单。</p><p>Socket 的属性不多，有套接字的状态，SocketImpl，读写的状态等等，源码如下图：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Socket%E7%9A%84%E5%B1%9E%E6%80%A7.jpeg" alt="Socket的属性"></p><p>套接字的状态变更都是有对应操作方法的，比如套接字新建（createImpl 方法）后，状态就会更改成 created = true，连接（connect）之后，状态更改成 connected = true 等等。</p><h4 id="9-3-2-初始化"><a href="#9-3-2-初始化" class="headerlink" title="9.3.2-初始化"></a>9.3.2-初始化</h4><p>Socket 的构造器比较多，可以分成两大类：</p><ol><li>指定代理类型（Proxy）创建套节点，一共有三种类型为：DIRECT（直连）、HTTP（HTTP、FTP 高级协议的代理）、SOCKS（SOCKS 代理），三种不同的代码方式对应的 SocketImpl 不同，分别是：PlainSocketImpl、HttpConnectSocketImpl、SocksSocketImpl，除了类型之外 Proxy 还指定了地址和端口；</li><li>默认 SocksSocketImpl 创建，并且需要在构造器中传入地址和端口，源码如下：</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// address 代表IP地址，port 表示套接字的端口</span><span class="token comment" spellcheck="true">// address 我们一般使用 InetSocketAddress，InetSocketAddress 有 ip+port、域名+port、InetAddress 等初始化方式</span><span class="token keyword">public</span> <span class="token function">Socket</span><span class="token punctuation">(</span>InetAddress address<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>address <span class="token operator">!=</span> null <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span> port<span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">,</span>         <span class="token punctuation">(</span>SocketAddress<span class="token punctuation">)</span> null<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里的 address 可以是 ip 地址或者域名，比如说 127.0.0.1 或者 <a href="http://www.wenhe.com。" target="_blank" rel="noopener">www.wenhe.com。</a></p><p>我们一起看一下这个构造器调用的 this 底层构造器的源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// stream 为 true 时，表示为stream socket 流套接字，使用 TCP 协议，比较稳定可靠，但占用资源多</span><span class="token comment" spellcheck="true">// stream 为 false 时，表示为datagram socket 数据报套接字，使用 UDP 协议，不稳定，但占用资源少</span><span class="token keyword">private</span> <span class="token function">Socket</span><span class="token punctuation">(</span>SocketAddress address<span class="token punctuation">,</span> SocketAddress localAddr<span class="token punctuation">,</span>               <span class="token keyword">boolean</span> stream<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token function">setImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// backward compatibility</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>address <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建 socket</span>        <span class="token function">createImpl</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果 ip 地址不为空，绑定地址</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>localAddr <span class="token operator">!=</span> null<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// create、bind、connect 也是 native 方法</span>            <span class="token function">bind</span><span class="token punctuation">(</span>localAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">connect</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> <span class="token operator">|</span> IllegalArgumentException <span class="token operator">|</span> SecurityException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ce<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">addSuppressed</span><span class="token punctuation">(</span>ce<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">throw</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从源码中可以看出：</p><ol><li>在构造 Socket 的时候，你可以选择 TCP 或 UDP，默认是 TCP；</li><li>如果构造 Socket 时，传入地址和端口，那么在构造的时候，就会尝试在此地址和端口上创建套接字；</li><li>Socket 的无参构造器只会初始化 SocksSocketImpl，并不会和当前地址端口绑定，需要我们手动的调用 connect 方法，才能使用当前地址和端口；</li><li>Socket 我们可以理解成网络沟通的语言层次的抽象，底层网络创建、连接和关闭，仍然是 TCP 或 UDP 本身网络协议指定的标准，Socket 只是使用 Java 语言做了一层封装，从而让我们更方便地使用。</li></ol><h4 id="9-3-3-connect-连接服务端"><a href="#9-3-3-connect-连接服务端" class="headerlink" title="9.3.3-connect 连接服务端"></a>9.3.3-connect 连接服务端</h4><p>connect 方法主要用于 Socket 客户端连接上服务端，如果底层是 TCP 层协议的话，就是通过三次握手和服务端建立连接，为客户端和服务端之间的通信做好准备，底层源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span>SocketAddress endpoint<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>connect 方法要求有两个入参，第一个入参是 SocketAddress，表示服务端的地址，我们可以使用 InetSocketAddress 进行初始化，比如：new InetSocketAddress(“<a href="http://www.wenhe.com”" target="_blank" rel="noopener">www.wenhe.com”</a>, 2000)。</p><p>第二入参是超时时间的意思（单位毫秒），表示客户端连接服务端的最大等待时间，如果超过当前等待时间，仍然没有成功建立连接，抛 SocketTimeoutException 异常，如果是 0 的话，表示无限等待。</p><h4 id="9-3-4-Socket-常用设置参数"><a href="#9-3-4-Socket-常用设置参数" class="headerlink" title="9.3.4-Socket 常用设置参数"></a>9.3.4-Socket 常用设置参数</h4><p>Socket 的常用设置参数在 SocketOptions 类中都可以找到，接下来我们来一一分析下，以下理解大多来自类注释和网络。</p><h5 id="1-setTcpNoDelay"><a href="#1-setTcpNoDelay" class="headerlink" title="1.setTcpNoDelay"></a>1.setTcpNoDelay</h5><p>此方法是用来设置 TCP_NODELAY 属性的，属性的注释是这样的：此设置仅仅对 TCP 生效，主要为了禁止使用 Nagle 算法，true 表示禁止使用，false 表示使用，默认是 false。</p><p>对于 Nagle 算法，我们引用维基百科上的解释：</p><blockquote><p><strong>纳格算法</strong>是以减少数据包发送量来增进 [TCP/IP] 网络的性能，它由约翰·纳格任职于<a href="https://zh.wikipedia.org/w/index.php?title=Ford_Aerospace&action=edit&redlink=1" target="_blank" rel="noopener">Ford Aerospace</a>时命名。</p><p>纳格的文件<a href="https://zh.wikipedia.org/wiki/納格算法#cite_note-1" target="_blank" rel="noopener">[注 1]</a>描述了他所谓的“小数据包问题”－某个应用程序不断地提交小单位的数据，且某些常只占1<a href="https://zh.wikipedia.org/wiki/字节" target="_blank" rel="noopener">字节</a>大小。因为<a href="https://zh.wikipedia.org/wiki/傳輸控制協議" target="_blank" rel="noopener">TCP</a>数据包具有40<a href="https://zh.wikipedia.org/wiki/字节" target="_blank" rel="noopener">字节</a>的标头信息（TCP与IPv4各占20字节），这导致了41字节大小的数据包只有1字节的可用信息，造成庞大的浪费。这种状况常常发生于<a href="https://zh.wikipedia.org/wiki/Telnet" target="_blank" rel="noopener">Telnet</a>工作阶段－大部分的键盘操作会产生1字节的数据并马上提交。更糟的是，在慢速的网络连线下，这类的数据包会大量地在同一时点传输，造成<a href="https://zh.wikipedia.org/w/index.php?title=壅塞碰撞&action=edit&redlink=1" target="_blank" rel="noopener">壅塞碰撞</a>。</p><p>纳格算法的工作方式是合并（<a href="https://zh.wiktionary.org/wiki/en:Coalesce" target="_blank" rel="noopener">coalescing</a>）一定数量的输出数据后一次提交。特别的是，只要有已提交的数据包尚未确认，发送者会持续缓冲数据包，直到累积一定数量的数据才提交。</p></blockquote><p>总结算法开启关闭的场景：</p><ol><li>如果 Nagle 算法关闭，对于小数据包，比如一次鼠标移动，点击，客户端都会立马和服务端交互，实时响应度非常高，但频繁的通信却很占用不少网络资源；</li><li>如果 Nagle 算法开启，算法会自动合并小数据包，等到达到一定大小（MSS）后，才会和服务端交互，优点是减少了通信次数，缺点是实时响应度会低一些。</li></ol><p>Socket 创建时，默认是开启 Nagle 算法的，可以根据实时性要求来选择是否关闭 Nagle 算法。</p><h5 id="2-setSoLinger"><a href="#2-setSoLinger" class="headerlink" title="2.setSoLinger"></a>2.setSoLinger</h5><p>setSoLinger 方法主要用来设置 SO_LINGER 属性值的。</p><p>注释上大概是这个意思：在我们调用 close 方法时，默认是直接返回的，但如果给 SO_LINGER 赋值，就会阻塞 close 方法，在 SO_LINGER 时间内，等待通信双方发送数据，如果时间过了，还未结束，将发送 TCP RST 强制关闭 TCP 。</p><p>我们看一下 setSoLinger 源码：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// on 为 false，表示不启用延时关闭，true 的话表示启用延时关闭</span><span class="token comment" spellcheck="true">// linger 为延时的时间，单位秒</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSoLinger</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> on<span class="token punctuation">,</span> <span class="token keyword">int</span> linger<span class="token punctuation">)</span> <span class="token keyword">throws</span> SocketException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 检查是否已经关闭</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SocketException</span><span class="token punctuation">(</span><span class="token string">"Socket is closed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 不启用延时关闭</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>on<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">getImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>SocketOptions<span class="token punctuation">.</span>SO_LINGER<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span>on<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 启用延时关闭，如果 linger 为 0，那么会立即关闭</span>    <span class="token comment" spellcheck="true">// linger 最大为 65535 秒，约 18 小时</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>linger <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"invalid value for SO_LINGER"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>linger <span class="token operator">></span> <span class="token number">65535</span><span class="token punctuation">)</span>            linger <span class="token operator">=</span> <span class="token number">65535</span><span class="token punctuation">;</span>        <span class="token function">getImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setOption</span><span class="token punctuation">(</span>SocketOptions<span class="token punctuation">.</span>SO_LINGER<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>linger<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="3-setOOBInline"><a href="#3-setOOBInline" class="headerlink" title="3.setOOBInline"></a>3.setOOBInline</h5><p>setOOBInline 方法主要使用设置 SO_OOBINLINE 属性。</p><p>注释上说：如果希望接受 TCP urgent data（TCP 紧急数据）的话，可以开启该选项，默认该选项是关闭的，我们可以通过 Socket#sendUrgentData 方法来发送紧急数据。</p><p>查询了很多资料，都建议尽可能的去避免设置该值，禁止使用 TCP 紧急数据。</p><h5 id="4-setSoTimeout"><a href="#4-setSoTimeout" class="headerlink" title="4.setSoTimeout"></a>4.setSoTimeout</h5><p>setSoTimeout 方法主要是用来设置 SO_TIMEOUT 属性的。</p><p>注释上说：用来设置阻塞操作的超时时间，阻塞操作主要有：</p><ol><li>ServerSocket.accept() 服务器等待客户端的连接；</li><li>SocketInputStream.read() 客户端或服务端读取输入超时；</li><li>DatagramSocket.receive()。</li></ol><p>我们必须在必须在阻塞操作之前设置该选项， 如果时间到了，操作仍然在阻塞，会抛出 InterruptedIOException 异常（Socket 会抛出 SocketTimeoutException 异常，不同的套接字抛出的异常可能不同）。</p><p>对于 Socket 来说，超时时间如果设置成 0，表示没有超时时间，阻塞时会无限等待。</p><h5 id="5-setSendBufferSize"><a href="#5-setSendBufferSize" class="headerlink" title="5.setSendBufferSize"></a>5.setSendBufferSize</h5><p>setSendBufferSize 方法主要用于设置 SO_SNDBUF 属性的，入参是 int 类型，表示设置发送端（输出端）的缓冲区的大小，单位是字节。</p><p>入参 size 必须大于 0，否则会抛出 IllegalArgumentException 异常。</p><p>一般我们都是采取默认的，如果值设置太小，很有可能导致网络交互过于频繁，如果值设置太大，那么交互变少，实时性就会变低。</p><h5 id="6-setReceiveBufferSize"><a href="#6-setReceiveBufferSize" class="headerlink" title="6.setReceiveBufferSize"></a>6.setReceiveBufferSize</h5><p>setReceiveBufferSize 方法主要用来设置 SO_RCVBUF 属性的，入参是 int 类型，表示设置接收端的缓冲区的大小，单位是字节。</p><p>入参 size 必须大于 0，否则会抛出 IllegalArgumentException 异常。</p><p>一般来说，在套接字建立连接之后，我们可以随意修改窗口大小，但是当窗口大小大于 64k 时，需要注意：</p><ol><li>必须在 Socket 连接客户端之前设置缓冲值；</li><li>必须在 ServerSocket 绑定本地地址之前设置缓冲值。</li></ol><h5 id="7-setKeepAlive"><a href="#7-setKeepAlive" class="headerlink" title="7.setKeepAlive"></a>7.setKeepAlive</h5><p>setKeepAlive 方法主要用来设置 SO_KEEPALIVE 属性，主要是用来探测服务端的套接字是否还是存活状态，默认设置是 false，不会触发这个功能。</p><p>如果 SO_KEEPALIVE 开启的话，TCP 自动触发功能：如果两小时内，客户端和服务端的套接字之间没有任何通信，TCP 会自动发送 keepalive 探测给对方，对方必须响应这个探测（假设是客户端发送给服务端），预测有三种情况：</p><ol><li>服务端使用预期的 ACK 回复，说明一切正常；</li><li>服务端回复 RST，表示服务端处于死机或者重启状态，终止连接；</li><li>没有得到服务端的响应（会尝试多次），表示套接字已经关闭了。</li></ol><h5 id="8-setReuseAddress"><a href="#8-setReuseAddress" class="headerlink" title="8.setReuseAddress"></a>8.setReuseAddress</h5><p>setReuseAddress 方法主要用来设置 SO_REUSEADDR 属性，入参是布尔值，默认是 false。</p><p>套接字在关闭之后，会等待一段时间之后才会真正的关闭，如果此时有新的套接字前来绑定同样的地址和端口时，如果 setReuseAddress 为 true 的话，就可以绑定成功，否则绑定失败。</p><h4 id="9-3-5-总结"><a href="#9-3-5-总结" class="headerlink" title="9.3.5-总结"></a>9.3.5-总结</h4><p>如果平时一直在做业务代码，Socket 可能用到的很少，但面试问到网络协议时，或者以后有机会做做中间件的时候，就会有大概率会接触到 Socket，所以多学学，作为知识储备也蛮好的。</p><h3 id="9-4-ServerSocket-源码及面试题"><a href="#9-4-ServerSocket-源码及面试题" class="headerlink" title="9.4-ServerSocket 源码及面试题"></a>9.4-ServerSocket 源码及面试题</h3><p>上一小节我们学习了 Socket，本文我们来看看服务端套接字 API：ServerSocket，本文学习完毕之后，我们就可以把客服端 Socket 和服务端 ServerSocket 串联起来，做一个真实的网络通信的 demo 了。</p><h4 id="9-4-1-类属性"><a href="#9-4-1-类属性" class="headerlink" title="9.4.1-类属性"></a>9.4.1-类属性</h4><p>ServerSocket 的主要作用，是作为服务端的套接字，接受客户端套接字传递过来的信息，并把响应回传给客户端，其属性非常简单，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> created <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 已创建</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> bound <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 绑定</span><span class="token keyword">private</span> <span class="token keyword">boolean</span> closed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 已关闭</span><span class="token comment" spellcheck="true">// 底层的功能都依靠 SocketImpl 来实现</span><span class="token keyword">private</span> SocketImpl impl<span class="token punctuation">;</span></code></pre><p>ServerSocket 和 Socket 一样，底层都是依靠 SocketImpl 的能力，而 SocketImpl 底层能力的实现基本上都是 native 方法实现的。</p><h4 id="9-4-2-初始化"><a href="#9-4-2-初始化" class="headerlink" title="9.4.2-初始化"></a>9.4.2-初始化</h4><p>初始化大概可以分成两类：无参构造器和有参构造器。</p><ol><li>无参构造器做的事情比较简单，只指定了 SocketImpl 为 SocksSocketImpl 类；</li><li>有参构造器有几种初始化的形式，我们一起来看一下参数最多的构造器的源码。</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ServerSocket</span><span class="token punctuation">(</span><span class="token keyword">int</span> port<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">,</span> InetAddress bindAddr<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 默认是 SocksSocketImpl 实现</span>    <span class="token function">setImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 端口必须大于 0，小于 65535</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>port <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> port <span class="token operator">></span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>                   <span class="token string">"Port value out of range: "</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 最大可连接数如果小于1，那么采取默认的 50</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>backlog <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>      backlog <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 底层 navtive 方法</span>        <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>bindAddr<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">,</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>SecurityException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>IOException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>入参 port 指的是 ServerSocket 需要绑定本地那个端口。</p><p>入参 backlog 指的是服务端接受客户端连接队列的最大长度，这里需要注意的是，这里并不是限制客户端连接的个数，我们在 JDK8 版本下做过实验，我们把服务端的 backlog 设置成 1，并且变慢服务端的处理速度，当服务端并发请求过来时，并不是第二个请求过来就拒绝连接，我们在实际工作中，最好也不要用 backlog 来限制客户端连接的个数。</p><p>还有点需要注意的是 backlog 小于 1 时，backlog 会被设置成默认的 50。</p><p>入参 InetAddress 表示 ip 地址。</p><h4 id="9-4-3-bind"><a href="#9-4-3-bind" class="headerlink" title="9.4.3-bind"></a>9.4.3-bind</h4><p>bind 方法主要作用是把 ServerSocket 绑定到本地的端口上，只有当我们使用无参构造器初始化 ServerSocket 时，才会用到这个方法，如果使用有参构造器的话，在初始化时就已经绑定到本地的端口上了。</p><p>配合无参构造器，一般我们这么用：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 进行初始化</span>ServerSocket serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 进行绑定</span>serverSocket<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">7007</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="9-4-4-accept"><a href="#9-4-4-accept" class="headerlink" title="9.4.4-accept"></a>9.4.4-accept</h4><p>accept 方法主要是用来 ServerSocket 接受来自客户端的套接字的，如果此时没有来自客户端的请求时，该方法就会一直阻塞，如果有通过 setSoTimeout 方法设置超时时间，那么 accept 只会在超时间内阻塞，过了超时时间就会抛出异常。</p><p>bind 和 accept 方法底层都是 native 方法实现，我们就不看源码了。</p><h4 id="9-4-5-面试题"><a href="#9-4-5-面试题" class="headerlink" title="9.4.5-面试题"></a>9.4.5-面试题</h4><h5 id="1-说说你对-Socket-和-ServerSocket-的理解？"><a href="#1-说说你对-Socket-和-ServerSocket-的理解？" class="headerlink" title="1.说说你对 Socket 和 ServerSocket 的理解？"></a>1.说说你对 Socket 和 ServerSocket 的理解？</h5><p>答：两者我们都可以称为套接字，底层基于 TCP/UDP 协议，套接字对底层协议进行了封装，让我们使用时更加方便，Socket 常被使用在客户端，用于向服务端请求数据和接受响应，ServerSocket 常用于在服务端，用于接受客户端的请求并进行处理，两者其底层使用都是依靠 SocketImpl 的子类的 native 方法。</p><h5 id="2-说说对-SocketOptions-中的-SO-TIMEOUT-的理解？"><a href="#2-说说对-SocketOptions-中的-SO-TIMEOUT-的理解？" class="headerlink" title="2.说说对 SocketOptions 中的 SO_TIMEOUT 的理解？"></a>2.说说对 SocketOptions 中的 SO_TIMEOUT 的理解？</h5><p>答：SocketOptions 类有很多属性设置，比如 SO_TIMEOUT 、SO_LINGER 等等，这些问题说一下自己的理解即可，可以参考 《Socket 源码及面试题》 中对各种属性的解析。</p><h5 id="3-在构造-Socket-的时候，我可以选择-TCP-或-UDP-么？应该如何选择？"><a href="#3-在构造-Socket-的时候，我可以选择-TCP-或-UDP-么？应该如何选择？" class="headerlink" title="3.在构造 Socket 的时候，我可以选择 TCP 或 UDP 么？应该如何选择？"></a>3.在构造 Socket 的时候，我可以选择 TCP 或 UDP 么？应该如何选择？</h5><p>答：可以的，Socket 有三个参数的构造器，第三个参数表示你想使用 TCP 还是 UDP。</p><h5 id="4-TCP-有自动检测服务端是否存活的机制么？有没有更好的办法？"><a href="#4-TCP-有自动检测服务端是否存活的机制么？有没有更好的办法？" class="headerlink" title="4.TCP 有自动检测服务端是否存活的机制么？有没有更好的办法？"></a>4.TCP 有自动检测服务端是否存活的机制么？有没有更好的办法？</h5><p>答：有的，我们可以通过 setKeepAlive 方法来激活该功能，如果两小时内，客户端和服务端的套接字之间没有任何通信，TCP 会自动发送 keepalive 探测给服务端，预测服务端有三种情况：</p><ol><li>服务端使用预期的 ACK 回复，说明一切正常；</li><li>服务端回复 RST，表示服务端处于死机或者重启状态，终止连接；</li><li>没有得到服务端的响应（会尝试多次），表示套接字已经关闭了。</li></ol><p>但我们并不建议使用这种方式，我们可以自己起一个定时任务，定时的访问服务端的特殊接口，如果服务端返回的数据和预期一致，说明服务端是存活的。</p><h4 id="9-4-6-总结"><a href="#9-4-6-总结" class="headerlink" title="9.4.6-总结"></a>9.4.6-总结</h4><p>Socket 和 ServerSocket 在源码方面没啥特别可说的地方，基本都是一些设置，底层实现都是 native 的方法，但面试官会从此延伸到一些网络协议方面的知识，因为这已经超出本专栏的范畴了，感兴趣的同学可以自行百度。</p><h3 id="9-5-工作实战：Socket-结合线程池的使用"><a href="#9-5-工作实战：Socket-结合线程池的使用" class="headerlink" title="9.5-工作实战：Socket 结合线程池的使用"></a>9.5-工作实战：Socket 结合线程池的使用</h3><p>Socket 面试最终题一般都是让你写一个简单的客户端和服务端通信的例子，本文就带大家一起来写这个 demo。</p><h4 id="9-5-1-要求"><a href="#9-5-1-要求" class="headerlink" title="9.5.1-要求"></a>9.5.1-要求</h4><ol><li>可以使用 Socket 和 ServiceSocket 以及其它 API；</li><li>写一个客户端和服务端之间 TCP 通信的例子；</li><li>服务端处理任务需要异步处理；</li><li>因为服务端处理能力很弱，只能同时处理 5 个请求，当第六个请求到达服务器时，需要服务器返回明确的错误信息：服务器太忙了，请稍后重试~。</li></ol><p>需求比较简单，唯一复杂的地方在于第四点，我们需要对客户端的请求量进行控制，首先我们需要确认的是，我们是无法控制客户端发送的请求数的，所以我们只能从服务端进行改造，比如从服务端进行限流。</p><p>有的同学可能很快想到，我们应该使用 ServerSocket 的 backlog 的属性，把其设置成 5，但我们在上一章中说到 backlog 并不能准确代表限制的客户端连接数，而且我们还要求服务端返回具体的错误信息，即使 backlog 生效，也只会返回固定的错误信息，不是我们定制的错误信息。</p><p>我们好好想想，线程池似乎可以做这个事情，我们可以把线程池的 coreSize 和 maxSize 都设置成 4，把队列大小设置成 1，这样服务端每次收到请求后，会先判断一下线程池中的队列有没有数据，如果有的话，说明当前服务器已经马上就要处理第五个请求了，当前请求就是第六个请求，应该被拒绝。</p><p>正好线程池的加入也可以满足第三点，服务端的任务可以异步执行。</p><h4 id="9-5-2-客户端代码"><a href="#9-5-2-客户端代码" class="headerlink" title="9.5.2-客户端代码"></a>9.5.2-客户端代码</h4><p>客户端的代码比较简单，直接向服务器请求数据即可，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SocketClient</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Integer SIZE <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadPoolExecutor socketPoll <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span>                                                                               365L<span class="token punctuation">,</span>                                                                               TimeUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">,</span>                                                                               <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 模拟客户端同时向服务端发送 6 条消息</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">6</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      socketPoll<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">7007</span><span class="token punctuation">,</span> <span class="token string">"nihao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * 发送tcp   *   * @param domainName 域名   * @param port       端口   * @param content    发送内容   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">send</span><span class="token punctuation">(</span>String domainName<span class="token punctuation">,</span> <span class="token keyword">int</span> port<span class="token punctuation">,</span> String content<span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"客户端开始运行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Socket socket <span class="token operator">=</span> null<span class="token punctuation">;</span>    OutputStream outputStream <span class="token operator">=</span> null<span class="token punctuation">;</span>    InputStreamReader isr <span class="token operator">=</span> null<span class="token punctuation">;</span>    BufferedReader br <span class="token operator">=</span> null<span class="token punctuation">;</span>    InputStream is <span class="token operator">=</span> null<span class="token punctuation">;</span>    StringBuffer response <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>domainName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 无参构造器初始化 Socket，默认底层协议是 TCP</span>      socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      socket<span class="token punctuation">.</span><span class="token function">setReuseAddress</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 客户端准备连接服务端，设置超时时间 10 秒</span>      socket<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>domainName<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TCPClient 成功和服务端建立连接"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 准备发送消息给服务端</span>      outputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 设置 UTF 编码，防止乱码</span>      <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> content<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 输出字节码</span>      <span class="token function">segmentWrite</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 关闭输出</span>      socket<span class="token punctuation">.</span><span class="token function">shutdownOutput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TCPClient 发送内容为 {}"</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 等待服务端的返回</span>      socket<span class="token punctuation">.</span><span class="token function">setSoTimeout</span><span class="token punctuation">(</span><span class="token number">50000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//50秒还没有得到数据，直接断开连接</span>      <span class="token comment" spellcheck="true">// 得到服务端的返回流</span>      is <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>      br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>isr<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 从流中读取返回值</span>      response <span class="token operator">=</span> <span class="token function">segmentRead</span><span class="token punctuation">(</span>br<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 关闭输入流</span>      socket<span class="token punctuation">.</span><span class="token function">shutdownInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//关闭各种流和套接字</span>      <span class="token function">close</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> outputStream<span class="token punctuation">,</span> isr<span class="token punctuation">,</span> br<span class="token punctuation">,</span> is<span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"TCPClient 接受到服务端返回的内容为 {}"</span><span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ConnectException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"TCPClient-send socket连接失败"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"socket连接失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"TCPClient-send unkown errror"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"socket连接失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">close</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span> outputStream<span class="token punctuation">,</span> isr<span class="token punctuation">,</span> br<span class="token punctuation">,</span> is<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// do nothing</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * 关闭各种流   *   * @param socket   * @param outputStream   * @param isr   * @param br   * @param is   * @throws IOException   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span>Socket socket<span class="token punctuation">,</span> OutputStream outputStream<span class="token punctuation">,</span> InputStreamReader isr<span class="token punctuation">,</span>                           BufferedReader br<span class="token punctuation">,</span> InputStream is<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> socket <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>socket<span class="token punctuation">.</span><span class="token function">isClosed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        socket<span class="token punctuation">.</span><span class="token function">shutdownOutput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        socket<span class="token punctuation">.</span><span class="token function">shutdownInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> outputStream<span class="token punctuation">)</span> <span class="token punctuation">{</span>      outputStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> br<span class="token punctuation">)</span> <span class="token punctuation">{</span>      br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> isr<span class="token punctuation">)</span> <span class="token punctuation">{</span>      isr<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> is<span class="token punctuation">)</span> <span class="token punctuation">{</span>      is<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * 分段读   *   * @param br   * @throws IOException   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> StringBuffer <span class="token function">segmentRead</span><span class="token punctuation">(</span>BufferedReader br<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String line<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>line <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sb<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * 分段写   *   * @param bytes   * @param outputStream   * @throws IOException   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">segmentWrite</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">,</span> OutputStream outputStream<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> start<span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> end <span class="token operator">!=</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      start <span class="token operator">=</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> i <span class="token operator">*</span> SIZE<span class="token punctuation">;</span>      end <span class="token operator">=</span> length <span class="token operator">></span> SIZE <span class="token operator">?</span> start <span class="token operator">+</span> SIZE <span class="token operator">:</span> bytes<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      length <span class="token operator">-=</span> SIZE<span class="token punctuation">;</span>      outputStream<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>      outputStream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>客户端代码中我们也用到了线程池，主要是为了并发模拟客户端一次性发送 6 个请求，按照预期服务端在处理第六个请求的时候，会返回特定的错误信息给客户端。</p><p>以上代码主要方法是 send 方法，主要处理像服务端发送数据，并处理服务端的响应。</p><h4 id="9-5-3-服务端代码"><a href="#9-5-3-服务端代码" class="headerlink" title="9.5.3-服务端代码"></a>9.5.3-服务端代码</h4><p>服务端的逻辑分成两个部分，第一部分是控制客户端的请求个数，当超过服务端的能力时，拒绝新的请求，当服务端能力可响应时，放入新的请求，第二部分是服务端任务的执行逻辑。</p><h5 id="1-对客户端请求进行控制"><a href="#1-对客户端请求进行控制" class="headerlink" title="1.对客户端请求进行控制"></a>1.对客户端请求进行控制</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SocketServiceStart</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/**   * 服务端的线程池，两个作用   * 1：让服务端的任务可以异步执行   * 2：管理可同时处理的服务端的请求数   */</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadPoolExecutor collectPoll <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span>                                                                               365L<span class="token punctuation">,</span>                                                                               TimeUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">,</span>                                                                               <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>                                                                                   <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@Test</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/**   * 启动服务端   */</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"SocketServiceStart 服务端开始启动"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// backlog  serviceSocket处理阻塞时，客户端最大的可创建连接数，超过客户端连接不上</span>      <span class="token comment" spellcheck="true">// 当线程池能力处理满了之后，我们希望尽量阻塞客户端的连接</span><span class="token comment" spellcheck="true">//      ServerSocket serverSocket = new ServerSocket(7007,1,null);</span>      <span class="token comment" spellcheck="true">// 初始化服务端</span>      ServerSocket serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      serverSocket<span class="token punctuation">.</span><span class="token function">setReuseAddress</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//      serverSocket.bind(new InetSocketAddress(InetAddress.getLocalHost().getHostAddress(), 80));</span>      serverSocket<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span> <span class="token number">7007</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"SocketServiceStart 服务端启动成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 自旋，让客户端一直在取客户端的请求，如果客户端暂时没有请求，会一直阻塞</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 接受客户端的请求</span>        Socket socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果队列中有数据了，说明服务端已经到了并发处理的极限了，此时需要返回客户端有意义的信息</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>collectPoll<span class="token punctuation">.</span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"SocketServiceStart 服务端处理能力到顶，需要控制客户端的请求"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//返回处理结果给客户端</span>          <span class="token function">rejectRequest</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 异步处理客户端提交上来的任务</span>          collectPoll<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SocketService</span><span class="token punctuation">(</span>socket<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>          socket<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"SocketServiceStart - start error"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"SocketServiceStart - start error"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回特定的错误码给客户端</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rejectRequest</span><span class="token punctuation">(</span>Socket socket<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    OutputStream outputStream <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>      outputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token string">"服务器太忙了，请稍后重试~"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      SocketClient<span class="token punctuation">.</span><span class="token function">segmentWrite</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>      socket<span class="token punctuation">.</span><span class="token function">shutdownOutput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//关闭流</span>      SocketClient<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span>outputStream<span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们使用 collectPoll.getQueue().size() &gt;= 1 来判断目前服务端是否已经到达处理的极限了，如果队列中有一个任务正在排队，说明当前服务端已经超负荷运行了，新的请求应该拒绝掉，如果队列中没有数据，说明服务端还可以接受新的请求。</p><p>以上代码注释详细，就不累赘说了。</p><h5 id="2-服务端任务的处理逻辑"><a href="#2-服务端任务的处理逻辑" class="headerlink" title="2.服务端任务的处理逻辑"></a>2.服务端任务的处理逻辑</h5><p>服务端的处理逻辑比较简单，主要步骤是：从客户端的 Socket 中读取输入，进行处理，把响应返回给客户端。</p><p>我们使用线程沉睡 2 秒来模拟服务端的处理逻辑，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SocketService</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> Socket socket<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">SocketService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token function">SocketService</span><span class="token punctuation">(</span>Socket socket<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>socket <span class="token operator">=</span> socket<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"SocketService 服务端任务开始执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    OutputStream outputStream <span class="token operator">=</span> null<span class="token punctuation">;</span>    InputStream is <span class="token operator">=</span> null<span class="token punctuation">;</span>    InputStreamReader isr <span class="token operator">=</span> null<span class="token punctuation">;</span>    BufferedReader br <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//接受消息</span>      socket<span class="token punctuation">.</span><span class="token function">setSoTimeout</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 10秒还没有得到数据，直接断开连接</span>      is <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      isr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>is<span class="token punctuation">,</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>isr<span class="token punctuation">)</span><span class="token punctuation">;</span>      StringBuffer sb <span class="token operator">=</span> SocketClient<span class="token punctuation">.</span><span class="token function">segmentRead</span><span class="token punctuation">(</span>br<span class="token punctuation">)</span><span class="token punctuation">;</span>      socket<span class="token punctuation">.</span><span class="token function">shutdownInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"SocketService accept info is {}"</span><span class="token punctuation">,</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//服务端处理 模拟服务端处理耗时</span>      Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      String response  <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//返回处理结果给客户端</span>      outputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      SocketClient<span class="token punctuation">.</span><span class="token function">segmentWrite</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>      socket<span class="token punctuation">.</span><span class="token function">shutdownOutput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//关闭流</span>      SocketClient<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span>outputStream<span class="token punctuation">,</span>isr<span class="token punctuation">,</span>br<span class="token punctuation">,</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"SocketService 服务端任务执行完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"SocketService IOException"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"SocketService Exception"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        SocketClient<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>socket<span class="token punctuation">,</span>outputStream<span class="token punctuation">,</span>isr<span class="token punctuation">,</span>br<span class="token punctuation">,</span>is<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"SocketService IOException"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="9-5-4-测试"><a href="#9-5-4-测试" class="headerlink" title="9.5.4-测试"></a>9.5.4-测试</h4><p>测试的时候，我们必须先启动服务端，然后再启动客户端，首先我们启动服务端，打印日志如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Socket-Demo%E6%97%A5%E5%BF%97.jpeg" alt="Socket-Demo日志"></p><p>接着我们启动客户端，打印日志如下：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Socket-Demo%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A5%E5%BF%97.jpeg" alt="Socket-Demo客户端日志"></p><p>我们最后看一下服务端的运行日志：</p><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Socket-Demo%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%97%A5%E5%BF%97.jpeg" alt="Socket-Demo服务端日志"></p><p>从以上运行结果中，我们可以看出得出的结果是符合我们预期的，服务端在请求高峰时，能够并发处理5个请求，其余请求可以用正确的提示进行拒绝。</p><h4 id="9-5-5-总结"><a href="#9-5-5-总结" class="headerlink" title="9.5.5-总结"></a>9.5.5-总结</h4><p>所以代码集中在 SocketClient、SocketServiceStart、SocketService 中，启动的顺序为先启动 SocketServiceStart，后运行 SocketClient，感兴趣的同学可以自己 debug 下，加深印象。</p>]]></content>
      
      
      <categories>
          
          <category> Java源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS学习笔记</title>
      <link href="/2020/01/18/css-xue-xi-bi-ji/"/>
      <url>/2020/01/18/css-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="1-1什么是CSS？"><a href="#1-1什么是CSS？" class="headerlink" title="1.1什么是CSS？"></a>1.1什么是CSS？</h2><p>css是指层叠样式表，样式定义如何显示html元素</p><p>语法</p><pre class=" language-css"><code class="language-css"><span class="token selector">选择器</span><span class="token punctuation">{</span>声明<span class="token number">1</span>；声明<span class="token number">2</span>；<span class="token punctuation">}</span></code></pre><p><strong>css</strong>主要用于设置HTML页面中的文本内容（）字体、大小、对齐方式等）、图形的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样。</p><h2 id="1-2引入css样式表"><a href="#1-2引入css样式表" class="headerlink" title="1.2引入css样式表"></a>1.2引入css样式表</h2><p>1.内部样式表（内嵌式）</p><p>内嵌式是将css代码集中写在HTML代码的头部head标签中，并用style标签定义。</p><pre><code>&lt;head&gt; &lt;title&gt;例子&lt;/title&gt;&lt;style  type=&quot;text/css&quot;&gt;选择器{属性1：属性值1；属性2：属性值2：}&lt;/style&gt;&lt;/head&gt;</code></pre><p>2.行内式（<strong>内联样式</strong>）</p><p>是通过标签的style属性来设置元素的样式</p><p>&lt;标签名  style=“属性1：属性值1；属性2：属性值2”&gt; 内容&lt;/标签名&gt;</p><p>3.外部样式表（外链式）</p><p>嵌入式是将所有的样式放在一个或多个以.css为扩展名的外部样式表文件中，通过<link>标签将外部样式表文件链接到HTML文档中。</p><pre><code>&lt;hesd&gt;    &lt;link  href=&quot;CSS文件的路径&quot;  rel=“style sheet”/&gt;    &lt;/head&gt;</code></pre><h2 id="1-3-CSS的选择器"><a href="#1-3-CSS的选择器" class="headerlink" title="1.3 CSS的选择器"></a>1.3 CSS的选择器</h2><ol><li><p>元素选择器（标签选择器）</p><p>指用HTML元素名（或标签名）作为选择器，按标签名分类，为页面中某一类标签指定统一的CSS样式</p><p>格式如下： 标签名（元素名）{属性1：属性值1；属性2：属性值2；}</p></li></ol><ol start="2"><li><p>类选择器</p><p>类选择器允许以一种独立于文档元素的方式来指定样式。</p><p>该选择器可以单独使用，也可以与其他元素结合使用。</p><p>格式：.类名{属性1：属性值1；属性2：属性值2}</p><p>调用时&lt;标签名  class=“类名&gt;即可</p></li></ol><ol start="3"><li><p>id选择器</p><p>id选择器使用”#“进行标识，格式如下：</p><p>#id名{属性1：属性值1；属性2：属性值2}</p><p>id名即为HTML元素的id属性值，元素的id是唯一的。</p><p>类选择器可以多次重复使用，而id选择器是唯一的。</p></li></ol><ol start="4"><li><p>通配符选择器</p><p>通配符选择器用”*“号表示，是所有选择器中范围最广的，能匹配页面中所有的元素。</p><p>  *{属性1:属性值1；属性2：属性值2；}</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML学习笔记</title>
      <link href="/2020/01/18/html-xue-xi-bi-ji/"/>
      <url>/2020/01/18/html-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML学习笔记"><a href="#HTML学习笔记" class="headerlink" title="HTML学习笔记"></a>HTML学习笔记</h1><h1 id="1-HTML初识"><a href="#1-HTML初识" class="headerlink" title="1-HTML初识"></a>1-HTML初识</h1><p>超文本标记语言，主要通过HTML标签对网页中的文本、图片、声音等内容进行描述。</p><h2 id="1-1-HTML-标签"><a href="#1-1-HTML-标签" class="headerlink" title="1.1-HTML 标签"></a><strong>1.1-HTML 标签</strong></h2><p>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。</p><p>HTML 标签是由尖括号包围的关键词<br>HTML 标签通常是成对出现的<br>标签对中的第一个标签是开始标签，第二个标签是结束标签<br>开始和结束标签也被称为开放标签和闭合标签</p><h2 id="1-2-语法骨架"><a href="#1-2-语法骨架" class="headerlink" title="1.2-语法骨架"></a>1.2-语法骨架</h2><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>      根标签   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>   头标签      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>   标题标签   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  主题标签   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>html标签：作用：所有html中标签的一个根节点<br>head标签：作用：用于存放：title,metal,base,style,script,link 注意在head标签中必须设置title标签<br>title标签 ：作用：让页面拥有一个属于自己的标题<br>body标签：作用：页面的主体部分，用于存放所有的html标签：p,h,a,b,u,i,s,em,dei,ins,strong,img</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span> 声明为html文档<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span> 是html页面的根元素<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span> 包含了文档的元（meta）数据，如<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span>  <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 定义网页编码格式为utf-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span> 描述了文档的标题<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span> HTML 文档的主体（可见的页面内容）<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span> 定义一个大的段落<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>换行<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>XXX<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>链接</code></pre><h2 id="1-3-HTML属性"><a href="#1-3-HTML属性" class="headerlink" title="1.3-HTML属性"></a>1.3-HTML属性</h2><p><code>class</code>—为html元素定义一个或多个类名（类名从样式文件引入）</p><p><code>id</code>—定义元素的唯一id</p><p><code>style</code>—规定元素的行内样式</p><p><code>title</code>—描述元素的额外信息（作为工具条使用）</p><p>HYML注释—<!--XXXX--></p><h1 id="2-HTML-基本标签"><a href="#2-HTML-基本标签" class="headerlink" title="2-HTML 基本标签"></a>2-HTML 基本标签</h1><pre><code>&lt;h1&gt;&lt;h2&gt;...&lt;h6&gt; 标题&lt;hr1&gt;——水平线&lt;font&gt;——字体&lt;font size=&quot;2&quot; color-&quot;red&quot; face=&quot;微软雅黑&quot;&gt;&lt;b&gt;&lt;i&gt;——格式化标签 &lt;b&gt;粗体 &lt;i&gt;斜体&lt;ul&gt;&lt;01&gt;——列表标签 &lt;li&gt;——列表标签内的每一列&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;——无序列表&lt;01&gt;&lt;li&gt;&lt;/li&gt;&lt;101&gt;——有序列表&lt;a&gt;——超链接标签 target——定义文档链接在何处显示&lt;a heaf=&quot;www.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;XXX&quot;&gt;XXX&lt;/a&gt;</code></pre><h2 id="2-1-—图片标签"><a href="#2-1-—图片标签" class="headerlink" title="2.1-—图片标签"></a>2.1-<img>—图片标签</h2><p><strong>属性</strong></p><p><code>src</code>：图片的路径地址（必写属性）</p><p><code>width</code>：宽度      height：高度</p><p><code>title</code>：提示文本（鼠标悬停在图片上方会出现的提示信息）</p><p><code>alt</code>：替换文本（图片加载失败时会出现的文字信息）</p><p><code>border</code>：边框（只能定义边框的粗细）</p><h2 id="2-2-—表格标签"><a href="#2-2-—表格标签" class="headerlink" title="2.2-—表格标签"></a>2.2-<table><th></th><tr><td>—表格标签</td></tr></table></h2><p><code>&lt;table&gt;</code>父标签，相当于整个表格的容器</p><p><strong>属性</strong></p><p><code>border</code>：边框的宽度</p><p><code>cellpadding</code>：单元格边沿与其内容之间的空白</p><p><code>cellspaceling</code>：单元格之间的空白</p><p><code>bgcolor</code>：表格中的背景颜色</p><p><code>height</code>：表格的高度</p><p><code>width</code>：表格的宽度</p><p><code>&lt;th&gt;</code>表格表头，单元格内容默认居中加粗</p><p><code>&lt;tr&gt;</code>标签用于定义行</p><p><code>&lt;td&gt;</code>标签用于定义表格的单元格（列）</p><p><code>&lt;div&gt;</code>—块级元素，定义了文档的区域，用于组合其他html元素的容器</p><p><code>&lt;span&gt;</code>—内联元素，用来组合文档中的行内元素</p><h2 id="2-3-表单标签"><a href="#2-3-表单标签" class="headerlink" title="2.3-表单标签"></a>2.3-<from>表单标签</from></h2><p><strong>把表单中的数据提交给远端的服务器</strong></p><p>表单元素是允许用户在表单中输入内容： 如：文本域（texttarea） 下拉列表、单选框（radio-buttons）、复选框（checkboxes）。表格中使用的输入元素为 <code>&lt;input&gt;</code></p><p><code>&lt;form&gt;</code>表单标签在浏览器上没有任何显示，但所有需要提交到服务器的数据都需要存放在表单标签中</p><p><strong>action属性：</strong>请求路径，确认表单提交到服务器的地址。</p><p><strong>method 属性：</strong>请求方式 如：GET PODRT。</p><h2 id="2-4-输入域标签"><a href="#2-4-输入域标签" class="headerlink" title="2.4-输入域标签"></a>2.4-<input>输入域标签</h2><p><input>标签用于获得用户的输入信息，type属性值不同，输入类型不同。</p><ol><li><p><strong>type属性</strong></p><p>—text：文本框，单行的输入字段，默认宽度为20个字符</p><p>—password：密码框，密码字段</p><p>—radio：单选框，表示只能选择一组互斥选项按钮的一个</p><p>—submit：提交按钮，将表单数据发送到服务器</p><p>—checkbox：复选框</p><p>—file：文件上传组件</p><p>—hidden：隐藏字段</p><p>—reset：重置按钮</p><p>—image：图形提交按钮</p><p>—button：普通按钮，常用于与JavaScript结合使用</p></li><li><p><strong>name属性</strong>：如果需要将表单数据提交到服务器，必须提供name属性值。服务器通过name属性值获得提交的数据。</p></li><li><p><strong>value属性</strong>：设置input标签的默认值，注submit和reset为按钮显示</p></li><li><p><strong>size属性</strong>：input宽度大小</p></li><li><p><strong>checked属性</strong>：单选框或复选框被选中</p></li><li><p><strong>readonly</strong>：是否只读，数据不会被提交</p></li><li><p><strong>disabled</strong>：是否可用，数据不会被提交</p></li><li><p><strong>maxlength</strong>：允许输入的最大长度</p></li><li><pre><code>&lt;select&gt;x下拉列表—可用单选和多选，需要子标签&lt;option&gt;制定列表项——name属性:发送服务器的名称——multipe属性:不写默认单选，取值为“multiple”表示多选——size属性：多选时，课件选项的数目—&lt;option&gt;子标签：下拉列表中的一个选项注：一般option要给value属性值，如果不给默认把option文本内容发送到服务器selected：勾选当前列表项value：发送到服务器的选项值</code></pre></li></ol><h2 id="2-5文本域标签"><a href="#2-5文本域标签" class="headerlink" title="2.5文本域标签"></a>2.5<textared>文本域标签</textared></h2><p>—cols属性：文本域的列数</p><p>—rows属性：文本域的行数</p><pre><code>&lt;label&gt;—定义input元素的标注&lt;nav&gt;—定义导航链接</code></pre><h2 id="2-6常用事件属性"><a href="#2-6常用事件属性" class="headerlink" title="2.6常用事件属性"></a>2.6常用事件属性</h2><ol><li><p><strong>窗口事件</strong></p><p>onafterprint：在文档打印之后运行</p><p>onbeforeprint:在文档打印之前运行</p><p>onload：在文档加载时运行</p><p>onresize：在调整窗口大小时运行</p><p>onunload：当用户离开文档时运行</p></li></ol><ol start="2"><li><p><strong><em>表单事件</em></strong></p><p>onbur：当元素失去焦点时运行</p><p>onchange：当元素改变时运行</p><p>onfocus：当元素获得焦点时运行</p><p>onselect：当选取元素时运行</p><p>onsubmit：当提交表单时运行</p></li></ol><ol start="3"><li><p><strong>键盘事件</strong></p><p>onkeydown：当按下按键时运行</p><p>onkeypress：当按下并松开按键时运行</p><p>onkeyup：当松开案件时运行</p></li></ol><ol start="4"><li><p><strong>鼠标事件</strong></p><p>onclick：当单击鼠标时运行</p><p>ondbclick：当双击鼠标时运行</p><p>onmousedown：当按下鼠标按钮时</p><p>onmousemove：当鼠标指针移动时</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud学习笔记1</title>
      <link href="/2020/01/17/springcloud-xue-xi-bi-ji-yi/"/>
      <url>/2020/01/17/springcloud-xue-xi-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud学习笔记"><a href="#SpringCloud学习笔记" class="headerlink" title="SpringCloud学习笔记"></a>SpringCloud学习笔记</h1><h2 id="1-架构演进和分布式系统基础"><a href="#1-架构演进和分布式系统基础" class="headerlink" title="1-架构演进和分布式系统基础"></a>1-架构演进和分布式系统基础</h2><h3 id="1-1-单体应用"><a href="#1-1-单体应用" class="headerlink" title="1.1-单体应用"></a>1.1-单体应用</h3><ol><li>把所有的功能集中在同一系统中实现，应用程序的全部功能被一起打包作为单个单元或应用程序</li><li>这个单元可以是JAR、WAR、EAR,或其他一些归档格式，运行在同一个 tomcat 进程中</li><li>其全部集成在一个单一的单元.</li><li><strong>优点：</strong><ul><li>方便调试，代码都在一起</li><li>易于部署，所有服务都在本地容器内</li><li>中小型项目可以快速迭代，不需要太多资源</li></ul></li><li><strong>缺点：</strong><ul><li>可复用性差：服务被打包在应用中，功能不易复用</li><li>系统启动慢：一个进程包含了所有的业务逻辑，涉及到的启动模块过多，导致系统的启动、重启时间周期过长 </li><li>线上问题修复周期长：任何一个线上问题修复需要对整个应用系统进行全面升级。</li><li>系统扩展性比较差：增加新东西的时候不能针对单个点增加，全局性的增加.牵一发而动全身。</li><li>技术债务逐渐上升：随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务，并且越积越多。</li><li>阻碍技术创新：单体应用往往使用统一的技术平台或方案解决所有问题，团队的每个成员都必须使用相同的开发语言和架构，想要引入新的框架或技术平台非常困难。</li></ul></li></ol><h3 id="1-2-微服务应用"><a href="#1-2-微服务应用" class="headerlink" title="1.2-微服务应用"></a>1.2-微服务应用</h3><ol><li>微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法</li><li>每个小型服务都运行在自己的进程中，并经常采用HTTP资源API轻量的机制来相互通信</li><li>这些服务围绕业务功能进行构建，并能通过全自动的部署机制来进行独立部署</li><li>一个微服务只关注某个特定的功能</li><li><strong>优点：</strong><ul><li>易于开发和维护：一个微服务只会关注一个特定的业务功能，所以业务清晰、代码量较少。开发和维护单个微服务相对简单，每个服务为独立的业务开发，一个微服务只关注某个特定的功能，如订单管理、用户管理等</li><li>单个微服务启动较快，每个微服务可独立运行在自己的进程里</li><li>局部修改容易部署：单体应用只要有修改，就得重新部署整个应用。一般来说，对某个微服务进行修改，只需要重新部署这个服务即可</li><li>技术栈不受限制：在微服务架构中，可以结合项目业务及团队的特点，合理的选择技术栈</li><li>按需伸缩：可根据需求，实现细粒度的扩展</li></ul></li><li><strong>缺点：</strong><ul><li>运维要求高：更多的服务意味着要投入更多的运维</li><li>分布式固有的复杂性：使用微服务构建的是分布式系统。对于一个分布式系统，系统容错、网络延迟、分布式事务等都会带来巨大的问题。</li><li>接口调整成本高：微服务之间通过接口进行通信。如果修改某一个微服务的API，可能所有用到这个接口的微服务都需要进行调整</li></ul></li></ol><h3 id="1-3-集群、分布式和微服务的区别"><a href="#1-3-集群、分布式和微服务的区别" class="headerlink" title="1.3-集群、分布式和微服务的区别"></a>1.3-集群、分布式和微服务的区别</h3><ol><li>分布式：<ul><li>一个业务分拆多个子业务，部署在不同的服务器上</li><li>分布式中的每一个节点，都可以做集群</li><li>分布式需要做好事务管理</li><li>区别分布式的方式是根据不同机器不同业务。</li></ul></li><li>微服务：<ul><li>微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成</li><li>系统中的各个微服务可被独立部署，各个微服务之间是松耦合的</li><li>每个微服务仅关注于完成一件任务并很好地完成该任务</li></ul></li><li>集群：<ul><li>同一个业务，部署在多个服务器上        </li><li>区别集群的方式是根据部署多台服务器业务是否相同</li><li>集群模式需要做好session共享，确保在不同服务器切换的过程中不会因为没有获取到session而中止退出服务</li><li>一般配置Nginx的负载容器实现：静态资源缓存、Session共享可以附带实现，Nginx支持5000个并发量</li></ul></li><li>分布式是否属于微服务<ul><li>不一定，如果一个很大应用，拆分成三个应用，但还是很庞大，虽然分布式了，但不是微服务。微服务核心要素是微小</li><li>微服务的设计是为了不因为某个模块的升级和BUG影响现有的系统业务</li><li>微服务的应用不一定是分散在多个服务器上，也可以是同一个服务器     </li><li>微服务架构是分布式服务架构的子集</li><li>分布式：分散压力。微服务：分散能力</li></ul></li><li>单应用与集群<ul><li>整个项目所有的服务都由这台服务器提供。这就是单机结构</li><li>单机复制几份，这样就构成了一个“集群”</li><li>集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群</li><li>每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍</li></ul></li></ol><h2 id="2-微服务核心基础"><a href="#2-微服务核心基础" class="headerlink" title="2-微服务核心基础"></a>2-微服务核心基础</h2><h3 id="2-1-微服务架构"><a href="#2-1-微服务架构" class="headerlink" title="2.1-微服务架构"></a>2.1-微服务架构</h3><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务于服务间采用轻量级的通信机制互相沟通（通常是基于 HTTP 的 RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p><ul><li>分布式：不同的功能模块部署在不同的服务器上，减轻网站高并发带来的压力。</li><li>集群：多台服务器上部署相同应用构成一个集群，通过负载均衡共同向外提供服务。</li><li>微服务：微服务架构模式就是将web应用拆分为一系列小的服务模块，这些模块可以独立地编译、部署，并通过各自暴露的API接口通讯，共同组成一个web应用。</li><li>SpringCloud是基于SpringBoot的一整套微服务框架，提供了一系列可配置的组件，如<strong>配置管理</strong>、<strong>服务发现</strong>、<strong>负载均衡</strong>、<strong>熔断器</strong>、<strong>断路器</strong>、<strong>智能路由</strong>、<strong>微代理</strong>、<strong>控制总线</strong>、<strong>全局锁</strong>、<strong>决策竞选</strong>、<strong>分布式会话</strong>和<strong>集群状态管理</strong>等。</li></ul><h3 id="2-2-什么是SpringCloud？"><a href="#2-2-什么是SpringCloud？" class="headerlink" title="2.2-什么是SpringCloud？"></a>2.2-什么是SpringCloud？</h3><p>Spring Cloud是一个基于Spring Boot实现的服务工具治理包，专注于全局的服务治理框架。</p><p>Spring Cloud 是一系列框架的有序集合。<br> 它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。<br> Spring 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/SpringCloud%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84.png" alt="SpringCloud组件架构"></p><ul><li>所有请求都通过API网关来访问内部服务；</li><li>网关接受请求后，从注册中心获取可用服务模块；</li><li>由Ribbon进行负载均衡后，分发到后台的具体实例；</li><li>各个服务模块之间通过Feign进行通信处理业务；</li><li>Hystrix负责处理服务超时熔断；</li><li>Turbine监控服务间的调用和熔断相关指标。</li></ul><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/SpringCloud%E6%B5%81%E7%A8%8B.png" alt="SpringCloud流程"></p><h2 id="2-3-微服务技术"><a href="#2-3-微服务技术" class="headerlink" title="2.3-微服务技术"></a>2.3-微服务技术</h2><ul><li><p>Spring Cloud Config ：服务配置中心，将所有的服务的配置文件放到本地仓库或者远程仓库，配置中心负责读取仓库的配置文件，其他服务向配置中心读取配置。SpringCloud Config 使得服务的配置统一管理 并可以在不人为重启服务的情况下进行配置文件的刷新。</p></li><li><p>Spring Cloud Netflix ：它是通过包装了 Netflix 公司的微服务组件实现的，也是SpringCloud 核心的核心组件，包括 Eureka Hystrix Zuul Archaius 等。</p></li><li><p>Eureka ：服务注册和发现组件，可以细分为eureka server（服务注册中心）和eureka client（服务注册客户端，所有其他需注册到服务注册中心的微服务组件都可以看做是服务注册客户端）</p><ul><li>Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。</li><li>Eureka Client是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除（默认90秒）Eureka Server之间将会通过复制的方式完成数据的同步。Eureka还提供了客户端缓存的机制，即使所有的Eureka Server都挂掉了，客户端依然可以利用缓存中的信息消费其它服务的API。综上，Eureka通过心跳检测、健康检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性。</li></ul></li><li><p>Hystrix ：熔断器组件 Hystrix 通过控制服务的 API 接口的熔断来转移故障，防止微服务系统发生雪崩效应。另外， Hystrix 能够起到服务限流和服务降级的作用。使用Hystrix Dashboard 组件监控单个服务的熔断器的状态，使用 Turbine 组件可以聚合多，现了断路器的模式。“断路器” 本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p></li><li><p>Zuul ：（路由转发+过滤器）能路由网关组 Netflix Zuul能够起到智能路由和请求过滤的作用，是服务接口统一暴露 关键模块，也是安全验证、权限控制的一道门；Zuul路由是微服务架构的不可或缺的一部分，提供动态路由、监控、弹性、安全等的边缘服务，Zuul 是 Netflix 出品的一个基于 JVM 路由和服务端的负载均衡器。</p></li><li><p>Feign 声明式远程调度组件，Feign 是一个声明式的 Web Service 客户端，它的目的就是让 Web Service 调用更加简单。它整合了 Ribbon 和 Hystrix，从而让我们不再需要显式地使用这两个组件。Feign 还提供了 HTTP 请求的模板，通过编写简单的接口和插入注解，我们就可以定义好 HTTP 请求的参数、格式、地址等信息。接下来，Feign 会完全代理 HTTP 的请求，我们只需要像调用方法一样调用它就可以完成服务请求。</p><p>Feign 具有如下特性：</p><ul><li>可插拔的注解支持，包括 Feign 注解和 JAX-RS 注解</li><li>支持可插拔的 HTTP 编码器和解码器</li><li>支持 Hystrix 和它的 Fallback</li><li>支持 Ribbon 的负载均衡</li><li>支持 HTTP 请求和响应的压缩</li></ul></li><li><p>Ribbon 负载均衡组件，为REST客户端实现负载均衡。</p></li><li><p>Archaius ：配置管理 API 的组件， 一个基于 Java 的配置管理库主要用于多配置的动态获取。Spring Cloud Bus 消息总线组件，常和 Spring Cloud Config 配合使用，用于动态新服务的配置。</p></li><li><p>Spring Cloud Sleuth ：服务链路追踪组件，封装了 Dapper Zipkin, Kibina 等组件，可以实时监控服务的链路调用情况。</p></li><li><p>Spring Cloud Data Flow ：大数据操作组件，Spring Cloud Data Flow SpringXD替代品，也是 个混合计算的模型，可以通过命令行的方式操作数据流</p></li><li><p>Spring Cloud Security 安全模块组件，是对 Spring Security 封装，通常配合 0Auth2使用来保护微服务系统的安全。</p></li><li><p>Spring Cloud Consule ：该组件是 Spring Cloud Consul 的封装，和 ureka 类似，它是一个服务注册和发现组件</p></li><li><p>Spring Cloud Zookeeper 该组件是 Spring Cloud Zookeeper 封装，和 Eureka Consul相似，用于服务的注册和发现</p></li><li><p>Spring Cloud Stream ：数据流操作组件，可以封装 Redis RabbitMQ Kafka 等组件实现发送和接收消息等。</p></li><li><p>Spring Cloud CLI ：该组件是 Spring Cloud Spring Boot CLI 的封装，可以让用户以命令行方式快速运行和搭建容器</p></li><li><p>Spring Cloud Task 该组件基于 Spring Task ，提供了任务调度和任务管理的功能。　</p></li><li><p>Spring Cloud Connectors 用于 Paas 云平台连接到后端。</p></li></ul><h2 id="3-Dubbo和SpringCloud"><a href="#3-Dubbo和SpringCloud" class="headerlink" title="3-Dubbo和SpringCloud"></a>3-Dubbo和SpringCloud</h2><ol><li><p><strong>dubbo:</strong> zookeeper + dubbo + springmvc/springboot<br>官方地址：<a href="http://dubbo.apache.org/#!/?lang=zh-cn" target="_blank" rel="noopener">http://dubbo.apache.org/#!/?lang=zh-cn</a><br>配套：</p><p>​    通信方式：rpc<br>​    注册中心：zookeper/redis<br>​    配置中心：diamond</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/Dubbo%E7%BB%84%E4%BB%B6.png" alt="Dubbo"></p></li><li><p>Dubbo核心组件</p><ul><li><strong>Provider：</strong>暴露服务的提供方，可以通过 jar 或者容器的方式启动服务。</li><li><strong>Consumer：</strong>调用远程服务的服务消费方。</li><li><strong>Registry：</strong>服务注册中心和发现中心。</li><li><strong>Monitor：</strong>统计服务和调用次数，调用时间监控中心。（Dubbo 的控制台页面中可以显示，目前只有一个简单版本。）</li><li><strong>Container：</strong>服务运行的容器。</li></ul></li><li><p>Spring Cloud</p><p>springcloud: 全家桶+轻松嵌入第三方组件<br>官网：<a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">http://projects.spring.io/spring-cloud/</a><br>配套</p><p>​        通信方式：http restful<br>​        注册中心：eruka/consul<br>​        配置中心：config<br>​        断路器：hystrix<br>​        网关：zuul<br>​        分布式追踪系统：sleuth+zipkin</p></li><li><p>SpringCloud和Dubbo区别</p><table><thead><tr><th></th><th>Dubbo</th><th>Spring Cloud</th></tr></thead><tbody><tr><td>服务注册中心</td><td>Zookeeper</td><td>Spring Cloud Netflix Eureka</td></tr><tr><td>服务调用方式</td><td>RPC</td><td>REST API</td></tr><tr><td>服务监控</td><td>无</td><td>Spring Boot Admin</td></tr><tr><td>断路器</td><td>不完善</td><td>Spring Cloud Netflix Hystrix</td></tr><tr><td>服务网关</td><td>无</td><td>Spring Cloud Netflix Zuul</td></tr><tr><td>分布式配置</td><td>无</td><td>Spring Cloud Config</td></tr><tr><td>服务跟踪</td><td>无</td><td>Spring Cloud Sleuth</td></tr><tr><td>消息总线</td><td>无</td><td>Spring Cloud Bus</td></tr><tr><td>数据流</td><td>无</td><td>Spring Cloud Stream</td></tr><tr><td>批量任务</td><td>无</td><td>Spring Cloud Task</td></tr></tbody></table></li><li><p>Spring Cloud 抛弃了 Dubbo 的 RPC 通信，采用的是基于 HTTP 的 REST 方式。严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生 RPC 带来的问题。而且 REST 相比 RPC 更为灵活，服务提供方和调用方，不存在代码级别的强依赖，这在强调快速演化的微服务环境下显得更加合适。</p><p>很明显，Spring Cloud 的功能比 Dubbo 更加强大，涵盖面更广，而且作为 Spring 的拳头项目，它也能够与 Spring Framework、Spring Boot、Spring Data、Spring Batch 等其他 Spring 项目完美融合，这些对于微服务而言是至关重要的。</p></li><li><p>微服务下电商项目模块设计</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E7%94%B5%E5%95%86%E5%BE%AE%E6%9C%8D%E5%8A%A1.png" alt="电商微服务"></p><ul><li>用户服务<ul><li>用户信息接口</li><li>登录接口</li></ul></li><li>商品服务<ul><li>商品列表</li><li>商品详情</li></ul></li><li>订单服务 <ul><li>我的订单</li><li>下单接口</li></ul></li></ul></li></ol><h2 id="4-SpringCloud核心组件注册中心"><a href="#4-SpringCloud核心组件注册中心" class="headerlink" title="4-SpringCloud核心组件注册中心"></a>4-SpringCloud核心组件注册中心</h2><h3 id="4-1-什么是微服务的注册中心？"><a href="#4-1-什么是微服务的注册中心？" class="headerlink" title="4.1-什么是微服务的注册中心？"></a>4.1-什么是微服务的注册中心？</h3><p>在微服务架构下，主要有三种角色：<strong>服务提供者（RPC Server）</strong>、<strong>服务消费者（RPC Client）</strong>和<strong>服务注册中心（Registry）</strong>，三者的交互关系如下面这张图：</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="微服务注册中心"></p><p>RPC Server 提供服务，在启动时，根据服务发布文件 server.xml 中的配置的信息，向 Registry 注册自身服务，并向 Registry 定期发送心跳汇报存活状态。</p><p>RPC Client 调用服务，在启动时，根据服务引用文件 client.xml 中配置的信息，向 Registry 订阅服务，把 Registry 返回的服务节点列表缓存在本地内存中，并与 RPC Sever 建立连接。</p><p>当 RPC Server 节点发生变更时，Registry 会同步变更，RPC Client 感知后会刷新本地内存中缓存的服务节点列表。</p><p>RPC Client 从本地缓存的服务节点列表中，基于负载均衡算法选择一台 RPC Sever 发起调用。</p><p>注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。</p><ul><li><p><strong>数据模型</strong></p><p>注册中心的核心数据是服务的名字和它对应的网络地址，当服务注册了多个实例时，我们需要对不健康的实例进行过滤或者针对实例的一些特征进行流量的分配，那么就需要在实例上存储一些例如健康状态、权重等属性。随着服务规模的扩大，渐渐的又需要在整个服务级别设定一些权限规则、以及对所有实例都生效的一些开关，于是在服务级别又会设立一些属性。再往后，我们又发现单个服务的实例又会有划分为多个子集的需求，例如一个服务是多机房部署的，那么可能需要对每个机房的实例做不同的配置，这样又需要在服务和实例之间再设定一个数据级别。</p></li><li><p><strong>数据一致性</strong></p><p>数据一致性是分布式系统永恒的话题，Paxos协议的艰深更让数据一致性成为程序员大牛们吹水的常见话题。不过从协议层面上看，一致性的选型已经很长时间没有新的成员加入了。目前来看基本可以归为两家：一种是基于Leader的非对等部署的单点写一致性，一种是对等部署的多写一致性。当我们选用服务注册中心的时候，并没有一种协议能够覆盖所有场景，例如当注册的服务节点不会定时发送心跳到注册中心时，强一致协议看起来是唯一的选择，因为无法通过心跳来进行数据的补偿注册，第一次注册就必须保证数据不会丢失。而当客户端会定时发送心跳来汇报健康状态时，第一次的注册的成功率并不是非常关键（当然也很关键，只是相对来说我们容忍数据的少量写失败），因为后续还可以通过心跳再把数据补偿上来，此时Paxos协议的单点瓶颈就会不太划算了，这也是Eureka为什么不采用Paxos协议而采用自定义的Renew机制的原因。</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7.png" alt="数据一致性"></p></li><li><p><strong>负载均衡</strong></p><p>负载均衡严格的来说，并不算是传统注册中心的功能。一般来说服务发现的完整流程应该是先从注册中心获取到服务的实例列表，然后再根据自身的需求，来选择其中的部分实例或者按照一定的流量分配机制来访问不同的服务提供者，因此注册中心本身一般不限定服务消费者的访问策略。<code>Eureka</code>、<code>Zookeeper</code>包括<code>Consul</code>，本身都没有去实现可配置及可扩展的负载均衡机制，Eureka的负载均衡是由ribbon来完成的，而Consul则是由Fabio做负载均衡。</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="客户端负载均衡"></p><p>服务端的负载均衡，给服务提供者更强的流量控制权，但是无法满足不同的消费者希望使用不同负载均衡策略的需求。而不同负载均衡策略的场景，确实是存在的。而客户端的负载均衡则提供了这种灵活性，并对用户扩展提供更加友好的支持。但是客户端负载均衡策略如果配置不当，可能会导致服务提供者出现热点，或者压根就拿不到任何服务提供者。</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="服务端负载均衡"></p></li><li><p><strong>健康检查</strong></p><p>Zookeeper和Eureka都实现了一种TTL的机制，就是如果客户端在一定时间内没有向注册中心发送心跳，则会将这个客户端摘除。Eureka做的更好的一点在于它允许在注册服务的时候，自定义检查自身状态的健康检查方法。这在服务实例能够保持心跳上报的场景下，是一种比较好的体验，在Dubbo和SpringCloud这两大体系内，也被培养成用户心智上的默认行为。Nacos也支持这种TTL机制，不过这与ConfigServer在阿里巴巴内部的机制又有一些区别。Nacos目前支持临时实例使用心跳上报方式维持活性，发送心跳的周期默认是5秒，Nacos服务端会在15秒没收到心跳后将实例设置为不健康，在30秒没收到心跳时将这个临时实例摘除。</p><p>客户端健康检查和服务端健康检查有一些不同的关注点。客户端健康检查主要关注客户端上报心跳的方式、服务端摘除不健康客户端的机制。而服务端健康检查，则关注探测客户端的方式、灵敏度及设置客户端健康状态的机制。从实现复杂性来说，服务端探测肯定是要更加复杂的，因为需要服务端根据注册服务配置的健康检查方式，去执行相应的接口，判断相应的返回结果，并做好重试机制和线程池的管理。这与客户端探测，只需要等待心跳，然后刷新TTL是不一样的。同时服务端健康检查无法摘除不健康实例，这意味着只要注册过的服务实例，如果不调用接口主动注销，这些服务实例都需要去维持健康检查的探测任务，而客户端则可以随时摘除不健康实例，减轻服务端的压力。</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/Nacos%E7%9A%84%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.png" alt="Nacos的健康检查"></p></li><li><p>性能与容量</p><p>虽然大部分用户用到的性能不高，但是他们仍然希望选用的产品的性能越高越好。影响读写性能的因素很多：一致性协议、机器的配置、集群的规模、存量数据的规模、数据结构及读写逻辑的设计等等。在服务发现的场景中，我们认为读写性能都是非常关键的，但是并非性能越高就越好，因为追求性能往往需要其他方面做出牺牲。Zookeeper在写性能上似乎能达到上万的TPS，这得益于Zookeeper精巧的设计，不过这显然是因为有一系列的前提存在。首先Zookeeper的写逻辑就是进行K-V的写入，内部没有聚合；其次Zookeeper舍弃了服务发现的基本功能如健康检查、友好的查询接口，它在支持这些功能的时候，显然需要增加一些逻辑，甚至弃用现有的数据结构；最后，Paxos协议本身就限制了Zookeeper集群的规模，3、5个节点是不能应对大规模的服务订阅和查询的。</p></li><li><p>易用性</p><p>易用性也是用户比较关注的一块内容。产品虽然可以在功能特性或者性能上做到非常先进，但是如果用户的使用成本极高，也会让用户望而却步。易用性包括多方面的工作，例如API和客户端的接入是否简单，文档是否齐全易懂，控制台界面是否完善等。对于开源产品来说，还有一块是社区是否活跃。在比较Nacos、Eureka和Zookeeper在易用性上的表现时，我们诚邀社区的用户进行全方位的反馈，因为毕竟在阿里巴巴集团内部，我们对Eureka、Zookeeper的使用场景是有限的。从我们使用的经验和调研来看，Zookeeper的易用性是比较差的，Zookeeper的客户端使用比较复杂，没有针对服务发现的模型设计以及相应的API封装，需要依赖方自己处理。对多语言的支持也不太好，同时没有比较好用的控制台进行运维管理。</p></li><li><p>集群扩展性</p><p>集群扩展性和集群容量以及读写性能关系紧密。当使用一个比较小的集群规模就可以支撑远高于现有数量的服务注册及访问时，集群的扩展能力暂时就不会那么重要。从协议的层面上来说，Zookeeper使用的ZAB协议，由于是单点写，在集群扩展性上不具备优势。Eureka在协议上来说理论上可以扩展到很大规模，因为都是点对点的数据同步，但是从我们对Eureka的运维经验来看，Eureka集群在扩容之后，性能上有很大问题。</p></li></ul><p><strong>几大服务注册中心的对比：</strong></p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94.png" alt="注册中心对比"></p><h3 id="4-2-SpringCloud微服务核心组件Eureka"><a href="#4-2-SpringCloud微服务核心组件Eureka" class="headerlink" title="4.2-SpringCloud微服务核心组件Eureka"></a>4.2-SpringCloud微服务核心组件Eureka</h3><p>Eureka是Netflix开源的服务发现组件，本身是一个基于REST的服务，包含Server和Client两部分，并且服务端与客户端均采用java编写，所以Eureka主要适用于通过java实现的分布式系统，或是JVM兼容语言构建的系统，Spring Cloud将它集成在子项目Spring Cloud Netflix中。在微服务系统中，我们需要单独创建一个Eureka Server作为注册中心，其他的微服务就相当于客户端，注册到我们的注册中心中。</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/Eureka.png" alt="Eureka"></p><pre class=" language-properties"><code class="language-properties">Register(服务注册)：把自己的IP和端口注册给Eureka。Renew(服务续约)：发送心跳包，每30秒发送一次。告诉Eureka自己还活着。Cancel(服务下线)：当provider关闭时会向Eureka发送消息，把自己从服务列表中删除。防止consumer调用到不存在的服务。<span class="token attr-name">Get</span> <span class="token attr-value">Registry(获取服务注册列表)：获取其他服务列表。</span>Replicate(集群中数据同步)：eureka集群中的数据复制与同步。<span class="token attr-name">Make</span> <span class="token attr-value">Remote Call(远程调用)：完成服务的远程调用。</span></code></pre><p><strong>流程：</strong></p><p>各个微服务启动时，会通过 Eureka Client 向 Eureka Server 注册自己，Eureka Server 会存储该服务的信息</p><p>也就是说，每个微服务的客户端和服务端，都会注册到 Eureka Server，这就衍生出了微服务相互识别的话题</p><ul><li><p>同步：每个 Eureka Server 同时也是 Eureka Client（逻辑上的）<br>　　　多个 Eureka Server 之间通过复制的方式完成服务注册表的同步，形成 Eureka 的高可用</p></li><li><p>识别：Eureka Client 会缓存 Eureka Server 中的信息<br>　　　即使所有 Eureka Server 节点都宕掉，服务消费者仍可使用缓存中的信息找到服务提供者<strong>（笔者已亲测）</strong></p></li><li><p>续约：微服务会周期性（默认30s）地向 Eureka Server 发送心跳以Renew（续约）信息（类似于heartbeat）</p></li><li><p>续期：Eureka Server 会定期（默认60s）执行一次失效服务检测功能<br>　　　它会检查超过一定时间（默认90s）没有Renew的微服务，发现则会注销该微服务节点</p></li><li><p><strong>Eureka服务端</strong></p><p>提供服务注册和发现的能力（通常就是微服务中的注册中心），各个节点启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在前端界面中直观的看到。</p><p>即服务注册中心。它同其他服务注册中心一样，支持高可用配置。依托于强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。</p><p>Eureka服务端支持集群模式部署，当集群中有分片发生故障的时候，Eureka会自动转入自我保护模式。它允许在分片发生故障的时候继续提供服务的发现和注册，当故障分配恢复时，集群中的其他分片会把他们的状态再次同步回来。集群中的的不同服务注册中心通过异步模式互相复制各自的状态，这也意味着在给定的时间点每个实例关于所有服务的状态可能存在不一致的现象。</p></li><li><p><strong>Eureka客户端</strong></p><p>一个Java客户端，用于简化与 Eureka Server 的交互，<strong>客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后</strong>，将会向Eureka Server发送心跳,<strong>默认周期为30秒</strong>，如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个<strong>服务节点移除(默认90秒)</strong>。。</p><p>Eureka客户端，主要处理服务的注册和发现。客户端服务通过注册和参数配置的方式，嵌入在客户端应用程序的代码中。在应用程序启动时，Eureka客户端向服务注册中心注册自身提供的服务，并周期性的发送心跳来更新它的服务租约。同时，他也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期行的刷新服务状态。</p></li><li><p><strong>心跳检测</strong></p><p>在应用启动后，客户端将会向Eureka Server发送心跳（默认为30秒，我们项目配置的是30秒）。Eureka Serber如果在多个心跳周期内没有收到某个微服务节点的心跳，将会剔除该节点（默认90秒，我们项目配置的是90秒）。</p></li><li><p><strong>集群数据同步</strong></p><p>Eureka Server之间通过复制的方式来进行数据同步。</p></li><li><p><strong>客户端缓存功能</strong></p><p>Eureka Client具有缓存功能，即使所有的Eureka Server都挂掉，客户端依然可以利用缓存中的信息消费其他服务的API。</p></li><li><p><strong>清理失效节点</strong></p></li><li><p><strong>自我保护模式</strong></p><p>自我保护模式是指在网络出现异常的情况下，由于Eureka Server无法收到客户端的心跳续约，Eureka Server会判断该节点不可用，但其实该节点可能是正常的，可用的。为了避免误删，Eureka Server引入了自我保护模式。一旦Eureka Server发现当前收到的心跳总次数小于心跳阈值的85%（默认值），就会进入自我保护模式，此时Eureka Server不会清理任何节点。直到Eureka Server收到的心跳总次数大于等于心跳阈值的85%。</p><p>自我保护模式的设计哲学是：在不确定节点是否可用的情况下，尽可能保留节点。</p></li></ul><p><strong>Eureka工作流程：</strong></p><ol><li>Eureka Server 启动成功，等待服务端注册。在启动过程中如果配置了集群，集群之间定时通过 Replicate 同步注册表，每个 Eureka Server 都存在独立完整的服务注册表信息</li><li>Eureka Client 启动时根据配置的 Eureka Server 地址去注册中心注册服务</li><li>Eureka Client 会每 30s 向 Eureka Server 发送一次心跳请求，证明客户端服务正常</li><li>当 Eureka Server 90s 内没有收到 Eureka Client 的心跳，注册中心则认为该节点失效，会注销该实例</li><li>单位时间内 Eureka Server 统计到有大量的 Eureka Client 没有上送心跳，则认为可能为网络异常，进入自我保护机制，不再剔除没有上送心跳的客户端</li><li>当 Eureka Client 心跳请求恢复正常之后，Eureka Server 自动退出自我保护模式</li><li>Eureka Client 定时全量或者增量从注册中心获取服务注册表，并且将获取到的信息缓存到本地</li><li>服务调用时，Eureka Client 会先从本地缓存找寻调取的服务。如果获取不到，先从注册中心刷新注册表，再同步到本地缓存</li><li>Eureka Client 获取到目标服务器信息，发起服务调用</li><li>Eureka Client 程序关闭时向 Eureka Server 发送取消请求，Eureka Server 将实例从注册表中删除</li></ol><h3 id="4-3-Eureka-Server搭建实战"><a href="#4-3-Eureka-Server搭建实战" class="headerlink" title="4.3-Eureka Server搭建实战"></a>4.3-Eureka Server搭建实战</h3><ol><li><p>创建eureka-server工程</p></li><li><p>添加依赖</p><p><strong>父工程添加：</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>Greenwich.SR1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>Eureka Server工程添加：</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>添加配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8761</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>server<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> 127.0.0.1  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//$<span class="token punctuation">{</span>eureka.instance.hostname<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">:</span>$<span class="token punctuation">{</span>server.port<span class="token punctuation">}</span>/eureka/    <span class="token comment" spellcheck="true">#声明自己是个服务端</span>    <span class="token key atrule">register-with-eureka</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>    <span class="token key atrule">fetch-registry</span><span class="token punctuation">:</span> <span class="token boolean important">false</span></code></pre></li><li><p>启动类配置：<br>启动Eureka Server注册中心，和普通的SpringBoot应用的启动没有太大的区别。只需要在启动类上增加<code>@EnableEurekaServe</code>r注解，来开启Eureka Server服务即可。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableEurekaServer</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaServerApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringcloudEurekaServerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>访问注册中心</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E8%AE%BF%E9%97%AE%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="访问注册中心"></p></li></ol><h3 id="4-4-Eureka-Client搭建商品服务实战"><a href="#4-4-Eureka-Client搭建商品服务实战" class="headerlink" title="4.4-Eureka Client搭建商品服务实战"></a>4.4-Eureka Client搭建商品服务实战</h3><ol><li><p>创建实体类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//商品名称</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//商品价格</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> price<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//库存</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> store<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>创建Service</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProductService</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Product<span class="token operator">></span> <span class="token function">getProducts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Product <span class="token function">findById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">ProductService</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Product<span class="token operator">></span> daoMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        Product p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"iphonex"</span><span class="token punctuation">,</span><span class="token number">9999</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"冰箱"</span><span class="token punctuation">,</span><span class="token number">5342</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"洗衣机"</span><span class="token punctuation">,</span><span class="token number">523</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product p4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">"电话"</span><span class="token punctuation">,</span><span class="token number">64345</span><span class="token punctuation">,</span> <span class="token number">150</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product p5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">"汽车"</span><span class="token punctuation">,</span><span class="token number">2345</span><span class="token punctuation">,</span> <span class="token number">140</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product p6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">"椅子"</span><span class="token punctuation">,</span><span class="token number">253</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Product p7 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">"java编程思想"</span><span class="token punctuation">,</span><span class="token number">2341</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p3<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p4<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p4<span class="token punctuation">)</span><span class="token punctuation">;</span>        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p5<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p5<span class="token punctuation">)</span><span class="token punctuation">;</span>        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p6<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p6<span class="token punctuation">)</span><span class="token punctuation">;</span>        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p7<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p7<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Product<span class="token operator">></span> <span class="token function">getProducts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Collection<span class="token operator">&lt;</span>Product<span class="token operator">></span> collection <span class="token operator">=</span> daoMap<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Product<span class="token operator">></span> productList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> productList<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Product <span class="token function">findById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> daoMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>Controller</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api/v1/product"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ProductService productService<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取所有商品列表     * @return     */</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"list"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> productService<span class="token punctuation">.</span><span class="token function">getProducts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 根据id查找商品详情     * @param id     * @return     */</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"find"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> productService<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>启动类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token comment" spellcheck="true">//By having spring-cloud-starter-netflix-eureka-client on the classpath, your application automatically registers with the Eureka Server. Configuration is required to locate the Eureka server, as shown in the following example:</span><span class="token annotation punctuation">@EnableEurekaClient</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductServiceApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ProductServiceApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>配置文件</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> product<span class="token punctuation">-</span>service<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>8761/eureka  <span class="token key atrule">instance</span><span class="token punctuation">:</span>    <span class="token key atrule">prefer-ip-address</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 当其它服务获取地址时提供ip而不是hostname</span>    <span class="token key atrule">ip-address</span><span class="token punctuation">:</span> 127.0.0.1 <span class="token comment" spellcheck="true"># 指定自己的ip信息，不指定的话会自己寻找</span></code></pre></li><li><p>访问注册中心可以看到我们的商品服务</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E6%B3%A8%E5%86%8C%E5%95%86%E5%93%81%E6%9C%8D%E5%8A%A1.png" alt="注册商品服务"></p><p>eureka管理后台出现一串红色字体：是警告，说明有服务上线率低</p><pre><code>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&#39;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</code></pre><p>关闭检查方法：eureka服务端配置文件加入</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">enable-self-preservation</span><span class="token punctuation">:</span> <span class="token boolean important">false</span></code></pre><p>注意：自我保护模式禁止关闭，默认是开启状态true</p></li></ol><h2 id="5-服务消费者Ribbon和Feign"><a href="#5-服务消费者Ribbon和Feign" class="headerlink" title="5-服务消费者Ribbon和Feign"></a>5-服务消费者Ribbon和Feign</h2><h3 id="5-1-常用的服务间调用方式"><a href="#5-1-常用的服务间调用方式" class="headerlink" title="5.1-常用的服务间调用方式"></a>5.1-常用的服务间调用方式</h3><ul><li><p><strong>RPC</strong></p><p>RPC 即远程过程调用（Remote Procedure Call Protocol，简称RPC），像调用本地服务(方法)一样调用服务器的服务(方法)。通常的实现有 XML-RPC , JSON-RPC , 通信方式基本相同, 所不同的只是传输数据的格式.</p><p>客户端和服务器之间建立TCP连接（长连接），可以一次建立一个，也可以多个调用复用一次链接。</p><p>RPC是分布式架构的核心，按响应方式分如下两种：</p><p>同步调用：客户端调用服务方方法，等待直到服务方返回结果或者超时，再继续自己的操作</p><p>异步调用：客户端把消息发送给中间件，不再等待服务端返回，直接继续自己的操作。</p><p>同步调用的实现方式有WebService和RMI。Web Service提供的服务是基于web容器的，底层使用http协议，因而适合不同语言异构系统间的调用。RMI实际上是Java语言的RPC实现，允许方法返回 Java 对象以及基本数据类型，适合用于JAVA语言构建的不同系统间的调用。</p><p>异步调用的JAVA实现版就是JMS(Java Message Service)，目前开源的的JMS中间件有Apache社区的ActiveMQ、Kafka消息中间件，另外有阿里的RocketMQ。</p><p><strong>RPC架构里包含如下4个组件:</strong></p><ol><li>客户端(Client)：服务调用方</li><li>客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数打包成网络消息，再通过网络发送给服务方</li><li>服务端存根(Server Stub)：接受客户端发送过来的消息并解包，再调用本地服务</li><li>服务端(Server)：真正的服务提供者。 </li></ol></li></ul><p>  RPC主要是用在大型企业里面，因为大型企业里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。实际的开发当中是这么做的，项目一般使用maven来管理。比如我们有一个处理订单的系统服务，先声明它的所有的接口（这里就是具体指Java中的<code>interface</code>），然后将整个项目打包为一个<code>jar</code>包，服务端这边引入这个二方库，然后实现相应的功能，客户端这边也只需要引入这个二方库即可调用了。为什么这么做？主要是为了减少客户端这边的<code>jar</code>包大小，RPC数据包较小，因为每一次打包发布的时候，<code>jar</code>包太多总是会影响效率。另外也是将客户端和服务端解耦，提高代码的可移植性。</p><p>  <strong>同步调用与异步调用</strong>:</p><ol><li>同步调用就是客户端等待调用执行完成并返回结果。</li><li>异步调用就是客户端不等待调用执行完成返回结果，不过依然可以通过回调函数等接收到返回结果的通知。如果客户端并不关心结果，则可以变成一个单向的调用。这个过程有点类似于Java中的callable和runnable接口，我们进行异步执行的时候，如果需要知道执行的结果，就可以使用callable接口，并且可以通过Future类获取到异步执行的结果信息。如果不关心执行的结果，直接使用runnable接口就可以了，因为它不返回结果，当然callable也是可以的，我们不去获取Future就可以了。</li></ol><p>  <strong>流行的RPC框架</strong>：<br>  目前流行的开源RPC框架还是比较多的。下面重点介绍三种：</p><ul><li>gRPC是Google的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言。 我们知道HTTP2.0是基于二进制的HTTP协议升级版本，目前各大浏览器都在快马加鞭的加以支持。 这个RPC框架是基于HTTP协议实现的，底层使用到了Netty框架的支持。</li><li>Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的IDL定义文件自动生成服务代码框架。用户只要在其之前进行二次开发就行，对于底层的RPC通讯等都是透明的。不过这个对于用户来说的话需要学习特定领域语言这个特性，还是有一定成本的。</li><li>Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。同样 的远程接口是基于Java Interface，并且依托于spring框架方便开发。可以方便的打包成单一文件，独立进程运行，和现在的微服务概念一致。</li></ul><p>  <strong>RPC框架要做到的最基本的三件事：</strong></p><p>  1、服务端如何确定客户端要调用的函数；</p><p>  在远程调用中，客户端和服务端分别维护一个【ID-&gt;函数】的对应表， ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，附上这个ID，服务端通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p><p>  2、如何进行序列化和反序列化；</p><p>  客户端和服务端交互时将参数或结果转化为字节流在网络中传输，那么数据转化为字节流的或者将字节流转换成能读取的固定格式时就需要进行序列化和反序列化，序列化和反序列化的速度也会影响远程调用的效率。</p><p>  3、如何进行网络传输（选择何种网络协议）；</p><p>  多数RPC框架选择TCP作为传输协议，也有部分选择HTTP。如gRPC使用HTTP2。不同的协议各有利弊。TCP更加高效，而HTTP在实际应用中更加的灵活。</p><ul><li><p><strong>REST</strong></p><p>REST即表述性状态传递（Representational State Transfer，简称REST），是一种软件架构风格。REST通过HTTP协议定义的通用动词方法(GET、PUT、DELETE、POST) ，以URI对网络资源进行唯一标识，响应端根据请求端的不同需求，通过无状态通信，对其请求的资源进行表述。</p><p><strong>Rest架构的主要原则：</strong></p><ol><li><p>网络上的所有事物都被抽象为资源</p></li><li><p>每个资源都有一个唯一的资源标识符</p></li><li><p>同一个资源具有多种表现形式(xml,json等)</p></li><li><p>对资源的各种操作不会改变资源标识符</p></li><li><p>所有的操作都是无状态的</p></li></ol><p>其中表述性状态，是指(在某个瞬间状态的)资源数据的快照，包括资源数据的内容、表述格式(XML、JSON)等信息。</p><p>其中无状态通信，是指服务端(响应端)不保存任何与特定HTTP请求相关的资源，应用状态必须由请求方在请求过程中提供。要求在网络通信过程中，任意一个Web请求必须与其他请求隔离，当请求端提出请求时，请求本身包含了响应端为响应这一请求所需的全部信息。</p><p>REST使用HTTP+URI+XML /JSON 的技术来实现其API要求的架构风格：HTTP协议和URI用于统一接口和定位资源，文本、二进制流、XML、JSON等格式用来作为资源的表述。</p><p><code>满足REST约束条件和原则的架构，就被称为是RESTful架构。就像URL都是URI(统一资源标识)的表现形式一样，RESTful是符合REST原则的表现形式。</code></p></li><li><p><strong>RPC和REST比较</strong></p><ol><li><p>RPC优缺点</p><ul><li><p>原理：socket+动态代理</p></li><li><p>优点：</p><ol><li><p>调用简单，清晰，透明，不用像 rest 一样复杂，就像调用本地方法一样简单</p></li><li><p>高效低延迟，性能高</p></li><li><p>自定义协议（让传输报文提及更小），数据包较小</p></li><li><p>性能消耗低，高效的序列化协议可以支持高效的二进制传输</p></li><li><p>自带负载均衡</p></li></ol></li><li><p>缺点：</p><ol><li><p>耦合性强</p><p>他人总结：</p><pre><code>我们为每个微服务定义了各自的 service 抽象接口，并通过持续集成发布到私有仓库中，调用方应用对微服务提供的抽象接口存在强依赖关系，因此不论开发、测试、集成环境都需要严格的管理版本依赖，才不会出现服务方与调用方的不一致导致应用无法编译成功等一系列问题，以及这也会直接影响本地开发的环境要求，往往一个依赖很多服务的上层应用，每天都要更新很多代码并 install 之后才能进行后续的开发。若没有严格的版本管理制度或开发一些自动化工具，这样的依赖关系会成为开发团队的一大噩梦。而 REST 接口相比 RPC 更为轻量化，服务提供方和调用方的依赖只是依靠一纸契约，不存在代码级别的强依赖，当然 REST 接口也有痛点，因为接口定义过轻，很容易导致定义文档与实际实现不一致导致服务集成时的问题，但是该问题很好解决，只需要通过每个服务整合swagger，让每个服务的代码与文档一体化，就能解决。所以在分布式环境下，REST 方式的服务依赖要比 RPC 方式的依赖更为灵活。</code></pre></li><li><p>无法跨语言，平台敏感</p><p>Java 写的 RPC 微服务无法给 Python 调用，需要再实现一层 REST 来对外提供服务。</p></li></ol></li></ul></li><li><p>REST</p><ul><li>原理：HTTP调用</li><li>优点：<ol><li>耦合性低，兼容性好，提高开发效率</li><li>不用关心接口实现细节，相对更规范，更标准，更通用，跨语言支持</li></ol></li><li>缺点：<ol><li>性能不如 RPC 高</li><li>HTTP数据包较大</li></ol></li></ul></li></ol></li><li><p><strong>应用场景选择</strong></p><p>RPC 适用于内网服务调用，对外提供服务请走 REST。</p><p>IO 密集的服务调用用 RPC，低频服务用 REST。</p><p>服务调用过于密集与复杂，RPC 就比较适用。</p><p><strong>REST和RPC都常用于微服务架构中。</strong></p><ol><li>HTTP相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，现在开源中间件，基本最先支持的几个协议都包含RESTful。</li><li>RPC 框架作为架构微服务化的基础组件，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务。</li></ol></li></ul><h3 id="5-2-Ribbon"><a href="#5-2-Ribbon" class="headerlink" title="5.2-Ribbon"></a>5.2-Ribbon</h3><ol><li><p>什么是负载均衡？</p><p>负载均衡是微服务架构中必须使用的技术，通过负载均衡来实现系统的高可用、集群扩容等功能。负载均衡可通过硬件设备及软件来实现，硬件比如：F5、Array等，软件比如：LVS、Nginx等。</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="微服务负载均衡"></p><p>用户请求先到达负载均衡器（也相当于一个服务），负载均衡器根据负载均衡算法将请求转发到微服务。负载均衡算法有：轮训、随机、加权轮训、加权随机、地址哈希等方法，负载均衡器维护一份服务列表，根据负载均衡算法将请求转发到相应的微服务上，所以负载均衡可以为微服务集群分担请求，降低系统的压力。</p></li><li><p>什么是客户端负载均衡？</p><p>上图是服务端负载均衡，客户端负载均衡与服务端负载均衡的区别在于客户端要维护一份服务列表，Ribbon从Eureka Server获取服务列表，Ribbon根据负载均衡算法直接请求到具体的微服务，然后进行访问，这是客户端负载均衡。</p><p>当我们将Ribbon和Eureka一起使用时，Ribbon会从Eureka注册中心去获取服务端列表，然后进行轮询访问以到达负载均衡的作用，客户端负载均衡中也需要心跳机制去维护服务端清单的有效性，当然这个过程需要配合服务注册中心一起完成。</p></li><li><p>什么是服务端负载均衡？</p><p>负载均衡是我们处理高并发、缓解网络压力和进行服务端扩容的重要手段之一，但是一般情况下我们所说的负载均衡通常都是指服务端负载均衡，服务端负载均衡又分为两种，一种是硬件负载均衡，还有一种是软件负载均衡。</p><ul><li><p>硬件负载均衡主要通过在服务器节点之间安装专门用于负载均衡的设备，常见的如F5。</p></li><li><p>软件负载均衡则主要是在服务器上安装一些具有负载均衡功能的软件来完成请求分发进而实现负载均衡，常见的就是Nginx。</p><p>无论是硬件负载均衡还是软件负载均衡都会维护一个可用的服务端清单，然后通过心跳机制来删除故障的服务端节点以保证清单中都是可以正常访问的服务端节点，此时当客户端的请求到达负载均衡服务器时，负载均衡服务器按照某种配置好的规则从可用服务端清单中选出一台服务器去处理客户端的请求。这就是服务端负载均衡。</p></li></ul></li><li><p>Ribbon是什么？</p><p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。</p><p>Load Balance负载均衡是用于解决一台机器(一个进程)无法解决所有请求而产生的一种算法。像nginx可以使用负载均衡分配流量，ribbon为客户端提供负载均衡，dubbo服务调用里的负载均衡等等，很多地方都使用到了负载均衡。</p><p><strong>使用负载均衡带来的好处很明显(系统高可用、网络压力缓解、处理能力扩容)：</strong></p><p>当集群里的1台或者多台服务器down的时候，剩余的没有down的服务器可以保证服务的继续使用<br>使用了更多的机器保证了机器的良性使用，不会由于某一高峰时刻导致系统cpu急剧上升<br><strong>负载均衡有好几种实现策略，常见的有：</strong></p><ul><li>随机 (Random)</li><li>轮询 (RoundRobin)</li><li>一致性哈希 (ConsistentHash)</li><li>哈希 (Hash)</li><li>加权（Weighted）(默认会启动一个每隔30秒的定时任务来为每个服务实例计算权重.)</li></ul><p>服务发现的任务由Eureka完成，而服务消费的任务由Ribbon完成,它是一个基于Http和TCP的客户端负载均衡器，可以通过在客户端中配置的ribbonServerList服务端列表去轮询访问以达到均衡负载的作用(对于服务提供方，同一服务的实例通常会有多个来保证服务的高可用性).</p></li><li><p>Ribbon实战</p><ol><li><p>添加依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-ribbon<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>在application.yml中添加配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>  <span class="token key atrule">MaxAutoRetries</span><span class="token punctuation">:</span> <span class="token number">2 </span><span class="token comment" spellcheck="true">#最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试</span>  <span class="token key atrule">MaxAutoRetriesNextServer</span><span class="token punctuation">:</span> <span class="token number">3 </span><span class="token comment" spellcheck="true">#切换实例的重试次数</span>  <span class="token key atrule">OkToRetryOnAllOperations</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true">#对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false</span>  <span class="token key atrule">ConnectTimeout</span><span class="token punctuation">:</span> <span class="token number">5000  </span><span class="token comment" spellcheck="true">#请求连接的超时时间</span>  <span class="token key atrule">ReadTimeout</span><span class="token punctuation">:</span> <span class="token number">6000 </span><span class="token comment" spellcheck="true">#请求处理的超时时间</span></code></pre></li><li><p>在订单服务启动类中添加如下代码：</p><pre class=" language-java"><code class="language-java">        <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@LoadBalanced</span>    <span class="token keyword">public</span> RestTemplate <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p>修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用：</p><pre class=" language-java"><code class="language-java">        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> ProductOrder <span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">,</span> <span class="token keyword">int</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object obj <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span><span class="token string">"http://product-service/api/v1/product/find?id="</span><span class="token operator">+</span>productId<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>        ProductOrder productOrder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProductOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        productOrder<span class="token punctuation">.</span><span class="token function">setCreateTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        productOrder<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        productOrder<span class="token punctuation">.</span><span class="token function">setTradeNo</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> productOrder<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>控制台输出如下：</p><pre><code>2020-01-18 22:32:24.792  INFO 28215 --- [nio-8081-exec-1] c.n.l.DynamicServerListLoadBalancer      : DynamicServerListLoadBalancer for client product-service initialized: DynamicServerListLoadBalancer:{NFLoadBalancer:name=product-service,current list of Servers=[127.0.0.1:8082],Load balancer stats=Zone stats: {defaultzone=[Zone:defaultzone;    Instance count:1;    Active connections count: 0;    Circuit breaker tripped count: 0;    Active connections per server: 0.0;]},Server stats: [[Server:127.0.0.1:8082;    Zone:defaultZone;    Total Requests:0;    Successive connection failure:0;    Total blackout seconds:0;    Last connection made:Thu Jan 01 08:00:00 CST 1970;    First connection made: Thu Jan 01 08:00:00 CST 1970;    Active Connections:0;    total failure count in last (1000) msecs:0;    average resp time:0.0;    90 percentile resp time:0.0;    95 percentile resp time:0.0;    min resp time:0.0;    max resp time:0.0;    stddev resp time:0.0]]}ServerList:org.springframework.cloud.netflix.ribbon.eureka.DomainExtractingServerList@56d1dd2a{id=6, name=椅子, price=253, store=20}</code></pre><p><code>将商品服务多节点启动，会看到订单服务会通过Ribbon的负载均衡来调用商品服务。</code></p></li></ol></li><li><p>Ribbon修改负载均衡策略</p><p>在application.yml配置文件中加入：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#自定义负载均衡策略</span>    <span class="token key atrule">product-service</span><span class="token punctuation">:</span>      <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>        <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule</code></pre><p><strong>策略选择：</strong></p><ol><li>如果每个机器配置一样，则建议不修改策略 (推荐)</li><li>如果部分机器配置强，则可以改为 WeightedResponseTimeRule</li></ol></li></ol><h3 id="5-3-微服务调用方式之Feign"><a href="#5-3-微服务调用方式之Feign" class="headerlink" title="5.3-微服务调用方式之Feign"></a>5.3-微服务调用方式之Feign</h3><ol><li><p>Feign是什么？</p><p><strong>Feign是Netflix开发的声明式、模板化的HTTP客户端， Feign可以帮助我们更快捷、优雅地调用HTTP API。</strong></p><p>Feign是一个声明式WebService客户端，使用Feign能让编写WebService客户端更加简单，它的使用方法是定义一个接口，然后在上面添加注解,同时也支持JAX-RS标准的注解。Feign也支持可拔插式的编码器和解码器，Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters.Feign可以与Eureka和Ribbon组合使用以支持负载均衡。</p><p><strong>只需要你创建一个接口，然后在上面添加注解即可。</strong></p><p>Feign 是一种声明式、模板化的 HTTP 客户端。在 Spring Cloud 中使用 Feign，可以做到使用 HTTP 请求访问远程服务，就像调用本地方法一样的，开发者完全感知不到这是在调用远程方法，更感知不到在访问 HTTP 请求。接下来介绍一下 Feign 的特性，具体如下：</p><ul><li>可插拔的注解支持，包括 Feign 注解和AX-RS注解。</li><li>支持可插拔的 HTTP 编码器和解码器。</li><li>支持 Hystrix 和它的 Fallback。</li><li>支持 Ribbon 的负载均衡。</li><li>支持 HTTP 请求和响应的压缩。Feign 是一个声明式的 WebService 客户端，它的目的就是让 Web Service 调用更加简单。它整合了 Ribbon 和 Hystrix，从而不需要开发者针对 Feign 对其进行整合。Feign 还提供了 HTTP 请求的模板，通过编写简单的接口和注解，就可以定义好 HTTP 请求的参数、格式、地址等信息。Feign 会完全代理 HTTP 的请求，在使用过程中我们只需要依赖注入 Bean，然后调用对应的方法传递参数即可。</li></ul></li><li><p>Feign能干什么？</p><p>Feign旨在使编写Java Htpp客户端变得更容易。</p><p>使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理,形成了一套模板化的调用方法.但是在实际开发中,由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用,所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用.所以，Feign在此基础上做了进一步封装,由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它(以前是Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可),即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。</p></li><li><p>添加Feign依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span># 注意：新旧版本依赖名称不同</code></pre></li><li><p>添加配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#feign的配置，连接超时及读取超时配置</span><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>      <span class="token key atrule">default</span><span class="token punctuation">:</span>        <span class="token key atrule">connectTimeout</span><span class="token punctuation">:</span> <span class="token number">5000</span>        <span class="token key atrule">readTimeout</span><span class="token punctuation">:</span> <span class="token number">5000</span>        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> basic</code></pre></li><li><p>启动类增加注解<code>@EnableFeignClients</code>（开启 Feign 扫描支持）</p></li><li><p>Feign接口编写</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"product-service"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProductFeignClient</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"api/v1//product/find"</span><span class="token punctuation">)</span>    String <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>Controller</p><pre class=" language-java"><code class="language-java">RestController<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ProductFeignClient productFeignClient<span class="token punctuation">;</span>   <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span>"api<span class="token operator">/</span>v1<span class="token comment" spellcheck="true">//product)</span>    String <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> productFeignClient<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>Feign工作原理</p><ul><li>在开发微服务应用时，我们会在主程序入口添加 @EnableFeignClients 注解开启对 Feign Client 扫描加载处理。根据 Feign Client 的开发规范，定义接口并加 @FeignClients 注解。</li><li>当程序启动时，会进行包扫描，扫描所有 @FeignClients 的注解的类，并将这些信息注入 Spring IOC 容器中。当定义的 Feign 接口中的方法被调用时，通过JDK的代理的方式，来生成具体的 RequestTemplate。当生成代理时，Feign 会为每个接口方法创建一个 RequetTemplate 对象，该对象封装了 HTTP 请求需要的全部信息，如请求参数名、请求方法等信息都是在这个过程中确定的。</li><li>然后由 RequestTemplate 生成 Request，然后把 Request 交给 Client 去处理，这里指的 Client 可以是 JDK 原生的 URLConnection、Apache 的 Http Client 也可以是 Okhttp。最后 Client 被封装到 LoadBalanceclient 类，这个类结合 Ribbon 负载均衡发起服务之间的调用。</li></ul></li><li><p>@FeignClient 注解</p><ul><li>name：指定 Feign Client 的名称，如果项目使用了 Ribbon，name 属性会作为微服务的名称，用于服务发现。</li><li>url：url 一般用于调试，可以手动指定 @FeignClient 调用的地址。</li><li>decode404：当发生404错误时，如果该字段为 true，会调用 decoder 进行解码，否则抛出 FeignException。</li><li>configuration：Feign 配置类，可以自定义 Feign 的 Encoder、Decoder、LogLevel、Contract。</li><li>fallback：定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback 指定的类必须实现 @FeignClient 标记的接口。</li><li>fallbackFactory：工厂类，用于生成 fallback 类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码。</li><li>path：定义当前 FeignClient 的统一前缀。</li></ul></li><li><p>超时时间配置</p><p>如果在一个微服务当中对同一个接口同时配置了Hystrix与ribbon两个超时时间，则在接口调用的时候，两个计时器会同时读秒。</p><p>比如，访问一个接口需要2秒，你的ribbon配置的超时时间是3秒，Hystrix配置的超时时间是1秒。</p><p>在这种情况下，程序会回调进入到Hystrix的fallback方法，因为在访问接口的时候，Hystrix与ribbon的两个计时器同时计时，而在Hystrix计时器结束的时候自动停止了访问进行回调，进入fallback方法。</p><p><strong>如果没有配置Hystrix的话，访问一个接口需要2秒，你的ribbon配置的超时时间是3秒，Hystrix配置的超时时间是1秒，不会有异常。</strong></p><p>在这个地方建议配置Hystrix的超时时间要大于ribbon的超时时间，否则会在接口调用还未完成的时候直接进入回调方法。</p><p><strong>Hystrix与ribbon的默认请求超时时间都是1秒</strong></p><p>配置如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8200</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">application</span><span class="token punctuation">:</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> testFeign<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  <span class="token key atrule">client</span><span class="token punctuation">:</span>    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>8100/eureka/    <span class="token key atrule">register-with-eureka</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>    <span class="token key atrule">fetch-registry</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token comment" spellcheck="true">###设置feign客户端超时时间</span><span class="token comment" spellcheck="true">###SpringCloud feign 默认开启支持ribbon</span><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">###指的是建立连接所用的时间，适用于网络状况正常的情况下，两端连接所用的时间。</span>  <span class="token key atrule">ReadTimeout</span><span class="token punctuation">:</span> <span class="token number">5000</span>  <span class="token comment" spellcheck="true">###指的是建立连接后从服务器读取到可用资源所用的时间。</span>  <span class="token key atrule">ConnectTimeout</span><span class="token punctuation">:</span> <span class="token number">5000</span><span class="token comment" spellcheck="true">###配置请求超时时间</span><span class="token key atrule">hystrix</span><span class="token punctuation">:</span>  <span class="token key atrule">command</span><span class="token punctuation">:</span>    <span class="token key atrule">default</span><span class="token punctuation">:</span>      <span class="token key atrule">execution</span><span class="token punctuation">:</span>        <span class="token key atrule">isolation</span><span class="token punctuation">:</span>          <span class="token key atrule">thread</span><span class="token punctuation">:</span>            <span class="token key atrule">timeoutInMilliseconds</span><span class="token punctuation">:</span> <span class="token number">7000</span><span class="token comment" spellcheck="true">###配置具体方法超时时间    </span>    <span class="token key atrule">serverMethod</span><span class="token punctuation">:</span>      <span class="token key atrule">execution</span><span class="token punctuation">:</span>        <span class="token key atrule">isolation</span><span class="token punctuation">:</span>          <span class="token key atrule">thread</span><span class="token punctuation">:</span>            <span class="token key atrule">timeoutInMilliseconds</span><span class="token punctuation">:</span> <span class="token number">3000</span><span class="token comment" spellcheck="true">###开启Hystrix断路器</span><span class="token key atrule">feign</span><span class="token punctuation">:</span>  <span class="token key atrule">hystrix</span><span class="token punctuation">:</span>    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p>一般情况下 都是 <code>ribbon 的超时时间（&lt;）hystrix的超时时间</code>（因为涉及到ribbon的重试机制） 因为ribbon的重试机制和Feign的重试机制有冲突，所以源码中默认关闭Feign的重试机制。</p></li><li><p><strong>Feign和Ribbon的区别：</strong></p><ul><li>启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的是@EnableFeignClients。</li><li>服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。</li><li>调用方式不同，<strong>Ribbon</strong>需要自己构建http请求，是一个基于 HTTP 和 TCP 客户端 的负载均衡的工具。它可以在客户端配置 <code>RibbonServerList</code>（服务端列表），使用 HttpClient 或 RestTemplate http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。<strong>Feign</strong>则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。然后就像是调用自身工程的方法调用，而感觉不到是调用远程方法，使得编写 客户端变得非常容易。要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。</li></ul></li></ol><h2 id="6-服务降级熔断-Hystrix"><a href="#6-服务降级熔断-Hystrix" class="headerlink" title="6-服务降级熔断 Hystrix"></a>6-服务降级熔断 Hystrix</h2><h3 id="6-1-分布式核心知识之服务熔断、降级、限流"><a href="#6-1-分布式核心知识之服务熔断、降级、限流" class="headerlink" title="6.1-分布式核心知识之服务熔断、降级、限流"></a>6.1-分布式核心知识之服务熔断、降级、限流</h3><ol><li><h4 id="服务熔断："><a href="#服务熔断：" class="headerlink" title="服务熔断："></a>服务熔断：</h4><ul><li><p>在介绍熔断机制之前，我们需要了解微服务的雪崩效应。在微服务架构中，微服务是完成一个单一的业务功能，这样做的好处是可以做到解耦，每个微服务可以独立演进。但是，一个应用可能会有多个微服务组成，微服务之间的数据交互通过远程过程调用完成。这就带来一个问题，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。</p></li><li><p>熔断机制是应对雪崩效应的一种微服务链路保护机制。我们在各种场景下都会接触到熔断这两个字。高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。股票交易中，如果股票指数过高，也会采用熔断机制，暂停股票的交易。同样，在微服务架构中，熔断机制也是起着类似的作用。当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p></li></ul><p>服务熔断一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为过载保护；服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）</p><p>在Spring Cloud框架里，熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制。</p></li><li><h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><ul><li>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作；服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，我们可以将一些 不重要 或 不紧急 的服务或任务进行服务的 <strong>延迟使用</strong> 或 <strong>暂停使用</strong>，</li><li>是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行；对于复杂系统而言，会有很多的微服务通过 rpc 调用，从而产生一个业务需要一条很长的调用链，其中任何一环故障了都会导致整个调用链失败或超时而导致业务服务不可用或阻塞。这种情况下，可以暂时去掉调用链中故障的服务来进行降级，其中降级策略又有很多种，比如限流，接口拒绝等。</li></ul></li><li><h4 id="服务熔断和降级的区别"><a href="#服务熔断和降级的区别" class="headerlink" title="服务熔断和降级的区别"></a>服务熔断和降级的区别</h4><p><strong>相同点</strong>：</p><ul><li>目的：目的很一致，都是从可用性可靠性着想，为防止系统的整体缓慢甚至崩溃，采用的技术手段；</li><li>最终表现：最终表现类似，对于两者来说，最终让用户体验到的是某些功能暂时不可达或不可用；</li><li>粒度：粒度一般都是服务级别，当然，业界也有不少更细粒度的做法，比如做到数据持久层（允许查询，不允许增删改）；</li><li>自治：自治性要求很高，熔断模式一般都是服务基于策略的自动触发，降级虽说可人工干预，但在微服务架构下，完全靠人显然不可能，开关预置、配置中心都是必要手段；</li></ul><p><strong>区别</strong>：</p><ul><li>触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；</li><li>管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需对业务有层级之分（比如降级一般是从最外围服务开始）</li><li>实现方式不太一样；服务降级具有代码侵入性(由控制器完成/或自动降级)，熔断一般称为自我熔断。</li></ul></li><li><h4 id="服务限流"><a href="#服务限流" class="headerlink" title="服务限流"></a>服务限流</h4><ul><li>在开发高并发系统时有三把利器用来保护系统：缓存、降级和限流。缓存的目的是提升系统访问速度和增大系统能处理的容量，可谓是抗高并发流量的银弹；而降级是当服务出问题或者影响到核心流程的性能则需要暂时屏蔽掉，待高峰或者问题解决后再打开；而有些场景并不能用缓存和降级来解决，比如稀缺资源（秒杀、抢购）、写服务（如评论、下单）、频繁的复杂查询（评论的最后几页），因此需有一种手段来限制这些场景的并发/请求量，即限流。</li><li>限流的目的是通过对并发访问/请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据，如商品详情页库存默认有货）。</li><li>一般开发高并发系统常见的限流有：限制总并发数（比如数据库连接池、线程池）、限制瞬时并发数（如nginx的limit_conn模块，用来限制瞬时并发连接数）、限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）；其他还有如限制远程接口调用速率、限制MQ的消费速率。另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</li><li><strong>常见的限流算法有</strong>：令牌桶、漏桶。计数器也可以进行粗暴限流实现。</li></ul></li></ol><h3 id="6-2-Netflix开源组件断路器Hystrix"><a href="#6-2-Netflix开源组件断路器Hystrix" class="headerlink" title="6.2-Netflix开源组件断路器Hystrix"></a>6.2-Netflix开源组件断路器Hystrix</h3><p>文档地址：<br><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix</a><br><a href="https://github.com/Netflix/Hystrix/wiki" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki</a></p><h4 id="6-2-1-Hystrix是什么？"><a href="#6-2-1-Hystrix是什么？" class="headerlink" title="6.2.1-Hystrix是什么？"></a>6.2.1-Hystrix是什么？</h4><p>在一个分布式系统里，一个服务依赖多个服务，可能存在某个服务调用失败，比如超时、异常等，如何能够保证在一个依赖出问题的情况下，不会导致整体服务失败，通过Hystrix就可以解决这些问题。</p><p>Hystrix是一个库，通过添加延迟容忍和容错逻辑，帮助你控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点、停止级联失败和提供回退选项来实现这一点，所有这些都可以提高系统的整体弹性。</p><p>在微服务场景中，通常会有很多层的服务调用。如果一个底层服务出现问题，故障会被向上传播给用户。我们需要一种机制，当底层服务不可用时，可以阻断故障的传播。这就是断路器的作用。他是系统服务稳定性的最后一重保障。</p><p>在springcloud中断路器组件就是Hystrix。Hystrix也是Netflix套件的一部分。他的功能是，当对某个服务的调用在一定的时间内（默认10s，由metrics.rollingStats.timeInMilliseconds配置），有超过一定次数（默认20次，由circuitBreaker.requestVolumeThreshold参数配置）并且失败率超过一定值（默认50%，由circuitBreaker.errorThresholdPercentage配置），该服务的断路器会打开。返回一个由开发者设定的fallback</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/Hystrix.png" alt="Hystrix"></p><p>fallback可以是另一个由Hystrix保护的服务调用，也可以是固定的值。fallback也可以设计成链式调用，先执行某些逻辑，再返回fallback。</p><h4 id="6-2-2-Hystrix设计目的"><a href="#6-2-2-Hystrix设计目的" class="headerlink" title="6.2.2-Hystrix设计目的"></a>6.2.2-Hystrix设计目的</h4><ul><li>通过第三方客户端库提供保护，并控制延迟和失败（通常通过网络）依赖项的故障。</li><li>停止复杂的分布式系统中的级联故障。</li><li>快速失败，迅速恢复。</li><li>回退并在可能的情况下正常降级。</li><li>启用近乎实时的监视，警报和操作控制。</li></ul><h4 id="6-2-3-Hystrix解决什么问题？"><a href="#6-2-3-Hystrix解决什么问题？" class="headerlink" title="6.2.3-Hystrix解决什么问题？"></a>6.2.3-Hystrix解决什么问题？</h4><p>复杂分布式体系结构中的应用程序具有数十种依赖关系，每种依赖关系不可避免地会在某个时刻失败。如果主机应用程序未与这些外部故障隔离开来，则可能会被淘汰。</p><p>例如，对于依赖于30个服务的应用程序，其中每个服务的正常运行时间为99.99％，您可以期望：</p><blockquote><p>99.99 30 = 99.7％的正常运行时间<br>10亿个请求中的0.3％= 3,000,000次故障<br>/每月2小时以上的停机时间，即使所有依赖项都具有出色的正常运行时间。</p></blockquote><p>现实通常更糟。</p><p>即使<strong>您没有对整个系统进行永续性设计，</strong>即使所有依赖项都能很好地执行，即使0.01％的停机时间对数十种服务中的每一项的总影响也等于一个月可能停机数小时。</p><hr><p>当一切正常时，请求流如下所示：</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E6%AD%A3%E5%B8%B8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%B5%81.png" alt="正常的请求流"></p><p>当许多后端系统之一变得潜在时，它可以阻止整个用户请求：</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E9%98%BB%E6%AD%A2%E7%94%A8%E6%88%B7%E8%AF%B7%E6%B1%82.png" alt="阻止用户请求"></p><p>随着高流量，单个后端依赖性变得潜在，这可能导致所有服务器上的所有资源在几秒钟内变得饱和。</p><p>应用程序中可能会引起网络请求的，通过网络或客户端库进行访问的每个点都是潜在失败的根源。比故障更糟糕的是，这些应用程序还会导致服务之间的延迟增加，从而备份队列，线程和其他系统资源，从而导致整个系统出现更多级联故障。</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C%E6%97%B6%E7%9A%84%E8%AF%B7%E6%B1%82.png" alt="系统故障时的请求"></p><p>当通过第三方客户端执行网络访问时，这些问题会更加严重。在“黑盒子”中，实现细节被隐藏并且可以随时更改，并且每个客户端库的网络或资源配置都不相同，并且通常难以监视和监控。更改。</p><p>更糟糕的是，传递依赖项会执行潜在的昂贵或易出错的网络调用，而不会被应用程序明确调用。</p><p>网络连接失败或降级。服务和服务器出现故障或变慢。新的库或服务部署会更改行为或性能特征。客户端库有错误。</p><p>所有这些都代表需要隔离和管理的故障和延迟，以使单个故障依赖项无法关闭整个应用程序或系统。</p><h4 id="6-2-3-Hystrix遵循的设计原则："><a href="#6-2-3-Hystrix遵循的设计原则：" class="headerlink" title="6.2.3-Hystrix遵循的设计原则："></a>6.2.3-Hystrix遵循的设计原则：</h4><ul><li>防止任何单个依赖项耗尽所有容器（例如Tomcat）用户线程。</li><li>减少负载并快速失败，而不是排队。</li><li>在可行的情况下提供备用，以保护用户免受故障的影响。</li><li>使用隔离技术（例如隔板，泳道和断路器模式）来限制任何一种依赖关系的影响。</li><li>通过近实时指标，监视和警报优化发现时间</li><li>通过在Hystrix的大多数方面中以低延迟传播配置更改来优化恢复时间，并支持动态属性更改，这使您可以通过低延迟反馈环路进行实时操作修改。</li><li>防止整个依赖项客户端执行失败，而不仅仅是网络流量失败。</li></ul><h4 id="6-2-4-Hystrix如何实现这些设计目标？"><a href="#6-2-4-Hystrix如何实现这些设计目标？" class="headerlink" title="6.2.4-Hystrix如何实现这些设计目标？"></a>6.2.4-Hystrix如何实现这些设计目标？</h4><ul><li>将对外部系统（或“依赖项”）的所有调用包装在通常在单独线程中执行的<code>HystrixCommand</code>或<code>HystrixObservableCommand</code>对象中（这是<a href="http://en.wikipedia.org/wiki/Command_pattern" target="_blank" rel="noopener">命令模式</a>的示例）。</li><li>超时呼叫花费的时间超过您定义的阈值。有一个默认的，而是由“属性”，使它们比测量的99.5略高的方式对大多数依赖你自定义设置这些超时个百分点每个依存性的性能。</li><li>为每个依赖项维护一个小的线程池（或信号灯）；如果已满，发往该依赖项的请求将立即被拒绝，而不是排队。</li><li>测量成功，失败（客户端抛出的异常），超时和线程拒绝。</li><li>如果某个服务的错误百分比超过阈值，则使断路器跳闸，以在一段时间内手动或自动停止所有对特定服务的请求。</li><li>当请求失败，被拒绝，超时或短路时执行回退逻辑。</li><li>几乎实时监控指标和配置更改。</li></ul><p>当您使用Hystrix封装每个基础依赖项时，如上图所示的体系结构将更改为类似于下图。每个依赖项彼此隔离，受到延迟时发生饱和的资源的限制，并包含回退逻辑，该逻辑决定了在依赖项中发生任何类型的故障时做出什么响应：</p><p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E6%95%85%E9%9A%9C%E6%97%B6%E5%81%9A%E5%87%BA%E5%93%8D%E5%BA%94.png" alt="故障时做出响应"></p><h3 id="6-3-Feign结合Hystrix断路器开发实战"><a href="#6-3-Feign结合Hystrix断路器开发实战" class="headerlink" title="6.3-Feign结合Hystrix断路器开发实战"></a>6.3-Feign结合Hystrix断路器开发实战</h3><ol><li>加入依赖</li></ol><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-hystrix<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>注意：网上新旧版本问题，所以要以官网为主，不然部分注解会丢失</p><ol start="2"><li>启动类增加注解<code>@EnableCircuitBreaker</code></li></ol><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableFeignClients</span><span class="token annotation punctuation">@EnableCircuitBreaker</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderServiceApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>OrderServiceApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@LoadBalanced</span>    <span class="token keyword">public</span> RestTemplate <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="3"><li>API接口编码实战</li></ol><p><strong>熔断-&gt;服务降级</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"api/v1/order"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ProductOrderService productOrderService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"save"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@HystrixCommand</span><span class="token punctuation">(</span>fallbackMethod <span class="token operator">=</span> <span class="token string">"saveOrderFail"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">save</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"user_id"</span><span class="token punctuation">)</span><span class="token keyword">int</span> userId<span class="token punctuation">,</span> <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"product_id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> productId<span class="token punctuation">)</span><span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        data<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        data<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">,</span> productOrderService<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> productId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span>  data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//注意，方法签名一定要要和api方法一致</span>    <span class="token keyword">private</span> Object <span class="token function">saveOrderFail</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">,</span> <span class="token keyword">int</span> productId<span class="token punctuation">)</span><span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"抢购人数太多，您被挤出来了，稍等重试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>编写fallback方法实现，方法签名一定要和api方法签名一致（注意点！！！）</p><ol start="4"><li><strong>Feign结合Hystrix断路器</strong></li></ol><ul><li><p>开启feign支持hystrix  (注意，一定要开启，旧版本默认支持，新版本默认关闭)</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">feign</span><span class="token punctuation">:</span>          <span class="token key atrule">hystrix</span><span class="token punctuation">:</span>            <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre></li><li><p><code>FeignClient(name=&quot;xxx&quot;, fallback=xxx.class )</code>, class需要继承当前FeignClient的类</p><p><strong>自定义服务降级处理</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 针对商品服务，做降级处理 */</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductClientFallback</span> <span class="token keyword">implements</span> <span class="token class-name">ProductClient</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">findById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"feign 调用product-service findbyid 异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">/**   * 商品服务客户端   */</span>  <span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"product-service"</span><span class="token punctuation">,</span> fallback <span class="token operator">=</span> ProductClientFallback<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProductClient</span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/api/v1/product/find"</span><span class="token punctuation">)</span>      String <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><h3 id="6-4-熔断降级服务异常报警通知实战"><a href="#6-4-熔断降级服务异常报警通知实战" class="headerlink" title="6.4-熔断降级服务异常报警通知实战"></a>6.4-熔断降级服务异常报警通知实战</h3><ol><li><p>加入redis依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>配置redis连接信息</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 127.0.0.1    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">timeout</span><span class="token punctuation">:</span> <span class="token number">2000</span></code></pre></li><li><p>监控报警</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"api/v1/order"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ProductOrderService productOrderService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> StringRedisTemplate redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"save"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@HystrixCommand</span><span class="token punctuation">(</span>fallbackMethod <span class="token operator">=</span> <span class="token string">"saveOrderFail"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">save</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"user_id"</span><span class="token punctuation">)</span><span class="token keyword">int</span> userId<span class="token punctuation">,</span> <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"product_id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> productId<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span><span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        data<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        data<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"data"</span><span class="token punctuation">,</span> productOrderService<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> productId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span>  data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//注意，方法签名一定要要和api方法一致</span>    <span class="token keyword">private</span> Object <span class="token function">saveOrderFail</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">,</span> <span class="token keyword">int</span> productId<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//监控报警</span>        String saveOrderKey <span class="token operator">=</span> <span class="token string">"save-order"</span><span class="token punctuation">;</span>        String sendValue <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>saveOrderKey<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> String ip <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getRemoteAddr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>sendValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"紧急短信，用户下单失败，请离开查找原因,ip地址是="</span><span class="token operator">+</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//发送一个http请求，调用短信服务 TODO</span>                redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>saveOrderKye<span class="token punctuation">,</span> <span class="token string">"save-order-fail"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已经发送过短信，20秒内不重复发送"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"抢购人数太多，您被挤出来了，稍等重试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="6-5-Hystrix降级策略和调整"><a href="#6-5-Hystrix降级策略和调整" class="headerlink" title="6.5-Hystrix降级策略和调整"></a>6.5-Hystrix降级策略和调整</h3><ol><li><p><strong>查看默认降级策略 HystrixCommandProperties</strong></p><ul><li><code>execution.isolation.strategy</code>   隔离策略<br>THREAD 线程池隔离 （默认）<br>SEMAPHORE 信号量<br>信号量适用于接口并发量高的情况，如每秒数千次调用的情况，导致的线程开销过高，通常只适用于非网络调用，执行速度快</li><li><code>execution.isolation.thread.timeoutInMilliseconds</code>  超时时间<br>默认 1000毫秒</li><li><code>execution.timeout.enabled</code> 是否开启超时限制 （一定不要禁用）</li><li><code>execution.isolation.semaphore.maxConcurrentRequests</code> 隔离策略为 信号量的时候，如果达到最大并发数时，后续请求会被拒绝，默认是10<br>官方文档:<a href="https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.strategy" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.strategy</a></li></ul></li><li><p>调整策略<br>超时时间调整</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">hystrix</span><span class="token punctuation">:</span>  <span class="token key atrule">command</span><span class="token punctuation">:</span>    <span class="token key atrule">default</span><span class="token punctuation">:</span>      <span class="token key atrule">execution</span><span class="token punctuation">:</span>        <span class="token key atrule">isolation</span><span class="token punctuation">:</span>          <span class="token key atrule">thread</span><span class="token punctuation">:</span>            <span class="token key atrule">timeoutInMilliseconds</span><span class="token punctuation">:</span> <span class="token number">4000</span></code></pre></li></ol><h3 id="6-6-断路器Dashboard监控仪表盘"><a href="#6-6-断路器Dashboard监控仪表盘" class="headerlink" title="6.6-断路器Dashboard监控仪表盘"></a>6.6-断路器Dashboard监控仪表盘</h3><ol><li><p>添加依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-hystrix-dashboard<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>启动类增加注解<code>@EnableHystrixDashboard</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableFeignClients</span><span class="token annotation punctuation">@EnableCircuitBreaker</span><span class="token annotation punctuation">@EnableHystrixDashboard</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderServiceApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>OrderServiceApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@LoadBalanced</span>    <span class="token keyword">public</span> RestTemplate <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>配置文件增加endpoint</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">management</span><span class="token punctuation">:</span>  <span class="token key atrule">endpoints</span><span class="token punctuation">:</span>    <span class="token key atrule">web</span><span class="token punctuation">:</span>      <span class="token key atrule">exposure</span><span class="token punctuation">:</span>        <span class="token key atrule">include</span><span class="token punctuation">:</span> <span class="token string">"*"</span></code></pre></li><li><p>访问入口<br><a href="http://localhost:8080/hystrix" target="_blank" rel="noopener">http://localhost:8080/hystrix</a><br>Hystrix Dashboard输入： <a href="http://localhost:8080/actuator/hystrix.stream" target="_blank" rel="noopener">http://localhost:8080/actuator/hystrix.stream</a><br><strong>参考资料</strong></p><pre><code>默认开启监控配置https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security-actuator配置文件类：spring-configuration-metadata.json</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务架构基础</title>
      <link href="/2020/01/16/wei-fu-wu-jia-gou-ji-chu/"/>
      <url>/2020/01/16/wei-fu-wu-jia-gou-ji-chu/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式架构基础</title>
      <link href="/2020/01/16/fen-bu-shi-jia-gou-ji-chu/"/>
      <url>/2020/01/16/fen-bu-shi-jia-gou-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式架构基础"><a href="#分布式架构基础" class="headerlink" title="分布式架构基础"></a>分布式架构基础</h1><h2 id="1-分布式系统"><a href="#1-分布式系统" class="headerlink" title="1-分布式系统"></a>1-分布式系统</h2><p>分布式系统是其组件分布在连网的计算机上，组件之间通过传递消息进行通信和动作协调的系统。一个标准的分布式系统在没有任何特定业务逻辑约束的情况下，一般有以下几个特征：</p><ul><li><strong>分布性</strong>：一个分布式系统中的计算机在空间部署上是可以随意分布的，这些计算机可能处于不同的机柜上，不同的城市的机房中，或者是世界上任何一个角落。同时，机器的分布情况也会随时变动；</li><li><strong>并发性</strong>：在一个计算机网络中，程序运行过程中的并发性操作是非常常见的行为，例如同一个分布式系统的多个节点，可能会并发地操作一些共享的资源，诸如数据库或分布式存储等，如何准确并高效地协调分布式并发操作也成为了分布式系统架构与设计中最大的挑战之一；</li><li><strong>缺乏全局时钟</strong>：分布式系统中多个进程可能在空间上分布式在各处，进程之间通过交换消息来相互协作，密切的协作通常取决于对程序动作发生的时间的共识。但在分布式系统中，各进程与时钟同步所达到的准确性是有限的，即没有一个正确时间的全局概念；</li><li><strong>故障独立性</strong>：组成分布式系统的所有计算机，都有可能发生任何形式的故障。单个模块的故障相对容易预知并设计应对逻辑，但分布式系统可能以新的方式出现故障。网络故障导致互连的计算机的隔离，但它们并不一定会停止运行，而且程序很难判断是网络故障还是因为延迟。同样，当被网络隔离计算程序在异常终止时，也许不能马上通知与它通信的其他组件了解。系统的每个组件会单独地出现故障，而其他组件还在运行。</li></ul><p>分布式系统能够实现高可用、高吞吐、大容量存储、海量计算、并行计算等优异能力，天然的分布性和可伸缩等特性，也打破了物理上单机的瓶颈，使其能不断支撑着业务的发展而演进，并推进了云计算、大数据、人工智能等领域的发展。但是正如每个硬币都有两面，分布式系统的复杂性，也使其在设计、研发、运行、维护、安全性等方面都面临更多的挑战。</p><h2 id="2-分布式理论"><a href="#2-分布式理论" class="headerlink" title="2-分布式理论"></a>2-分布式理论</h2><h3 id="2-1-CAP理论"><a href="#2-1-CAP理论" class="headerlink" title="2.1-CAP理论"></a>2.1-CAP理论</h3><p>CAP理论又称CAP定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p><p><img src="/2020/01/16/fen-bu-shi-jia-gou-ji-chu/CAP.png" alt="CAP"></p><p><strong>归纳如下：</strong></p><ul><li>一致性（<strong>Consistency</strong>）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。等同于所有节点访问同一份最新的数据副本；集群中<strong>所有节点的数据</strong>，<strong>时刻</strong>保持一致。</li><li>可用性（<strong>Availability</strong>）：每一个请求，都一定能够收到一个响应，无论响应成功还是失败。在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求，对数据更新具备高可用性。</li><li>可扩展性/<strong>分区容忍性</strong>（<strong>Partition-tolerance</strong>）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul><p>CAP原理告诉我们，这三个因素最多只能满足两个，不可能三者兼顾。对于分布式系统来说，分区容错是基本要求，所以必然要放弃一致性。对于大型网站来说，分区容错和可用性的要求更高，所以一般都会选择适当放弃一致性。对应CAP理论，NoSQL追求的是AP，而传统数据库追求的是CA，这也可以解释为什么传统数据库的扩展能力有限的原因。</p><p>也就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡。</p><p>任何一个分布式系统，都不能够同时满足一致性，可用性，分区容错性。</p><p><strong>所以在分布式系统可供选择的方案有三种：</strong></p><ul><li>CP：选择了数据一致性和分区容错性，放弃了可用性。一旦发生网络分区，受影响的服务就需要等待数据一致，因此在等待期间无法对外继续提供服务。</li><li>AP：选择了可用性和分区容错性，放弃了数据（强）一致性。</li><li>CA：放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择。</li></ul><p><strong>原因：</strong></p><ul><li>CA满足的情况下，P不能满足的原因：<pre><code>    数据同步(C)需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以P就不满足</code></pre></li><li>CP 满足的情况下，A不能满足的原因：<pre><code>    数据同步(C)需要时间, 机器数量也多(P)，但是同步数据需要时间，所以不能再正常时间内响应，所以A就不满足</code></pre></li><li>AP 满足的情况下，C不能满足的原因：<pre><code>    机器数量也多(P)，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以C不满足</code></pre></li></ul><p><strong>微服务注册中心的选择：</strong></p><ul><li>Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足。如金融行业</li><li>Eureka：AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化。如电商系统</li></ul><h3 id="2-2-BASE理论"><a href="#2-2-BASE理论" class="headerlink" title="2.2-BASE理论"></a>2.2-BASE理论</h3><p>BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p><p>BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。</p><p>基于CAP理论，CAP理论不适用于数据库事务（因为更新一些错误的数据而导致数据出现紊乱，无论什么样的数据库高可用方案都是徒劳） ，虽然XA事务可以保证数据库在分布式系统下的ACID特性，但是会带来性能方面的影响。</p><ul><li>基本可用（Basically available）：在分布式系统出现不可预知的故障时，损失系统部分可用性。<ul><li>响应时间上的损失。正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出现故障，查询结果的响应时间增加了1~2秒。</li><li>系统功能上的损失：正常情况下，在一个电子商务网站上进行购物的时候，消费者几乎能够顺利完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li><li>数据库采用分片模式，把100万用户数据分布在5个实例上，其中一个实例故障了，仍然可以保证80%的可用用户数据。</li></ul></li><li>软状态（Soft-state）：什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</li><li>最终一致性（Eventually-consistent）：最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li></ul><p><strong>ACID和BASE的区别与联系</strong>：</p><p>ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性，ACID和BASE代表了两种截然相反的设计哲学。</p><p>ACID 是传统数据库系统常用的设计理论，追求强一致性模型。BASE 常用于大型分布式系统，只需要保证最终一致性。在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p><h2 id="3-分布式系统的主要组成"><a href="#3-分布式系统的主要组成" class="headerlink" title="3-分布式系统的主要组成"></a>3-分布式系统的主要组成</h2><h3 id="3-1-分布式服务"><a href="#3-1-分布式服务" class="headerlink" title="3.1-分布式服务"></a>3.1-分布式服务</h3><p>分布式系统下节点间服务通讯有两种途径，一种是通过 RPC(Remote Procedure Call) 实现两点间通讯，可以设计成同步通讯，也可以是异步的；一种是通过消息中间件实现通信，一般是异步通讯方式。</p><ul><li><p>RPC 调用</p><p>RPC 调用也是分布式环境下常见的通讯方式，有同步的模式，也有异步的模式。同步模式下，客户端发起调用并阻塞当前线程，直到服务端处理完毕返回响应才完成整个调用过程；异步模式下，客户端发起调用后立即返回，并记录当前请求，直到接收到服务端响应后才找到对应的请求进行结果的处理，并完成整个调用过程。</p><p>RPC 调用中一般只有两个角色：客户端和服务端，但在分布式环境下服务端可能有多台机器，他们共同组成一个集群，每台都提供一样的服务。这时就要有一种机制能让客户端将持续不断的请求均衡的分发到所有的服务端，一般将这种机制称为「负载均衡」。负载均衡可以在客户端实现，也可以通过专门的负载均衡设备实现。如果采用客户端负载均衡方案，需要让客户端感知所有服务端的机器地址和端口，需要引入一套「服务发现和集成的体系」，好处是通讯是点对点的，比较高效，且不存在单点。如果使用专门负载均衡设备，则客户端只需感知负载均衡设备的地址，由它来对接所有服务端，并均衡服务请求，这种模式比较简单，但存在性能单点，且延长了请求链路，稳定性也会受影响。无论是客户端还是专门设备做负载聚合，都可以根据不同的场景采用适合的负载均衡策略，常见的策略有随机（Random）、轮询（RoundRobin）、最快连接数（Fastest Connection）、最小连接数（Least Connection）等等。</p></li><li><p>消息中间件</p><p>消息中间件一般是独立部署的一组应用程序，负责消息的接收和投递。整个通讯过程是异步的，有消息发布者、消息中间件和消息订阅者三个角色，消息从发布端发出后，会被消息中间件接收并做持久化，消息的消费有两种常见的模式，一种是消息中心主动投递的模式（推模式），一种是订阅者主动拉取的模式（拉模式）。在推模式下，发布者发布消息，消息发到消息中心做持久化，然后被投递到订阅端集群，一般来说会选择在所有订阅者中随机选一台投递，在这种模式下，要求消息订阅者集群的消息消费速度要能跟上发布消息是速度；在拉模式下，消费者根据队列里消息总数来做均分，主动连上消息中间件进行消费，对消费速度没有速度限制，所以一般拉模式的消息中间件会提供更强的消息扛积压能力。</p><p>由于消息被持久化，所以可以做到消息的可靠投递，保证了分布式环境下通讯的可靠达到。在分布式环境下，一个系统可能会在一次事务操作中通过消息的方式去改变其它系统的状态（主要指存储的状态），为了能模拟类似事务的一致性，异步消息可以利用 DB 的持久化来支持事务型消息。事务型消息指的是发布消息的应用系统在本地数据库事务操作序列中发送的消息。此类消息的投递与数据库事务状态保持一致，当事务状态是提交时，消息会被投递到订阅者，当事务状态是回滚时，消息不会被投递到订阅者，这也是分布式环境下消息中间件需要支持的特殊场景。</p></li></ul><h3 id="3-2-分布式数据存储"><a href="#3-2-分布式数据存储" class="headerlink" title="3.2-分布式数据存储"></a>3.2-分布式数据存储</h3><ol><li><p>分布式缓存</p><p>当传统数据库面临大规模数据访问时，磁盘 I/O 能力往往成为性能瓶颈，从而导致过高的响应延迟，而比较常用的提升性能的手段，是在应用和数据库之间加入一层分布式缓存来提升数据访问性能，分布式缓存将高速内存作为数据对象的存储介质，理想情况下可以获得内存级的读写性能，常见的缓存实现会通过 LRU 算法来缓存访问最多的数据，进而提升缓存效率。</p><p>通过分布式缓存服务器集群，将缓存数据分布到集群多台服务器上可在一定程度上改善缓存的可用性，同时也能起到扩展缓存容量的作用，当一台缓存服务器宕机的时候，只有部分缓存数据丢失，重新从数据库加载这部分数据不会对数据库产生很大影响。</p><p>分布式缓存还具有支持弹性扩展的能力，通过动态增加或减少节点，应对变化的数据访问负载，提供可预测的性能与扩展性，同时也能最大限度地提高资源利用率</p><p>分布式缓存比较典型应用场景包括：</p><p><strong>应用对象缓存</strong>：缓存系统作为 ORM 框架的二级缓存对外提供服务，目的是减轻数据库的负载压力，加速应用访问;</p><p><strong>状态缓存</strong>：缓存包括 Session 会话状态及应用横向扩展时的状态数据等，这类数据一般是难以恢复的，对可用性要求较高，多应用于高用集群;</p><p><strong>并行处理</strong>：通常涉及大量中间计算结果需要共享;</p><p><strong>事件处理</strong>：分布式缓存提供了针对事件流的连续查询 (continuous query) 处理技术，满足实时性需求;</p><p><strong>极限事务处理</strong>：分布式缓存为事务型应用提供高吞吐率、低延时的解决方案，支持高并发事务请求处理，多应用于铁路、金融服务和电等领域。</p><p>通过配置合理容量的分布式缓存，能在提升应用数据访问性能的同时，降低总体拥有成本，因此架构设计上做到合理利用缓存，变得就越来越重要。</p></li><li><p>分布式文件系统</p><p>分布式文件系统，是指允许文件通过网络在多台计算机中分散存储的共享文件系统，它通过网络将分布在不同区域的多台计算机连接在一起从而组合成容量更大，处理能力更强的分布式文件存储系统。分布式文件系统很好的解决单台计算机存储和处理能力存在上限的问题，具备大的存储容量和处理能力的扩展能力。</p><p>在分布式文件系统中，客户端并非直接访问底层存储，而是通过网络以特定的通信协议和服务器沟通，进而完成文件存储操作，借由通信协议的设计，可以让客户端和服务器端都能根据访问控制清单或是授权，来限制对于文件系统的访问。由于分布式文件系统的网络接入特性，使得不同用户都能通过网络接入分布式文件系统，实现文件数据的共享，从用户角度看，分布式文件系统与单机文件系统看到的视图是一样的，使用方式也相同。</p><p>分布式文件系统除了能提供比单机文件系统更大的存储容量和处理能力外，通过数据复制与容错，也拥有了本地文件系统所无法具备的数据备份、数据安全等优点，也就是说，即使系统中有一小部分的节点脱机，整体来说系统仍然可以持续运作而不会有数据损失。</p></li><li><p>分布式数据库</p><p>随着数据量的高速增长，分布式数据库技术也得到了快速的发展，传统的关系型数据库开始从集中式模型向分布式架构发展。分布式数据库是指利用高速计算机网络将物理上分散的多个数据存储单元连接起来组成一个逻辑上统一的数据库。分布式数据库的基本思想是将原来集中式数据库中的数据分散存储到多个通过网络连接的数据存储节点上，以获取更大的存储容量和更高的并发访问量。</p><p>分布式数据库可以按需增加、减少数据库处理节点，很好地解决了单台数据库的存储和处理能力上限问题；除此之外，分布式数据库往往具备较强的容错能力，通过数据复制、副本冗余，当某个处理节点出现故障时，能够自动恢复，对使用者没有感知。最后，分布式数据库底层采用廉价服务器，相比传统单机数据库使用的高端服务器和高端存储，成本大幅度降低。</p><p>在分布式数据库中，客户端并非直接访问底层的存储系统，而是使用结构化查询语言（SQL语言）访问数据库节点，再由数据库节点的 SQL 引擎翻译成针对底层存储系统的操作。一套分布式数据库往往会服务多个业务，分布式数据库内部支持多个业务之间的隔离，当某个业务出现异常时，只会影响该业务，不会对其它业务造成影响。蚂蚁的 OceanBase 是一个典型的分布式数据库。使用分布式数据库，将大大降低单库故障的发生机率，并简化单库故障的恢复机制。再结合分布式数据中间件在业务维度数据分片和路由、数据源动态调整、应用层高可用容灾、异构数据源适配等能力，将能很好的实现分布式环境下 DB 的高性能访问和高可用。</p></li><li><p>分布式数据中间件</p><p>关系型数据库是经典的持久化解决方案，但在海量业务场景下也会遇到单表的容量瓶颈和单库的性能瓶颈。按照分布式的思想，数据也要拆分，让集中在单点的读写访问分布到多个 DB 服务器上，从而获得容量和性能上的弹性延伸能力。根据业务场景可分为垂直拆分（按业务）、水平拆分（按请求/用户做哈希，或者做区间拆分）、读写拆分等。</p><p>按照垂直拆分后的数据会造成本来单库事务变成跨库事务，很难通过传统数据库的机制来保证 ACID，需要引入一种应用层的，基于服务的事务协调机制。这个下文会有专门阐述。按照水平拆分的数据，需要按照某些业务维度将数据拆分到不同的库表，从而解决数据水平扩展的问题，也提升了整体的 QPS，使数据层具备 TB+/天 的吞吐能力。数据拆分后，每次数据访问需要按照分库分表的规则进行路由，本质上是通过规则对原始 SQL 进行重写，拆分成多条 SQL，并分发给链接多个库的数据源去执行，并汇总结果。由于整个过程都在应用层进行，为屏蔽复杂性，需要将上述逻辑封装一层中间件类库中，并通过标准 JDBC 接口对外暴露接口，让业务透明的完成整个数据库的访问过程。</p><p>通过一层统一的分布式数据中间件，让业务通过标准 SQL 和标准 JDBC 接口就能访问一组理论容量「无限大」的关系型数据库集群，并且具有很好的性能。同时，通过这层中间件，也能实现所有数据库参数的动态调整、路由规则动态调整、数据库分片权重的调整，从而在应用层实现数据库访问的高可用，且不依赖于数据库高可用机制，甚至提供更灵活强大的故障容忍能力。此外，标准 SQL 和 JDBC 屏蔽了底层数据库的实现，使应用具备透明对接异构数据源的能力，实现复杂场景的业务访问和一些双写双读的需求。</p></li></ol><h3 id="3-3-分布式事务"><a href="#3-3-分布式事务" class="headerlink" title="3.3-分布式事务"></a>3.3-分布式事务</h3><p>传统关系型数据库的事务模型必须遵守 ACID 原则。在单数据库模式下，ACID 模型能有效保障数据的完整性，但是在大规模分布式环境下，单库无法承载高并发和海量数据，所以数据会被通过垂直拆分或水平拆分到不同的 DB 中，一个业务往往会跨越多个数据库。在 JavaEE 规范中使用 2PC (2 Phase Commit, 两阶段提交) 来处理跨 DB 环境下的事务问题，但是 2PC 是反可伸缩模式，也就是说，在事务处理过程中，参与者需要一直持有资源直到整个分布式事务结束。这样，当业务规模达到千万级以上时，2PC 的局限性就越来越明显，系统可伸缩性会变得很差。基于 BASE 的思想可以仿照 2PC 的方式，在应用层来实现分布式环境下多个事务协调一致。 在充分保障分布式环境下高可用性、高可靠性的同时兼顾数据一致性的要求，其最大的特点是保证数据最终一致 (Eventually consistent)。</p><p>在分布式事务中，可以简单分成事务发起方和事务参与者两个角色。发起方负责启动分布式事务，触发创建主事务记录。发起方是分布式事务的总体协调者，负责调用参与者的服务，记录相应的事务日志，并感知整个分布式事务状态来决定整个事务是 COMMIT 还是 ROLLBACK。参与者是分布式事务中的一个原子单位，所有参与者都必须定义 prepare、commit、rollback 3个基本接口，并保证其业务数据的幂等性，也必须保证 prepare 中的数据操作能够被提交 (COMMIT) 或者回滚 (ROLLBACK)。</p><p>整个协调过程从发起方开启一个本地事务开始，过程中参与者会显式调用参与方的业务方法，这些显式调用的方法即为一阶段的 prepare 方法，一般参与方会在该方法内锁定资源。这些方法调用可以采用第一小节提到的「消息中间件」，也可以采用「RPC 通讯」。一旦这次本地事务成功，则本地事务提交，发起方会调用第二阶段的真正 commit 方法，来让所有参与方的事务完成第二阶段的提交。本地事务提交失败或者在这之前某个逻辑中失败（可能是本地逻辑异常，也可能参与方一阶段失败），则本地事务失败，发起方会负责完成一阶段的所有回滚操作，避免出现不一致情况。</p><p>在分布式环境下，单点故障是个常态，所以无论是发起方还是参与方都可能在任何一刻不可用，此时需要一个第三方的恢复系统来感知所有的事务状态，并通过定期轮询来发现异常状态的事务记录，并将其恢复至最终一致。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试之Junit</title>
      <link href="/2020/01/15/dan-yuan-ce-shi-zhi-junit/"/>
      <url>/2020/01/15/dan-yuan-ce-shi-zhi-junit/</url>
      
        <content type="html"><![CDATA[<h1 id="Junit5单元测试"><a href="#Junit5单元测试" class="headerlink" title="Junit5单元测试"></a>Junit5单元测试</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1-前言"></a>1-前言</h2><p>单元测试是软件开发过程中必不可少的一环，但是在平常开发中往往因为项目周期紧，工作量大而被忽略，这样往往导致软件问题层出不穷。线上出现不少问题其实在右单元测试的情况下就可以及时发现和处理，因此培养自己在日常开发中写单元测试的能力是很有必要的，无论是对自己编码能力的提高，还是项目质量的提升，都大有帮助。</p><h2 id="2-认识Junit5"><a href="#2-认识Junit5" class="headerlink" title="2-认识Junit5"></a>2-认识Junit5</h2><p>在java单元测试领域中，<code>Junit</code>和<code>TestNG</code>占据着主要的市场，其中Junit有着就爱哦长的发展历史和不断演进的丰富功能，备受大多数Java开发者的青睐。</p><p>而<code>Junit5</code>版本是Junit单元测试框架的一次重大升级，要完全使用<code>Junit5</code>的功能，就必须使用<code>JDK8</code>以上的环境。</p><p>与以前版本不同的是Junit5是由三个不同子项目的几个不同模块组成：</p><p><code>Junit 5 = Junit Platform + Junit Jupiter + Junit Vintage</code></p><ul><li>Junit Platform：用于JVM上启动测试框架的基础服务，提供命令行，IDE和构建工具等方式执行测试的支持，并通过命令行定义TestEngine API；</li><li>Junit Jupiter：用于编写测试和扩展编程的扩展模型，然后通过插件在Junit、Gradle或Maven中来构建；</li><li>Junit Vintage：用于在Junit 5中兼容运行Junit3.x和Junit4.x的测试用例；</li></ul><h2 id="3-为什么需要Junit-5？"><a href="#3-为什么需要Junit-5？" class="headerlink" title="3-为什么需要Junit 5？"></a>3-为什么需要Junit 5？</h2><p>自从有了Junit之类的测试框架，Java单元测试领域逐渐成熟，开发人员对单元测试框架也有了更高的要求：</p><p>​    如：更多的测试方法、更少的其他库依赖；</p><p>因此大家都期待着一个更强大的测试框架诞生，Junit作为Java测试领域的领头羊，推出了Junit 5这个版本；</p><p>主要特性有：</p><ul><li>提供全新的断言和测试注解，支持测试类内嵌，允许在断言中使用Lambda表达式</li><li>更丰富的测试方法：支持动态测试，重复测试，参数化测试等</li><li>实现了模块化，让测试执行和测试发现等不同模块解耦，减少依赖</li><li>提供对Java8的支持，如Lambda表达式，Stream API等</li></ul><p><img src="/2020/01/15/dan-yuan-ce-shi-zhi-junit/junit.png" alt="Junit5"></p><h2 id="4-如何使用Junit-5"><a href="#4-如何使用Junit-5" class="headerlink" title="4-如何使用Junit 5"></a>4-如何使用Junit 5</h2><ol><li><p>首先需要添加Junit 5的依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.junit.jupiter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit-jupiter-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${junit.jupiter.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>${junit.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre></li><li><p>定义测试方法</p><table><thead><tr><th>import org.junit.jupiter.api.*（注解）</th><th>描述</th></tr></thead><tbody><tr><td>@Test</td><td>将方法标识为测试方法</td></tr><tr><td>@RepeatedTest（<Number>）</Number></td><td>重复测试<Number>次</Number></td></tr><tr><td>@TestFactory</td><td>方法是进行动态测试的工厂</td></tr><tr><td>@BeforeEach</td><td>在每次测试之前执行，它用于准备测试环境（如：读取输入数据，初始化类）</td></tr><tr><td>@AfterEach</td><td>在每次测试后执行，它用于清理测试环境（如：删除临时数据，恢复默认值），它还可以通过清理昂贵的内存结构来节省内存</td></tr><tr><td>@BeforeAll</td><td>在所有测试开始前执行一次，它用于执行耗时的活动，例如：连接到数据库；需要标记带有此批注的方法<code>static</code>才能与Junit一起使用</td></tr><tr><td>@AfterAll</td><td>在完成所有测试之后，执行一次，它用于执行清理活动，例如：与数据库断开连接；需要定义此注解的方法static以便与Junit一起使用</td></tr><tr><td>@Nested</td><td>使得可以嵌套内部测试类以强制执行一定的执行顺序，能够以静态内部类的形式对测试用例类进行逻辑分组</td></tr><tr><td>@Tag(“<TagName>“)</TagName></td><td>Junit 5中的测试可以通过标签过滤；例如：仅运行标签为“快速”的测试方法</td></tr><tr><td>@ExtendWith</td><td>可以让你注册一个或多个扩展点集成的扩展类</td></tr><tr><td>@Disabled（@Disabled（“WhyDisabled”））</td><td>指示应该禁用测试，当基础代码已更改且测试用例尚未适用时，这很有用；或者如果侧测试的执行时间太长而无法包括在内；最佳的做法是提供可选说明，说明为什么禁用测试</td></tr><tr><td>@DisplayName（”<Name>“）</Name></td><td>&lt;名称&gt;，将由测试运行器显示，与方法名称相反，DisplayName可以包含空格</td></tr></tbody></table></li><li><p>断言</p><p>在断言API设计上，Junit 5进行显著的改进，并且充分利用Java 8的新特性，特别是Lambda表达式，最终提供了新的断言类</p><p><code>org.junit.jupiter.api.Assertions</code>；许多断言方法接收Lambda表达式参数，在断言消息使用Lambda表达式的一个优点就是踏实延迟计算的，如果消息构造开销很大，这样做一定程度上可以节省时间和资源。</p><ul><li><code>assertAll</code>：断言所有提供的可执行文件都不会抛出异常。若提供的标题(heading),其将包含在MultipleFailuresError的消息字符串中。</li><li><code>assertArrayEquals</code>：断言期望的和实际的XX类型数组是相等的。若失败，将显示提供的失败消息。</li><li><code>assertDoesNotThrow</code>：虽然从测试方法抛出的任何异常都会导致测试失败，但在某些用例中，显式断言测试方法中的给定代码块不会抛出异常会很有用。若提供的标题(heading),其将包含在MultipleFailuresError的消息字符串中。</li><li><code>assertEquals</code>：断言预期和实际是相等的。如有必要，将从提供的messageSupplier中懒惰地检索失败消息。</li><li><code>assertFalse</code>：断言提供的条件不是真。失败并显示提供的失败消息。</li><li><code>assertIterableEquals</code>：断言预期和实际的迭代是完全相同的。类似于检查assertArrayEquals(Object []，Object []，String)中的完全相等，如果遇到两个迭代(包括期望和实际)，则它们的迭代器必须以相同的顺序返回相等的元素。注意：这意味着迭代器不需要是同一类型。</li><li><code>assertNotNull</code>：断言提供的条件不为null</li><li><code>assertNotSame</code>：断言预期和实际不会引用同一个对象</li><li><code>assertNull</code>：断言提供的实际为null</li><li><code>assertSame</code>：断言预期和实际引用同一个对象</li><li><code>assertThrows</code>：断言所提供的可执行代码块的执行会引发expectedType的异常并返回异常。如果没有抛出异常，或者抛出了不同类型的异常，则此方法将失败。如果不想对异常实例执行其他检查，只需忽略返回值。</li><li><code>assertTimeout</code>：断言在超出给定超时之前，所提供的可执行代码块的执行完成。注意：可执行代码块将在与调用代码相同的线程中执行。因此，如果超过超时，则不会抢先中止执行可执行代码块。</li><li><code>assertTimeoutPreemptively</code>：断言在超出给定超时之前，所提供的可执行代码块的执行完成。注意：可执行代码块将在与调用代码不同的线程中执行。此外，如果超过超时，则可抢占地执行可执行代码块。</li><li><code>assertTrue</code>：断言提供的条件为true</li><li><code>fail</code>：使用给定的失败消息以及根本原因进行测试失败。泛型返回类型V允许此方法直接用作单语句lambda表达式，从而避免需要实现具有显式返回值的代码块。 由于此方法在其return语句之前抛出AssertionFailedError，因此该方法实际上永远不会向其调用者返回值。</li></ul></li><li><p>测试方法案例</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"我的第一个测试用例"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyFirstTestCaseTest</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@BeforeAll</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始化数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@AfterAll</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"清理数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@BeforeEach</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tearup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前测试方法开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@AfterEach</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">tearDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前测试方法结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"我的第一个测试"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testFirstTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我的第一个测试开始测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"我的第二个测试"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testSecondTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我的第二个测试开始测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>测试结果如下：</p><p><img src="/2020/01/15/dan-yuan-ce-shi-zhi-junit/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95.jpg" alt="第一个测试"></p></li></ol><p>   <strong>禁用测试方法：</strong><code>@Disabled</code></p><pre class=" language-java"><code class="language-java">   <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"我的第三个测试"</span><span class="token punctuation">)</span>   <span class="token annotation punctuation">@Disabled</span>   <span class="token annotation punctuation">@Test</span>   <span class="token keyword">void</span> <span class="token function">testThirdTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我的第三个测试开始测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span></code></pre><p>   测试结果如下：</p><p>   <img src="/2020/01/15/dan-yuan-ce-shi-zhi-junit/%E7%A6%81%E7%94%A8%E6%B5%8B%E8%AF%95.png" alt="禁用测试"></p><p>   <code>@Disabled</code> 也可以使用在类上，用于标记类下所有的测试方法不被执行，一般使用对多个测试类组合测试的时候。</p><p>   <strong>内嵌测试类：</strong><code>@Nested</code></p><p>   当我们编写的类和代码逐渐增多，随之而来的需要测试的对应测试类也会越来越多。为了解决测试类数量爆炸的问题，JUnit 5提供了@Nested 注解，能够以静态内部成员类的形式对测试用例类进行逻辑分组。 并且每个静态内部类都可以有自己的生命周期方法， 这些方法将按从外到内层次顺序执行。 此外，嵌套的类也可以用<code>@DisplayName</code> 标记，这样我们就可以使用正确的测试名称。</p><pre class=" language-java"><code class="language-java">   <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"内嵌测试类"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NestUnitTest</span> <span class="token punctuation">{</span>       <span class="token annotation punctuation">@BeforeEach</span>       <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"测试方法执行前准备"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token annotation punctuation">@Nested</span>       <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"第一个内嵌测试类"</span><span class="token punctuation">)</span>       <span class="token keyword">class</span> <span class="token class-name">FirstNestTest</span> <span class="token punctuation">{</span>           <span class="token annotation punctuation">@Test</span>           <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第一个内嵌测试类执行测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token annotation punctuation">@Nested</span>       <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"第二个内嵌测试类"</span><span class="token punctuation">)</span>       <span class="token keyword">class</span> <span class="token class-name">SecondNestTest</span> <span class="token punctuation">{</span>           <span class="token annotation punctuation">@Test</span>           <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"第二个内嵌测试类执行测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><p>   测试结果如下：</p><p>   <img src="/2020/01/15/dan-yuan-ce-shi-zhi-junit/%E5%86%85%E5%B5%8C%E6%B5%8B%E8%AF%95%E7%B1%BB.png" alt="内嵌测试类"></p><p>   <strong>重复性测试：</strong><code>@RepeatedTest</code><br>   在 JUnit 5 里新增了对测试方法设置运行次数的支持，允许让测试方法进行重复运行。当要运行一个测试方法 N次时，可以使用 @RepeatedTest 标记它</p><pre class=" language-java"><code class="language-java">   <span class="token annotation punctuation">@DisplayName</span><span class="token punctuation">(</span><span class="token string">"重复测试"</span><span class="token punctuation">)</span>   <span class="token annotation punctuation">@RepeatedTest</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">i_am_a_repeated_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span></code></pre><p>   测试结果如下：</p><p>   <img src="/2020/01/15/dan-yuan-ce-shi-zhi-junit/%E9%87%8D%E5%A4%8D%E6%B5%8B%E8%AF%95.png" alt="重复测试"></p><ol start="5"><li><p>断言案例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AssertionsDemo</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//定义一个person对象，Person类里面有两个参数lastName,firstName</span>    <span class="token keyword">static</span> Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 使用 @BeforeAll注解在所有测试方法执行前执行person对象的赋值     */</span>    <span class="token annotation punctuation">@BeforeAll</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">initPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        person<span class="token punctuation">.</span><span class="token function">setFirstName</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        person<span class="token punctuation">.</span><span class="token function">setLastName</span><span class="token punctuation">(</span><span class="token string">"Doe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * assertEquals比较两个值是否相同     * assertTrue 判断括号里面的参数是否为true     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">standardAssertions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//当不相等时，会打印出第三个参数，下面的所有的此类型的参数都是这种作用</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"The optional assertion message is now the last parameter."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertTrue</span><span class="token punctuation">(</span><span class="token string">'a'</span> <span class="token operator">&lt;</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">"Assertion messages can be lazily evaluated -- "</span>                <span class="token operator">+</span> <span class="token string">"to avoid constructing complex messages unnecessarily."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * assertAll()方法用于将多个测试语句放在一个组中执行     * 组中若有一个测试语句不通过，则这个组将会一起报错.     * 方法中第一个参数：组名称     * 方法中第二个参数：组测试语句     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">groupedAssertions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">assertAll</span><span class="token punctuation">(</span><span class="token string">"person"</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">,</span> person<span class="token punctuation">.</span><span class="token function">getFirstName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"Doe"</span><span class="token punctuation">,</span> person<span class="token punctuation">.</span><span class="token function">getLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * assertAll()方法也可以嵌套多个assertAll()方法     * 其中嵌套的多个测试组，这些组只会打印出这个组和父组的错误，对其他的组没有影响     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">dependentAssertions</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">assertAll</span><span class="token punctuation">(</span><span class="token string">"properties"</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">//第一个测试组</span>                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                    String firstName <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">getFirstName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">assertNotNull</span><span class="token punctuation">(</span>firstName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">assertAll</span><span class="token punctuation">(</span><span class="token string">"first name"</span><span class="token punctuation">,</span>                            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">assertTrue</span><span class="token punctuation">(</span>firstName<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"J"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">assertTrue</span><span class="token punctuation">(</span>firstName<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">"n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">//第二个测试组</span>                <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                    String lastName <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">getLastName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">assertNotNull</span><span class="token punctuation">(</span>lastName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">assertAll</span><span class="token punctuation">(</span><span class="token string">"last name"</span><span class="token punctuation">,</span>                            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">assertTrue</span><span class="token punctuation">(</span>lastName<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">assertTrue</span><span class="token punctuation">(</span>lastName<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">"e"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * assertThrows()可以用来判断lambda表达式中的代码抛出的异常     * 比如下面案例就是测试了抛出异常的信息是否相同     * 参数：     * 1：异常类声明     * 2：测试代码Lambda表达式     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">exceptionTesting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Throwable exception <span class="token operator">=</span> <span class="token function">assertThrows</span><span class="token punctuation">(</span>IllegalArgumentException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//这里只是简单的做个测试，当然1/0不该抛IllegalArgumentException异常 ，只是简单的测试一下</span>              <span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"a message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"a message"</span><span class="token punctuation">,</span> exception<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * assertTimeout()对方法执行时间进行测试     * 这里要借助java.time.Duration中的方法结合实现     * 实例中执行的代码部分必须在2分钟之内执行完毕，否则测试不通过     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">timeoutNotExceeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">assertTimeout</span><span class="token punctuation">(</span><span class="token function">ofMinutes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//执行的代码部分</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * assertTimeout()还可以接受一个返回值（泛型 T）     * 被测试代码如果通过测试并返回一个值，这个值被assertTimeout()方法返回     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">timeoutNotExceededWithResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String actualResult <span class="token operator">=</span> <span class="token function">assertTimeout</span><span class="token punctuation">(</span><span class="token function">ofMinutes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"a result"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token string">"a result"</span><span class="token punctuation">,</span> actualResult<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * assertTimeout（）毫秒案例     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">timeoutExceeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">assertTimeout</span><span class="token punctuation">(</span><span class="token function">ofMillis</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="6-Junit参数化测试"><a href="#6-Junit参数化测试" class="headerlink" title="6-Junit参数化测试"></a>6-Junit参数化测试</h2><ul><li><p><code>@ValueSource</code>——最简单的数据参数源，通过注解可以直接指定携带的运行参数，支持 Java 的八大基本类型和字符串，Class，使用时赋值给注解上对应类型属性，以数组方式传递。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ValueSourcesExampleTest</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@ParameterizedTest</span>  <span class="token annotation punctuation">@ValueSource</span><span class="token punctuation">(</span>ints <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">testNumberShouldBeEven</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@ParameterizedTest</span>  <span class="token annotation punctuation">@ValueSource</span><span class="token punctuation">(</span>strings <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Radar"</span><span class="token punctuation">,</span> <span class="token string">"Rotor"</span><span class="token punctuation">,</span> <span class="token string">"Tenet"</span><span class="token punctuation">,</span> <span class="token string">"Madam"</span><span class="token punctuation">,</span> <span class="token string">"Racecar"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">testStringShouldBePalindrome</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token function">isPalindrome</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@ParameterizedTest</span>  <span class="token annotation punctuation">@ValueSource</span><span class="token punctuation">(</span>doubles <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">.</span>D<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">.</span>D<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">.</span>D<span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">testDoubleNumberBeEven</span><span class="token punctuation">(</span><span class="token keyword">double</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> word<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>word<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出如下：</p><pre><code>[INFO] -------------------------------------------------------[INFO]  T E S T S[INFO] -------------------------------------------------------[INFO] Running qiucao.learning.ParaTest[INFO] Tests run: 11, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.155 s - in qiucao.learning.ParaTest[INFO][INFO] Results:[INFO][INFO] Tests run: 11, Failures: 0, Errors: 0, Skipped: 0</code></pre></li><li><p><code>@EnumSource</code>——枚举参数源，允许我们通过将参数值由给定Enum枚举类型传入。并可以通过制定约束条件或正则匹配来筛选传入参数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnumSourcesExampleTest</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@ParameterizedTest</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"[{index}] TimeUnit: {arguments}"</span><span class="token punctuation">)</span>  <span class="token annotation punctuation">@EnumSource</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">testTimeUnitMinimumNanos</span><span class="token punctuation">(</span>TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assertTrue</span><span class="token punctuation">(</span>unit<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span>2000000L<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@ParameterizedTest</span>  <span class="token annotation punctuation">@EnumSource</span><span class="token punctuation">(</span>value <span class="token operator">=</span> TimeUnit<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> names <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"SECONDS"</span><span class="token punctuation">,</span> <span class="token string">"MINUTES"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">testTimeUnitJustSecondsAndMinutes</span><span class="token punctuation">(</span>TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assertTrue</span><span class="token punctuation">(</span>EnumSet<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>unit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertFalse</span><span class="token punctuation">(</span>EnumSet        <span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">,</span>            TimeUnit<span class="token punctuation">.</span>MICROSECONDS<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>unit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@ParameterizedTest</span>  <span class="token annotation punctuation">@EnumSource</span><span class="token punctuation">(</span>value <span class="token operator">=</span> TimeUnit<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> mode <span class="token operator">=</span> Mode<span class="token punctuation">.</span>EXCLUDE<span class="token punctuation">,</span> names <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"SECONDS"</span><span class="token punctuation">,</span> <span class="token string">"MINUTES"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">testTimeUnitExcludingSecondsAndMinutes</span><span class="token punctuation">(</span>TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assertFalse</span><span class="token punctuation">(</span>EnumSet<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>unit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertTrue</span><span class="token punctuation">(</span>EnumSet        <span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">,</span>            TimeUnit<span class="token punctuation">.</span>MICROSECONDS<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>unit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@ParameterizedTest</span>  <span class="token annotation punctuation">@EnumSource</span><span class="token punctuation">(</span>value <span class="token operator">=</span> TimeUnit<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> mode <span class="token operator">=</span> Mode<span class="token punctuation">.</span>MATCH_ALL<span class="token punctuation">,</span> names <span class="token operator">=</span> <span class="token string">".*SECONDS"</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">testTimeUnitIncludingAllTypesOfSecond</span><span class="token punctuation">(</span>TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assertFalse</span><span class="token punctuation">(</span>EnumSet<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>HOURS<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>unit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertTrue</span><span class="token punctuation">(</span>EnumSet        <span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>NANOSECONDS<span class="token punctuation">,</span>            TimeUnit<span class="token punctuation">.</span>MICROSECONDS<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>unit<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出如下：</p><pre><code>[INFO] -------------------------------------------------------[INFO]  T E S T S[INFO] -------------------------------------------------------[INFO] Running qiucao.learning.ParaTest[INFO] Tests run: 18, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.206 s - in qiucao.learning.ParaTest[INFO][INFO] Results:[INFO][INFO] Tests run: 18, Failures: 0, Errors: 0, Skipped: 0</code></pre></li><li><p><code>@MethodSource</code>——通过其他的Java方法函数来作为参数源。引用的方法返回值必须是Stream, Iterator 或者Iterable，指定一个返回的 Stream / Array / 可迭代对象 的方法作为数据源。 需要注意的是该方法必须是静态的，并且不能接受任何参数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodSourceExampleTest</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@ParameterizedTest</span>  <span class="token annotation punctuation">@MethodSource</span><span class="token punctuation">(</span><span class="token string">"stringGenerator"</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">shouldNotBeNullString</span><span class="token punctuation">(</span>String arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">assertNotNull</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@ParameterizedTest</span>  <span class="token annotation punctuation">@MethodSource</span><span class="token punctuation">(</span><span class="token string">"intGenerator"</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">shouldBeNumberWithinRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">assertAll</span><span class="token punctuation">(</span>        <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">assertTrue</span><span class="token punctuation">(</span>arg <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token function">assertTrue</span><span class="token punctuation">(</span>arg <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@ParameterizedTest</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"[{index}] user with id: {0} and name: {1}"</span><span class="token punctuation">)</span>  <span class="token annotation punctuation">@MethodSource</span><span class="token punctuation">(</span><span class="token string">"userGenerator"</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">shouldUserWithIdAndName</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">,</span> String name<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">assertNotNull</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertNotNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">static</span> Stream<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">stringGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token string">"world"</span><span class="token punctuation">,</span> <span class="token string">"let's"</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">static</span> IntStream <span class="token function">intGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> IntStream<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">static</span> Stream<span class="token operator">&lt;</span>Arguments<span class="token operator">></span> <span class="token function">userGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>Arguments<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> <span class="token string">"Sally"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Arguments<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>2L<span class="token punctuation">,</span> <span class="token string">"Terry"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Arguments<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>3L<span class="token punctuation">,</span> <span class="token string">"Fred"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出如下：</p><pre><code>[INFO] -------------------------------------------------------[INFO]  T E S T S[INFO] -------------------------------------------------------[INFO] Running qiucao.learning.ParaTest[INFO] Tests run: 16, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.191 s - in qiucao.learning.ParaTest[INFO][INFO] Results:[INFO][INFO] Tests run: 16, Failures: 0, Errors: 0, Skipped: 0</code></pre></li><li><p><code>@ArgumentsSource</code>——通过实现 ArgumentsProvider 接口的参数类来作为数据源，重写它的 <code>provideArguments</code> 方法可以返回自定义类型的 Stream<Arguments> ，作为测试方法所需要的数据使用。</Arguments></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArgumentsSourceExampleTest</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@ParameterizedTest</span>  <span class="token annotation punctuation">@ArgumentsSource</span><span class="token punctuation">(</span>CustomArgumentsGenerator<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">testGeneratedArguments</span><span class="token punctuation">(</span><span class="token keyword">double</span> number<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token function">assertFalse</span><span class="token punctuation">(</span>number <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">.</span>D<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertTrue</span><span class="token punctuation">(</span>number <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertTrue</span><span class="token punctuation">(</span>number <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CustomArgumentsGenerator</span> <span class="token keyword">implements</span> <span class="token class-name">ArgumentsProvider</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Stream<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Arguments</span><span class="token operator">></span> <span class="token function">provideArguments</span><span class="token punctuation">(</span>ExtensionContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Arguments<span class="token operator">:</span><span class="token operator">:</span>of<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p><code>@CsvSource</code>——通过 @CsvSource 可以注入指定 CSV 格式 (comma-separated-values) 的一组数据，用每个逗号分隔的值来匹配一个测试方法对应的参数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CsvSourceExampleTest</span> <span class="token punctuation">{</span>  Map<span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> String<span class="token operator">></span> idToUsername <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">{</span>    idToUsername<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> <span class="token string">"Selma"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    idToUsername<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>2L<span class="token punctuation">,</span> <span class="token string">"Lisa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    idToUsername<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>3L<span class="token punctuation">,</span> <span class="token string">"Tim"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@ParameterizedTest</span>  <span class="token annotation punctuation">@CsvSource</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"1,Selma"</span><span class="token punctuation">,</span> <span class="token string">"2,Lisa"</span><span class="token punctuation">,</span> <span class="token string">"3,Tim"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">testUsersFromCsv</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assertTrue</span><span class="token punctuation">(</span>idToUsername<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertTrue</span><span class="token punctuation">(</span>idToUsername<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出如下：</p><pre><code>[INFO] -------------------------------------------------------[INFO]  T E S T S[INFO] -------------------------------------------------------[INFO] Running qiucao.learning.ParaTest[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.164 s - in qiucao.learning.ParaTest[INFO][INFO] Results:[INFO][INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0</code></pre></li><li><p><code>@CsvFileSource</code>——除了使用csv参数源，这里也支持使用csv文件作为参数源</p><p>假设users.csv 文件包含如下csv格式的数据：</p><pre class=" language-css"><code class="language-css"><span class="token number">1</span>,Selma<span class="token number">2</span>,Lisa<span class="token number">3</span>,Tim</code></pre><p>代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CsvFileSourceExampleTest</span> <span class="token punctuation">{</span>  Map<span class="token operator">&lt;</span>Long<span class="token punctuation">,</span> String<span class="token operator">></span> idToUsername <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">{</span>    idToUsername<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> <span class="token string">"Selma"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    idToUsername<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>2L<span class="token punctuation">,</span> <span class="token string">"Lisa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    idToUsername<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>3L<span class="token punctuation">,</span> <span class="token string">"Tim"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@ParameterizedTest</span>  <span class="token annotation punctuation">@CsvFileSource</span><span class="token punctuation">(</span>resources <span class="token operator">=</span> <span class="token string">"/users.csv"</span><span class="token punctuation">)</span>  <span class="token keyword">void</span> <span class="token function">testUsersFromCsv</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assertTrue</span><span class="token punctuation">(</span>idToUsername<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assertTrue</span><span class="token punctuation">(</span>idToUsername<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出如下：</p><pre><code>[INFO] -------------------------------------------------------[INFO]  T E S T S[INFO] -------------------------------------------------------[INFO] Running qiucao.learning.ParaTest[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.199 s - in qiucao.learning.ParaTest[INFO][INFO] Results:[INFO][INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 单元测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Junit </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Angular学习笔记</title>
      <link href="/2020/01/15/angular-xue-xi-bi-ji/"/>
      <url>/2020/01/15/angular-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Angular学习笔记"><a href="#Angular学习笔记" class="headerlink" title="Angular学习笔记"></a>Angular学习笔记</h1><h1 id="1-Angular入门"><a href="#1-Angular入门" class="headerlink" title="1-Angular入门"></a>1-Angular入门</h1><h2 id="1-1-开发环境的搭建"><a href="#1-1-开发环境的搭建" class="headerlink" title="1.1-开发环境的搭建"></a>1.1-开发环境的搭建</h2><ol><li><p>安装最新版本的NodeJS</p><p>具体安装教程可参照 <a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhouyu2017/p/6485265.html</a></p></li><li><p>设置镜像</p><p>在命令窗口中进行操作：</p><p>或者设置淘宝镜像：<code>npm config set registry https://registry.npm.taobao.org/</code></p><p>查看镜像地址：<code>npm config get registry</code></p></li><li><p>安装Angular Cli</p><p>安装脚手架工具：<code>npm install -g @angular/cli</code></p><p>如果npm安装脚手架工具失败，可先安装cnpm淘宝镜像 <code>npm install –g cnpm –registry=https：//[registry.npm.taobao.org](http://registry.npm.taobao.org/)</code> </p><p>再使用cnpm安装脚手架工具 <code>cnpm install -g @angular/cli</code></p><p>验证是否安装成功：<code>ng version</code></p></li><li><p>安装Visual Studio Code</p><p>具体安装教程可参照 <a href="https://jingyan.baidu.com/article/59703552b622b78fc007401b.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/59703552b622b78fc007401b.html</a></p><p>安装完成后添加Angular v8 Snippets插件来支持Angular语法;安装Chinese(Simplified) Language Pack for Visual Studio Code插件来汉化Visual Studio Code;安装jslint插件来保持代码风格的一致性。</p><p>插件具体安装教程可参照 <a href="https://jingyan.baidu.com/article/90808022029213fd91c80f15.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/90808022029213fd91c80f15.html</a></p><p>如果网络环境受到限制无法直接安装，可采用离线安装，具体的操作教程可参考：<a href="https://blog.csdn.net/u012814856/article/details/80684376" target="_blank" rel="noopener">https://blog.csdn.net/u012814856/article/details/80684376</a></p></li></ol><h2 id="1-2-新建项目"><a href="#1-2-新建项目" class="headerlink" title="1.2-新建项目"></a>1.2-新建项目</h2><ol><li><p>新建项目</p><p>找到你要创建项目的目录，使用“<code>ng new 项目名称</code>”创建一个Angular项目（如果要创建带路由的项目，则使用“<code>ng new  项目名  --routing</code> ”来创建项目）</p><p>进入刚刚创建的项目的目录下，添加项目依赖：npm install 或 cnpm install</p><p>启动项目<code>ng serve</code> （如果使用代理proxy.conf.json，则使用“npm start”来启动项目,此时需要在package,json中做相关配置<code>：“start” : ”ng serve --proxy-config proxy.conf.json”</code>,）</p></li><li><p>新建组件</p><p>在app目录下新建<code>components</code>文件夹</p><p>新建组件，在命令框中使用命令 <code>“ng g component components/组件名”</code> 创建新组件。创建之后要在<code>app.module.ts</code>中引入该组件</p><p>新建文件夹、各种文件可直接在相应的目录下右击创建</p></li><li><p>使用<code>ng-zorro</code>的组件</p><p>需要安装ng-zorro-antd相关的依赖，具体教程参见 <a href="https://ng.ant.design/docs/getting-started/zh" target="_blank" rel="noopener">https://ng.ant.design/docs/getting-started/zh</a></p></li></ol><h2 id="1-3-常见命令"><a href="#1-3-常见命令" class="headerlink" title="1.3-常见命令"></a>1.3-常见命令</h2><ol><li><p>查看nodejs的版本  <code>node –v</code></p></li><li><p>查看npm的版本   <code>npm –v</code></p></li><li><p>查看Cli脚手架的版本信息 <code>ng version</code></p></li><li><p>设置npm前缀 <code>npm config set prefix &quot;D:\Develop\nodejs\node_global&quot;</code> （具体路径根据实际情况来定）</p></li><li><p>查看npm前缀 <code>npm config get prefix</code></p></li><li><p>设置npm缓存 <code>npm config set cache &quot;D:\Develop\nodejs\node_cache&quot;</code> （具体路径根据实际情况来定）</p></li><li><p>查看npm缓存 <code>npm config get cache</code></p></li><li><p>查看npm配置信息列表  <code>npm config list</code></p></li><li><p>创建一个Angular项目   <code>ng new 项目名称</code></p></li><li><p>创建一个带有路由的Angular项目  <code>ng new 项目名称 --routing</code></p></li><li><p>退出某个目录   cd ..</p></li><li><p>进入某个目录   cd Program Files\Microsoft VS Code\bin （具体路径根据实际情况来定）</p></li><li><p>转换盘符     d： （具体切换到那个盘根据实际情况来定） </p></li><li><p>初始化项目依赖  <code>npm install 或者 cnpm install</code>  </p></li><li><p>创建一个组件   <code>ng g  component components/组件名</code> （components是自己新建的文件夹，可根据实际情况改变）</p></li><li><p>启动项目     <code>ng serve  或   ng serve --open</code></p></li><li><p>使用代理时启动项目 <code>npm start</code></p></li><li><p>自动完成 ng-zorro-antd 的初始化配置  <code>ng  add  ng-zorro-antd</code> </p></li></ol><h2 id="1-4-参考网站"><a href="#1-4-参考网站" class="headerlink" title="1.4-参考网站"></a>1.4-参考网站</h2><p> <a href="https://segmentfault.com/a/1190000008754631" target="_blank" rel="noopener">Angular 4.x 修仙之路</a><a href="https://segmentfault.com/a/1190000008754631" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008754631</a>                                 </p><p>Angular中文官网:<a href="https://angular.cn/" target="_blank" rel="noopener">https://angular.cn/</a>                                                          </p><p>npm install Angular依赖包下载<a href="https://www.npmjs.com/package/package" target="_blank" rel="noopener">https://www.npmjs.com/package/package</a>                                       </p><p>ng zorro网址<a href="https://ng.ant.design/docs/introduce/zh" target="_blank" rel="noopener">https://ng.ant.design/docs/introduce/zh</a>        </p><h1 id="2-Angular基础"><a href="#2-Angular基础" class="headerlink" title="2-Angular基础"></a>2-Angular基础</h1><h2 id="2-1-架构概览"><a href="#2-1-架构概览" class="headerlink" title="2.1-架构概览"></a>2.1-架构概览</h2><p>Angular 是一个用 HTML 和 TypeScript 构建客户端应用的平台与框架。 Angular 本身就是用 TypeScript 写成的。它将核心功能和可选功能作为一组 TypeScript 库进行实现，你可以把它们导入你的应用中。</p><p>Angular 的基本构造块是 <em>NgModule</em>，它为<em>组件</em>提供了编译的上下文环境。 NgModule 会把相关的代码收集到一些功能集中。Angular 应用就是由一组 NgModule 定义出的。 应用至少会有一个用于引导应用的<em>根模块</em>，通常还会有很多<em>特性模块</em>。</p><ul><li>组件定义<em>视图</em>。视图是一组可见的屏幕元素，Angular 可以根据你的程序逻辑和数据来选择和修改它们。 每个应用都至少有一个根组件。</li><li>组件使用<em>服务</em>。服务会提供那些与视图不直接相关的功能。服务提供商可以作为<em>依赖</em>被<em>注入</em>到组件中， 这能让你的代码更加模块化、更加可复用、更加高效。</li></ul><p>组件和服务都是简单的类，这些类使用<em>装饰器</em>来标出它们的类型，并提供元数据以告知 Angular 该如何使用它们。</p><ul><li>组件类的元数据将组件类和一个用来定义视图的<em>模板</em>关联起来。 模板把普通的 HTML 和 Angular <em>指令</em>与<em>绑定标记（markup）</em>组合起来，这样 Angular 就可以在呈现 HTML 之前先修改这些 HTML。</li><li>服务类的元数据提供了一些信息，Angular 要用这些信息来让组件可以通过<em>依赖注入（DI）</em>使用该服务。</li></ul><p>应用的组件通常会定义很多视图，并进行分级组织。 Angular 提供了 <code>Router</code> 服务来帮助你定义视图之间的导航路径。 路由器提供了先进的浏览器内导航功能。</p><h2 id="2-2-基本概念"><a href="#2-2-基本概念" class="headerlink" title="2.2-基本概念"></a>2.2-基本概念</h2><h3 id="2-2-1-模块"><a href="#2-2-1-模块" class="headerlink" title="2.2.1-模块"></a>2.2.1-模块</h3><p>Angular 定义了 <code>NgModule</code>，它和 JavaScript（ES2015） 的模块不同而且有一定的互补性。 NgModule 为一个组件集声明了编译的上下文环境，它专注于某个应用领域、某个工作流或一组紧密相关的能力。 NgModule 可以将其组件和一组相关代码（如服务）关联起来，形成功能单元。</p><p>每个 Angular 应用都有一个<em>根模块</em>，通常命名为 <code>AppModule</code>。根模块提供了用来启动应用的引导机制。 一个应用通常会包含很多功能模块。</p><p>像 JavaScript 模块一样，NgModule 也可以从其它 NgModule 中导入功能，并允许导出它们自己的功能供其它 NgModule 使用。 比如，要在你的应用中使用路由器（Router）服务，就要导入 <code>Router</code> 这个 NgModule。</p><p>把你的代码组织成一些清晰的功能模块，可以帮助管理复杂应用的开发工作并实现可复用性设计。 另外，这项技术还能让你获得<em>惰性加载</em>（也就是按需加载模块）的优点，以尽可能减小启动时需要加载的代码体积。</p><h3 id="2-2-2-组件"><a href="#2-2-2-组件" class="headerlink" title="2.2.2-组件"></a>2.2.2-组件</h3><p>每个 Angular 应用都至少有一个组件，也就是<em>根组件</em>，它会把组件树和页面中的 DOM 连接起来。 每个组件都会定义一个类，其中包含应用的数据和逻辑，并与一个 HTML <em>模板</em>相关联，该模板定义了一个供目标环境下显示的视图。</p><p><code>@Component()</code> 装饰器表明紧随它的那个类是一个组件，并提供模板和该组件专属的元数据。</p><h3 id="2-2-3-模板、指令和数据绑定"><a href="#2-2-3-模板、指令和数据绑定" class="headerlink" title="2.2.3-模板、指令和数据绑定"></a>2.2.3-模板、指令和数据绑定</h3><p>模板会把 HTML 和 Angular 的标记（markup）组合起来，这些标记可以在 HTML 元素显示出来之前修改它们。 模板中的<em>指令</em>会提供程序逻辑，而<em>绑定标记</em>会把你应用中的数据和 DOM 连接在一起。 有两种类型的数据绑定：</p><ul><li><em>事件绑定</em>让你的应用可以通过更新应用的数据来响应目标环境下的用户输入。</li><li><em>属性绑定</em>让你将从应用数据中计算出来的值插入到 HTML 中。</li></ul><p>在视图显示出来之前，Angular 会先根据你的应用数据和逻辑来运行模板中的指令并解析绑定表达式，以修改 HTML 元素和 DOM。 Angular 支持<em>双向数据绑定</em>，这意味着 DOM 中发生的变化（比如用户的选择）同样可以反映回你的程序数据中。</p><p>你的模板也可以用<em>管道</em>转换要显示的值以增强用户体验。比如，可以使用管道来显示适合用户所在地区的日期和货币格式。 Angular 为一些通用的转换提供了预定义管道，你还可以定义自己的管道。</p><h3 id="2-2-4-服务与依赖注入"><a href="#2-2-4-服务与依赖注入" class="headerlink" title="2.2.4-服务与依赖注入"></a>2.2.4-服务与依赖注入</h3><p>对于与特定视图无关并希望跨组件共享的数据或逻辑，可以创建<em>服务</em>类。 服务类的定义通常紧跟在 “@Injectable()” 装饰器之后。该装饰器提供的元数据可以让你的服务作为依赖<em>被注入到</em>客户组件中。</p><p><em>依赖注入</em>（或 DI）让你可以保持组件类的精简和高效。有了 DI，组件就不用从服务器获取数据、验证用户输入或直接把日志写到控制台，而是会把这些任务委托给服务。</p><h3 id="2-2-5-路由"><a href="#2-2-5-路由" class="headerlink" title="2.2.5-路由"></a>2.2.5-路由</h3><p>Angular 的 <code>Router</code> 模块提供了一个服务，它可以让你定义在应用的各个不同状态和视图层次结构之间导航时要使用的路径。 它的工作模型基于人们熟知的浏览器导航约定：</p><ul><li>在地址栏输入 URL，浏览器就会导航到相应的页面。</li><li>在页面中点击链接，浏览器就会导航到一个新页面。</li><li>点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。</li></ul><p>不过路由器会把类似 URL 的路径映射到视图而不是页面。 当用户执行一个动作时（比如点击链接），本应该在浏览器中加载一个新页面，但是路由器拦截了浏览器的这个行为，并显示或隐藏一个视图层次结构。</p><p>如果路由器认为当前的应用状态需要某些特定的功能，而定义此功能的模块尚未加载，路由器就会按需<em>惰性加载</em>此模块。</p><p>路由器会根据你应用中的导航规则和数据状态来拦截 URL。 当用户点击按钮、选择下拉框或收到其它任何来源的输入时，你可以导航到一个新视图。 路由器会在浏览器的历史日志中记录这个动作，所以前进和后退按钮也能正常工作。</p><p>要定义导航规则，你就要把<em>导航路径</em>和你的组件关联起来。 路径（path）使用类似 URL 的语法来和程序数据整合在一起，就像模板语法会把你的视图和程序数据整合起来一样。 然后你就可以用程序逻辑来决定要显示或隐藏哪些视图，以根据你制定的访问规则对用户的输入做出响应。</p><p><strong>注：</strong>这些基础部门之间是如何关联的呢？</p><p><img src="/2020/01/15/angular-xue-xi-bi-ji/Angular.png" alt="Angular"></p><ul><li>组件和模板共同定义了 Angular 的视图。<ul><li>组件类上的装饰器为其添加了元数据，其中包括指向相关模板的指针。</li><li>组件模板中的指令和绑定标记会根据程序数据和程序逻辑修改这些视图。</li></ul></li><li>依赖注入器会为组件提供一些服务，比如路由器服务就能让你定义如何在视图之间导航。</li></ul><h2 id="2-3-模块NgModule"><a href="#2-3-模块NgModule" class="headerlink" title="2.3-模块NgModule"></a>2.3-模块NgModule</h2><ol><li><p>NgModule简介</p><p>Angular 应用是模块化的，它拥有自己的模块化系统，称作 <em>NgModule</em>。 一个 NgModule 就是一个容器，用于存放一些内聚的代码块，这些代码块专注于某个应用领域、某个工作流或一组紧密相关的功能。 它可以包含一些组件、服务提供商或其它代码文件，其作用域由包含它们的 NgModule 定义。 它还可以导入一些由其它模块中导出的功能，并导出一些指定的功能供其它 NgModule 使用。</p><p>每个 Angular 应用都至少有一个 NgModule 类，也就是<a href="http://angular-doc.paas.cmbchina.cn/guide/bootstrapping" target="_blank" rel="noopener">根模块</a>，它习惯上命名为 <code>AppModule</code>，并位于一个名叫 <code>app.module.ts</code> 的文件中。<em>引导</em>这个根模块就可以启动你的应用。</p><p>虽然小型的应用可能只有一个 NgModule，不过大多数应用都会有很多<em>特性模块</em>。应用的<em>根模块</em>之所以叫根模块，是因为它可以包含任意深度的层次化子模块。</p></li></ol><ol start="2"><li><p>@NgModule 元数据</p><p>NgModule 是一个带有 <code>@NgModule()</code> 装饰器的类。<code>@NgModule()</code> 装饰器是一个函数，它接受一个元数据对象，该对象的属性用来描述这个模块。其中最重要的属性如下。</p><ul><li><p><code>declarations</code>（可声明对象表） —— 那些属于本 NgModule 的<a href="http://angular-doc.paas.cmbchina.cn/guide/architecture-components" target="_blank" rel="noopener">组件</a>、<em>指令</em>、<em>管道</em>。</p></li><li><p><code>exports</code>（导出表） —— 那些能在其它模块的<em>组件模板</em>中使用的可声明对象的子集。</p></li><li><p><code>imports</code>（导入表） —— 那些导出了<em>本</em>模块中的组件模板所需的类的其它模块。</p></li><li><p><code>providers</code> —— 本模块向全局服务中贡献的那些<a href="http://angular-doc.paas.cmbchina.cn/guide/architecture-services" target="_blank" rel="noopener">服务</a>的创建器。 这些服务能被本应用中的任何部分使用。（你也可以在组件级别指定服务提供商，这通常是首选方式。）</p></li><li><p><code>bootstrap</code> —— 应用的主视图，称为<em>根组件</em>。它是应用中所有其它视图的宿主。只有<em>根模块</em>才应该设置这个 <code>bootstrap</code> 属性。</p></li><li><p>一个简单的根 NgModule 定义：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> NgModule <span class="token punctuation">}</span>      <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> BrowserModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/platform-browser'</span><span class="token punctuation">;</span>@<span class="token function">NgModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  imports<span class="token punctuation">:</span>      <span class="token punctuation">[</span> BrowserModule <span class="token punctuation">]</span><span class="token punctuation">,</span>  providers<span class="token punctuation">:</span>    <span class="token punctuation">[</span> Logger <span class="token punctuation">]</span><span class="token punctuation">,</span>  declarations<span class="token punctuation">:</span> <span class="token punctuation">[</span> AppComponent <span class="token punctuation">]</span><span class="token punctuation">,</span>  exports<span class="token punctuation">:</span>      <span class="token punctuation">[</span> AppComponent <span class="token punctuation">]</span><span class="token punctuation">,</span>  bootstrap<span class="token punctuation">:</span>    <span class="token punctuation">[</span> AppComponent <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre></li></ul></li></ol><ol start="3"><li><p>NgModule 和组件</p><p>NgModule 为其中的组件提供了一个<em>编译上下文环境</em>。根模块总会有一个根组件，并在引导期间创建它。 但是，任何模块都能包含任意数量的其它组件，这些组件可以通过路由器加载，也可以通过模板创建。那些属于这个 NgModule 的组件会共享同一个编译上下文环境。</p><p>组件及其模板共同定义<em>视图</em>。组件还可以包含<em>视图层次结构</em>，它能让你定义任意复杂的屏幕区域，可以将其作为一个整体进行创建、修改和销毁。 一个视图层次结构中可以混合使用由不同 NgModule 中的组件定义的视图。</p></li><li><p>Angular 自带的库</p><p>Angular 会作为一组 JavaScript 模块进行加载，你可以把它们看成库模块。每个 Angular 库的名称都带有 <code>@angular</code> 前缀。 使用 <code>npm</code> 包管理器安装 Angular 的库，并使用 JavaScript 的 <code>import</code> 语句导入其中的各个部分。</p><p>例如，像下面这样，从 <code>@angular/core</code> 库中导入 Angular 的 <code>Component</code> 装饰器</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span></code></pre></li></ol><h2 id="2-4-组件"><a href="#2-4-组件" class="headerlink" title="2.4-组件"></a>2.4-组件</h2><p>组件<em>控制屏幕上被称为</em>视图*的一小片区域。比如，<a href="http://angular-doc.paas.cmbchina.cn/tutorial/index" target="_blank" rel="noopener">教程</a>中的下列视图都是由一个个组件所定义和控制的：</p><ul><li>带有导航链接的应用根组件。</li><li>英雄列表。</li><li>英雄编辑器。</li></ul><p>你在类中定义组件的应用逻辑，为视图提供支持。 组件通过一些由属性和方法组成的 API 与视图交互。</p><p>比如，<code>HeroListComponent</code> 中有一个 名为<code>heroes</code>的属性，它储存着一个数组的英雄数据。 <code>HeroListComponent</code> 还有一个 <code>selectHero()</code> 方法，当用户从列表中选择一个英雄时，它会设置 <code>selectedHero</code> 属性的值。 该组件会从服务获取英雄列表，它是一个 TypeScript 的构造器<a href="http://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties" target="_blank" rel="noopener">参数型属性</a>。本服务通过依赖注入系统提供给该组件。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">HeroListComponent</span> <span class="token keyword">implements</span> <span class="token class-name">OnInit</span> <span class="token punctuation">{</span>  heroes<span class="token punctuation">:</span> Hero<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  selectedHero<span class="token punctuation">:</span> Hero<span class="token punctuation">;</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> service<span class="token punctuation">:</span> HeroService<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  <span class="token function">ngOnInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>heroes <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>service<span class="token punctuation">.</span><span class="token function">getHeroes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">selectHero</span><span class="token punctuation">(</span>hero<span class="token punctuation">:</span> Hero<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>selectedHero <span class="token operator">=</span> hero<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当用户在应用中穿行时，Angular 就会创建、更新、销毁一些组件。 你的应用可以通过一些可选的<a href="http://angular-doc.paas.cmbchina.cn/guide/lifecycle-hooks" target="_blank" rel="noopener">生命周期钩子</a>（比如<code>ngOnInit()</code>）来在每个特定的时机采取行动。</p><ol><li><p>组件的元数据</p><p><code>@Component</code> 装饰器会指出紧随其后的那个类是个组件类，并为其指定元数据。 在下面的范例代码中，你可以看到 <code>HeroListComponent</code> 只是一个普通类，完全没有 Angular 特有的标记或语法。 直到给它加上了 <code>@Component</code> 装饰器，它才变成了组件。</p><p>组件的元数据告诉 Angular 到哪里获取它需要的主要构造块，以创建和展示这个组件及其视图。 具体来说，它把一个<em>模板</em>（无论是直接内联在代码中还是引用的外部文件）和该组件关联起来。 该组件及其模板，共同描述了一个<em>视图</em>。</p><p>除了包含或指向模板之外，<code>@Component</code> 的元数据还会配置要如何在 HTML 中引用该组件，以及该组件需要哪些服务等等。</p><p>下面的例子中就是 <code>HeroListComponent</code> 的基础元数据：</p><pre class=" language-typescript"><code class="language-typescript">@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span>    <span class="token string">'app-hero-list'</span><span class="token punctuation">,</span>  templateUrl<span class="token punctuation">:</span> <span class="token string">'./hero-list.component.html'</span><span class="token punctuation">,</span>  providers<span class="token punctuation">:</span>  <span class="token punctuation">[</span> HeroService <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">HeroListComponent</span> <span class="token keyword">implements</span> <span class="token class-name">OnInit</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">/* . . . */</span><span class="token punctuation">}</span></code></pre><p>这个例子展示了一些最常用的 <code>@Component</code> 配置选项：</p><ul><li><code>selector</code>：是一个 CSS 选择器，它会告诉 Angular，一旦在模板 HTML 中找到了这个选择器对应的标签，就创建并插入该组件的一个实例。 比如，如果应用的 HTML 中包含 ``，Angular 就会在这些标签中插入一个 <code>HeroListComponent</code> 实例的视图。</li><li><code>templateUrl</code>：该组件的 HTML 模板文件相对于这个组件文件的地址。 另外，你还可以用 <code>template</code> 属性的值来提供内联的 HTML 模板。 这个模板定义了该组件的<em>宿主视图</em>。</li><li><code>providers</code>：当前组件所需的服务<a href="http://angular-doc.paas.cmbchina.cn/guide/glossary#provider" target="_blank" rel="noopener">提供商</a>的一个数组。在这个例子中，它告诉 Angular 该如何提供一个 <code>HeroService</code> 实例，以获取要显示的英雄列表。</li></ul></li><li><p>模板与视图</p><p>你要通过组件的配套模板来定义其视图。模板就是一种 HTML，它会告诉 Angular 如何渲染该组件。</p><p>视图通常会分层次进行组织，让你能以 UI 分区或页面为单位进行修改、显示或隐藏。 与组件直接关联的模板会定义该组件的<em>宿主视图</em>。该组件还可以定义一个<em>带层次结构的视图</em>，它包含一些<em>内嵌的视图</em>作为其它组件的宿主。</p><p>带层次结构的视图可以包含同一模块（NgModule）中组件的视图，也可以（而且经常会）包含其它模块中定义的组件的视图。</p></li><li><p>模板语法</p><p>模板很像标准的 HTML，但是它还包含 Angular 的<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax" target="_blank" rel="noopener">模板语法</a>，这些模板语法可以根据你的应用逻辑、应用状态和 DOM 数据来修改这些 HTML。 你的模板可以使用<em>数据绑定</em>来协调应用和 DOM 中的数据，使用<em>管道</em>在显示出来之前对其进行转换，使用<em>指令</em>来把程序逻辑应用到要显示的内容上。</p><p>比如，下面是本教程中 <code>HeroListComponent</code> 的模板：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h2</span><span class="token punctuation">></span></span>Hero List<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h2</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span><span class="token punctuation">></span></span>Pick a hero from the list<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">*ngFor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>let hero of heroes<span class="token punctuation">"</span></span> <span class="token attr-name">(click)</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectHero(hero)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    {{hero.name}}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-hero-detail</span> <span class="token attr-name">*ngIf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectedHero<span class="token punctuation">"</span></span> <span class="token attr-name">[hero]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectedHero<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-hero-detail</span><span class="token punctuation">></span></span></code></pre><p>这个模板使用了典型的 HTML 元素，比如 <code>和</code>，还包括一些 Angular 的模板语法元素，如 <code>*ngFor</code>，<code></code>，<code>click</code>、<code>[hero]</code> 和 ``。这些模板语法元素告诉 Angular 该如何根据程序逻辑和数据在屏幕上渲染 HTML。</p><ul><li><code>*ngFor</code> 指令告诉 Angular 在一个列表上进行迭代。</li><li><code></code>、<code>(click)</code> 和 <code>[hero]</code> 把程序数据绑定到及绑定回 DOM，以响应用户的输入。更多内容参见稍后的<a href="http://angular-doc.paas.cmbchina.cn/guide/architecture-components#data-binding" target="_blank" rel="noopener">数据绑定</a>部分。</li><li>模板中的 `` 标签是一个代表新组件 <code>HeroDetailComponent</code> 的元素。 <code>HeroDetailComponent</code>（代码略）定义了 <code>HeroListComponent</code> 的英雄详情子视图。 注意观察像这样的自定义组件是如何与原生 HTML 元素无缝的混合在一起的。</li></ul></li><li><p>数据绑定</p><p>如果没有框架，你就要自己负责把数据值推送到 HTML 控件中，并把来自用户的响应转换成动作和对值的更新。 手动写这种数据推拉逻辑会很枯燥、容易出错，难以阅读 —— 有前端 JavaScript 开发经验的程序员一定深有体会。</p><p>Angular 支持<em>双向数据绑定</em>，这是一种对模板中的各个部件与组件中的各个部件进行协调的机制。 往模板 HTML 中添加绑定标记可以告诉 Angular 该如何连接它们。</p><p>下图显示了数据绑定标记的四种形式。每种形式都有一个方向 —— 从组件到 DOM、从 DOM 到组件或双向。</p><p><img src="/2020/01/15/angular-xue-xi-bi-ji/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png" alt="数据绑定"></p><p> <code>HeroListComponent</code> 模板中的例子使用了其中的三种形式：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span><span class="token punctuation">></span></span>{{hero.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-hero-detail</span> <span class="token attr-name">[hero]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectedHero<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-hero-detail</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">(click)</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectHero(hero)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span></code></pre><ul><li><code></code><a href="http://angular-doc.paas.cmbchina.cn/guide/displaying-data#interpolation" target="_blank" rel="noopener"><em>插值表达式</em></a>在 `` 标签中显示组件的 <code>hero.name</code> 属性的值。</li><li><code>[hero]</code><a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#property-binding" target="_blank" rel="noopener"><em>属性绑定</em></a>把父组件 <code>HeroListComponent</code> 的 <code>selectedHero</code> 的值传到子组件 <code>HeroDetailComponent</code> 的 <code>hero</code> 属性中。</li><li>当用户点击某个英雄的名字时，<code>(click)</code> <a href="http://angular-doc.paas.cmbchina.cn/guide/user-input#binding-to-user-input-events" target="_blank" rel="noopener"><em>事件绑定</em></a>会调用组件的 <code>selectHero</code> 方法。</li></ul><p><strong>双向数据绑定</strong>（主要用于<a href="http://angular-doc.paas.cmbchina.cn/guide/forms" target="_blank" rel="noopener">模板驱动表单</a>中），它会把属性绑定和事件绑定组合成一种单独的写法。</p><p> <code>HeroDetailComponent</code> 模板中的例子通过 <code>ngModel</code> 指令使用了双向数据绑定：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">[(ngModel)]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hero.name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><p>在双向绑定中，数据属性值通过属性绑定从组件流到输入框。用户的修改通过事件绑定流回组件，把属性值设置为最新的值。</p><p>Angular 在每个 JavaScript 事件循环中处理<em>所有的</em>数据绑定，它会从组件树的根部开始，递归处理全部子组件。</p><p><img src="/2020/01/15/angular-xue-xi-bi-ji/%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.png" alt="双向数据绑定"></p><p>数据绑定在模板及其组件之间的通讯中扮演了非常重要的角色，它对于父组件和子组件之间的通讯也同样重要。</p><p><img src="/2020/01/15/angular-xue-xi-bi-ji/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.png" alt="父子组件通信"></p></li><li><p>管道</p><p>Angular 的管道可以让你在模板中声明显示值的转换逻辑。 带有 <code>@Pipe</code> 装饰器的类中会定义一个转换函数，用来把输入值转换成供视图显示用的输出值。</p><p>Angular 自带了很多管道，比如 <a href="https://angular.cn/api/common/DatePipe" target="_blank" rel="noopener">date</a> 管道和 <a href="https://angular.cn/api/common/CurrencyPipe" target="_blank" rel="noopener">currency</a> 管道，完整的列表参见 <a href="https://angular.cn/api?type=pipe" target="_blank" rel="noopener">Pipes API 列表</a>。你也可以自己定义一些新管道。</p><p>要在 HTML 模板中指定值的转换方式，请使用 <a href="https://angular.cn/guide/template-syntax#pipe" target="_blank" rel="noopener">管道操作符 (|)</a>。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token punctuation">{</span><span class="token punctuation">{</span>interpolated_value <span class="token operator">|</span> pipe_name<span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>你可以把管道串联起来，把一个管道函数的输出送给另一个管道函数进行转换。 管道还能接收一些参数，来控制它该如何进行转换。</p><p>比如，你可以把要使用的日期格式传给 <code>date</code> 管道：</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- Default format: output 'Jun 15, 2015'--></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>Today is {{today | date}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- fullDate format: output 'Monday, June 15, 2015'--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>The date is {{today | date:'fullDate'}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!-- shortTime format: output '9:43 AM'--></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>The time is {{today | date:'shortTime'}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre></li><li><p>指令</p><p>Angular 的模板是<em>动态的</em>。当 Angular 渲染它们的时候，会根据<em>指令</em>给出的指示对 DOM 进行转换。 指令就是一个带有 <code>@Directive()</code> 装饰器的类。</p><p>组件从技术角度上说就是一个指令，但是由于组件对 Angular 应用来说非常独特、非常重要，因此 Angular 专门定义了 <code>@Component()</code> 装饰器，它使用一些面向模板的特性扩展了 <code>@Directive()</code> 装饰器。</p><p>除组件外，还有两种指令：<em>结构型指令</em>和<em>属性型指令</em>。 Angular 本身定义了一系列这两种类型的指令，你也可以使用 <code>@Directive()</code> 装饰器来定义自己的指令。</p><p>像组件一样，指令的元数据把它所装饰的指令类和一个 <code>selector</code> 关联起来，<code>selector</code> 用来把该指令插入到 HTML 中。 在模板中，指令通常作为属性出现在元素标签上，可能仅仅作为名字出现，也可能作为赋值目标或绑定目标出现。</p><ul><li><p>结构型指令</p><p><em>结构型指令</em>通过添加、移除或替换 DOM 元素来修改布局。</p><p> 这个范例模板使用了两个内置的结构型指令来为要渲染的视图添加程序逻辑：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">*ngFor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>let hero of heroes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-hero-detail</span> <span class="token attr-name">*ngIf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectedHero<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-hero-detail</span><span class="token punctuation">></span></span></code></pre><ul><li><a href="http://angular-doc.paas.cmbchina.cn/guide/displaying-data#ngFor" target="_blank" rel="noopener"><code>*ngFor</code></a> 是一个迭代器，它要求 Angular 为 <code>heroes</code> 列表中的每个英雄渲染出一个 ``。</li><li><a href="http://angular-doc.paas.cmbchina.cn/guide/displaying-data#ngIf" target="_blank" rel="noopener"><code>*ngIf</code></a> 是个条件语句，只有当选中的英雄存在时，它才会包含 <code>HeroDetail</code> 组件。</li></ul></li><li><p>属性型指令</p><p><em>属性型指令</em>会修改现有元素的外观或行为。 在模板中，它们看起来就像普通的 HTML 属性一样，因此得名“属性型指令”。</p><p><code>ngModel</code> 指令就是属性型指令的一个例子，它实现了双向数据绑定。 <code>ngModel</code> 修改现有元素（一般是 ``）的行为：设置其显示属性值，并响应 change 事件。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">[(ngModel)]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hero.name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><p>Angular 还有很多预定义指令既不修改布局结构（比如 <a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#ngSwitch" target="_blank" rel="noopener">ngSwitch</a>），也不修改 DOM 元素和组件的样子（比如 <a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#ngStyle" target="_blank" rel="noopener">ngStyle</a> 和 <a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#ngClass" target="_blank" rel="noopener">ngClass</a>）。</p></li></ul></li></ol><h2 id="2-5-服务与依赖注入"><a href="#2-5-服务与依赖注入" class="headerlink" title="2.5-服务与依赖注入"></a>2.5-服务与依赖注入</h2><p><em>服务</em>是一个广义的概念，它包括应用所需的任何值、函数或特性。狭义的服务是一个明确定义了用途的类。它应该做一些具体的事，并做好。</p><p>Angular 把组件和服务区分开，以提高模块性和复用性。 通过把组件中和视图有关的功能与其他类型的处理分离开，你可以让组件类更加精简、高效。</p><p>理想情况下，组件的工作只管用户体验，而不用顾及其它。 它应该提供用于数据绑定的属性和方法，以便作为视图（由模板渲染）和应用逻辑（通常包含一些<em>模型</em>的概念）的中介者。</p><p>组件应该把诸如从服务器获取数据、验证用户输入或直接往控制台中写日志等工作委托给各种服务。通过把各种处理任务定义到可注入的服务类中，你可以让它被任何组件使用。 通过在不同的环境中注入同一种服务的不同提供商，你还可以让你的应用更具适应性。</p><p>Angular 不会<em>强迫</em>你遵循这些原则。Angular 只会通过<em>依赖注入</em>来帮你更容易地将应用逻辑分解为服务，并让这些服务可用于各个组件中。</p><ol><li><p>服务案例</p><p>下面是一个服务类的范例，用于把日志记录到浏览器的控制台：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>  <span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token function">error</span><span class="token punctuation">(</span>msg<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token function">warn</span><span class="token punctuation">(</span>msg<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>服务也可以依赖其它服务。比如，这里的 <code>HeroService</code> 就依赖于 <code>Logger</code> 服务，它还用 <code>BackendService</code> 来获取英雄数据。<code>BackendService</code> 还可能再转而依赖 <code>HttpClient</code> 服务来从服务器异步获取英雄列表。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">HeroService</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> heroes<span class="token punctuation">:</span> Hero<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>    <span class="token keyword">private</span> backend<span class="token punctuation">:</span> BackendService<span class="token punctuation">,</span>    <span class="token keyword">private</span> logger<span class="token punctuation">:</span> Logger<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  <span class="token function">getHeroes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>backend<span class="token punctuation">.</span><span class="token function">getAll</span><span class="token punctuation">(</span>Hero<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>heroes<span class="token punctuation">:</span> Hero<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Fetched </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>heroes<span class="token punctuation">.</span>length<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> heroes.`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>heroes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>heroes<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// fill cache</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>heroes<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>依赖注入</p><p>DI 被融入 Angular 框架中，用于在任何地方给新建的组件提供服务或所需的其它东西。 组件是服务的消费者，也就是说，你可以把一个服务<em>注入</em>到组件中，让组件类得以访问该服务类。</p><p>在 Angular 中，要把一个类定义为服务，就要用 <code>@Injectable()</code> 装饰器来提供元数据，以便让 Angular 可以把它作为<em>依赖</em>注入到组件中。 同样，也要使用 <code>@Injectable()</code> 装饰器来表明一个组件或其它类（比如另一个服务、管道或 NgModule）<em>拥有</em>一个依赖。</p><ul><li><em>注入器</em>是主要的机制。Angular 会在启动过程中为你创建全应用级注入器以及所需的其它注入器。你不用自己创建注入器。</li><li>该注入器会创建依赖、维护一个<em>容器</em>来管理这些依赖，并尽可能复用它们。</li><li><em>提供商</em>是一个对象，用来告诉注入器应该如何获取或创建依赖。</li></ul><p>你的应用中所需的任何依赖，都必须使用该应用的注入器来注册一个提供商，以便注入器可以使用这个提供商来创建新实例。 对于服务，该提供商通常就是服务类本身。</p></li></ol><p>   当 Angular 创建组件类的新实例时，它会通过查看该组件类的构造函数，来决定该组件依赖哪些服务或其它依赖项。 比如 <code>HeroListComponent</code> 的构造函数中需要 <code>HeroService</code>：</p><pre class=" language-typescript"><code class="language-typescript">   <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> service<span class="token punctuation">:</span> HeroService<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p>   当 Angular 发现某个组件依赖某个服务时，它会首先检查是否该注入器中已经有了那个服务的任何现有实例。如果所请求的服务尚不存在，注入器就会使用以前注册的服务提供商来制作一个，并把它加入注入器中，然后把该服务返回给 Angular。</p><p>   当所有请求的服务已解析并返回时，Angular 可以用这些服务实例为参数，调用该组件的构造函数。</p><p>   <code>HeroService</code> 的注入过程如下所示：</p><p>   <img src="/2020/01/15/angular-xue-xi-bi-ji/HeroService%E6%B3%A8%E5%85%A5%E8%BF%87%E7%A8%8B.png" alt="HeroService注入过程"></p><ol start="3"><li><p>提供服务</p><p>对于要用到的任何服务，你必须至少注册一个<em>提供商</em>。服务可以在自己的元数据中把自己注册为提供商，这样可以让自己随处可用。或者，你也可以为特定的模块或组件注册提供商。要注册提供商，就要在服务的 <code>@Injectable()</code> 装饰器中提供它的元数据，或者在<code>@NgModule()</code> 或 <code>@Component()</code> 的元数据中。</p><ul><li>默认情况下，Angular CLI 的 <a href="http://angular-doc.paas.cmbchina.cn/cli/generate" target="_blank" rel="noopener"><code>ng generate service</code></a> 命令会在 <code>@Injectable()</code> 装饰器中提供元数据来把它注册到根注入器中。本教程就用这种方法注册了 HeroService 的提供商：</li></ul><pre><code>content_copy@Injectable({  providedIn: &#39;root&#39;, })</code></pre><p>当你在根一级提供服务时，Angular 会为 HeroService 创建一个单一的共享实例，并且把它注入到任何想要它的类中。这种在 <code>@Injectable</code> 元数据中注册提供商的方式还让 Angular 能够通过移除那些从未被用过的服务来优化大小。</p><ul><li>当你使用<a href="http://angular-doc.paas.cmbchina.cn/guide/architecture-modules" target="_blank" rel="noopener">特定的 NgModule</a> 注册提供商时，该服务的同一个实例将会对该 NgModule 中的所有组件可用。要想在这一层注册，请用 <code>@NgModule()</code> 装饰器中的 <code>providers</code> 属性：</li></ul><pre><code>content_copy@NgModule({  providers: [   BackendService,   Logger ], ... })</code></pre><ul><li><p>当你在组件级注册提供商时，你会为该组件的每一个新实例提供该服务的一个新实例。 要在组件级注册，就要在 <code>@Component()</code> 元数据的 <code>providers</code> 属性中注册服务提供商。</p><pre class=" language-typescript"><code class="language-typescript">@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span>    <span class="token string">'app-hero-list'</span><span class="token punctuation">,</span>  templateUrl<span class="token punctuation">:</span> <span class="token string">'./hero-list.component.html'</span><span class="token punctuation">,</span>  providers<span class="token punctuation">:</span>  <span class="token punctuation">[</span> HeroService <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li></ul></li></ol><h2 id="2-6-工具与技巧"><a href="#2-6-工具与技巧" class="headerlink" title="2.6-工具与技巧"></a>2.6-工具与技巧</h2><h3 id="响应式编程工具"><a href="#响应式编程工具" class="headerlink" title="响应式编程工具"></a>响应式编程工具</h3><ul><li><a href="http://angular-doc.paas.cmbchina.cn/guide/lifecycle-hooks" target="_blank" rel="noopener">生命周期钩子</a>：通过实现生命周期钩子接口，可以窃听组件生命周期中的一些关键时刻 —— 从创建到销毁。</li><li><a href="http://angular-doc.paas.cmbchina.cn/guide/observables" target="_blank" rel="noopener">可观察对象（Observable）和事件处理</a>：如何在组件和服务中使用可观察对象来发布和订阅任意类型的消息，比如用户交互事件和异步操作结果。</li></ul><h3 id="客户端与服务器的交互工具"><a href="#客户端与服务器的交互工具" class="headerlink" title="客户端与服务器的交互工具"></a>客户端与服务器的交互工具</h3><ul><li><a href="http://angular-doc.paas.cmbchina.cn/guide/http" target="_blank" rel="noopener">HTTP</a>：用 HTTP 客户端与服务器通讯，以获取数据、保存数据或执行服务端动作。</li><li><a href="http://angular-doc.paas.cmbchina.cn/guide/universal" target="_blank" rel="noopener">服务端渲染</a>：Angular Universal 会通过服务端渲染（SSR）技术在服务器上生成静态的应用页面。 这让你可以在服务器上运行 Angular 应用，以提升性能并在手机或低功耗设备上快速显示首屏，并为 Web 爬虫提供帮助（SEO）。</li><li><a href="http://angular-doc.paas.cmbchina.cn/guide/service-worker-intro" target="_blank" rel="noopener">Service Worker</a>：借助 Service Worker 来减轻对网络的依赖，你可以显著提升用户体验。</li></ul><h3 id="特定领域的库"><a href="#特定领域的库" class="headerlink" title="特定领域的库"></a>特定领域的库</h3><ul><li><a href="http://angular-doc.paas.cmbchina.cn/guide/animations" target="_blank" rel="noopener">动画</a>：使用 Angular 的动画库，你可以让组件支持动画行为，而不用深入了解动画技术或 CSS。</li><li><a href="http://angular-doc.paas.cmbchina.cn/guide/forms" target="_blank" rel="noopener">Forms</a>：通过基于 HTML 的验证和脏数据检查，来支持复杂的数据输入场景。</li></ul><h3 id="为开发周期提供支持"><a href="#为开发周期提供支持" class="headerlink" title="为开发周期提供支持"></a>为开发周期提供支持</h3><ul><li><p><a href="http://angular-doc.paas.cmbchina.cn/guide/aot-compiler" target="_blank" rel="noopener">编译</a>：Angular 为开发环境提供了 JIT（即时）编译方式，为生产环境提供了 AOT（预先）编译方式。</p></li><li><p><a href="http://angular-doc.paas.cmbchina.cn/guide/testing" target="_blank" rel="noopener">测试平台</a>：对应用的各个部件运行单元测试，让它们好像在和 Angular 框架交互一样。</p></li><li><p><a href="http://angular-doc.paas.cmbchina.cn/guide/i18n" target="_blank" rel="noopener">国际化</a>：Angular 的国际化工具可以帮助你让应用可用于多种语言中。</p></li><li><p><a href="http://angular-doc.paas.cmbchina.cn/guide/security" target="_blank" rel="noopener">安全指南</a>：学习 Angular 对常见 Web 应用的弱点和工具（比如跨站脚本攻击）提供的内置防护措施。</p></li></ul><h3 id="环境搭建、构建与开发配置"><a href="#环境搭建、构建与开发配置" class="headerlink" title="环境搭建、构建与开发配置"></a>环境搭建、构建与开发配置</h3><ul><li><a href="http://angular-doc.paas.cmbchina.cn/cli" target="_blank" rel="noopener">CLI 命令参考手册</a>：Angular CLI 是一个命令行工具，你可以使用它来创建项目、生成应用及库代码，还能执行很多开发任务，比如测试、打包和发布。</li><li><a href="http://angular-doc.paas.cmbchina.cn/guide/file-structure" target="_blank" rel="noopener">工作区与文件结构</a>：理解 Angular 工作区与项目文件夹的结构。</li><li><a href="http://angular-doc.paas.cmbchina.cn/guide/npm-packages" target="_blank" rel="noopener">npm 包</a>：Angular 框架、Angular CLI 和 Angular 应用中用到的组件都是用 <a href="https://docs.npmjs.com/" target="_blank" rel="noopener">npm</a> 打包的，并通过 npm 注册服务器进行发布。Angular CLI 会创建一个默认的 <code>package.json</code> 文件，它会指定一组初始的包，它们可以一起使用，共同支持很多常见的应用场景。</li><li><a href="http://angular-doc.paas.cmbchina.cn/guide/typescript-configuration" target="_blank" rel="noopener">TypeScript 配置</a>：TypeScript 是 Angular 应用开发的主要语言。</li><li><a href="http://angular-doc.paas.cmbchina.cn/guide/browser-support" target="_blank" rel="noopener">浏览器支持</a>：学习如何让你的应用能和各种浏览器兼容。</li><li><a href="http://angular-doc.paas.cmbchina.cn/guide/build" target="_blank" rel="noopener">构建与运行</a>：学习为项目定义不同的构建和代理服务器设置的配置方式，比如开发、预生产和生产。</li><li><a href="http://angular-doc.paas.cmbchina.cn/guide/deployment" target="_blank" rel="noopener">部署</a>：学习把你的 Angular 应用发布到远端服务器的技巧。</li></ul><h1 id="3-组件与模板"><a href="#3-组件与模板" class="headerlink" title="3-组件与模板"></a>3-组件与模板</h1><h2 id="3-1-显示数据"><a href="#3-1-显示数据" class="headerlink" title="3.1-显示数据"></a>3.1-显示数据</h2><ol><li><p>使用插件表达式显示组件属性</p><p>要显示组件的属性，最简单的方式就是通过插值表达式 (interpolation) 来绑定属性名。 要使用插值表达式，就把属性名包裹在双花括号里放进视图模板，如 <code></code>。</p><p>使用 CLI 命令 <a href="http://angular-doc.paas.cmbchina.cn/cli/new" target="_blank" rel="noopener"><code>ng new displaying-data</code></a> 创建一个工作空间和一个名叫 <code>displaying-data</code> 的应用。</p><p>删除 <code>app.component.html</code> 文件，这个范例中不再需要它了。</p><p>然后，到 <code>app.component.ts</code> 文件中修改组件的模板和代码。</p><p>修改完之后，它应该是这样的：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-root'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`    &lt;h1>{{title}}&lt;/h1>    &lt;h2>My favorite hero is: {{myHero}}&lt;/h2>    `</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppComponent</span> <span class="token punctuation">{</span>  title <span class="token operator">=</span> <span class="token string">'Tour of Heroes'</span><span class="token punctuation">;</span>  myHero <span class="token operator">=</span> <span class="token string">'Windstorm'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>再把两个属性 <code>title</code> 和 <code>myHero</code> 添加到之前空白的组件中。</p><p>修改完的模板会使用双花括号形式的插值表达式来显示这两个模板属性：</p><pre class=" language-typescript"><code class="language-typescript">template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`  &lt;h1>{{title}}&lt;/h1>  &lt;h2>My favorite hero is: {{myHero}}&lt;/h2>  `</span></span></code></pre><p>Angular 自动从组件中提取 <code>title</code> 和 <code>myHero</code> 属性的值，并且把这些值插入浏览器中。当这些属性发生变化时，Angular 就会自动刷新显示。</p><p><strong>注意</strong>：你没有调用 <strong>new</strong> 来创建 <code>AppComponent</code> 类的实例，是 Angular 替你创建了它。那么它是如何创建的呢？</p><p><strong>注意</strong> ：<code>@Component</code> 装饰器中指定的 CSS 选择器 <code>selector</code>，它指定了一个叫 `` 的元素。 该元素是 <code>index.html</code> 文件里的一个占位符。</p><p>src/index.html</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span></code></pre><p>当你通过 <code>main.ts</code> 中的 <code>AppComponent</code> 类启动时，Angular 在 <code>index.html</code> 中查找一个 <code>元素， 然后实例化一个 `AppComponent`，并将其渲染到</code> 标签中。</p><p>运行应用。它应该显示出标题和英雄名：</p><p><img src="/2020/01/15/angular-xue-xi-bi-ji/title-and-hero.png" alt="title-and-hero"></p></li><li><p>内联模板还是模板文件？</p><p>你可以在两种地方存放组件模板。 你可以使用 <code>template</code> 属性把它定义为<em>内联</em>的，或者把模板定义在一个独立的 HTML 文件中， 再通过 <code>@Component</code> 装饰器中的 <code>templateUrl</code> 属性， 在组件元数据中把它链接到组件。</p><p>到底选择内联 HTML 还是独立 HTML 取决于个人喜好、具体状况和组织级策略。 上面的应用选择内联 HTML ，是因为模板很小，而且没有额外的 HTML 文件显得这个演示简单些。</p><p>无论用哪种风格，模板数据绑定在访问组件属性方面都是完全一样的。</p><p>默认情况下，Angular CLI 命令 <a href="http://angular-doc.paas.cmbchina.cn/cli/generate" target="_blank" rel="noopener"><code>ng generate component</code></a> 在生成组件时会带有模板文件，你可以通过参数来覆盖它</p></li><li><p>使用构造函数还是变量初始化？</p><p>虽然这个例子使用了变量赋值的方式初始化组件，你还可以使用构造函数来声明和初始化属性。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppComponent</span> <span class="token punctuation">{</span>  title<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  myHero<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">'Tour of Heroes'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>myHero <span class="token operator">=</span> <span class="token string">'Windstorm'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>使用ngFor显示数组属性</p><p>要显示一个英雄列表，先向组件中添加一个英雄名字数组，然后把 <code>myHero</code> 重定义为数组中的第一个名字。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppComponent</span> <span class="token punctuation">{</span>  title <span class="token operator">=</span> <span class="token string">'Tour of Heroes'</span><span class="token punctuation">;</span>  heroes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Windstorm'</span><span class="token punctuation">,</span> <span class="token string">'Bombasto'</span><span class="token punctuation">,</span> <span class="token string">'Magneta'</span><span class="token punctuation">,</span> <span class="token string">'Tornado'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  myHero <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>heroes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接着，在模板中使用 Angular 的 <code>ngFor</code> 指令来显示 <code>heroes</code> 列表中的每一项</p><pre class=" language-typescript"><code class="language-typescript">template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`  &lt;h1>{{title}}&lt;/h1>  &lt;h2>My favorite hero is: {{myHero}}&lt;/h2>  &lt;p>Heroes:&lt;/p>  &lt;ul>    &lt;li *ngFor="let hero of heroes">      {{ hero }}    &lt;/li>  &lt;/ul>`</span></span></code></pre><p>这个界面使用了由 <code>和</code> 标签组成的无序列表。<code>元素里的 `*ngFor` 是 Angular 的“迭代”指令。 它将</code> 元素及其子级标记为“迭代模板”：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">*ngFor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>let hero of heroes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  {{ hero }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span></code></pre><p><img src="/2020/01/15/angular-xue-xi-bi-ji/hero-names-list.png" alt="hero-names-list"></p></li><li><p>为数据创建一个类</p><p>应用代码直接在组件内部直接定义了数据。 作为演示还可以，但它显然不是最佳实践。</p><p>现在使用的是到了一个字符串数组的绑定。在真实的应用中，大多是到一个对象数组的绑定。</p><p>要将此绑定转换成使用对象，需要把这个英雄名字数组变成 <code>Hero</code> 对象数组。但首先得有一个 <code>Hero</code> 类。</p><p><code>ng generate class hero</code></p><p>代码如下：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Hero</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>    <span class="token keyword">public</span> id<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span>    <span class="token keyword">public</span> name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>你定义了一个类，具有一个构造函数和两个属性：<code>id</code> 和 <code>name</code>。</p><p>它可能看上去不像是有属性的类，但它确实有，利用的是 TypeScript 提供的简写形式 —— 用构造函数的参数直接定义属性。</p><p>来看第一个参数：</p><p><code>public id: number,</code>这个简写语法做了很多：</p><ul><li>声明了一个构造函数参数及其类型。</li><li>声明了一个同名的公共属性。</li><li>当创建该类的一个实例时，把该属性初始化为相应的参数值。</li></ul><p><strong>使用Hero类：</strong></p><p>导入了 <code>Hero</code> 类之后，组件的 <code>heroes</code> 属性就可以返回一个<em>类型化的</em><code>Hero</code> 对象数组了</p><pre class=" language-typescript"><code class="language-typescript">heroes <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Windstorm'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span> <span class="token string">'Bombasto'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token string">'Magneta'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token string">'Tornado'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>myHero <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>heroes<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>接着，修改模板。 现在它显示的是英雄的 <code>id</code> 和 <code>name</code>。 要修复它，只显示英雄的 <code>name</code> 属性就行了。</p><pre class=" language-typescript"><code class="language-typescript">template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`  &lt;h1>{{title}}&lt;/h1>  &lt;h2>My favorite hero is: {{myHero.name}}&lt;/h2>  &lt;p>Heroes:&lt;/p>  &lt;ul>    &lt;li *ngFor="let hero of heroes">      {{ hero.name }}    &lt;/li>  &lt;/ul>`</span></span></code></pre></li><li><p>通过ngIf进行条件显示</p><p>有时，应用需要只在特定情况下显示视图或视图的一部分。</p><p>来改一下这个例子，如果多于三位英雄，显示一条消息。</p><p>Angular 的 <code>ngIf</code> 指令会根据一个布尔条件来显示或移除一个元素。 来看看实际效果，把下列语句加到模板的底部：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">*ngIf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>heroes.length <span class="token punctuation">></span> 3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>There are many heroes!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><p>双引号中的模板表达式 <code>*ngIf=&quot;heros.length &gt; 3&quot;</code>，外观和行为很象 TypeScript 。 当组件中的英雄列表有三个以上的条目时，Angular 就会把这个段落添加到 DOM 中，于是消息显示了出来。 如果有三个或更少的条目，则 Angular 会省略这些段落，所以不显示消息。</p><p>Angular 并不是在显示和隐藏这条消息，它是在从 DOM 中添加和移除这个段落元素。 这会提高性能，特别是在一些大的项目中有条件地包含或排除一大堆带着很多数据绑定的 HTML 时。</p></li></ol><h2 id="3-2-模板语法"><a href="#3-2-模板语法" class="headerlink" title="3.2-模板语法"></a>3.2-模板语法</h2><p>Angular 应用管理着用户之所见和所为，并通过 Component 类的实例（<em>组件</em>）和面向用户的模板交互来实现这一点。</p><p>从使用模型-视图-控制器 (MVC) 或模型-视图-视图模型 (MVVM) 的经验中，很多开发人员都熟悉了组件和模板这两个概念。 在 Angular 中，组件扮演着控制器或视图模型的角色，模板则扮演视图的角色。</p><ol><li><p>模板中的HTML</p><p>HTML 是 Angular 模板的语言。几乎所有的 HTML 语法都是有效的模板语法。 但值得注意的例外是 <code>元素，它被禁用了，以阻止脚本注入攻击的风险。（实际上，</code> 只是被忽略了。）</p><p>有些合法的 HTML 被用在模板中是没有意义的。<code>、</code> 和 `` 元素这个舞台上中并没有扮演有用的角色。剩下的所有元素基本上就都一样用了。</p><p>可以通过组件和指令来扩展模板中的 HTML 词汇。它们看上去就是新元素和属性。接下来将学习如何通过数据绑定来动态获取/设置 DOM（文档对象模型）的值。</p><p>首先看看数据绑定的第一种形式 —— 插值表达式，它展示了模板的 HTML 可以有多丰富。</p></li><li><p>插值与模板表达式</p><p>插值能让你把计算后的字符串合并到 HTML 元素标签之间和属性赋值语句内的文本中。模板表达式则是用来供你求出这些字符串的。</p><ul><li><p>插值表达式</p><p>所谓 “插值” 是指将表达式嵌入到标记文本中。 默认情况下，插值表达式会用双花括号 <code>{{`和 `}}</code> 作为分隔符。</p><p>在下面的代码片段中，<code>{{ currentCustomer }}</code> 就是插值表达式的例子。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span>Current customer: {{ currentCustomer }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span></code></pre><p>插值表达式可以把计算后的字符串插入到 HTML 元素标签内的文本或对标签的属性进行赋值</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>{{title}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{{itemImageUrl}}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>在括号之间的“素材”，通常是组件属性的名字。Angular 会用组件中相应属性的字符串值，替换这个名字。 上例中，Angular 计算 <code>title</code> 和 <code>itemImageUrl</code> 属性的值，并把它们填在空白处。 首先显示粗体的应用标题，然后显示英雄的图片。</p><p>一般来说，括号间的素材是一个<strong>模板表达式</strong>，Angular 先<strong>对它求值</strong>，再把它<strong>转换成字符串</strong>。 下列插值表达式通过把括号中的两个数字相加说明了这一点：</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- "The sum of 1 + 1 is 2" --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>The sum of 1 + 1 is {{1 + 1}}.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><p>这个表达式可以调用宿主组件的方法，就像下面用的 <code>getVal()</code>：</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- "The sum of 1 + 1 is not 4" --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>The sum of 1 + 1 is not {{1 + 1 + getVal()}}.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><p>Angular 对所有双花括号中的表达式求值，把求值的结果转换成字符串，并把它们跟相邻的字符串字面量连接起来。最后，把这个组合出来的插值结果赋给<strong>元素或指令的属性</strong>。</p><p>从表面上看，你就像是在元素标签之间插入了结果并对标签的属性进行了赋值。</p></li></ul></li><li><p>表达式上下文</p><p>典型的<em>表达式上下文</em>就是这个<strong>组件实例</strong>，它是各种绑定值的来源。 在下面的代码片段中，双花括号中的 <code>recommended</code> 和引号中的 <code>itemImageUrl2</code> 所引用的都是 <code>AppComponent</code> 中的属性。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h4</span><span class="token punctuation">></span></span>{{recommended}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h4</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">[src]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>itemImageUrl2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><p>表达式的上下文可以包括组件之外的对象。 比如<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#template-input-variable" target="_blank" rel="noopener">模板输入变量</a> (<code>let customer</code>)和<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#ref-vars" target="_blank" rel="noopener">模板引用变量</a>(<code>#customerInput</code>)就是备选的上下文对象之一。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">*ngFor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>let customer of customers<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{customer.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">></span></span></code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>Type something:  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">#customerInput</span><span class="token punctuation">></span></span>{{customerInput.value}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span></code></pre><p>表达式中的上下文变量是由<em>模板变量</em>、指令的<em>上下文变量</em>（如果有）和组件的<em>成员</em>叠加而成的。 如果你要引用的变量名存在于一个以上的命名空间中，那么，模板变量是最优先的，其次是指令的上下文变量，最后是组件的成员。</p></li><li><p>模板语句</p><p>模板<strong>语句</strong>用来响应由绑定目标（如 HTML 元素、组件或指令）触发的<strong>事件</strong>。 模板语句将在<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#event-binding" target="_blank" rel="noopener">事件绑定</a>一节看到，它出现在 <code>=</code> 号右侧的引号中，就像这样：<code>(event)=&quot;statement&quot;</code>。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">(click)</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>deleteHero()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Delete hero<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code></pre><p>模板语句<em>有副作用</em>。 这是事件处理的关键。因为你要根据用户的输入更新应用状态。</p><p>响应事件是 Angular 中“单向数据流”的另一面。 在一次事件循环中，可以随意改变任何地方的任何东西。</p><p>和模板表达式一样，模板<em>语句</em>使用的语言也像 JavaScript。 模板语句解析器和模板表达式解析器有所不同，特别之处在于它支持基本赋值 (<code>=</code>) 和表达式链 (<code>;</code> 和 <code>,</code>)。</p><p>然而，某些 JavaScript 语法仍然是不允许的：</p><ul><li><code>new</code> 运算符</li><li>自增和自减运算符：<code>++</code> 和 <code>--</code></li><li>操作并赋值，例如 <code>+=</code> 和 <code>-=</code></li><li>位操作符 <code>|</code> 和 <code>&amp;</code></li><li><a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#expression-operators" target="_blank" rel="noopener">模板表达式运算符</a></li></ul></li><li><p>语句上下文</p><p>和表达式中一样，语句只能引用语句上下文中 —— 通常是正在绑定事件的那个<strong>组件实例</strong>。</p><p>典型的<em>语句上下文*就是当前组件的实例。 <code>(click)=&quot;deleteHero()&quot;</code> 中的 *deleteHero</em> 就是这个数据绑定组件上的一个方法。</p><p><code>&lt;button (click)=&quot;deleteHero()&quot;&gt;Delete hero&lt;/button&gt;</code></p><p>语句上下文可以引用模板自身上下文中的属性。 在下面的例子中，就把模板的 <code>$event</code> 对象、<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#template-input-variable" target="_blank" rel="noopener">模板输入变量</a> (<code>let hero</code>)和<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#ref-vars" target="_blank" rel="noopener">模板引用变量</a> (<code>#heroForm</code>)传给了组件中的一个事件处理器方法。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">(click)</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>onSave($event)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Save<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">*ngFor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>let hero of heroes<span class="token punctuation">"</span></span> <span class="token attr-name">(click)</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>deleteHero(hero)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{hero.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">#heroForm</span> <span class="token attr-name">(ngSubmit)</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>onSubmit(heroForm)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> ... <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span></code></pre><p>模板上下文中的变量名的优先级高于组件上下文中的变量名。在上面的 <code>deleteHero(hero)</code> 中，<code>hero</code> 是一个模板输入变量，而不是组件中的 <code>hero</code> 属性。</p><p>模板语句不能引用全局命名空间的任何东西。比如不能引用 <code>window</code> 或 <code>document</code>，也不能调用 <code>console.log</code> 或 <code>Math.max</code>。</p></li><li><p>绑定语法</p><p>数据绑定是一种机制，用来协调用户所见和应用数据。 虽然你能往 HTML 推送值或者从 HTML 拉取值， 但如果把这些琐事交给数据绑定框架处理， 应用会更容易编写、阅读和维护。 只要简单地在绑定源和目标 HTML 元素之间声明绑定，框架就会完成这项工作。</p><p>绑定的类型可以根据数据流的方向分成三类： <em>从数据源到视图</em>、<em>从视图到数据源</em>以及双向的<em>从视图到数据源再到视图</em>。</p><table><thead><tr><th>数据方向</th><th>语法</th><th>绑定类型</th></tr></thead><tbody><tr><td>单向<br>从数据源到视图</td><td> [<a href="http://angular-doc.paas.cmbchina.cn/api/router/RouterLinkWithHref#target" target="_blank" rel="noopener">target</a>]=”expression” bind-target=”expression”</td><td>插值<br>属性<br>Attribute<br>CSS 类<br>样式</td></tr><tr><td>从视图到数据源的单向绑定</td><td>(<a href="http://angular-doc.paas.cmbchina.cn/api/router/RouterLinkWithHref#target" target="_blank" rel="noopener">target</a>)=”statement” on-target=”statement”事件</td><td>事件</td></tr><tr><td>双向</td><td>[(<a href="http://angular-doc.paas.cmbchina.cn/api/router/RouterLinkWithHref#target" target="_blank" rel="noopener">target</a>)]=”expression” bindon-target=”expression”</td><td>双向</td></tr></tbody></table></li><li><p>绑定目标</p><table><thead><tr><th>绑定类型</th><th>目标</th><th>范例</th></tr></thead><tbody><tr><td>属性</td><td>元素的 property<br>组件的 property<br>指令的 property</td><td>&lt;img [src]=”heroImageUrl”&gt; <br>&lt;app-hero-detail [hero]=”currentHero”&gt; <br>&lt;div [ngClass]=”{‘special’: isSpecial}”&gt;</td></tr><tr><td>事件</td><td>元素的事件<br>组件的事件<br>指令的事件</td><td>&lt;button (click)=”onSave()”&gt;Save<br> &lt;app-hero-detail (deleteRequest)=”deleteHero()”&gt;<br> &lt;div (myClick)=”clicked=$event” clickable&gt;click me</td></tr><tr><td>双向</td><td>事件与 property</td><td>&lt;input [(<a href="http://angular-doc.paas.cmbchina.cn/api/forms/NgModel" target="_blank" rel="noopener">ngModel</a>)]=”name”&gt;</td></tr><tr><td>Attribute</td><td>attribute（例外情况）</td><td>&lt;button [attr.aria-label]=”help”&gt;help</td></tr><tr><td>CSS 类</td><td><code>class</code> property</td><td>&lt;div [class.special]=”isSpecial”&gt;Special</td></tr><tr><td>样式</td><td><code>style</code> property</td><td>&lt;button [style.color]=”isSpecial ? ‘red’ : ‘green’”&gt;</td></tr></tbody></table></li><li><p>内置指令</p><ul><li><p>内置属性型指令</p><p>属性型指令会监听和修改其它 HTML 元素或组件的行为、元素属性（Attribute）、DOM 属性（Property）。 它们通常会作为 HTML 属性的名称而应用在元素上。</p><ul><li><p>NgClass</p><p>你经常用动态添加或删除 CSS 类的方式来控制元素如何显示。 通过绑定到 <code>NgClass</code>，可以同时添加或移除多个类。</p><p><a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#class-binding" target="_blank" rel="noopener">CSS 类绑定</a> 是添加或删除<em>单个</em>类的最佳途径。</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- toggle the "special" class on/off with a property --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">[class.special]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isSpecial<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>The class binding is special<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>当想要同时添加或移除<em>多个</em> CSS 类时，<code>NgClass</code> 指令可能是更好的选择。</p><p>试试把 <code>ngClass</code> 绑定到一个 key:value 形式的控制对象。这个对象中的每个 key 都是一个 CSS 类名，如果它的 value 是 <code>true</code>，这个类就会被加上，否则就会被移除。</p><p>组件方法 <code>setCurrentClasses</code> 可以把组件的属性 <code>currentClasses</code> 设置为一个对象，它将会根据三个其它组件的状态为 <code>true</code> 或 <code>false</code> 而添加或移除三个类。</p><pre class=" language-typescript"><code class="language-typescript">currentClasses<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">setCurrentClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// CSS classes: added/removed per current state of component properties</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>currentClasses <span class="token operator">=</span>  <span class="token punctuation">{</span>    <span class="token string">'saveable'</span><span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>canSave<span class="token punctuation">,</span>    <span class="token string">'modified'</span><span class="token punctuation">:</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>isUnchanged<span class="token punctuation">,</span>    <span class="token string">'special'</span><span class="token punctuation">:</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>isSpecial  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>把 <code>NgClass</code> 属性绑定到 <code>currentClasses</code>，根据它来设置此元素的 CSS 类：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">[ngClass]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentClasses<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>This div is initially saveable, unchanged, and special<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre></li><li><p>NgStyle</p><p>你可以根据组件的状态动态设置内联样式。 <code>NgStyle</code> 绑定可以同时设置多个内联样式。</p><p><a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#style-binding" target="_blank" rel="noopener">样式绑定</a>是设置<em>单一</em>样式值的简单方式。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">[style.font-size]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isSpecial ? <span class="token punctuation">'</span>x-large<span class="token punctuation">'</span> : <span class="token punctuation">'</span>smaller<span class="token punctuation">'</span><span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>  This div is x-large or smaller.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>如果要同时设置<em>多个</em>内联样式，<code>NgStyle</code> 指令可能是更好的选择。</p><p><code>NgStyle</code> 需要绑定到一个 key:value 控制对象。 对象的每个 key 是样式名，它的 value 是能用于这个样式的任何值。</p><p>来看看组件的 <code>setCurrentStyles</code> 方法，它会根据另外三个属性的状态把组件的 <code>currentStyles</code> 属性设置为一个定义了三个样式的对象：</p><pre class=" language-typescript"><code class="language-typescript">currentStyles<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">setCurrentStyles</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// CSS styles: set per current state of component properties</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>currentStyles <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">'font-style'</span><span class="token punctuation">:</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>canSave      <span class="token operator">?</span> <span class="token string">'italic'</span> <span class="token punctuation">:</span> <span class="token string">'normal'</span><span class="token punctuation">,</span>    <span class="token string">'font-weight'</span><span class="token punctuation">:</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>isUnchanged <span class="token operator">?</span> <span class="token string">'bold'</span>   <span class="token punctuation">:</span> <span class="token string">'normal'</span><span class="token punctuation">,</span>    <span class="token string">'font-size'</span><span class="token punctuation">:</span>   <span class="token keyword">this</span><span class="token punctuation">.</span>isSpecial    <span class="token operator">?</span> <span class="token string">'24px'</span>   <span class="token punctuation">:</span> <span class="token string">'12px'</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>把 <code>ngStyle</code> 属性绑定到 <code>currentStyles</code>，来根据它设置此元素的样式：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">[ngStyle]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentStyles<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  This div is initially italic, normal weight, and extra large (24px).<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre></li><li><p>NgModel- 使用[(ngModel)]双向绑定到表单元素</p><p>当开发数据输入表单时，你通常都要既显示数据属性又根据用户的更改去修改那个属性。</p><p>使用 <code>NgModel</code> 指令进行双向数据绑定可以简化这种工作。例子如下：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">[(ngModel)]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentHero.name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><p><strong>使用 ngModel 时需要 FormsModule</strong><br>在使用 ngModel 指令进行双向数据绑定之前，你必须导入 FormsModule 并把它添加到 NgModule 的 imports 列表中。 要了解 FormsModule 和 ngModel 的更多知识，参见表单一章。</p><p>导入 FormsModule 并让 [(ngModel)] 可用的代码如下：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> NgModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> BrowserModule <span class="token punctuation">}</span>  <span class="token keyword">from</span> <span class="token string">'@angular/platform-browser'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> FormsModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/forms'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// &lt;--- JavaScript import from Angular</span><span class="token comment" spellcheck="true">/* Other imports */</span>@<span class="token function">NgModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  imports<span class="token punctuation">:</span> <span class="token punctuation">[</span>    BrowserModule<span class="token punctuation">,</span>    FormsModule  <span class="token comment" spellcheck="true">// &lt;--- import into the NgModule</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">/* Other module metadata */</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre></li></ul></li><li><p>内置结构型属性</p><p>结构型指令的职责是 HTML 布局。 它们塑造或重塑 DOM 的<em>结构</em>，这通常是通过添加、移除和操纵它们所附加到的宿主元素来实现的。</p><ul><li><p>NgIf</p><p>通过把 <code>NgIf</code> 指令应用到元素上（称为<em>宿主元素</em>），你可以往 DOM 中添加或从 DOM 中移除这个元素。 在下面的例子中，该指令绑定到了类似于 <code>isActive</code> 这样的条件表达式。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-hero-detail</span> <span class="token attr-name">*ngIf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>isActive<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-hero-detail</span><span class="token punctuation">></span></span></code></pre><p>当 <code>isActive</code> 表达式返回真值时，<code>NgIf</code> 把 <code>HeroDetailComponent</code> 添加到 DOM 中；为假时，<code>NgIf</code> 会从 DOM 中移除 <code>HeroDetailComponent</code>，并销毁该组件及其所有子组件。</p><p><code>ngIf</code> 指令通常会用来防范空指针错误。 而显示/隐藏的方式是无法防范的，当一个表达式尝试访问空值的属性时，Angular 就会抛出一个异常。</p><p>这里我们用 <code>NgIf</code> 来保护了两个 `` 防范空指针错误。 <code>currentHero</code> 的名字只有当存在 <code>currentHero</code> 时才会显示出来。 而 <code>nullHero</code> 永远不会显示。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">*ngIf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentHero<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello, {{currentHero.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">*ngIf</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>nullHero<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Hello, {{nullHero.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre></li><li><p>NgFor</p><p><code>NgFor</code> 是一个<em>重复器</em>指令 —— 自定义数据显示的一种方式。 你的目标是展示一个由多个条目组成的列表。首先定义了一个 HTML 块，它规定了单个条目应该如何显示。 再告诉 Angular 把这个块当做模板，渲染列表中的每个条目。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">*ngFor</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>let hero of heroes<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>{{hero.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre></li><li><p>NgSwitch</p><p><code>NgSwitch</code> 指令类似于 JavaScript 的 <code>switch</code> 语句。 它可以从多个可能的元素中根据<em>switch 条件</em>来显示某一个。 Angular 只会把<em>选中的</em>元素放进 DOM 中。</p><p><code>NgSwitch</code> 实际上包括三个相互协作的指令：<code>NgSwitch</code>、<code>NgSwitchCase</code> 和 <code>NgSwitchDefault</code>，例子如下：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">[ngSwitch]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentHero.emotion<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-happy-hero</span>    <span class="token attr-name">*ngSwitchCase</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>happy<span class="token punctuation">'</span><span class="token punctuation">"</span></span>    <span class="token attr-name">[hero]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentHero<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-happy-hero</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-sad-hero</span>      <span class="token attr-name">*ngSwitchCase</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>sad<span class="token punctuation">'</span><span class="token punctuation">"</span></span>      <span class="token attr-name">[hero]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentHero<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-sad-hero</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-confused-hero</span> <span class="token attr-name">*ngSwitchCase</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>confused<span class="token punctuation">'</span><span class="token punctuation">"</span></span> <span class="token attr-name">[hero]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentHero<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-confused-hero</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>app-unknown-hero</span>  <span class="token attr-name">*ngSwitchDefault</span>           <span class="token attr-name">[hero]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>currentHero<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>app-unknown-hero</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p><code>NgSwitch</code> 是主控指令，要把它绑定到一个返回<em>候选值</em>的表达式。 本例子中的 <code>emotion</code> 是个字符串，但实际上这个候选值可以是任意类型。</p><p><strong>绑定到 <code>[ngSwitch]</code></strong>。如果试图用 <code>*ngSwitch</code> 的形式使用它就会报错，这是因为 <code>NgSwitch</code> 是一个<em>属性型</em>指令，而不是<em>结构型指令</em>。 它要修改的是所在元素的行为，而不会直接接触 DOM 结构。</p><p><strong>绑定到 <code>\*ngSwitchCase</code> 和 <code>\*ngSwitchDefault</code></strong> <code>NgSwitchCase</code> 和 <code>NgSwitchDefault</code> 指令都是<em>结构型指令</em>，因为它们会从 DOM 中添加或移除元素。</p><ul><li><code>NgSwitchCase</code> 会在它绑定到的值等于候选值时，把它所在的元素加入到 DOM 中。</li><li><code>NgSwitchDefault</code> 会在没有任何一个 <code>NgSwitchCase</code> 被选中时把它所在的元素加入 DOM 中。</li></ul><p>这组指令在要添加或移除<em>组件元素</em>时会非常有用。 这个例子会在 <code>hero-switch.components.ts</code> 中定义的四个“感人英雄”组件之间选择。 每个组件都有一个<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#inputs-outputs" target="_blank" rel="noopener">输入属性</a><code>hero</code>，它绑定到父组件的 <code>currentHero</code> 上。</p><p>这组指令在原生元素和<a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" target="_blank" rel="noopener">Web Component</a>上都可以正常工作。 比如，你可以把 `` 分支改成这样：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">*ngSwitchCase</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">'</span>confused<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Are you as confused as {{currentHero.name}}?<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre></li></ul></li></ul></li></ol><h2 id="3-3-用户输入"><a href="#3-3-用户输入" class="headerlink" title="3.3-用户输入"></a>3.3-用户输入</h2><p>当用户点击链接、按下按钮或者输入文字时，这些用户动作都会产生 DOM 事件。 本章解释如何使用 Angular 事件绑定语法把这些事件绑定到事件处理器。</p><ol><li><p>绑定到用户输入事件</p><p>你可以使用 <a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#event-binding" target="_blank" rel="noopener">Angular 事件绑定</a>机制来响应任何 <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener">DOM 事件</a>。 许多 DOM 事件是由用户输入触发的。绑定这些事件可以获取用户输入。</p><p>要绑定 DOM 事件，只要把 DOM 事件的名字包裹在圆括号中，然后用放在引号中的<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#template-statements" target="_blank" rel="noopener">模板语句</a>对它赋值就可以了。</p><p>下例展示了一个事件绑定，它实现了一个点击事件处理器：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">(click)</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>onClickMe()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Click me!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span></code></pre><p>等号左边的 <code>(click)</code> 表示把按钮的点击事件作为<strong>绑定目标</strong>。 等号右边引号中的文本是<strong>模板语句</strong>，通过调用组件的 <code>onClickMe</code> 方法来响应这个点击事件。</p><p>写绑定时，需要知道模板语句的<strong>执行上下文</strong>。 出现在模板语句中的每个标识符都属于特定的上下文对象。 这个对象通常都是控制此模板的 Angular 组件。 上例中只显示了一行 HTML，那段 HTML 片段属于下面这个组件：</p><pre class=" language-html"><code class="language-html">@Component({  selector: 'app-click-me',  template: `    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">(click)</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>onClickMe()<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Click me!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    {{clickMessage}}`})export class ClickMeComponent {  clickMessage = '';  onClickMe() {    this.clickMessage = 'You are my hero!';  }}</code></pre><p>当用户点击按钮时，Angular 调用 <code>ClickMeComponent</code> 的 <code>onClickMe</code> 方法。</p></li><li><p>通过 $event 对象取得用户输入</p><p>DOM 事件可以携带可能对组件有用的信息。 本节将展示如何绑定输入框的 <code>keyup</code> 事件，在每个敲击键盘时获取用户输入。</p><p>下面的代码监听 <code>keyup</code> 事件，并将整个事件载荷 (<code>$event</code>) 传递给组件的事件处理器。</p><pre class=" language-typescript"><code class="language-typescript">template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`  &lt;input (keyup)="onKey($event)">  &lt;p>{{values}}&lt;/p>`</span></span></code></pre><p>当用户按下并释放一个按键时，触发 <code>keyup</code> 事件，Angular 在 <code>$event</code> 变量提供一个相应的 DOM 事件对象，上面的代码将它作为参数传递给 <code>onKey()</code> 方法。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">KeyUpComponent_v1</span> <span class="token punctuation">{</span>  values <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>  <span class="token function">onKey</span><span class="token punctuation">(</span>event<span class="token punctuation">:</span> <span class="token keyword">any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// without type info</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>values <span class="token operator">+</span><span class="token operator">=</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token string">' | '</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>$event</code> 对象的属性取决于 DOM 事件的类型。例如，鼠标事件与输入框编辑事件包含了不同的信息。</p><p>所有<a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank" rel="noopener">标准 DOM 事件对象</a>都有一个 <code>target</code> 属性， 引用触发该事件的元素。 在本例中，<code>target</code> 是<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement" target="_blank" rel="noopener">`` 元素</a>， <code>event.target.value</code> 返回该元素的当前内容。</p><p>在组件的 <code>onKey()</code> 方法中，把输入框的值和分隔符 (|) 追加组件的 <code>values</code> 属性。 使用<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#interpolation" target="_blank" rel="noopener">插值表达式</a>来把存放累加结果的 <code>values</code> 属性回显到屏幕上。</p></li></ol><h2 id="3-4-生命周期钩子"><a href="#3-4-生命周期钩子" class="headerlink" title="3.4-生命周期钩子"></a>3.4-生命周期钩子</h2><p>每个组件都有一个被 Angular 管理的生命周期。</p><p>Angular 创建它，渲染它，创建并渲染它的子组件，在它被绑定的属性发生变化时检查它，并在它从 DOM 中被移除前销毁它。</p><p>Angular 提供了<strong>生命周期钩子</strong>，把这些关键生命时刻暴露出来，赋予你在它们发生时采取行动的能力。</p><p>除了那些组件内容和视图相关的钩子外,指令有相同生命周期钩子。</p><ol><li><p>组件生命周期钩子概览</p><p>指令和组件的实例有一个生命周期：当 Angular 新建、更新和销毁它们时触发。 通过实现一个或多个 Angular <code>core</code> 库里定义的<em>生命周期钩子</em>接口，开发者可以介入该生命周期中的这些关键时刻。</p><p>每个接口都有唯一的一个钩子方法，它们的名字是由接口名再加上 <code>ng</code> 前缀构成的。比如，<code>OnInit</code> 接口的钩子方法叫做 <code>ngOnInit</code>， Angular 在创建组件后立刻调用它，：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">PeekABoo</span> <span class="token keyword">implements</span> <span class="token class-name">OnInit</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> logger<span class="token punctuation">:</span> LoggerService<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// implement OnInit's `ngOnInit` method</span>  <span class="token function">ngOnInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">logIt</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`OnInit`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token function">logIt</span><span class="token punctuation">(</span>msg<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>logger<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`#</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>nextId<span class="token operator">++</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>msg<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>没有指令或者组件会实现所有这些接口，并且有些钩子只对组件有意义。只有在指令/组件中<em>定义过的</em>那些钩子方法才会被 Angular 调用。</p></li><li><p>生命周期的顺序</p><p>当 Angular 使用构造函数新建一个组件或指令后，就会按下面的顺序在特定时刻调用这些生命周期钩子方法：</p><table><thead><tr><th>钩子</th><th>用途及时机</th></tr></thead><tbody><tr><td>ngOnChanges()</td><td>当 Angular（重新）设置数据绑定输入属性时响应。 该方法接受当前和上一属性值的 <code>SimpleChanges</code> 对象<br>在 <code>ngOnInit()</code> 之前以及所绑定的一个或多个输入属性的值发生变化时都会调用。</td></tr><tr><td>ngOnInit()</td><td>在 Angular 第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。<br>在第一轮 <code>ngOnChanges()</code> 完成之后调用，只调用<strong>一次</strong>。</td></tr><tr><td>ngDoCheck()</td><td>检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应。<br>在每个变更检测周期中，紧跟在 <code>ngOnChanges()</code> 和 <code>ngOnInit()</code> 后面调用。</td></tr><tr><td><a href="http://angular-doc.paas.cmbchina.cn/api/router/RouterLinkActive#ngAfterContentInit" target="_blank" rel="noopener">ngAfterContentInit()</a></td><td>当 Angular 把外部内容投影进组件/指令的视图之后调用。<br>第一次 <code>ngDoCheck()</code> 之后调用，只调用一次。</td></tr><tr><td>ngAfterContentChecked()</td><td>每当 Angular 完成被投影组件内容的变更检测之后调用。<br><code>ngAfterContentInit()</code> 和每次 <code>ngDoCheck()</code> 之后调用</td></tr><tr><td><a href="http://angular-doc.paas.cmbchina.cn/api/forms/NgForm#ngAfterViewInit" target="_blank" rel="noopener">ngAfterViewInit()</a></td><td>当 Angular 初始化完组件视图及其子视图之后调用。<br>第一次 <code>ngAfterContentChecked()</code> 之后调用，只调用一次。</td></tr><tr><td>ngAfterViewChecked()</td><td>每当 Angular 做完组件视图和子视图的变更检测之后调用。<br><code>ngAfterViewInit()</code> 和每次 <code>ngAfterContentChecked()</code> 之后调用。</td></tr><tr><td>ngOnDestroy()</td><td>每当 Angular 每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。<br>在 Angular 销毁指令/组件之前调用。</td></tr></tbody></table></li></ol><h2 id="3-5-组件之间的交互"><a href="#3-5-组件之间的交互" class="headerlink" title="3.5-组件之间的交互"></a>3.5-组件之间的交互</h2><ol><li><p>通过输入型绑定把数据从父组件传到子组件</p><p><code>HeroChildComponent</code> 有两个<strong><em>输入型属性\</em></strong>，它们通常带<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#inputs-outputs" target="_blank" rel="noopener">@Input 装饰器</a>。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component<span class="token punctuation">,</span> Input <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> Hero <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./hero'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-hero-child'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`    &lt;h3>{{hero.name}} says:&lt;/h3>    &lt;p>I, {{hero.name}}, am at your service, {{masterName}}.&lt;/p>  `</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">HeroChildComponent</span> <span class="token punctuation">{</span>  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> hero<span class="token punctuation">:</span> Hero<span class="token punctuation">;</span>  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token string">'master'</span><span class="token punctuation">)</span> masterName<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>第二个 <code>@Input</code> 为子组件的属性名 <code>masterName</code> 指定一个别名 <code>master</code>(译者注：不推荐为起别名，请参见风格指南).</p><p>父组件 <code>HeroParentComponent</code> 把子组件的 <code>HeroChildComponent</code> 放到 <code>*ngFor</code> 循环器中，把自己的 <code>master</code> 字符串属性绑定到子组件的 <code>master</code> 别名上，并把每个循环的 <code>hero</code> 实例绑定到子组件的 <code>hero</code> 属性。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> HEROES <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./hero'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-hero-parent'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`    &lt;h2>{{master}} controls {{heroes.length}} heroes&lt;/h2>    &lt;app-hero-child *ngFor="let hero of heroes"      [hero]="hero"      [master]="master">    &lt;/app-hero-child>  `</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">HeroParentComponent</span> <span class="token punctuation">{</span>  heroes <span class="token operator">=</span> HEROES<span class="token punctuation">;</span>  master <span class="token operator">=</span> <span class="token string">'Master'</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行应用程序会显示三个英雄：</p><p><img src="/2020/01/15/angular-xue-xi-bi-ji/parent-to-child.png" alt="parent-to-child"></p></li><li><p>通过 setter 截听输入属性值的变化</p><p>使用一个输入属性的 setter，以拦截父组件中值的变化，并采取行动。</p><p>子组件 <code>NameChildComponent</code> 的输入属性 <code>name</code> 上的这个 setter，会 trim 掉名字里的空格，并把空值替换成默认字符串。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component<span class="token punctuation">,</span> Input <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-name-child'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token string">'&lt;h3>"{{name}}"&lt;/h3>'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">NameChildComponent</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> _name <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token keyword">set</span> <span class="token function">name</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> <span class="token punctuation">(</span>name <span class="token operator">&amp;&amp;</span> name<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">'&lt;no name set>'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">get</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">string</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面的 <code>NameParentComponent</code> 展示了各种名字的处理方式，包括一个全是空格的名字。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-name-parent'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`  &lt;h2>Master controls {{names.length}} names&lt;/h2>  &lt;app-name-child *ngFor="let name of names" [name]="name">&lt;/app-name-child>  `</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">NameParentComponent</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Displays 'Dr IQ', '&lt;no name set>', 'Bombasto'</span>  names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Dr IQ'</span><span class="token punctuation">,</span> <span class="token string">'   '</span><span class="token punctuation">,</span> <span class="token string">'  Bombasto  '</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="/2020/01/15/angular-xue-xi-bi-ji/setter.png" alt="setter"></p></li><li><p>通过ngOnChanges()来截听输入属性值的变化</p><p>使用 <code>OnChanges</code> 生命周期钩子接口的 <code>ngOnChanges()</code> 方法来监测输入属性值的变化并做出回应。</p><p>当需要监视多个、交互式输入属性的时候，本方法比用属性的 setter 更合适。</p><p>这个 <code>VersionChildComponent</code> 会监测输入属性 <code>major</code> 和 <code>minor</code> 的变化，并把这些变化编写成日志以报告这些变化。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component<span class="token punctuation">,</span> Input<span class="token punctuation">,</span> OnChanges<span class="token punctuation">,</span> SimpleChange <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-version-child'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`    &lt;h3>Version {{major}}.{{minor}}&lt;/h3>    &lt;h4>Change log:&lt;/h4>    &lt;ul>      &lt;li *ngFor="let change of changeLog">{{change}}&lt;/li>    &lt;/ul>  `</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">VersionChildComponent</span> <span class="token keyword">implements</span> <span class="token class-name">OnChanges</span> <span class="token punctuation">{</span>  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> major<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> minor<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">;</span>  changeLog<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">ngOnChanges</span><span class="token punctuation">(</span>changes<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">[</span>propKey<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">]</span><span class="token punctuation">:</span> SimpleChange<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> log<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> propName <span class="token keyword">in</span> changes<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> changedProp <span class="token operator">=</span> changes<span class="token punctuation">[</span>propName<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">let</span> to <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>changedProp<span class="token punctuation">.</span>currentValue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>changedProp<span class="token punctuation">.</span><span class="token function">isFirstChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Initial value of </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>propName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> set to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>to<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> <span class="token keyword">from</span> <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>changedProp<span class="token punctuation">.</span>previousValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>propName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> changed from </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">from</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> to </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>to<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>changeLog<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>log<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">', '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>VersionParentComponent</code> 提供 <code>minor</code> 和 <code>major</code> 值，把修改它们值的方法绑定到按钮上。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-version-parent'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`    &lt;h2>Source code version&lt;/h2>    &lt;button (click)="newMinor()">New minor version&lt;/button>    &lt;button (click)="newMajor()">New major version&lt;/button>    &lt;app-version-child [major]="major" [minor]="minor">&lt;/app-version-child>  `</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">VersionParentComponent</span> <span class="token punctuation">{</span>  major <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  minor <span class="token operator">=</span> <span class="token number">23</span><span class="token punctuation">;</span>  <span class="token function">newMinor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>minor<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">newMajor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>major<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>minor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面是点击按钮的结果。</p><p><img src="/2020/01/15/angular-xue-xi-bi-ji/parent-to-child-on-changes.gif" alt="parent-to-child-on-changes"></p></li><li><p>父组件监听子组件的事件</p><p>子组件暴露一个 <code>EventEmitter</code> 属性，当事件发生时，子组件利用该属性 <code>emits</code>(向上弹射)事件。父组件绑定到这个事件属性，并在事件发生时作出回应。</p><p>子组件的 <code>EventEmitter</code> 属性是一个<strong>输出属性</strong>，通常带有<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#inputs-outputs" target="_blank" rel="noopener">@Output 装饰器</a>，就像在 <code>VoterComponent</code> 中看到的。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component<span class="token punctuation">,</span> EventEmitter<span class="token punctuation">,</span> Input<span class="token punctuation">,</span> Output <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-voter'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`    &lt;h4>{{name}}&lt;/h4>    &lt;button (click)="vote(true)"  [disabled]="didVote">Agree&lt;/button>    &lt;button (click)="vote(false)" [disabled]="didVote">Disagree&lt;/button>  `</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">VoterComponent</span> <span class="token punctuation">{</span>  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  @<span class="token function">Output</span><span class="token punctuation">(</span><span class="token punctuation">)</span> voted <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventEmitter</span><span class="token operator">&lt;</span><span class="token keyword">boolean</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  didVote <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>  <span class="token function">vote</span><span class="token punctuation">(</span>agreed<span class="token punctuation">:</span> <span class="token keyword">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>voted<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span>agreed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>didVote <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>点击按钮会触发 <code>true</code> 或 <code>false</code>(布尔型<em>有效载荷</em>)的事件。</p><p>父组件 <code>VoteTakerComponent</code> 绑定了一个事件处理器(<code>onVoted()</code>)，用来响应子组件的事件(<code>$event</code>)并更新一个计数器。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span>      <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-vote-taker'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`    &lt;h2>Should mankind colonize the Universe?&lt;/h2>    &lt;h3>Agree: {{agreed}}, Disagree: {{disagreed}}&lt;/h3>    &lt;app-voter *ngFor="let voter of voters"      [name]="voter"      (voted)="onVoted($event)">    &lt;/app-voter>  `</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">VoteTakerComponent</span> <span class="token punctuation">{</span>  agreed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  disagreed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  voters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Narco'</span><span class="token punctuation">,</span> <span class="token string">'Celeritas'</span><span class="token punctuation">,</span> <span class="token string">'Bombasto'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">onVoted</span><span class="token punctuation">(</span>agreed<span class="token punctuation">:</span> <span class="token keyword">boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    agreed <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>agreed<span class="token operator">++</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>disagreed<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>本框架把事件参数(用 <code>$event</code> 表示)传给事件处理方法，该方法会处理它：</p><p><img src="/2020/01/15/angular-xue-xi-bi-ji/child-to-parent.gif" alt="child-to-parent"></p></li><li><p>父组件与子组件通过本地变量互动</p><p>父组件不能使用数据绑定来读取子组件的属性或调用子组件的方法。但可以在父组件模板里，新建一个本地变量来代表子组件，然后利用这个变量来读取子组件的属性和调用子组件的方法，如下例所示。</p></li></ol><p>   子组件 <code>CountdownTimerComponent</code> 进行倒计时，归零时发射一个导弹。<code>start</code> 和 <code>stop</code> 方法负责控制时钟并在模板里显示倒计时的状态信息。</p><pre class=" language-typescript"><code class="language-typescript">   <span class="token keyword">import</span> <span class="token punctuation">{</span> Component<span class="token punctuation">,</span> OnDestroy<span class="token punctuation">,</span> OnInit <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span>   @<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>     selector<span class="token punctuation">:</span> <span class="token string">'app-countdown-timer'</span><span class="token punctuation">,</span>     template<span class="token punctuation">:</span> <span class="token string">'&lt;p>{{message}}&lt;/p>'</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CountdownTimerComponent</span> <span class="token keyword">implements</span> <span class="token class-name">OnInit</span><span class="token punctuation">,</span> OnDestroy <span class="token punctuation">{</span>     intervalId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     message <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>     seconds <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>     <span class="token function">clearTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>intervalId<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token function">ngOnInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token function">ngOnDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">clearTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>     <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">clearTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token template-string"><span class="token string">`Holding at T-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>seconds<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> seconds`</span></span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">private</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">clearTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>intervalId <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>seconds <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>seconds <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token string">'Blast off!'</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>seconds <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>seconds <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// reset</span>           <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> <span class="token template-string"><span class="token string">`T-</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>seconds<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> seconds and counting`</span></span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>       <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre><p>   计时器组件的宿主组件 <code>CountdownLocalVarParentComponent</code> 如下：</p><pre class=" language-typescript"><code class="language-typescript">   <span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span>                <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span>   <span class="token keyword">import</span> <span class="token punctuation">{</span> CountdownTimerComponent <span class="token punctuation">}</span>  <span class="token keyword">from</span> <span class="token string">'./countdown-timer.component'</span><span class="token punctuation">;</span>   @<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>     selector<span class="token punctuation">:</span> <span class="token string">'app-countdown-parent-lv'</span><span class="token punctuation">,</span>     template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`     &lt;h3>Countdown to Liftoff (via local variable)&lt;/h3>     &lt;button (click)="timer.start()">Start&lt;/button>     &lt;button (click)="timer.stop()">Stop&lt;/button>     &lt;div class="seconds">{{timer.seconds}}&lt;/div>     &lt;app-countdown-timer #timer>&lt;/app-countdown-timer>     `</span></span><span class="token punctuation">,</span>     styleUrls<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'../assets/demo.css'</span><span class="token punctuation">]</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CountdownLocalVarParentComponent</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p>   父组件不能通过数据绑定使用子组件的 <code>start</code> 和 <code>stop</code> 方法，也不能访问子组件的 <code>seconds</code> 属性。</p><p>   把本地变量(<code>#timer</code>)放到(``)标签中，用来代表子组件。这样父组件的模板就得到了子组件的引用，于是可以在父组件的模板中访问子组件的所有属性和方法。</p><p>   这个例子把父组件的按钮绑定到子组件的 <code>start</code> 和 <code>stop</code> 方法，并用插值表达式来显示子组件的 <code>seconds</code> 属性。</p><p>   下面是父组件和子组件一起工作时的效果。</p><p>   <img src="/2020/01/15/angular-xue-xi-bi-ji/countdown-timer-anim.gif" alt="countdown-timer-anim"></p><ol start="6"><li><p>父组件调用@ViewChild()</p><p>这个<em>本地变量</em>方法是个简单便利的方法。但是它也有局限性，因为父组件-子组件的连接必须全部在父组件的模板中进行。父组件本身的代码对子组件没有访问权。</p><p>如果父组件的<em>类</em>需要读取子组件的属性值或调用子组件的方法，就不能使用<em>本地变量</em>方法。</p><p>当父组件<em>类</em>需要这种访问时，可以把子组件作为 <em>ViewChild</em>，<strong><em>注入\</em></strong>到父组件里面。</p><p>下面是父组件 <code>CountdownViewChildParentComponent</code>:</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> AfterViewInit<span class="token punctuation">,</span> ViewChild <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span>                <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> CountdownTimerComponent <span class="token punctuation">}</span>  <span class="token keyword">from</span> <span class="token string">'./countdown-timer.component'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-countdown-parent-vc'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`  &lt;h3>Countdown to Liftoff (via ViewChild)&lt;/h3>  &lt;button (click)="start()">Start&lt;/button>  &lt;button (click)="stop()">Stop&lt;/button>  &lt;div class="seconds">{{ seconds() }}&lt;/div>  &lt;app-countdown-timer>&lt;/app-countdown-timer>  `</span></span><span class="token punctuation">,</span>  styleUrls<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'../assets/demo.css'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CountdownViewChildParentComponent</span> <span class="token keyword">implements</span> <span class="token class-name">AfterViewInit</span> <span class="token punctuation">{</span>  @<span class="token function">ViewChild</span><span class="token punctuation">(</span>CountdownTimerComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token keyword">static</span><span class="token punctuation">:</span> <span class="token keyword">false</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token keyword">private</span> timerComponent<span class="token punctuation">:</span> CountdownTimerComponent<span class="token punctuation">;</span>  <span class="token function">seconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token function">ngAfterViewInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ...</span>    <span class="token comment" spellcheck="true">// but wait a tick first to avoid one-time devMode</span>    <span class="token comment" spellcheck="true">// unidirectional-data-flow-violation error</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>seconds <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>timerComponent<span class="token punctuation">.</span>seconds<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>timerComponent<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>timerComponent<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>把子组件的视图插入到父组件类需要做一点额外的工作。</p><p>首先，你必须导入对装饰器 <code>ViewChild</code> 以及生命周期钩子 <code>AfterViewInit</code> 的引用。</p><p>接着，通过 <code>@ViewChild</code> 属性装饰器，将子组件 <code>CountdownTimerComponent</code> 注入到私有属性 <code>timerComponent</code> 里面。</p><p>组件元数据里就不再需要 <code>#timer</code> 本地变量了。而是把按钮绑定到父组件自己的 <code>start</code> 和 <code>stop</code> 方法，使用父组件的 <code>seconds</code> 方法的插值表达式来展示秒数变化。</p><p>这些方法可以直接访问被注入的计时器组件。</p><p><code>ngAfterViewInit()</code> 生命周期钩子是非常重要的一步。被注入的计时器组件只有在 Angular 显示了父组件视图之后才能访问，所以它先把秒数显示为 0.</p><p>然后 Angular 会调用 <code>ngAfterViewInit</code> 生命周期钩子，但这时候再更新父组件视图的倒计时就已经太晚了。Angular 的单向数据流规则会阻止在同一个周期内更新父组件视图。应用在显示秒数之前会被迫<em>再等一轮</em>。</p><p>使用 <code>setTimeout()</code> 来等下一轮，然后改写 <code>seconds()</code> 方法，这样它接下来就会从注入的这个计时器组件里获取秒数的值。</p></li><li><p>父组件和子组件通过服务来通讯</p><p>父组件和它的子组件共享同一个服务，利用该服务在组件家族内部实现双向通讯。</p><p>该服务实例的作用域被限制在父组件和其子组件内。这个组件子树之外的组件将无法访问该服务或者与它们通讯。</p><p>这个 MissionService 把 MissionControlComponent 和多个 AstronautComponent 子组件连接起来。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> Subject <span class="token punctuation">}</span>    <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>@<span class="token function">Injectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">MissionService</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Observable string sources</span>  <span class="token keyword">private</span> missionAnnouncedSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> missionConfirmedSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token operator">&lt;</span><span class="token keyword">string</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Observable string streams</span>  missionAnnounced$ <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>missionAnnouncedSource<span class="token punctuation">.</span><span class="token function">asObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  missionConfirmed$ <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>missionConfirmedSource<span class="token punctuation">.</span><span class="token function">asObservable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Service message commands</span>  <span class="token function">announceMission</span><span class="token punctuation">(</span>mission<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>missionAnnouncedSource<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>mission<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">confirmMission</span><span class="token punctuation">(</span>astronaut<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>missionConfirmedSource<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>astronaut<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>MissionControlComponent</code> 提供服务的实例，并将其共享给它的子组件(通过 <code>providers</code> 元数据数组)，子组件可以通过构造函数将该实例注入到自身。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span>          <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> MissionService <span class="token punctuation">}</span>     <span class="token keyword">from</span> <span class="token string">'./mission.service'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-mission-control'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`    &lt;h2>Mission Control&lt;/h2>    &lt;button (click)="announce()">Announce mission&lt;/button>    &lt;app-astronaut *ngFor="let astronaut of astronauts"      [astronaut]="astronaut">    &lt;/app-astronaut>    &lt;h3>History&lt;/h3>    &lt;ul>      &lt;li *ngFor="let event of history">{{event}}&lt;/li>    &lt;/ul>  `</span></span><span class="token punctuation">,</span>  providers<span class="token punctuation">:</span> <span class="token punctuation">[</span>MissionService<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">MissionControlComponent</span> <span class="token punctuation">{</span>  astronauts <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Lovell'</span><span class="token punctuation">,</span> <span class="token string">'Swigert'</span><span class="token punctuation">,</span> <span class="token string">'Haise'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  history<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  missions <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Fly to the moon!'</span><span class="token punctuation">,</span>              <span class="token string">'Fly to mars!'</span><span class="token punctuation">,</span>              <span class="token string">'Fly to Vegas!'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  nextMission <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> missionService<span class="token punctuation">:</span> MissionService<span class="token punctuation">)</span> <span class="token punctuation">{</span>    missionService<span class="token punctuation">.</span>missionConfirmed$<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>      astronaut <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>astronaut<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> confirmed the mission`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">announce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> mission <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>missions<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>nextMission<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>missionService<span class="token punctuation">.</span><span class="token function">announceMission</span><span class="token punctuation">(</span>mission<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>history<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Mission "</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>mission<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">" announced`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>nextMission <span class="token operator">>=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>missions<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nextMission <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>AstronautComponent</code> 也通过自己的构造函数注入该服务。由于每个 <code>AstronautComponent</code> 都是 <code>MissionControlComponent</code> 的子组件，所以它们获取到的也是父组件的这个服务实例。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component<span class="token punctuation">,</span> Input<span class="token punctuation">,</span> OnDestroy <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> MissionService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./mission.service'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> Subscription <span class="token punctuation">}</span>   <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-astronaut'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`    &lt;p>      {{astronaut}}: &lt;strong>{{mission}}&lt;/strong>      &lt;button        (click)="confirm()"        [disabled]="!announced || confirmed">        Confirm      &lt;/button>    &lt;/p>  `</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AstronautComponent</span> <span class="token keyword">implements</span> <span class="token class-name">OnDestroy</span> <span class="token punctuation">{</span>  @<span class="token function">Input</span><span class="token punctuation">(</span><span class="token punctuation">)</span> astronaut<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">;</span>  mission <span class="token operator">=</span> <span class="token string">'&lt;no mission announced>'</span><span class="token punctuation">;</span>  confirmed <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>  announced <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>  subscription<span class="token punctuation">:</span> Subscription<span class="token punctuation">;</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> missionService<span class="token punctuation">:</span> MissionService<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subscription <span class="token operator">=</span> missionService<span class="token punctuation">.</span>missionAnnounced$<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>      mission <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mission <span class="token operator">=</span> mission<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>announced <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>confirmed <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">confirm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>confirmed <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>missionService<span class="token punctuation">.</span><span class="token function">confirmMission</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>astronaut<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">ngOnDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// prevent memory leak when component destroyed</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subscription<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><em>History</em> 日志证明了：在父组件 <code>MissionControlComponent</code> 和子组件 <code>AstronautComponent</code> 之间，信息通过该服务实现了双向传递。</p><p><img src="/2020/01/15/angular-xue-xi-bi-ji/bidirectional-service.gif" alt="bidirectional-service"></p></li></ol><h2 id="3-6-管道"><a href="#3-6-管道" class="headerlink" title="3.6-管道"></a>3.6-管道</h2><p>每个应用开始的时候差不多都是一些简单任务：获取数据、转换它们，然后把它们显示给用户。 获取数据可能简单到创建一个局部变量就行，也可能复杂到从 WebSocket 中获取数据流。</p><p>一旦取到数据，你就可以把它们原始值的 <code>toString</code> 结果直接推入视图中。 但这种做法很少能具备良好的用户体验。 比如，几乎每个人都更喜欢简单的日期格式，例如1988-04-15，而不是服务端传过来的原始字符串格式 —— Fri Apr 15 1988 00:00:00 GMT-0700 (Pacific Daylight Time)。</p><p>显然，有些值最好显示成用户友好的格式。你很快就会发现，在很多不同的应用中，都在重复做出某些相同的变换。 你几乎会把它们看做某种 CSS 样式，事实上，你也确实更喜欢在 HTML 模板中应用它们 —— 就像 CSS 样式一样。</p><p>通过引入 Angular 管道（一种编写”从显示到值”转换逻辑的途径），你可以把它声明在 HTML 中。</p><ol><li><p>使用管道</p><p>管道把数据作为输入，然后转换它，给出期望的输出。 你要把组件的 <code>birthday</code> 属性转换成对人类更友好的日期格式。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-hero-birthday'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`&lt;p>The hero's birthday is {{ birthday | date }}&lt;/p>`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">HeroBirthdayComponent</span> <span class="token punctuation">{</span>  birthday <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">1988</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// April 15, 1988</span><span class="token punctuation">}</span></code></pre><p>重点看下组件的模板。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>The hero's birthday is {{ birthday | date }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><p>在这个插值表达式中，你让组件的 <code>birthday</code> 值通过<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#pipe" target="_blank" rel="noopener">管道操作符</a>( | )流动到 右侧的<a href="http://angular-doc.paas.cmbchina.cn/api/common/DatePipe" target="_blank" rel="noopener">Date 管道</a>函数中。所有管道都会用这种方式工作。</p></li><li><p>内置的管道</p><p>Angular 内置了一些管道，比如 DatePipe、UpperCasePipe、LowerCasePipe、CurrencyPipe 和 PercentPipe。 它们全都可以直接用在任何模板中。</p></li><li><p>对管道进行参数化</p><p>管道可能接受任何数量的可选参数来对它的输出进行微调。 可以在管道名后面添加一个冒号( : )再跟一个参数值，来为管道添加参数(比如 <code>currency:&#39;EUR&#39;</code>)。 如果这个管道可以接受多个参数，那么就用冒号来分隔这些参数值(比如 <code>slice:1:5</code>)。</p><p>修改生日模板，来为这个日期管道提供一个格式化参数。 当格式化完该英雄的 4 月 15 日生日之后，它应该被渲染成<strong>04/15/88</strong>。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>The hero's birthday is {{ birthday | date:"MM/dd/yy" }} <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><p>参数值可以是任何有效的模板表达式（参见<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax" target="_blank" rel="noopener">模板语法</a>中的<a href="http://angular-doc.paas.cmbchina.cn/guide/template-syntax#template-expressions" target="_blank" rel="noopener">模板表达式</a>部分），比如字符串字面量或组件的属性。 换句话说，借助属性绑定，你也可以像用绑定来控制生日的值一样，控制生日的显示格式。</p><p>来写第二个组件，它把管道的格式参数<em>绑定</em>到该组件的 <code>format</code> 属性。这里是新组件的模板：</p><pre class=" language-typescript"><code class="language-typescript">template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`  &lt;p>The hero's birthday is {{ birthday | date:format }}&lt;/p>  &lt;button (click)="toggleFormat()">Toggle Format&lt;/button>`</span></span></code></pre></li><li><p>自定义管道</p><p>你还可以写自己的自定义管道。 下面就是一个名叫 <code>ExponentialStrengthPipe</code> 的管道，它可以放大英雄的能力：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Pipe<span class="token punctuation">,</span> PipeTransform <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* * Raise the value exponentially * Takes an exponent argument that defaults to 1. * Usage: *   value | exponentialStrength:exponent * Example: *   {{ 2 | exponentialStrength:10 }} *   formats to: 1024*/</span>@<span class="token function">Pipe</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'exponentialStrength'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ExponentialStrengthPipe</span> <span class="token keyword">implements</span> <span class="token class-name">PipeTransform</span> <span class="token punctuation">{</span>  <span class="token function">transform</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span> exponent<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">number</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token function">isNaN</span><span class="token punctuation">(</span>exponent<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> exponent<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在这个管道的定义中体现了几个关键点：</p><ul><li>管道是一个带有“管道元数据(pipe metadata)”装饰器的类。</li><li>这个管道类实现了 <code>PipeTransform</code> 接口的 <code>transform</code> 方法，该方法接受一个输入值和一些可选参数，并返回转换后的值。</li><li>当每个输入值被传给 <code>transform</code> 方法时，还会带上另一个参数，比如你这个管道就有一个 <code>exponent</code>(放大指数) 参数。</li><li>可以通过 <code>@Pipe</code> 装饰器来告诉 Angular：这是一个管道。该装饰器是从 Angular 的 <code>core</code> 库中引入的。</li><li>这个 <code>@Pipe</code> 装饰器允许你定义管道的名字，这个名字会被用在模板表达式中。它必须是一个有效的 JavaScript 标识符。 比如，你这个管道的名字是 <code>exponentialStrength</code>。</li></ul></li></ol><h1 id="4-表单"><a href="#4-表单" class="headerlink" title="4-表单"></a>4-表单</h1><h2 id="4-1-表单简介"><a href="#4-1-表单简介" class="headerlink" title="4.1-表单简介"></a>4.1-表单简介</h2><p>用表单处理用户输入是许多常见应用的基础功能。 应用通过表单来让用户登录、修改个人档案、输入敏感信息以及执行各种数据输入任务。</p><p>Angular 提供了两种不同的方法来通过表单处理用户输入：响应式表单和模板驱动表单。 两者都从视图中捕获用户输入事件、验证用户输入、创建表单模型、修改数据模型，并提供跟踪这些更改的途径。</p><p>不过，响应式表单和模板驱动表单在如何处理和管理表单和表单数据方面有所不同。各有优势。</p><p><strong>一般来说：</strong></p><ul><li><strong>响应式表单</strong>更健壮：它们的可扩展性、可复用性和可测试性更强。 如果表单是应用中的关键部分，或者你已经准备使用响应式编程模式来构建应用，请使用响应式表单。</li><li><strong>模板驱动表单</strong>在往应用中添加简单的表单时非常有用，比如邮件列表的登记表单。它们很容易添加到应用中，但是不像响应式表单那么容易扩展。如果你有非常基本的表单需求和简单到能用模板管理的逻辑，请使用模板驱动表单。</li></ul><table><thead><tr><th></th><th>响应式</th><th>模板驱动</th></tr></thead><tbody><tr><td>建立（表单模式）</td><td>显式，在组件类中创建。</td><td>隐式，由组件创建。</td></tr><tr><td>数据模式</td><td>结构化</td><td>非结构化</td></tr><tr><td>可预测性</td><td>同步</td><td>异步</td></tr><tr><td>表单验证</td><td>函数</td><td>指令</td></tr><tr><td>可变性</td><td>不可变</td><td>可变</td></tr><tr><td>可伸缩性</td><td>访问底层API</td><td>在API之上的抽象</td></tr></tbody></table><h2 id="4-2-响应式表单"><a href="#4-2-响应式表单" class="headerlink" title="4.2-响应式表单"></a>4.2-响应式表单</h2><p><em>响应式表单</em>提供了一种模型驱动的方式来处理表单输入，其中的值会随时间而变化。本文会向你展示如何创建和更新单个表单控件，然后在一个分组中使用多个控件，验证表单的值，以及如何实现更高级的表单。</p><p>响应式表单使用显式的、不可变的方式，管理表单在特定的时间点上的状态。对表单状态的每一次变更都会返回一个新的状态，这样可以在变化时维护模型的整体性。响应式表单是围绕 Observable 的流构建的，表单的输入和值都是通过这些输入值组成的流来提供的，它可以同步访问。</p><p>响应式表单还提供了一种更直观的测试路径，因为在请求时你可以确信这些数据是一致的、可预料的。这个流的任何一个消费者都可以安全地操纵这些数据。</p><p>响应式表单与模板驱动的表单有着显著的不同点。响应式表单通过对数据模型的同步访问提供了更多的可预测性，使用 Observable 的操作符提供了不可变性，并且通过 Observable 流提供了变化追踪功能。 如果你更喜欢在模板中直接访问数据，那么模板驱动的表单会显得更明确，因为它们依赖嵌入到模板中的指令，并借助可变数据来异步跟踪变化。参见<a href="http://angular-doc.paas.cmbchina.cn/guide/forms-overview" target="_blank" rel="noopener">表单概览</a>来了解这两种范式之间的详细比较。</p><ul><li><p>注册 ReactiveFormsModule</p><p>要使用响应式表单，就要从 <code>@angular/forms</code> 包中导入 <code>ReactiveFormsModule</code> 并把它添加到你的 NgModule 的 <code>imports</code> 数组中。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> ReactiveFormsModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/forms'</span><span class="token punctuation">;</span>@<span class="token function">NgModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  imports<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token comment" spellcheck="true">// other imports ...</span>    ReactiveFormsModule  <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre></li><li><p>生成并导入一个新的表单控件</p><p><code>ng generate component NameEditor</code></p><p>当使用响应式表单时，<code>FormControl</code> 类是最基本的构造块。要注册单个的表单控件，请在组件中导入 <code>FormControl</code> 类，并创建一个 <code>FormControl</code> 的新实例，把它保存在类的某个属性中。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> FormControl <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/forms'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-name-editor'</span><span class="token punctuation">,</span>  templateUrl<span class="token punctuation">:</span> <span class="token string">'./name-editor.component.html'</span><span class="token punctuation">,</span>  styleUrls<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'./name-editor.component.css'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">NameEditorComponent</span> <span class="token punctuation">{</span>  name <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FormControl</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以用 <code>FormControl</code> 的构造函数设置初始值，这个例子中它是空字符串。通过在你的组件类中创建这些控件，你可以直接对表单控件的状态进行监听、修改和校验。</p></li><li><p>在模板中注册该控件</p><p>在组件类中创建了控件之后，你还要把它和模板中的一个表单控件关联起来。修改模板，为表单控件添加 formControl 绑定，formControl 是由 ReactiveFormsModule 中的 FormControlDirective 提供的。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>  Name:  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">[formControl]</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span></code></pre></li></ul><h2 id="4-3-模板驱动表单"><a href="#4-3-模板驱动表单" class="headerlink" title="4.3-模板驱动表单"></a>4.3-模板驱动表单</h2><p>开发表单需要设计能力（那超出了本章的范围），而框架支持<em>双向数据绑定、变更检测、验证和错误处理</em>，而本章你将会学到它们。</p><p>这个页面演示了如何从草稿构建一个简单的表单。这个过程中你将学会如何：</p><ul><li>用组件和模板构建 Angular 表单</li><li>用 <code>ngModel</code> 创建双向数据绑定，以读取和写入输入控件的值</li><li>跟踪状态的变化，并验证表单控件</li><li>使用特殊的 CSS 类来跟踪控件的状态并给出视觉反馈</li><li>向用户显示验证错误提示，以及启用/禁用表单控件</li><li>使用模板引用变量在 HTML 元素之间共享信息</li></ul><ol><li><p>创建 Hero 模型类</p><p><code>ng generate class Hero</code></p><p>代码如下：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Hero</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span>    <span class="token keyword">public</span> id<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">,</span>    <span class="token keyword">public</span> name<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span>    <span class="token keyword">public</span> power<span class="token punctuation">:</span> <span class="token keyword">string</span><span class="token punctuation">,</span>    <span class="token keyword">public</span> alterEgo<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token keyword">string</span>  <span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>创建表达组件</p><p><code>ng generate component HeroForm</code></p><p>代码如下：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Component <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> Hero <span class="token punctuation">}</span>    <span class="token keyword">from</span> <span class="token string">'../hero'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-hero-form'</span><span class="token punctuation">,</span>  templateUrl<span class="token punctuation">:</span> <span class="token string">'./hero-form.component.html'</span><span class="token punctuation">,</span>  styleUrls<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'./hero-form.component.css'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">HeroFormComponent</span> <span class="token punctuation">{</span>  powers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Really Smart'</span><span class="token punctuation">,</span> <span class="token string">'Super Flexible'</span><span class="token punctuation">,</span>            <span class="token string">'Super Hot'</span><span class="token punctuation">,</span> <span class="token string">'Weather Changer'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  model <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">'Dr IQ'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>powers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'Chuck Overstreet'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  submitted <span class="token operator">=</span> <span class="token keyword">false</span><span class="token punctuation">;</span>  <span class="token function">onSubmit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>submitted <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// TODO: Remove this when we're done</span>  <span class="token keyword">get</span> <span class="token function">diagnostic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>修改 app.module.ts</p><p>因为模板驱动的表单位于它们自己的模块，所以在使用表单之前，需要将 <code>FormsModule</code> 添加到应用模块的 <code>imports</code> 数组中。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> NgModule <span class="token punctuation">}</span>      <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> BrowserModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/platform-browser'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> FormsModule <span class="token punctuation">}</span>   <span class="token keyword">from</span> <span class="token string">'@angular/forms'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> AppComponent <span class="token punctuation">}</span>  <span class="token keyword">from</span> <span class="token string">'./app.component'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> HeroFormComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./hero-form/hero-form.component'</span><span class="token punctuation">;</span>@<span class="token function">NgModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  imports<span class="token punctuation">:</span> <span class="token punctuation">[</span>    BrowserModule<span class="token punctuation">,</span>    FormsModule  <span class="token punctuation">]</span><span class="token punctuation">,</span>  declarations<span class="token punctuation">:</span> <span class="token punctuation">[</span>    AppComponent<span class="token punctuation">,</span>    HeroFormComponent  <span class="token punctuation">]</span><span class="token punctuation">,</span>  providers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  bootstrap<span class="token punctuation">:</span> <span class="token punctuation">[</span> AppComponent <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre></li><li><p>修改 app.component.ts</p><pre class=" language-typescript"><code class="language-typescript"><span class="token operator">&lt;</span>app<span class="token operator">-</span>hero<span class="token operator">-</span>form<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>app<span class="token operator">-</span>hero<span class="token operator">-</span>form<span class="token operator">></span></code></pre></li><li><p>创建初始 HTML 表单模板</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Hero Form<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-group<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Name<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-control<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-group<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>alterEgo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Alter Ego<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-control<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>alterEgo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn btn-success<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Submit<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre></li></ol><h1 id="5-Observable和RxJS"><a href="#5-Observable和RxJS" class="headerlink" title="5-Observable和RxJS"></a>5-Observable和RxJS</h1><h2 id="5-1-可观察对象（Observable）"><a href="#5-1-可观察对象（Observable）" class="headerlink" title="5.1-可观察对象（Observable）"></a>5.1-可观察对象（Observable）</h2><p>可观察对象支持在应用中的发布者和订阅者之间传递消息。 在需要进行事件处理、异步编程和处理多个值的时候，可观察对象相对其它技术有着显著的优点。</p><p>可观察对象是声明式的 —— 也就是说，虽然你定义了一个用于发布值的函数，但是在有消费者订阅它之前，这个函数并不会实际执行。 订阅之后，当这个函数执行完或取消订阅时，订阅者就会收到通知。</p><p>可观察对象可以发送多个任意类型的值 —— 字面量、消息、事件。无论这些值是同步发送的还是异步发送的，接收这些值的 API 都是一样的。 由于准备（setup）和清场（teardown）的逻辑都是由可观察对象自己处理的，因此你的应用代码只管订阅并消费这些值就可以了，做完之后，取消订阅。无论这个流是击键流、HTTP 响应流还是定时器，对这些值进行监听和停止监听的接口都是一样的。</p><ul><li><p>基本用法</p><p>作为发布者，你创建一个 <code>Observable</code> 的实例，其中定义了一个<em>订阅者（subscriber）</em>函数。 当有消费者调用 <code>subscribe()</code> 方法时，这个函数就会执行。 订阅者函数用于定义“如何获取或生成那些要发布的值或消息”。</p><p>要执行所创建的可观察对象，并开始从中接收通知，你就要调用它的 <code>subscribe()</code> 方法，并传入一个<em>观察者（observer）</em>。 这是一个 JavaScript 对象，它定义了你收到的这些消息的处理器（handler）。 <code>subscribe()</code> 调用会返回一个 <code>Subscription</code> 对象，该对象具有一个 <code>unsubscribe()</code> 方法。 当调用该方法时，你就会停止接收通知。</p><p>下面这个例子中示范了这种基本用法，它展示了如何使用可观察对象来对当前地理位置进行更新。</p><p>Observe geolocation updates</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// Create an Observable that will start listening to geolocation updates</span><span class="token comment" spellcheck="true">// when a consumer subscribes.</span><span class="token keyword">const</span> locations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// Get the next and error callbacks. These will be passed in when</span>  <span class="token comment" spellcheck="true">// the consumer subscribes.</span>  <span class="token keyword">const</span> <span class="token punctuation">{</span>next<span class="token punctuation">,</span> error<span class="token punctuation">}</span> <span class="token operator">=</span> observer<span class="token punctuation">;</span>  <span class="token keyword">let</span> watchId<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Simple geolocation API check provides values to publish</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'geolocation'</span> <span class="token keyword">in</span> navigator<span class="token punctuation">)</span> <span class="token punctuation">{</span>    watchId <span class="token operator">=</span> navigator<span class="token punctuation">.</span>geolocation<span class="token punctuation">.</span><span class="token function">watchPosition</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> error<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Geolocation not available'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// When the consumer unsubscribes, clean up data ready for next subscription.</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> navigator<span class="token punctuation">.</span>geolocation<span class="token punctuation">.</span><span class="token function">clearWatch</span><span class="token punctuation">(</span>watchId<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Call subscribe() to start listening for updates.</span><span class="token keyword">const</span> locationsSubscription <span class="token operator">=</span> locations<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">next</span><span class="token punctuation">(</span>position<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Current Position: '</span><span class="token punctuation">,</span> position<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">error</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Error Getting Location: '</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Stop listening for location after 10 seconds</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> locationsSubscription<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>定义观察者</p><p>用于接收可观察对象通知的处理器要实现 <code>Observer</code> 接口。这个对象定义了一些回调函数来处理可观察对象可能会发来的三种通知：</p><table><thead><tr><th>通知类型</th><th>说明</th></tr></thead><tbody><tr><td>next</td><td>必要。用来处理每个送达值。在开始执行后可能执行零次或多次。</td></tr><tr><td>error</td><td>可选。用来处理错误通知。错误会中断这个可观察对象实例的执行过程。</td></tr><tr><td>complete</td><td>可选。用来处理执行完毕（complete）通知。当执行完毕后，这些值就会继续传给下一个处理器。</td></tr></tbody></table><p>观察者对象可以定义这三种处理器的任意组合。如果你不为某种通知类型提供处理器，这个观察者就会忽略相应类型的通知。</p></li><li><p>订阅</p><p>只有当有人订阅 <code>Observable</code> 的实例时，它才会开始发布值。 订阅时要先调用该实例的 <code>subscribe()</code> 方法，并把一个观察者对象传给它，用来接收通知。</p><p>下面的例子会创建并订阅一个简单的可观察对象，它的观察者会把接收到的消息记录到控制台中：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// Create simple observable that emits three values</span><span class="token keyword">const</span> myObservable <span class="token operator">=</span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Create observer object</span><span class="token keyword">const</span> myObserver <span class="token operator">=</span> <span class="token punctuation">{</span>  next<span class="token punctuation">:</span> x <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Observer got a next value: '</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">,</span>  error<span class="token punctuation">:</span> err <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Observer got an error: '</span> <span class="token operator">+</span> err<span class="token punctuation">)</span><span class="token punctuation">,</span>  complete<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Observer got a complete notification'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Execute with the observer object</span>myObservable<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>myObserver<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Logs:</span><span class="token comment" spellcheck="true">// Observer got a next value: 1</span><span class="token comment" spellcheck="true">// Observer got a next value: 2</span><span class="token comment" spellcheck="true">// Observer got a next value: 3</span><span class="token comment" spellcheck="true">// Observer got a complete notification</span></code></pre><p>另外，<code>subscribe()</code> 方法还可以接收定义在同一行中的回调函数，无论 <code>next</code>、<code>error</code> 还是 <code>complete</code> 处理器。比如，下面的 <code>subscribe()</code> 调用和前面指定预定义观察者的例子是等价的。</p><pre class=" language-typescript"><code class="language-typescript">myObservable<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>  x <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Observer got a next value: '</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">,</span>  err <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Observer got an error: '</span> <span class="token operator">+</span> err<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Observer got a complete notification'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>无论哪种情况，<code>next</code> 处理器都是必要的，而 <code>error</code> 和 <code>complete</code> 处理器是可选的。</p><p>注意，<code>next()</code> 函数可以接受消息字符串、事件对象、数字值或各种结构，具体类型取决于上下文。 为了更通用一点，我们把由可观察对象发布出来的数据统称为<em>流</em>。任何类型的值都可以表示为可观察对象，而这些值会被发布为一个流。</p></li><li><p>创建可观察对象</p><p>使用 <code>Observable</code> 构造函数可以创建任何类型的可观察流。 当执行可观察对象的 <code>subscribe()</code> 方法时，这个构造函数就会把它接收到的参数作为订阅函数来运行。 订阅函数会接收一个 <code>Observer</code> 对象，并把值发布给观察者的 <code>next()</code> 方法。</p><p>比如，要创建一个与前面的 <code>of(1, 2, 3)</code> 等价的可观察对象，你可以这样做：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// This function runs when subscribe() is called</span><span class="token keyword">function</span> <span class="token function">sequenceSubscriber</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// synchronously deliver 1, 2, and 3, then complete</span>  observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  observer<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// unsubscribe function doesn't need to do anything in this</span>  <span class="token comment" spellcheck="true">// because values are delivered synchronously</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Create a new Observable that will deliver the above sequence</span><span class="token keyword">const</span> sequence <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span>sequenceSubscriber<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// execute the Observable and print the result of each notification</span>sequence<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">next</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Finished sequence'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Logs:</span><span class="token comment" spellcheck="true">// 1</span><span class="token comment" spellcheck="true">// 2</span><span class="token comment" spellcheck="true">// 3</span><span class="token comment" spellcheck="true">// Finished sequence</span></code></pre><p>如果要略微加强这个例子，我们可以创建一个用来发布事件的可观察对象。在这个例子中，订阅函数是用内联方式定义的。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">fromEvent</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> eventName<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Add the event handler to the target</span>    target<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>eventName<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Detach the event handler from the target</span>      target<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span>eventName<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>现在，你就可以使用这个函数来创建可发布 <code>keydown</code> 事件的可观察对象了：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> ESC_KEY <span class="token operator">=</span> <span class="token number">27</span><span class="token punctuation">;</span><span class="token keyword">const</span> nameInput <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">)</span> as HTMLInputElement<span class="token punctuation">;</span><span class="token keyword">const</span> subscription <span class="token operator">=</span> <span class="token function">fromEvent</span><span class="token punctuation">(</span>nameInput<span class="token punctuation">,</span> <span class="token string">'keydown'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">:</span> KeyboardEvent<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>keyCode <span class="token operator">===</span> ESC_KEY<span class="token punctuation">)</span> <span class="token punctuation">{</span>      nameInput<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>多播</p><p>典型的可观察对象会为每一个观察者创建一次新的、独立的执行。 当观察者进行订阅时，该可观察对象会连上一个事件处理器，并且向那个观察者发送一些值。当第二个观察者订阅时，这个可观察对象就会连上一个新的事件处理器，并独立执行一次，把这些值发送给第二个可观察对象。</p><p>有时候，不应该对每一个订阅者都独立执行一次，你可能会希望每次订阅都得到同一批值 —— 即使是那些你已经发送过的。这在某些情况下有用，比如用来发送 <code>document</code> 上的点击事件的可观察对象。</p><p><em>多播</em>用来让可观察对象在一次执行中同时广播给多个订阅者。借助支持多播的可观察对象，你不必注册多个监听器，而是复用第一个（<code>next</code>）监听器，并且把值发送给各个订阅者。</p><p>当创建可观察对象时，你要决定你希望别人怎么用这个对象以及是否对它的值进行多播。</p><p>来看一个从 1 到 3 进行计数的例子，它每发出一个数字就会等待 1 秒。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">sequenceSubscriber</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> timeoutId<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Will run through an array of numbers, emitting one value</span>  <span class="token comment" spellcheck="true">// per second until it gets to the end of the array.</span>  <span class="token keyword">function</span> <span class="token function">doSequence</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>    timeoutId <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">===</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        observer<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">doSequence</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">doSequence</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Unsubscribe should clear the timeout to stop execution</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeoutId<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Create a new Observable that will deliver the above sequence</span><span class="token keyword">const</span> sequence <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span>sequenceSubscriber<span class="token punctuation">)</span><span class="token punctuation">;</span>sequence<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">next</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Finished sequence'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Logs:</span><span class="token comment" spellcheck="true">// (at 1 second): 1</span><span class="token comment" spellcheck="true">// (at 2 seconds): 2</span><span class="token comment" spellcheck="true">// (at 3 seconds): 3</span><span class="token comment" spellcheck="true">// (at 3 seconds): Finished sequence</span></code></pre><p>注意，如果你订阅了两次，就会有两个独立的流，每个流都会每秒发出一个数字。代码如下：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">// Subscribe starts the clock, and will emit after 1 second</span>sequence<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">next</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1st subscribe: '</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1st sequence finished.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// After 1/2 second, subscribe again.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  sequence<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token function">next</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2nd subscribe: '</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2nd sequence finished.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Logs:</span><span class="token comment" spellcheck="true">// (at 1 second): 1st subscribe: 1</span><span class="token comment" spellcheck="true">// (at 1.5 seconds): 2nd subscribe: 1</span><span class="token comment" spellcheck="true">// (at 2 seconds): 1st subscribe: 2</span><span class="token comment" spellcheck="true">// (at 2.5 seconds): 2nd subscribe: 2</span><span class="token comment" spellcheck="true">// (at 3 seconds): 1st subscribe: 3</span><span class="token comment" spellcheck="true">// (at 3 seconds): 1st sequence finished</span><span class="token comment" spellcheck="true">// (at 3.5 seconds): 2nd subscribe: 3</span><span class="token comment" spellcheck="true">// (at 3.5 seconds): 2nd sequence finished</span></code></pre><p>修改这个可观察对象以支持多播，代码如下：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">function</span> <span class="token function">multicastSequenceSubscriber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> seq <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Keep track of each observer (one for every active subscription)</span>  <span class="token keyword">const</span> observers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Still a single timeoutId because there will only ever be one</span>  <span class="token comment" spellcheck="true">// set of values being generated, multicasted to each subscriber</span>  <span class="token keyword">let</span> timeoutId<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Return the subscriber function (runs when subscribe()</span>  <span class="token comment" spellcheck="true">// function is invoked)</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span>observer<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    observers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// When this is the first subscription, start the sequence</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>observers<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      timeoutId <span class="token operator">=</span> <span class="token function">doSequence</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token function">next</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// Iterate through observers and notify all subscriptions</span>          observers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>obs <span class="token operator">=</span><span class="token operator">></span> obs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// Notify all complete callbacks</span>          observers<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>obs <span class="token operator">=</span><span class="token operator">></span> obs<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span> seq<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">{</span>      <span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Remove from the observers array so it's no longer notified</span>        observers<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>observers<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// If there's no more listeners, do cleanup</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>observers<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeoutId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Run through an array of numbers, emitting one value</span><span class="token comment" spellcheck="true">// per second until it gets to the end of the array.</span><span class="token keyword">function</span> <span class="token function">doSequence</span><span class="token punctuation">(</span>observer<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">===</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      observer<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token function">doSequence</span><span class="token punctuation">(</span>observer<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> <span class="token operator">++</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Create a new Observable that will deliver the above sequence</span><span class="token keyword">const</span> multicastSequence <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span><span class="token function">multicastSequenceSubscriber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Subscribe starts the clock, and begins to emit after 1 second</span>multicastSequence<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">next</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1st subscribe: '</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1st sequence finished.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// After 1 1/2 seconds, subscribe again (should "miss" the first value).</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  multicastSequence<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token function">next</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2nd subscribe: '</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2nd sequence finished.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Logs:</span><span class="token comment" spellcheck="true">// (at 1 second): 1st subscribe: 1</span><span class="token comment" spellcheck="true">// (at 2 seconds): 1st subscribe: 2</span><span class="token comment" spellcheck="true">// (at 2 seconds): 2nd subscribe: 2</span><span class="token comment" spellcheck="true">// (at 3 seconds): 1st subscribe: 3</span><span class="token comment" spellcheck="true">// (at 3 seconds): 1st sequence finished</span><span class="token comment" spellcheck="true">// (at 3 seconds): 2nd subscribe: 3</span><span class="token comment" spellcheck="true">// (at 3 seconds): 2nd sequence finished</span></code></pre></li><li><p>错误处理</p><p>由于可观察对象会异步生成值，所以用 <code>try/catch</code> 是无法捕获错误的。你应该在观察者中指定一个 <code>error</code> 回调来处理错误。发生错误时还会导致可观察对象清理现有的订阅，并且停止生成值。可观察对象可以生成值（调用 <code>next</code> 回调），也可以调用 <code>complete</code> 或 <code>error</code> 回调来主动结束。</p><pre class=" language-typescript"><code class="language-typescript">myObservable<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">next</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Next num: '</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Received an errror: '</span> <span class="token operator">+</span> err<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><h2 id="5-2-RxJS库"><a href="#5-2-RxJS库" class="headerlink" title="5.2-RxJS库"></a>5.2-RxJS库</h2><p>响应式编程是一种面向数据流和变更传播的异步编程范式（<a href="https://zh.wikipedia.org/wiki/响应式编程" target="_blank" rel="noopener">Wikipedia</a>）。RxJS（响应式扩展的 JavaScript 版）是一个使用可观察对象进行响应式编程的库，它让组合异步代码和基于回调的代码变得更简单 (<a href="http://reactivex.io/rxjs/" target="_blank" rel="noopener">RxJS Docs</a>)。</p><p>RxJS 提供了一种对 <code>Observable</code> 类型的实现，直到 <code>Observable</code> 成为了 JavaScript 语言的一部分并且浏览器支持它之前，它都是必要的。这个库还提供了一些工具函数，用于创建和使用可观察对象。这些工具函数可用于：</p><ul><li>把现有的异步代码转换成可观察对象</li><li>迭代流中的各个值</li><li>把这些值映射成其它类型</li><li>对流进行过滤</li><li>组合多个流</li></ul><ol><li><p>创建可观察对象的函数</p><p>RxJS 提供了一些用来创建可观察对象的函数。这些函数可以简化根据某些东西创建可观察对象的过程，比如事件、定时器、承诺等等。</p><p>比如：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token keyword">from</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Create an Observable out of a promise</span><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">(</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/api/endpoint'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Subscribe to begin listening for async result</span>data<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">next</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Error: '</span> <span class="token operator">+</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token function">complete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Completed'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> interval <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Create an Observable that will publish a value on an interval</span><span class="token keyword">const</span> secondsCounter <span class="token operator">=</span> <span class="token function">interval</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Subscribe to begin publishing values</span>secondsCounter<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>n <span class="token operator">=</span><span class="token operator">></span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`It's been </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>n<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> seconds since subscribing!`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>操作符</p><p>操作符是基于可观察对象构建的一些对集合进行复杂操作的函数。RxJS 定义了一些操作符，比如 <code>map()</code>、<code>filter()</code>、<code>concat()</code> 和 <code>flatMap()</code>。</p><p>操作符接受一些配置项，然后返回一个以来源可观察对象为参数的函数。当执行这个返回的函数时，这个操作符会观察来源可观察对象中发出的值，转换它们，并返回由转换后的值组成的新的可观察对象。</p><p>下面是一个简单的例子：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> map <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span><span class="token keyword">const</span> nums <span class="token operator">=</span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> squareValues <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>val<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> val <span class="token operator">*</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> squaredNums <span class="token operator">=</span> <span class="token function">squareValues</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>squaredNums<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>你可以使用<em>管道</em>来把这些操作符链接起来。管道让你可以把多个由操作符返回的函数组合成一个。<code>pipe()</code> 函数以你要组合的这些函数作为参数，并且返回一个新的函数，当执行这个新函数时，就会顺序执行那些被组合进去的函数。</p><p>应用于某个可观察对象上的一组操作符就像一个菜谱 —— 也就是说，对你感兴趣的这些值进行处理的一组操作步骤。这个菜谱本身不会做任何事。你需要调用 <code>subscribe()</code> 来通过这个菜谱生成一个结果。</p><p>例子如下：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> filter<span class="token punctuation">,</span> map <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span><span class="token keyword">const</span> nums <span class="token operator">=</span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Create a function that accepts an Observable.</span><span class="token keyword">const</span> squareOddVals <span class="token operator">=</span> <span class="token function">pipe</span><span class="token punctuation">(</span>  <span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">=</span><span class="token operator">></span> n <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Create an Observable that will run the filter and map functions</span><span class="token keyword">const</span> squareOdd <span class="token operator">=</span> <span class="token function">squareOddVals</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Subscribe to run the combined functions</span>squareOdd<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>pipe()</code> 函数也同时是 RxJS 的 <code>Observable</code> 上的一个方法，所以你可以用下列简写形式来达到同样的效果：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> filter<span class="token punctuation">,</span> map <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span><span class="token keyword">const</span> squareOdd <span class="token operator">=</span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>    <span class="token function">filter</span><span class="token punctuation">(</span>n <span class="token operator">=</span><span class="token operator">></span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">=</span><span class="token operator">></span> n <span class="token operator">*</span> n<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Subscribe to get values</span>squareOdd<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>RxJS 提供了很多操作符，不过只有少数是常用的。 下面是一个常用操作符的列表和用法范例，参见 <a href="https://rxjs-dev.firebaseapp.com/api" target="_blank" rel="noopener">RxJS API 文档</a>。</p></li><li><p>错误处理</p><p>除了可以在订阅时提供 <code>error()</code> 处理器外，RxJS 还提供了 <code>catchError</code> 操作符，它允许你在管道中处理已知错误。</p><p>假设你有一个可观察对象，它发起 API 请求，然后对服务器返回的响应进行映射。如果服务器返回了错误或值不存在，就会生成一个错误。如果你捕获这个错误并提供了一个默认值，流就会继续处理这些值，而不会报错。</p><p>下面是使用 <code>catchError</code> 操作符实现这种效果的例子：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> ajax <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/ajax'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> map<span class="token punctuation">,</span> catchError <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Return "response" from the API. If an error happens,</span><span class="token comment" spellcheck="true">// return an empty array.</span><span class="token keyword">const</span> apiData <span class="token operator">=</span> <span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">'/api/data'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>  <span class="token function">map</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res<span class="token punctuation">.</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'Value expected!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">.</span>response<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token function">catchError</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>apiData<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token function">next</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'data: '</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'errors already caught... will not run'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h2 id="5-3-Angular中的可观察对象"><a href="#5-3-Angular中的可观察对象" class="headerlink" title="5.3-Angular中的可观察对象"></a>5.3-Angular中的可观察对象</h2><p>Angular 使用可观察对象作为处理各种常用异步操作的接口。比如：</p><ul><li><code>EventEmitter</code> 类派生自 <code>Observable</code>。</li><li>HTTP 模块使用可观察对象来处理 AJAX 请求和响应。</li><li>路由器和表单模块使用可观察对象来监听对用户输入事件的响应。</li></ul><ol><li><p>事件发送器 EventEmitter</p><p>Angular 提供了一个 <code>EventEmitter</code> 类，它用来从组件的 <code>@Output()</code> 属性中发布一些值。<code>EventEmitter</code> 扩展了 <code>Observable</code>，并添加了一个 <code>emit()</code> 方法，这样它就可以发送任意值了。当你调用 <code>emit()</code> 时，就会把所发送的值传给订阅上来的观察者的 <code>next()</code> 方法。</p><p>这种用法的例子参见 <a href="https://angular.cn/api/core/EventEmitter" target="_blank" rel="noopener">EventEmitter</a> 文档。下面这个范例组件监听了 <code>open</code> 和 <code>close</code> 事件：</p><p>``</p><p>组件的定义如下：</p><pre class=" language-typescript"><code class="language-typescript">@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'zippy'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`  &lt;div class="zippy">    &lt;div (click)="toggle()">Toggle&lt;/div>    &lt;div [hidden]="!visible">      &lt;ng-content>&lt;/ng-content>    &lt;/div>  &lt;/div>`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ZippyComponent</span> <span class="token punctuation">{</span>  visible <span class="token operator">=</span> <span class="token keyword">true</span><span class="token punctuation">;</span>  @<span class="token function">Output</span><span class="token punctuation">(</span><span class="token punctuation">)</span> open <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventEmitter</span><span class="token operator">&lt;</span><span class="token keyword">any</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  @<span class="token function">Output</span><span class="token punctuation">(</span><span class="token punctuation">)</span> close <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventEmitter</span><span class="token operator">&lt;</span><span class="token keyword">any</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">toggle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>visible <span class="token operator">=</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>visible<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>visible<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>open<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>close<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>HTTP</p><p>Angular 的 <code>HttpClient</code> 从 HTTP 方法调用中返回了可观察对象。例如，<code>http.get(‘/api’)</code> 就会返回可观察对象。相对于基于承诺（Promise）的 HTTP API，它有一系列优点：</p><ul><li>可观察对象不会修改服务器的响应（和在承诺上串联起来的 <code>.then()</code> 调用一样）。反之，你可以使用一系列操作符来按需转换这些值。</li><li>HTTP 请求是可以通过 <code>unsubscribe()</code> 方法来取消的。</li><li>请求可以进行配置，以获取进度事件的变化。</li><li>失败的请求很容易重试。</li></ul></li><li><p>Async管道</p><p><a href="https://angular.cn/api/common/AsyncPipe" target="_blank" rel="noopener">AsyncPipe</a> 会订阅一个可观察对象或承诺，并返回其发出的最后一个值。当发出新值时，该管道就会把这个组件标记为需要进行变更检查的（译注：因此可能导致刷新界面）。</p><p>下面的例子把 <code>time</code> 这个可观察对象绑定到了组件的视图中。这个可观察对象会不断使用当前时间更新组件的视图。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'async-observable-pipe'</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`&lt;div>&lt;code>observable|async&lt;/code>:       Time: {{ time | async }}&lt;/div>`</span></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AsyncObservablePipeComponent</span> <span class="token punctuation">{</span>  time <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observable</span><span class="token punctuation">(</span>observer <span class="token operator">=</span><span class="token operator">></span>    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> observer<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>路由器 (router)</p><p><a href="https://angular.cn/api/router/Router#events" target="_blank" rel="noopener"><code>Router.events</code></a> 以可观察对象的形式提供了其事件。 你可以使用 RxJS 中的 <code>filter()</code> 操作符来找到感兴趣的事件，并且订阅它们，以便根据浏览过程中产生的事件序列作出决定。 </p><p>例子如下：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Router<span class="token punctuation">,</span> NavigationStart <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/router'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> filter <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-routable'</span><span class="token punctuation">,</span>  templateUrl<span class="token punctuation">:</span> <span class="token string">'./routable.component.html'</span><span class="token punctuation">,</span>  styleUrls<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'./routable.component.css'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Routable1Component</span> <span class="token keyword">implements</span> <span class="token class-name">OnInit</span> <span class="token punctuation">{</span>  navStart<span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span>NavigationStart<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> router<span class="token punctuation">:</span> Router<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Create a new Observable that publishes only the NavigationStart event</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>navStart <span class="token operator">=</span> router<span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>      <span class="token function">filter</span><span class="token punctuation">(</span>evt <span class="token operator">=</span><span class="token operator">></span> evt <span class="token keyword">instanceof</span> <span class="token class-name">NavigationStart</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span> as Observable<span class="token operator">&lt;</span>NavigationStart<span class="token operator">></span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">ngOnInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>navStart<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>evt <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Navigation Started!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><a href="https://angular.cn/api/router/ActivatedRoute" target="_blank" rel="noopener">ActivatedRoute</a> 是一个可注入的路由器服务，它使用可观察对象来获取关于路由路径和路由参数的信息。比如，<code>ActivateRoute.url</code> 包含一个用于汇报路由路径的可观察对象。</p><p>例子如下：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> ActivatedRoute <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/router'</span><span class="token punctuation">;</span>@<span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  selector<span class="token punctuation">:</span> <span class="token string">'app-routable'</span><span class="token punctuation">,</span>  templateUrl<span class="token punctuation">:</span> <span class="token string">'./routable.component.html'</span><span class="token punctuation">,</span>  styleUrls<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'./routable.component.css'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Routable2Component</span> <span class="token keyword">implements</span> <span class="token class-name">OnInit</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> activatedRoute<span class="token punctuation">:</span> ActivatedRoute<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token function">ngOnInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>activatedRoute<span class="token punctuation">.</span>url      <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>url <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'The URL changed to: '</span> <span class="token operator">+</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h1 id="6-NgModule"><a href="#6-NgModule" class="headerlink" title="6-NgModule"></a>6-NgModule</h1><p><strong>NgModules</strong> 用于配置注入器和编译器，并帮你把那些相关的东西组织在一起。</p><p>NgModule 是一个带有 <code>@NgModule</code> 装饰器的类。 <code>@NgModule</code> 的参数是一个元数据对象，用于描述如何编译组件的模板，以及如何在运行时创建注入器。 它会标出该模块自己的组件、指令和管道，通过 <code>exports</code> 属性公开其中的一部分，以便外部组件使用它们。 <code>NgModule</code> 还能把一些服务提供商添加到应用的依赖注入器中。</p><h2 id="6-1-启动过程"><a href="#6-1-启动过程" class="headerlink" title="6.1-启动过程"></a>6.1-启动过程</h2><p>NgModule 用于描述应用的各个部分如何组织在一起。 每个应用有至少一个 Angular 模块，<em>根</em>模块就是你用来启动此应用的模块。 按照惯例，它通常命名为 <code>AppModule</code>。</p><p>如果你使用 <a href="http://angular-doc.paas.cmbchina.cn/cli" target="_blank" rel="noopener">Angular CLI</a> 来生成一个应用，其默认的 <code>AppModule</code> 是这样的：</p><pre class=" language-typescript"><code class="language-typescript"><span class="token comment" spellcheck="true">/* JavaScript imports */</span><span class="token keyword">import</span> <span class="token punctuation">{</span> BrowserModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/platform-browser'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> NgModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> FormsModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/forms'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> HttpClientModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/common/http'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> AppComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./app.component'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* the AppModule class with the @NgModule decorator */</span>@<span class="token function">NgModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  declarations<span class="token punctuation">:</span> <span class="token punctuation">[</span>    AppComponent  <span class="token punctuation">]</span><span class="token punctuation">,</span>  imports<span class="token punctuation">:</span> <span class="token punctuation">[</span>    BrowserModule<span class="token punctuation">,</span>    FormsModule<span class="token punctuation">,</span>    HttpClientModule  <span class="token punctuation">]</span><span class="token punctuation">,</span>  providers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  bootstrap<span class="token punctuation">:</span> <span class="token punctuation">[</span>AppComponent<span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p>在 <code>import</code> 语句之后，是一个带有 <strong><code>@NgModule</code></strong> <a href="http://angular-doc.paas.cmbchina.cn/guide/glossary#decorator" target="_blank" rel="noopener">装饰器</a>的类。</p><p><code>@NgModule</code> 装饰器表明 <code>AppModule</code> 是一个 <code>NgModule</code> 类。 <code>@NgModule</code> 获取一个元数据对象，它会告诉 Angular 如何编译和启动本应用。</p><ul><li><strong>declarations</strong> —— 该应用所拥有的组件。</li><li><strong>imports</strong> —— 导入 <code>BrowserModule</code> 以获取浏览器特有的服务，比如 DOM 渲染、无害化处理和位置（location）。</li><li><strong>providers</strong> —— 各种服务提供商。</li><li><strong>bootstrap</strong> —— <em>根</em>组件，Angular 创建它并插入 <code>index.html</code> 宿主页面。</li></ul><p>Angular CLI 创建的默认应用只有一个组件 <code>AppComponent</code>，所以它会同时出现在 <code>declarations</code> 和 <code>bootstrap</code> 数组中。</p><ol><li><p>declarations 数组</p><p>该模块的 <code>declarations</code> 数组告诉 Angular 哪些组件属于该模块。 当你创建更多组件时，也要把它们添加到 <code>declarations</code> 中。</p><p>每个组件都应该（且只能）声明（declare）在一个 <code>NgModule</code> 类中。 如果你使用了未声明过的组件，Angular 就会报错。</p><p><code>declarations</code> 数组只能接受可声明对象。可声明对象包括组件、<a href="http://angular-doc.paas.cmbchina.cn/guide/attribute-directives" target="_blank" rel="noopener">指令</a>和<a href="http://angular-doc.paas.cmbchina.cn/guide/pipes" target="_blank" rel="noopener">管道</a>。 一个模块的所有可声明对象都必须放在 <code>declarations</code> 数组中。 可声明对象必须只能属于一个模块，如果同一个类被声明在了多个模块中，编译器就会报错。</p><p>这些可声明的类在当前模块中是可见的，但是对其它模块中的组件是不可见的 —— 除非把它们从当前模块导出， 并让对方模块导入本模块</p><p>下面是哪些类可以添加到 <code>declarations</code> 数组中的例子：</p><pre class=" language-typescript"><code class="language-typescript">declarations<span class="token punctuation">:</span> <span class="token punctuation">[</span>  YourComponent<span class="token punctuation">,</span>  YourPipe<span class="token punctuation">,</span>  YourDirective<span class="token punctuation">]</span><span class="token punctuation">,</span></code></pre><p>每个可声明对象都只能属于一个模块，所以只能把它声明在一个 <code>@NgModule</code> 中。当你需要在其它模块中使用它时，就要在那里导入包含这个可声明对象的模块。</p><p><strong>只有 <code>@NgModule</code></strong> 可以出现在 <code>imports</code> 数组中。</p></li><li><p>imports 数组模块的 <code>imports</code> 数组只会出现在 <code>@NgModule</code> 元数据对象中。 它告诉 Angular 该模块想要正常工作，还需要哪些模块。</p><p>列表中的模块导出了本模块中的各个组件模板中所引用的各个组件、指令或管道。在这个例子中，当前组件是 <code>AppComponent</code>，它引用了导出自 <code>BrowserModule</code>、<code>FormsModule</code> 或 <code>HttpClientModule</code> 的组件、指令或管道。 总之，组件的模板中可以引用在当前模块中声明的或从其它模块中导入的组件、指令、管道。</p></li><li><p>providers 数组</p><p><code>providers</code> 数组中列出了该应用所需的服务。当直接把服务列在这里时，它们是全应用范围的。 当你使用特性模块和惰性加载时，它们是范围化的。</p></li><li><p>bootstrap 数组</p><p>应用是通过引导根模块 <code>AppModule</code> 来启动的，根模块还引用了 <code>entryComponent</code>。 此外，引导过程还会创建 <code>bootstrap</code> 数组中列出的组件，并把它们逐个插入到浏览器的 DOM 中。</p><p>每个被引导的组件都是它自己的组件树的根。 插入一个被引导的组件通常触发一系列组件的创建并形成组件树。</p><p>虽然也可以在宿主页面中放多个组件，但是大多数应用只有一个组件树，并且只从一个根组件开始引导。</p><p>这个根组件通常叫做 <code>AppComponent</code>，并且位于根模块的 <code>bootstrap</code> 数组中。</p></li></ol><h2 id="6-2-常用模块"><a href="#6-2-常用模块" class="headerlink" title="6.2-常用模块"></a>6.2-常用模块</h2><ol><li><p>Angular模块化</p><p>模块是组织应用和使用外部库扩展应用的最佳途径。</p><p>Angular 自己的库都是 NgModule，比如 <code>FormsModule</code>、<code>HttpClientModule</code> 和 <code>RouterModule</code>。 很多第三方库也是 NgModule，比如 <a href="https://material.angular.cn/" target="_blank" rel="noopener">Material Design</a>、 <a href="http://ionicframework.com/" target="_blank" rel="noopener">Ionic</a> 和 <a href="https://github.com/angular/angularfire2" target="_blank" rel="noopener">AngularFire2</a>。</p><p>NgModule 把组件、指令和管道打包成内聚的功能块，每个模块聚焦于一个特性区域、业务领域、工作流或通用工具。</p><p>模块还可以把服务加到应用中。 这些服务可能是内部开发的（比如你自己写的），或者来自外部的（比如 Angular 的路由和 HTTP 客户端）。</p><p>模块可以在应用启动时急性加载，也可以由路由器进行异步的惰性加载。</p><p>NgModule 的元数据会做这些：</p><ul><li>声明某些组件、指令和管道属于这个模块。</li><li>公开其中的部分组件、指令和管道，以便其它模块中的组件模板中可以使用它们。</li><li>导入其它带有组件、指令和管道的模块，这些模块中的元件都是本模块所需的。</li><li>提供一些供应用中的其它组件使用的服务。</li></ul><p>每个 Angular 应用都至少有一个模块，也就是根模块。 你可以<a href="http://angular-doc.paas.cmbchina.cn/guide/bootstrapping" target="_blank" rel="noopener">引导</a>那个模块，以启动该应用。</p><p>对于那些只有少量组件的简单应用，根模块就是你所需的一切。 随着应用的成长，你要把这个根模块重构成一些<a href="http://angular-doc.paas.cmbchina.cn/guide/feature-modules" target="_blank" rel="noopener">特性模块</a>，它们代表一组密切相关的功能集。 然后你再把这些模块导入到根模块中。</p></li><li><p>常用模块</p><table><thead><tr><th>NgModule</th><th>导入自</th><th>为何使用</th></tr></thead><tbody><tr><td><a href="http://angular-doc.paas.cmbchina.cn/api/platform-browser/BrowserModule" target="_blank" rel="noopener">BrowserModule</a></td><td>@angular/platform-browser</td><td>当你想要在浏览器中运行应用时</td></tr><tr><td><a href="http://angular-doc.paas.cmbchina.cn/api/common/CommonModule" target="_blank" rel="noopener">CommonModule</a></td><td>@angular/common</td><td>当你想要使用 <code>NgIf</code> 和 <code>NgFor</code> 时</td></tr><tr><td><a href="http://angular-doc.paas.cmbchina.cn/api/forms/FormsModule" target="_blank" rel="noopener">FormsModule</a></td><td>@angular/forms</td><td>当要构建模板驱动表单时（它包含 <code>NgModel</code> ）</td></tr><tr><td><a href="http://angular-doc.paas.cmbchina.cn/api/forms/ReactiveFormsModule" target="_blank" rel="noopener">ReactiveFormsModule</a></td><td>@angular/forms</td><td>当要构建响应式表单时</td></tr><tr><td><a href="http://angular-doc.paas.cmbchina.cn/api/router/RouterModule" target="_blank" rel="noopener">RouterModule</a></td><td>@angular/router</td><td>要使用路由功能，并且你要用到 <code>RouterLink</code>,<code>.forRoot()</code> 和 <code>.forChild()</code> 时</td></tr><tr><td><a href="http://angular-doc.paas.cmbchina.cn/api/common/http/HttpClientModule" target="_blank" rel="noopener">HttpClientModule</a></td><td>@angular/common/<a href="http://angular-doc.paas.cmbchina.cn/api/common/http" target="_blank" rel="noopener">http</a></td><td>当你要和服务器对话时</td></tr></tbody></table></li></ol><h1 id="7-依赖注入"><a href="#7-依赖注入" class="headerlink" title="7-依赖注入"></a>7-依赖注入</h1><p>依赖注入（DI）是一种重要的应用设计模式。 Angular 有自己的 DI 框架，在设计应用时常会用到它，以提升它们的开发效率和模块化程度。</p><p>依赖，是当类需要执行其功能时，所需要的服务或对象。 DI 是一种编码模式，其中的类会从外部源中请求获取依赖，而不是自己创建它们。</p><p>在 Angular 中，DI 框架会在实例化该类时向其提供这个类所声明的依赖项。本指南介绍了 DI 在 Angular 中的工作原理，以及如何借助它来让你的应用更灵活、高效、健壮，以及可测试、可维护。</p><h2 id="7-1-创建和注册可注入的服务"><a href="#7-1-创建和注册可注入的服务" class="headerlink" title="7.1-创建和注册可注入的服务"></a>7.1-创建和注册可注入的服务</h2><p>DI 框架让你能从一个可注入的<em>服务</em>类（独立文件）中为组件提供数据。为了演示，我们还会创建一个用来提供英雄列表的、可注入的服务类，并把它注册为该服务的提供商。</p><ul><li><p>创建可注册的服务类</p><p><a href="http://angular-doc.paas.cmbchina.cn/cli" target="_blank" rel="noopener">Angular CLI</a> 可以用下列命令在 <code>src/app/heroes</code> 目录下生成一个新的 <code>HeroService</code> 类。</p><p><code>ng generate service heroes/hero</code></p><p>下列命令会创建 <code>HeroService</code> 的骨架。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span>@<span class="token function">Injectable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  providedIn<span class="token punctuation">:</span> <span class="token string">'root'</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">HeroService</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>@Injectable()</code> 是每个 Angular 服务定义中的基本要素。该类的其余部分导出了一个 <code>getHeroes</code> 方法，它会返回像以前一样的模拟数据。（真实的应用可能会从远程服务器中异步获取这些数据，不过这里我们先忽略它，专心实现服务的注入机制。）</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> HEROES <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./mock-heroes'</span><span class="token punctuation">;</span>@<span class="token function">Injectable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// we declare that this service should be created</span>  <span class="token comment" spellcheck="true">// by the root application injector.</span>  providedIn<span class="token punctuation">:</span> <span class="token string">'root'</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">HeroService</span> <span class="token punctuation">{</span>  <span class="token function">getHeroes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> HEROES<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>用服务提供商配置注入器</p><p>我们创建的类提供了一个服务。<code>@Injectable()</code> 装饰器把它标记为可供注入的服务，不过在你使用该服务的 <a href="http://angular-doc.paas.cmbchina.cn/guide/glossary#provider" target="_blank" rel="noopener">provider</a> 提供商配置好 Angular 的<a href="http://angular-doc.paas.cmbchina.cn/guide/glossary#injector" target="_blank" rel="noopener">依赖注入器</a>之前，Angular 实际上无法将其注入到任何位置。</p><p>该注入器负责创建服务实例，并把它们注入到像 <code>HeroListComponent</code> 这样的类中。 你很少需要自己创建 Angular 的注入器。Angular 会在执行应用时为你创建注入器，第一个注入器是<em>根注入器</em>，创建于<a href="http://angular-doc.paas.cmbchina.cn/guide/bootstrapping" target="_blank" rel="noopener">启动过程</a>中。</p><p>提供商会告诉注入器<em>如何创建该服务</em>。 要想让注入器能够创建服务（或提供其它类型的依赖），你必须使用某个提供商配置好注入器。</p><p>提供商可以是服务类本身，因此注入器可以使用 <code>new</code> 来创建实例。 你还可以定义多个类，以不同的方式提供同一个服务，并使用不同的提供商来配置不同的注入器。</p><p>你可以在三种位置之一设置元数据，以便在应用的不同层级使用提供商来配置注入器：</p><ul><li>在服务本身的 <code>@Injectable()</code> 装饰器中。</li><li>在 NgModule 的 <code>@NgModule()</code> 装饰器中。</li><li>在组件的 <code>@Component()</code> 装饰器中。</li></ul><p><code>@Injectable()</code> 装饰器具有一个名叫 <code>providedIn</code> 的元数据选项，在那里你可以指定把被装饰类的提供商放到 <code>root</code> 注入器中，或某个特定 NgModule 的注入器中。</p><p><code>@NgModule()</code> 和 <code>@Component()</code> 装饰器都有用一个 <code>providers</code> 元数据选项，在那里你可以配置 NgModule 级或组件级的注入器。</p></li><li><p>注入服务</p><p><code>HeroListComponent</code> 要想从 <code>HeroService</code> 中获取英雄列表，就得要求注入 <code>HeroService</code>，而不是自己使用 <code>new</code> 来创建自己的 <code>HeroService</code> 实例。</p><p>你可以通过制定<strong>带有依赖类型的构造函数参数</strong>来要求 Angular 在组件的构造函数中注入依赖项。下面的代码是 <code>HeroListComponent</code> 的构造函数，它要求注入 <code>HeroService</code>。</p><pre><code>constructor(heroService: HeroService)</code></pre></li></ul><h2 id="7-2-依赖注入实战"><a href="#7-2-依赖注入实战" class="headerlink" title="7.2-依赖注入实战"></a>7.2-依赖注入实战</h2><p>下面的例子往 <code>AppComponent</code> 里声明它依赖 <code>LoggerService</code> 和 <code>UserContext</code>。</p><p>src/app/app.component.ts</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">constructor</span><span class="token punctuation">(</span>logger<span class="token punctuation">:</span> LoggerService<span class="token punctuation">,</span> <span class="token keyword">public</span> userContext<span class="token punctuation">:</span> UserContextService<span class="token punctuation">)</span> <span class="token punctuation">{</span>  userContext<span class="token punctuation">.</span><span class="token function">loadUser</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>  logger<span class="token punctuation">.</span><span class="token function">logInfo</span><span class="token punctuation">(</span><span class="token string">'AppComponent initialized'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>UserContext</code> 转而依赖 <code>LoggerService</code> 和 <code>UserService</code>（这个服务用来收集特定用户信息）。</p><p>user-context.service.ts (injection)</p><pre class=" language-typescript"><code class="language-typescript">@<span class="token function">Injectable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  providedIn<span class="token punctuation">:</span> <span class="token string">'root'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">UserContextService</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> userService<span class="token punctuation">:</span> UserService<span class="token punctuation">,</span> <span class="token keyword">private</span> loggerService<span class="token punctuation">:</span> LoggerService<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当 Angular 新建 <code>AppComponent</code> 时，依赖注入框架会先创建一个 <code>LoggerService</code> 的实例，然后创建 <code>UserContextService</code> 实例。 <code>UserContextService</code> 也需要框架刚刚创建的这个 <code>LoggerService</code> 实例，这样框架才能为它提供同一个实例。<code>UserContextService</code> 还需要框架创建过的 <code>UserService</code>。 <code>UserService</code> 没有其它依赖，所以依赖注入框架可以直接 <code>new</code> 出该类的一个实例，并把它提供给 <code>UserContextService</code> 的构造函数。</p><p>父组件 <code>AppComponent</code> 不需要了解这些依赖的依赖。 只要在构造函数中声明自己需要的依赖即可（这里是 <code>LoggerService</code> 和 <code>UserContextService</code>），框架会帮你解析这些嵌套的依赖。</p><p>当所有的依赖都就位之后，<code>AppComponent</code> 就会显示该用户的信息。</p><h1 id="8-HttpClient"><a href="#8-HttpClient" class="headerlink" title="8-HttpClient"></a>8-HttpClient</h1><p>大多数前端应用都需要通过 HTTP 协议与后端服务器通讯。现代浏览器支持使用两种不同的 API 发起 HTTP 请求：<code>XMLHttpRequest</code> 接口和 <code>fetch()</code> API。</p><p><code>@angular/common/http</code> 中的 <code>HttpClient</code> 类为 Angular 应用程序提供了一个简化的 API 来实现 HTTP 客户端功能。它基于浏览器提供的 <code>XMLHttpRequest</code> 接口。 <code>HttpClient</code> 带来的其它优点包括：可测试性、强类型的请求和响应对象、发起请求与接收响应时的拦截器支持，以及更好的、基于可观察（Observable）对象的 API 以及流式错误处理机制。</p><p>要想使用 <code>HttpClient</code>，就要先导入 Angular 的 <code>HttpClientModule</code>。大多数应用都会在根模块 <code>AppModule</code> 中导入它。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> NgModule <span class="token punctuation">}</span>         <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> BrowserModule <span class="token punctuation">}</span>    <span class="token keyword">from</span> <span class="token string">'@angular/platform-browser'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> HttpClientModule <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/common/http'</span><span class="token punctuation">;</span>@<span class="token function">NgModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  imports<span class="token punctuation">:</span> <span class="token punctuation">[</span>    BrowserModule<span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// import HttpClientModule after BrowserModule.</span>    HttpClientModule<span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  declarations<span class="token punctuation">:</span> <span class="token punctuation">[</span>    AppComponent<span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  bootstrap<span class="token punctuation">:</span> <span class="token punctuation">[</span> AppComponent <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>在 <code>AppModule</code> 中导入 <code>HttpClientModule</code> 之后，你可以把 <code>HttpClient</code> 注入到应用类中，就像下面的 <code>ConfigService</code> 例子中这样。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/core'</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> HttpClient <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@angular/common/http'</span><span class="token punctuation">;</span>@<span class="token function">Injectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ConfigService</span> <span class="token punctuation">{</span>  <span class="token keyword">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> http<span class="token punctuation">:</span> HttpClient<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="8-1-获取json数据"><a href="#8-1-获取json数据" class="headerlink" title="8.1-获取json数据"></a>8.1-获取json数据</h2><p>应用通常会从服务器上获取 JSON 数据。 比如，该应用可能要从服务器上获取配置文件 <code>config.json</code>，其中指定了一些特定资源的 URL。</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"heroesUrl"</span><span class="token operator">:</span> <span class="token string">"api/heroes"</span><span class="token punctuation">,</span>  <span class="token property">"textfile"</span><span class="token operator">:</span> <span class="token string">"assets/textfile.txt"</span><span class="token punctuation">}</span></code></pre><p><code>ConfigService</code> 会通过 <code>HttpClient</code> 的 <code>get()</code> 方法取得这个文件。</p><pre class=" language-typescript"><code class="language-typescript">configUrl <span class="token operator">=</span> <span class="token string">'assets/config.json'</span><span class="token punctuation">;</span><span class="token function">getConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configUrl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>像 <code>ConfigComponent</code> 这样的组件会注入 <code>ConfigService</code>，并调用其 <code>getConfig</code> 方法。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token function">showConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>configService<span class="token punctuation">.</span><span class="token function">getConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> Config<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>config <span class="token operator">=</span> <span class="token punctuation">{</span>        heroesUrl<span class="token punctuation">:</span> data<span class="token punctuation">[</span><span class="token string">'heroesUrl'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        textfile<span class="token punctuation">:</span>  data<span class="token punctuation">[</span><span class="token string">'textfile'</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个服务方法返回配置数据的 <code>Observable</code> 对象，所以组件要<strong>订阅（subscribe）</strong> 该方法的返回值。 订阅时的回调函数会把这些数据字段复制到组件的 <code>config</code> 对象中，它会在组件的模板中绑定，以供显示。</p><h2 id="8-2-发起http请求"><a href="#8-2-发起http请求" class="headerlink" title="8.2-发起http请求"></a>8.2-发起http请求</h2><ul><li><p>post请求</p><pre class=" language-typescript"><code class="language-typescript">addHero <span class="token punctuation">(</span>hero<span class="token punctuation">:</span> Hero<span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span>Hero<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>http<span class="token punctuation">.</span>post<span class="token operator">&lt;</span>Hero<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>heroesUrl<span class="token punctuation">,</span> hero<span class="token punctuation">,</span> httpOptions<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>      <span class="token function">catchError</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleError</span><span class="token punctuation">(</span><span class="token string">'addHero'</span><span class="token punctuation">,</span> hero<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>HttpClient.post()</code> 方法像 <code>get()</code> 一样也有类型参数（你会希望服务器返回一个新的英雄对象），它包含一个资源 URL。</p><p>它还接受另外两个参数：</p><ol><li><code>hero</code> - 要 <code>POST</code> 的请求体数据。</li><li><code>httpOptions</code> - 这个例子中，该方法的选项<a href="http://angular-doc.paas.cmbchina.cn/guide/http#adding-headers" target="_blank" rel="noopener">指定了所需的请求头</a>。</li></ol><p>当然，它捕获错误的方式很像<a href="http://angular-doc.paas.cmbchina.cn/guide/http#error-details" target="_blank" rel="noopener">前面描述的</a>操作方式。</p><p><code>HeroesComponent</code> 通过订阅该服务方法返回的 <code>Observable</code> 发起了一次实际的 <code>POST</code> 操作。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">this</span><span class="token punctuation">.</span>heroesService<span class="token punctuation">.</span><span class="token function">addHero</span><span class="token punctuation">(</span>newHero<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>hero <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">this</span><span class="token punctuation">.</span>heroes<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>hero<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当服务器成功做出响应时，会带有这个新创建的英雄，然后该组件就会把这个英雄添加到正在显示的 <code>heroes</code> 列表中。</p></li><li><p>delete请求</p><p>该应用可以把英雄的 id 传给 <code>HttpClient.delete</code> 方法的请求 URL 来删除一个英雄。</p><pre class=" language-typescript"><code class="language-typescript">deleteHero <span class="token punctuation">(</span>id<span class="token punctuation">:</span> <span class="token keyword">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> Observable<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>heroesUrl<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// DELETE api/heroes/42</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>http<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> httpOptions<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>      <span class="token function">catchError</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleError</span><span class="token punctuation">(</span><span class="token string">'deleteHero'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>当 <code>HeroesComponent</code> 订阅了该服务方法返回的 <code>Observable</code> 时，就会发起一次实际的 <code>DELETE</code> 操作。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">this</span><span class="token punctuation">.</span>heroesService<span class="token punctuation">.</span><span class="token function">deleteHero</span><span class="token punctuation">(</span>hero<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>该组件不会等待删除操作的结果，所以它的 subscribe （订阅）中没有回调函数。不过就算你不关心结果，也仍然要订阅它。调用 <code>subscribe()</code> 方法会<strong>执行</strong>这个可观察对象，这时才会真的发起 DELETE 请求。</p></li></ul><h1 id="9-路由与导航"><a href="#9-路由与导航" class="headerlink" title="9-路由与导航"></a>9-路由与导航</h1><p>在用户使用应用程序时，Angular 的<strong><em>路由器\</em></strong>能让用户从一个<a href="http://angular-doc.paas.cmbchina.cn/guide/glossary#view" target="_blank" rel="noopener">视图</a>导航到另一个视图。</p><p>浏览器具有熟悉的导航模式：</p><ul><li>在地址栏输入 URL，浏览器就会导航到相应的页面。</li><li>在页面中点击链接，浏览器就会导航到一个新页面。</li><li>点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。</li></ul><p>Angular 的 <code>Router</code>（即“路由器”）借鉴了这个模型。它把浏览器中的 URL 看做一个操作指南， 据此导航到一个由客户端生成的视图，并可以把参数传给支撑视图的相应组件，帮它决定具体该展现哪些内容。 你可以为页面中的链接绑定一个路由，这样，当用户点击链接时，就会导航到应用中相应的视图。 当用户点击按钮、从下拉框中选取，或响应来自任何地方的事件时，你也可以在代码控制下进行导航。 路由器还在浏览器的历史日志中记录下这些活动，这样浏览器的前进和后退按钮也能照常工作。</p><h2 id="9-1-配置"><a href="#9-1-配置" class="headerlink" title="9.1-配置"></a>9.1-配置</h2><p>每个带路由的 Angular 应用都有一个<em><code>Router</code>（路由器）</em>服务的单例对象。 当浏览器的 URL 变化时，路由器会查找对应的 <code>Route</code>（路由），并据此决定该显示哪个组件。</p><p>路由器需要先配置才会有路由信息。 下面的例子创建了五个路由定义，并用 <code>RouterModule.forRoot()</code> 方法来配置路由器， 并把它的返回值添加到 <code>AppModule</code> 的 <code>imports</code> 数组中。</p><pre class=" language-typescript"><code class="language-typescript"><span class="token keyword">const</span> appRoutes<span class="token punctuation">:</span> Routes <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'crisis-center'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> CrisisListComponent <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'hero/:id'</span><span class="token punctuation">,</span>      component<span class="token punctuation">:</span> HeroDetailComponent <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span>    path<span class="token punctuation">:</span> <span class="token string">'heroes'</span><span class="token punctuation">,</span>    component<span class="token punctuation">:</span> HeroListComponent<span class="token punctuation">,</span>    data<span class="token punctuation">:</span> <span class="token punctuation">{</span> title<span class="token punctuation">:</span> <span class="token string">'Heroes List'</span> <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>    redirectTo<span class="token punctuation">:</span> <span class="token string">'/heroes'</span><span class="token punctuation">,</span>    pathMatch<span class="token punctuation">:</span> <span class="token string">'full'</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">{</span> path<span class="token punctuation">:</span> <span class="token string">'**'</span><span class="token punctuation">,</span> component<span class="token punctuation">:</span> PageNotFoundComponent <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>@<span class="token function">NgModule</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  imports<span class="token punctuation">:</span> <span class="token punctuation">[</span>    RouterModule<span class="token punctuation">.</span><span class="token function">forRoot</span><span class="token punctuation">(</span>      appRoutes<span class="token punctuation">,</span>      <span class="token punctuation">{</span> enableTracing<span class="token punctuation">:</span> <span class="token keyword">true</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// &lt;-- debugging purposes only</span>    <span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// other imports here</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p>这里的路由数组 <code>appRoutes</code> 描述如何进行导航。 把它传给 <code>RouterModule.forRoot()</code> 方法并传给本模块的 <code>imports</code> 数组就可以配置路由器。</p><p>每个 <code>Route</code> 都会把一个 URL 的 <code>path</code> 映射到一个组件。 注意，<code>path</code> 不能以<em>斜杠（<code>/</code>）</em>开头。 路由器会为解析和构建最终的 URL，这样当你在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。</p><p>第二个路由中的 <code>:id</code> 是一个路由参数的令牌(Token)。比如 <code>/hero/42</code> 这个 URL 中，“42”就是 <code>id</code> 参数的值。 此 URL 对应的 <code>HeroDetailComponent</code> 组件将据此查找和展现 <code>id</code> 为 42 的英雄。 在本章中稍后的部分，你将会学习关于路由参数的更多知识。</p><p>第三个路由中的 <code>data</code> 属性用来存放于每个具体路由有关的任意信息。该数据可以被任何一个激活路由访问，并能用来保存诸如 页标题、面包屑以及其它静态只读数据。本章稍后的部分，你将使用<a href="http://angular-doc.paas.cmbchina.cn/guide/router#resolve-guard" target="_blank" rel="noopener">resolve 守卫</a>来获取动态数据。</p><p>第四个路由中的空路径（<code>&#39;&#39;</code>）表示应用的默认路径，当 URL 为空时就会访问那里，因此它通常会作为起点。 这个默认路由会重定向到 URL <code>/heroes</code>，并显示 <code>HeroesListComponent</code>。</p><p>最后一个路由中的 <code>**</code> 路径是一个<strong>通配符</strong>。当所请求的 URL 不匹配前面定义的路由表中的任何路径时，路由器就会选择此路由。 这个特性可用于显示“404 - Not Found”页，或自动重定向到其它路由。</p><p><strong>这些路由的定义顺序</strong>是刻意如此设计的。路由器使用<strong>先匹配者优先</strong>的策略来匹配路由，所以，具体路由应该放在通用路由的前面。在上面的配置中，带静态路径的路由被放在了前面，后面是空路径路由，因此它会作为默认路由。而通配符路由被放在最后面，这是因为它能匹配上<em>每一个 URL</em>，因此应该<strong>只有在</strong>前面找不到其它能匹配的路由时才匹配它。</p><p>如果你想要看到在导航的生命周期中发生过哪些事件，可以使用路由器默认配置中的 <strong>enableTracing</strong> 选项。它会把每个导航生命周期中的事件输出到浏览器的控制台。 这应该只用于<em>调试</em>。你只需要把 <code>enableTracing: true</code> 选项作为第二个参数传给 <code>RouterModule.forRoot()</code> 方法就可以了。</p><h2 id="9-2-路由出口"><a href="#9-2-路由出口" class="headerlink" title="9.2-路由出口"></a>9.2-路由出口</h2><p><code>RouterOutlet</code> 是一个来自路由模块中的指令，它的用法类似于组件。 它扮演一个占位符的角色，用于在模板中标出一个位置，路由器将会把要显示在这个出口处的组件显示在这里。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-outlet</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-outlet</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- Routed components go here --></span></code></pre><p>有了这份配置，当本应用在浏览器中的 URL 变为 <code>/heroes</code> 时，路由器就会匹配到 <code>path</code> 为 <code>heroes</code> 的 <code>Route</code>，并在宿主视图中的<em><code>RouterOutlet</code></em>之后显示 <code>HeroListComponent</code> 组件。</p><h2 id="9-3-路由链接"><a href="#9-3-路由链接" class="headerlink" title="9.3-路由链接"></a>9.3-路由链接</h2><p>现在，你已经有了配置好的一些路由，还找到了渲染它们的地方，但又该如何导航到它呢？固然，从浏览器的地址栏直接输入 URL 也能做到，但是大多数情况下，导航是某些用户操作的结果，比如点击一个 A 标签。</p><p>考虑下列模板：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Angular Router<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">routerLink</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/crisis-center<span class="token punctuation">"</span></span> <span class="token attr-name">routerLinkActive</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>active<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Crisis Center<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">routerLink</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/heroes<span class="token punctuation">"</span></span> <span class="token attr-name">routerLinkActive</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>active<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Heroes<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nav</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>router-outlet</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>router-outlet</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka学习笔记</title>
      <link href="/2019/12/25/kafka-xue-xi-bi-ji/"/>
      <url>/2019/12/25/kafka-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka学习笔记"><a href="#Kafka学习笔记" class="headerlink" title="Kafka学习笔记"></a>Kafka学习笔记</h1><h1 id="1-kafka介绍"><a href="#1-kafka介绍" class="headerlink" title="1-kafka介绍"></a>1-kafka介绍</h1><h2 id="1-1-什么是kafka？"><a href="#1-1-什么是kafka？" class="headerlink" title="1.1-什么是kafka？"></a>1.1-什么是kafka？</h2><p><strong>Apache Kafka</strong>是一个分布式发布-订阅消息系统，它最初由 LinkedIn 公司开发，使用 Scala语言编写,之后成为 Apache 项目的一部分。Kafka 是一个分布式的，可划分的，多订阅者,冗余备份的持久性的日志服务。它主要用于处理活跃的流式数据。</p><p>kafka最基本的架构是生产者发布一个消息到Kafka的一个主题（topic），这个主题即是由扮演KafkaServer角色的broker提供，消费者订阅这个主题，然后从中获取消息.</p><h2 id="1-2-kafka特点"><a href="#1-2-kafka特点" class="headerlink" title="1.2-kafka特点"></a>1.2-kafka特点</h2><ul><li><strong>高吞吐量：</strong>Kafka的设计是工作在标准硬件之上，支持每秒数百万的消息</li><li><strong>负载均衡：</strong>通过zookeeper对Broker,Consumer的动态加入与离开进行管理。</li><li><strong>拉取系统：</strong>producer主动向kafka broker以 push方式发送消息，consumer采用pull方式消费消息</li><li><strong>动态扩展：</strong>当需要增加broker结点时，新增的broker会向zookeeper注册，而    consumer会通过zookeeper感知这些          变化，并及时作出调整。</li><li><strong>消息删除策略：</strong>数据文件将会根据broker中的配置要求,保留一定的时间之后删除。  kafka通过这种简单的手段,来释放磁盘空间。</li><li><strong>高性能：</strong>单节点支持上千客户端；</li><li><strong>分布式：</strong>数据副本冗余，流量负载均衡，可扩展；</li></ul><h2 id="1-3-kafka基本概念"><a href="#1-3-kafka基本概念" class="headerlink" title="1.3-kafka基本概念"></a>1.3-kafka基本概念</h2><ul><li><strong>Broker</strong>：Kafka消息服务器，消息中心。一个Broker可以容纳多个Topic。<ul><li><code>其作用简而言之就是接收producer请求并持久化，接收consumer请求并响应消费消息。</code> </li></ul></li><li><strong>Producer</strong>：消息生产者，就是向Kafka broker发消息的客户端。</li><li><strong>Consumer</strong>：消息消费者，向Kafka broker拉取消息的客户端。</li><li><strong>Consumer Group</strong>：每个consumer归属于一个特定的consumer group，一个partition中的消息只会被group中的一个consumer消费; 每个group中consumer消息消费互相独立;<ul><li><code>Kafka引进group的概念，可实现消息的单播和广播。</code></li></ul></li><li><strong>Topic</strong>：Topic为一个逻辑上的概念，每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic. Producer可以针对某个主题进行生产，Consumer可以针对某个主题进行订阅。</li><li><strong>Partition</strong>：Parition是物理上的概念，每个Topic包含一个或多个Partition。Kafka通过partition对topic的数据文件切片，可以将一个Topic可以分布存储到多个Broker上。</li></ul><h1 id="2-kafka架构"><a href="#2-kafka架构" class="headerlink" title="2-kafka架构"></a>2-kafka架构</h1><h2 id="2-1-kafka部署架构"><a href="#2-1-kafka部署架构" class="headerlink" title="2.1-kafka部署架构"></a>2.1-kafka部署架构</h2><p><img src="/2019/12/25/kafka-xue-xi-bi-ji/kafka%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84.png" alt="kafka部署架构"></p><ul><li>完全的分布式：Producer、Broker、Consumer、zookeeper都是分布式</li><li>一个典型的Kafka集群中包含若干Producer，若干broker（Kafka支持水平扩展，一般broker数量越多，集群吞吐率越高），若干Consumer Group，以及一个<a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">Zookeeper</a>集群。Kafka通过Zookeeper管理集群配置，选举leader，以及在Consumer Group发生变化时进行rebalance。Producer使用push模式将消息发布到broker，Consumer使用pull模式从broker订阅并消费消息</li></ul><h2 id="2-2-kafka集群架构"><a href="#2-2-kafka集群架构" class="headerlink" title="2.2-kafka集群架构"></a>2.2-kafka集群架构</h2><p><img src="/2019/12/25/kafka-xue-xi-bi-ji/kafka%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84.png" alt="kafka集群架构"></p><h2 id="2-3-kafka存储结构"><a href="#2-3-kafka存储结构" class="headerlink" title="2.3-kafka存储结构"></a>2.3-kafka存储结构</h2><h3 id="2-3-1-Topic中partition存储分布"><a href="#2-3-1-Topic中partition存储分布" class="headerlink" title="2.3.1-Topic中partition存储分布"></a>2.3.1-Topic中partition存储分布</h3><ul><li><strong>存储根目录</strong>：kafka的Log文件存储在Kafka broker中，其的根目录在server.properties文件中配置(参数 <code>log.dirs=xxx/message-folder</code>)   </li><li><strong>partition目录命名</strong>：在Kafka的Log文件存储中，同一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为topic名称+有序序号，第一个partiton序号从0开始，序号最大值为partitions数量减1</li></ul><p><strong>例子：</strong></p><p>例如创建1个topic名称分别为report_push, partitions=3，假设有三个broker（Broker1、Broker2、Broker3），那么其存储路径和目录规则可能为：<br>    Broker1根目录下有目录： report_push-0<br>    Broker2根目录下有目录： report_push-1<br>    Broker3根目录下有目录： report_push-2   </p><p><code>partition将均衡的分布在各个broker上，这样有助于提高吞吐量。</code></p><h3 id="2-3-2-partiton中文件存储方式"><a href="#2-3-2-partiton中文件存储方式" class="headerlink" title="2.3.2-partiton中文件存储方式"></a>2.3.2-partiton中文件存储方式</h3><p>每个partition在存储层面是append log文件。任何发布到此partition的消息都会被直接追加到log文件的尾部，每条消息在文件中的位置称为offset（偏移量），offset为一个long型数字，它是唯一标记一条消息。partition是以文件的形式存储在文件系统中。Logs文件根据broker中的配置要求,保留一定时间后删除来释放磁盘空间。</p><p><img src="/2019/12/25/kafka-xue-xi-bi-ji/partition.png" alt="partition"></p><ul><li><strong>Partition</strong>：<pre><code>Topic 物理上的分组，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。       partition 中的每条消息都会被分配一个有序的 id（offset）。</code></pre></li><li>每个partion(目录)相当于一个巨型文件被平均分配到多个大小相等segment(段)数据文件中，segment文件大小由属性log.segment.bytes 指定。但每个段segment file消息数量不一定相等，这种特性方便old segment file快速被删除。</li></ul><p><img src="/2019/12/25/kafka-xue-xi-bi-ji/segment.png" alt="segment"></p><h3 id="2-3-3-partiton中segment文件存储结构"><a href="#2-3-3-partiton中segment文件存储结构" class="headerlink" title="2.3.3-partiton中segment文件存储结构"></a>2.3.3-partiton中segment文件存储结构</h3><ul><li><strong>Segment file组成：</strong>由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀”.index”和“.log”分别表示为segment索引文件、数据文件.</li><li><strong>Segment文件命名规则：</strong>partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。</li></ul><p><img src="/2019/12/25/kafka-xue-xi-bi-ji/segment%E6%96%87%E4%BB%B6%E7%BB%84%E6%88%90.png" alt="segment文件组成"></p><h3 id="2-3-4-Segment中message存储结构"><a href="#2-3-4-Segment中message存储结构" class="headerlink" title="2.3.4-Segment中message存储结构"></a>2.3.4-Segment中message存储结构</h3><ul><li><p><strong>Message组成</strong>：每条Message包含了以下三个属性</p><table><thead><tr><th>offset</th><th>对应类型：long</th></tr></thead><tbody><tr><td>MessageSize</td><td>对应类型：int（32）</td></tr><tr><td>data</td><td>是message的具体内容</td></tr></tbody></table></li><li><p><strong>Message消息</strong>：是通信的基本单位，每个 producer 可以向一个 topic（主题）发布一些消息。</p></li><li><p>Kafka中的Message是以topic为基本单位组织的，不同的topic之间是相互独立的。每个topic又可以分成几个不同的partition(每个topic有几个partition是在创建topic时指定的)，每个partition存储一部分Message。</p></li><li><p>一个Segment由多个message组成</p></li><li><p><strong>offset</strong>：每条消息在文件中的位置，它唯一标记一条消息。kafka并没有提供其他额外的索引机制来存储offset，因为在kafka中几 乎不允许对消息进行“随机读写”。</p></li></ul><h3 id="2-3-5-segment索引文件、数据文件的关系"><a href="#2-3-5-segment索引文件、数据文件的关系" class="headerlink" title="2.3.5-segment索引文件、数据文件的关系"></a>2.3.5-segment索引文件、数据文件的关系</h3><ul><li><p><strong>segment索引文件</strong>：由下图中看出，index文件有两列，第一列代表message在log文件中的位置，第二列代表物理偏移量。以索引文件中 元数据3,497为例，依次在数据文件中表示第3个message(在全局partiton表示第368772个message)、以及该消息的物理偏移地址为497。索引文件稀疏索引方式存储，它减少索引文件大小。索引文件被映射到内存中，有助于提高查找速度</p><p><img src="/2019/12/25/kafka-xue-xi-bi-ji/segment%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84.png" alt="segment索引结构"></p></li><li><p><strong>segment数据文件</strong>：由上图了解到segment data file由许多message组成，message物理结构如下图</p><p><img src="/2019/12/25/kafka-xue-xi-bi-ji/segment%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84.png" alt="segment物理结构"></p></li><li><p><strong>Message的查找过程</strong>：</p><p><code>比如：要查找绝对offset为7的Message：</code><br>1、首先是用二分查找确定它是在哪个LogSegment中，自然是在第一个Segment中。</p><p>2、打开这个Segment的index文件，也是用二分查找找到offset小于或者等于指定offset的索引条目中最大的那个offset。自然offset为6的那个索引是我们要找的，通过索引文件我们知道offset为6的Message在数据文件中的物理位置为9807。</p><p>3、打开数据文件，从物理位置为9807的那个地方开始顺序扫描直到找到offset为7的那条Message。</p><p>这套机制是建立在offset是有序的。索引文件被映射到内存中，所以查找的速度还是很快的。</p><p>一句话，Kafka的Message存储采用了分区(partition)，分段(LogSegment)和稀疏索引这几个手段来达到了高效性。</p></li></ul><p><img src="/2019/12/25/kafka-xue-xi-bi-ji/message%E6%9F%A5%E6%89%BE.png" alt="message查找"></p><h3 id="2-3-6-Replication-存储副本"><a href="#2-3-6-Replication-存储副本" class="headerlink" title="2.3.6-Replication 存储副本"></a>2.3.6-Replication 存储副本</h3><p>Kafka从0.8开始提供<code>High Availability机制</code>。</p><p>​    <strong>同一个Partition可能会多个Replication ，这些Replication之间将会选举一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。Kafka内部有自己的算法将Replica均匀分布到整个集群，如果某些broker宕机，仍能保持kafka集群的高可用性</strong>。</p><p><code>Kafka分配Replica的算法如下</code>：<br>1、将所Broker（假设共n个Broker和待分配的Partition排序 )<br>2、将第i个Partition分配到第（i mod n个Broker上）<br>3、将第i个Partition的第j个Replica分配到第（(i + j) mode n个Broker上</p><p><img src="/2019/12/25/kafka-xue-xi-bi-ji/replication.png" alt="replication"></p><p><code>Kafka 的Leader Election</code><br>      Kafka在ZooKeeper中动态维护了一个<code>ISR</code>（in-sync replicas，这个ISR里的所Replica都跟上了leader，只ISR里的成员才被为Leader的可能），kafka引进Leader的概念是为了保持数据的一致性。</p><h1 id="3-kafka生产和消费"><a href="#3-kafka生产和消费" class="headerlink" title="3-kafka生产和消费"></a>3-kafka生产和消费</h1><h2 id="3-1-kafka生产"><a href="#3-1-kafka生产" class="headerlink" title="3.1-kafka生产"></a>3.1-kafka生产</h2><p><strong>Producer：</strong>消息生产者，就是向Kafka broker发消息的客户端。</p><p>Producer使用<code>push模式</code>将消息发布到broker，<strong>一个topic在集群中可以有多个partition，消息发送到哪个分区上， 由producer客户端决定</strong>， producer端实现“消息均衡分发”，一般可通过如下的<code>路由策略</code>实现：</p><ol><li><p><strong>采用Key Hash算法</strong>:根据消息的key来进行分区的分配，即hash(key) %  numPartitions，系统默认方式。</p></li><li><p><strong>自定义分区策略</strong>：可通过配置partitioner.class来实现自定义分区策略。 该class必须实现kafka.producer.Partitioner接口</p></li><li><p><strong>异步发送：</strong>producer端将多条消息暂且在客户端buffer起来，并将他们批量的发送到broker，因为小数据IO太多，会拖慢整体的网络延迟，批量延迟发送事实上提升了网络效率。可配置linger.ms和batch.size达到异步发送的机制， batch.size是指在客户端缓存多大的数据后发送， linger.ms是指如果缓存的数据大小达不到batch.size,但是缓存的时间达到了linger.ms，照样发送数据到broker。</p></li></ol><h2 id="3-2-kafka消费"><a href="#3-2-kafka消费" class="headerlink" title="3.2-kafka消费"></a>3.2-kafka消费</h2><ul><li><p><strong>Consumer和Consumer Group</strong></p><p>​       每一个consumer归属于一个特定的consumer group，同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group可同时消费这一消息</p></li><li><p><strong>Consumer Group的作用</strong></p><ul><li>Topic消息的<code>广播</code>（发给所有的Consumer）<pre><code>     如果需要实现广播，只要每个Consumer有一个独立的Group就可以了</code></pre></li><li>Topic消息的<code>单播</code>（发给某一个Consumer）<pre><code>     如果要实现单播只要所有的Consumer在同一个Group里</code></pre></li></ul></li></ul><p><img src="/2019/12/25/kafka-xue-xi-bi-ji/kafka%E6%B6%88%E8%B4%B9.png" alt="kafka消费"></p><p><code>注:同一个group中的consumer个数最好不要超过topic的partition数，如果超过，那么将有consumer处于闲置状态</code></p><h2 id="3-3-Kafka如何保证消息只能被消费一次呢？"><a href="#3-3-Kafka如何保证消息只能被消费一次呢？" class="headerlink" title="3.3-Kafka如何保证消息只能被消费一次呢？"></a>3.3-Kafka如何保证消息只能被消费一次呢？</h2><p>Consumer Group在消费某Topic时，kafka通过一个特殊的topic 即<strong>consumer_offsets记录该消费组Offset消费偏移量，最新Consumer加入并消费某一主题时，将会从可以从</strong>consumer_offsets获取最新的Offset点开始消费。在topic中存储结构如下：</p><p><img src="/2019/12/25/kafka-xue-xi-bi-ji/kafka%E6%B6%88%E8%B4%B9%E8%BF%87%E7%A8%8B.png" alt="kafka消费过程"></p><p><code>注：kafka只能保证同一个Partition中的消息消费是顺序性的，不能保证整个topic中的消息消费的顺序</code></p><h2 id="3-4-kafka集群管理"><a href="#3-4-kafka集群管理" class="headerlink" title="3.4-kafka集群管理"></a>3.4-kafka集群管理</h2><p>Zookeeper在Kafka中<strong>用于存储集群MataData并管理、协调Kafka代理。</strong></p><p><img src="/2019/12/25/kafka-xue-xi-bi-ji/kafka%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86.png" alt="kafka集群管理"></p><ul><li><p><strong>Zookeeper在Kafka中的用途:</strong></p><p><strong>用于管理、协调Kafka代理。</strong>每个Kafka代理都通过ZooKeeper协调其它Kafka代理。当Kafka系统中新增了代理或者某个代理故障失效时，ZooKeeper服务将通知生产者和消费者。生产者和消费者据此开始与其它代理协调工作</p><ol><li>kafka使用zookeeper来实现动态的集群扩展，不需要更改客户端（producer和consumer）的配置。<br>broker会在zookeeper注册并保持相关的元数据（topic，partition信息等）更新。</li><li>而客户端会在zookeeper上注册相关的watcher。一旦zookeeper发生变化，客户端能及时感知并作出相应调整。这样就保证了添加或去除broker时，各broker间仍能自动实现负载均衡。    这里的客户端指的是Kafka的消息生产端(Producer)和消息消费端(Consumer)</li><li>Broker端使用zookeeper来注册broker信息,以及监测partition leader存活性.</li><li>Consumer端使用zookeeper用来注册consumer信息,其中包括consumer消费的partition列表等,同时也用来发现broker列表,并和partition leader建立socket连接,并获取消息.</li><li>Zookeer和Producer没有建立关系，只和Brokers、Consumers建立关系以实现负载均衡，即同一个Consumer Group中的Consumers可以实现负载均衡.</li></ol></li></ul><h1 id="4-kafka常见问题"><a href="#4-kafka常见问题" class="headerlink" title="4-kafka常见问题"></a>4-kafka常见问题</h1><h2 id="4-1-如何保证消息的可靠性传输？"><a href="#4-1-如何保证消息的可靠性传输？" class="headerlink" title="4.1-如何保证消息的可靠性传输？"></a>4.1-如何保证消息的可靠性传输？</h2><ol><li>生产者不丢数据</li><li>服务器不丢数据</li><li>消费者不丢数据</li></ol><ul><li><p><strong>生产者</strong>：如果是同步模式，确认机制设为<code>acks=all</code>，也就是让消息写入leader和所有的副件;如果是异步模式消息发出去，但还没有收到确认的时候,缓冲池已满.在配置文件中设置<code>block.on.buffer.full =true</code>成不限制阻塞超时的时间， 让生产者一直阻塞， 等待缓冲区可用，不能清空，这样也能保证数据不丢失。</p></li><li><p><strong>消费者</strong>：确认数据被完成处理之后，再更新offset值， 不要自动提交offset,关闭自动提交offset,<code>enable.auto.commit=false</code></p></li><li><p><strong>服务器</strong>: follower数据还没有完成同步. leader宕机，重新选择leader </p><p>设置<code>replication. factor</code>太于1，至少每个partition有2个副本<br>设置<code>min . insync. replicas</code>太于1，要求leader感知到至少一个follower跟自己保持联系，确保leader挂了还有一个follower.</p></li></ul><h2 id="4-2-如何保证高可用？"><a href="#4-2-如何保证高可用？" class="headerlink" title="4.2-如何保证高可用？"></a>4.2-如何保证高可用？</h2><ol><li><p><strong>分布式</strong></p><p>由多个broker组成，每个broker是一个节点，topic可以人划分为多个partition，每个partition可以存在于不同的broker上。</p></li><li><p><strong>Replica机制</strong></p><p>每个partition的数据都会同步到其它机器上,形成多个replica副本，所有replica会选举一个leader.生产和消费都和leader打交道。其它 replica就是follower。写的时候，leader会负责把数据同步列所有follower 上去，读的候就直接读leader上的数据。只读写leader保证教据一致性，kafka会均匀地将 一个partition的所有 replica分布在不同的机器上，这样可以提高容错性。</p></li></ol><h2 id="4-3-如何避免重复消费？"><a href="#4-3-如何避免重复消费？" class="headerlink" title="4.3-如何避免重复消费？"></a>4.3-如何避免重复消费？</h2><p><strong>情况：</strong>ConSumer消费了数据之后，会把消费过后的消息offset提交一下，表示已经消费过，下次重启后,直接从offset继续消费,有某些异常情况时进程被kill,号致consumer消费了消息，但没来得及提交offset ,重启之后，少数消息会被再次消费一次。</p><p><strong>解决方法:——结合具体的业务</strong></p><ol><li><p>如果消费后写数据库，先查数据库中记录是否存在，如果存在则证明已消费，然后比较时间戳是否是最新的，如果是最新的消息，则更新数据库，否则丢弃。0racle中可以使用Merge实现。</p></li><li><p>如果是写Redis ,面接Set操作<br>或者给数据一个uuid,消费过的数据uuid保存到Redis中，如果重复则直接丢弃。</p></li></ol><h2 id="4-4-如何保证消息的顺序性？"><a href="#4-4-如何保证消息的顺序性？" class="headerlink" title="4.4-如何保证消息的顺序性？"></a>4.4-如何保证消息的顺序性？</h2><p><strong>情况：</strong>在数据量很大的情况下，如果消费者使用单线程消费处理，而且处理比较耗时的话，那么吞吐量就会很低。改用多个线程并发跑的话，就可能导致消息的顺序乱掉。</p><p><strong>解决方法：</strong></p><ol><li><p>一个topic，一个partition（内部有序），一个consumer，内部单线程消费，</p><p>吞吐量太低，一般不会使用</p></li><li><p>多线程写N个内存队列（queue），具有相同key的数据都存到同一个内存queue；然后对于N个线程，每个线程分别消费一个内存queue即可。</p></li></ol><p><strong>消息积压</strong>——例如消费后要写数据库，但数据库挂掉或者压力很大，消费者hang住，或者是消费者故障，导致消费速度极其慢，此时消息队列会积压大量的消息。</p><ol><li><p>查看kafka消息队列的积压情况</p><p><code>kafka-consumer-groups  --bootstrap-server master：9092</code></p><p><code>--describe --group group-name</code></p><p>a.将现有的consumer 停掉，防止再向队列中写消息。</p><p>b.定位消息积压的原因。</p><p>c.增加消费线程，提高消费速度。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot学习笔记2</title>
      <link href="/2019/12/25/springboot-bi-ji-er/"/>
      <url>/2019/12/25/springboot-bi-ji-er/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot2-0学习笔记"><a href="#SpringBoot2-0学习笔记" class="headerlink" title="SpringBoot2.0学习笔记"></a>SpringBoot2.0学习笔记</h1><h2 id="1-SpringBoot2-0入门"><a href="#1-SpringBoot2-0入门" class="headerlink" title="1-SpringBoot2.0入门"></a>1-SpringBoot2.0入门</h2><h3 id="1-1-SpringBoot2-x依赖环境和版本新特性"><a href="#1-1-SpringBoot2-x依赖环境和版本新特性" class="headerlink" title="1.1-SpringBoot2.x依赖环境和版本新特性"></a>1.1-SpringBoot2.x依赖环境和版本新特性</h3><p><strong>简介：讲解新版本依赖环境和springboot2新特性概述</strong></p><ul><li><p>1、依赖版本jdk8以上, Springboot2.x用JDK8, 因为底层是 Spring framework5</p></li><li><p>2、安装maven最新版本，maven3.2以上版本，下载地址 ：<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a></p></li><li><p>3、Eclipse或者IDE</p></li><li><p>4、新特性</p></li><li><p>5、翻译工具：<a href="https://translate.google.cn/" target="_blank" rel="noopener">https://translate.google.cn/</a></p></li><li><p>6、springbootGitHub地址：<a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot</a></p></li><li><p>7、springboot官方文档：<a href="https://spring.io/guides/gs/spring-boot/" target="_blank" rel="noopener">https://spring.io/guides/gs/spring-boot/</a></p></li></ul><h3 id="1-2-快速创建SpringBoot2-x应用之手工创建web应用"><a href="#1-2-快速创建SpringBoot2-x应用之手工创建web应用" class="headerlink" title="1.2-快速创建SpringBoot2.x应用之手工创建web应用"></a>1.2-快速创建SpringBoot2.x应用之手工创建web应用</h3><p><strong>简介：使用Maven手工创建SpringBoot2.x应用</strong></p><ul><li><p>手工创建:<a href="https://projects.spring.io/spring-boot/#quick-start" target="_blank" rel="noopener">https://projects.spring.io/spring-boot/#quick-start</a></p></li><li><p>官方推荐包命名接口，不要使用默认 defaultPackage</p></li><li><p>官方文档: <a href="https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-using-the-default-package" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-using-the-default-package</a></p><ul><li>例子：com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java</li></ul></li></ul><h3 id="1-3-快速创建SpringBoot2-x应用之工具类自动创建web应用"><a href="#1-3-快速创建SpringBoot2-x应用之工具类自动创建web应用" class="headerlink" title="1.3-快速创建SpringBoot2.x应用之工具类自动创建web应用"></a>1.3-快速创建SpringBoot2.x应用之工具类自动创建web应用</h3><p><strong>简介：使用构建工具自动生成项目基本架构</strong> 工具自动创建:<a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a></p><h3 id="1-4-SpringBoot2-x的依赖默认Maven版本"><a href="#1-4-SpringBoot2-x的依赖默认Maven版本" class="headerlink" title="1.4-SpringBoot2.x的依赖默认Maven版本"></a>1.4-SpringBoot2.x的依赖默认Maven版本</h3><p><strong>简介：讲解SpringBoot2.x的默认Maven依赖版本</strong></p><ul><li>官网地址<ul><li><a href="https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#appendix-dependency-versions" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#appendix-dependency-versions</a></li></ul></li></ul><h2 id="2-SpringBoot接口Http协议开发实战"><a href="#2-SpringBoot接口Http协议开发实战" class="headerlink" title="2-SpringBoot接口Http协议开发实战"></a>2-SpringBoot接口Http协议开发实战</h2><h3 id="2-1-SpringBoot2-xHTTP请求配置讲解"><a href="#2-1-SpringBoot2-xHTTP请求配置讲解" class="headerlink" title="2.1-SpringBoot2.xHTTP请求配置讲解"></a>2.1-SpringBoot2.xHTTP请求配置讲解</h3><p><strong>简介：SpringBoot2.xHTTP请求注解讲解和简化注解配置技巧</strong></p><ul><li>@RestController and @RequestMapping是springMVC的注解，不是springboot特有的</li><li>@RestController = @Controller+@ResponseBody</li><li>@SpringBootApplication = @Configuration+@EnableAutoConfiguration+@ComponentScanlocalhost:8080</li></ul><h3 id="2-2-开发必备工具PostMan接口工具介绍和使用"><a href="#2-2-开发必备工具PostMan接口工具介绍和使用" class="headerlink" title="2.2-开发必备工具PostMan接口工具介绍和使用"></a>2.2-开发必备工具PostMan接口工具介绍和使用</h3><p>用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的Firebug等网页调试工具。今天给大家介绍的这款网页调试工具不仅可以调试简单的css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的HTTP请求！<strong>Postman</strong>在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。</p><p><strong>简介：模拟Http接口测试工具PostMan安装和讲解</strong></p><ul><li>接口调试工具安装和基本使用</li><li>下载地址：<a href="https://www.getpostman.com/" target="_blank" rel="noopener">https://www.getpostman.com/</a></li></ul><h3 id="2-3-HTTP接口GET请求实战"><a href="#2-3-HTTP接口GET请求实战" class="headerlink" title="2.3-HTTP接口GET请求实战"></a>2.3-HTTP接口GET请求实战</h3><p><strong>简介:讲解springboot接口，http的get请求，各个注解使用</strong></p><ul><li><p>GET请求</p><ul><li><p>1、单一参数@RequestMapping(path = “/{id}”, method = RequestMethod.GET)</p><ul><li><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">getUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String id <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> </code></pre></li></ul></li></ul></li></ul><pre><code>- ```java  @RequestMapping(path = &quot;/{depid}/{userid}&quot;, method = RequestMethod.GET)   //可以同时指定多个提交方法   public String getUser(@PathVariable(&quot;depid&quot;)String departmentID,@PathVariable(&quot;userid&quot;) String userid)  ```</code></pre><ul><li><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path <span class="token operator">=</span> <span class="token string">"/{city_id}/{user_id}"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> RequestMethod<span class="token punctuation">.</span>GET<span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">findUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"city_id"</span><span class="token punctuation">)</span> String cityId<span class="token punctuation">,</span>                           <span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"user_id"</span><span class="token punctuation">)</span> String userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        params<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"cityId"</span><span class="token punctuation">,</span> cityId<span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">,</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> params<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li></ul><ul><li><p>Restful协议的GET请求</p><ul><li><p>@GetMapping注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/v1/page_user1"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">pageUser</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        params<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"from"</span><span class="token punctuation">,</span> from<span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"size"</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> params<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li></ul></li></ul><ul><li><p>参数设置默认值</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/v2/page_user2"</span><span class="token punctuation">)</span> <span class="token keyword">public</span> Object <span class="token function">pageUser2</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>defaultValue <span class="token operator">=</span> <span class="token string">"0"</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"page"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        params<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"from"</span><span class="token punctuation">,</span> from<span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"size"</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> params<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p>获取http的头部</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/v1/get_header"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">getHeader</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestHeader</span><span class="token punctuation">(</span><span class="token string">"access_token"</span><span class="token punctuation">)</span> String accessToken<span class="token punctuation">,</span> String id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        params<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"access_token"</span><span class="token punctuation">,</span> accessToken<span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> params<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p>使用HttpServletRequest</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/v1/test_request"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">testRequest</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        params<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String id <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> params<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li></ul><h3 id="2-4-HTTP其他提交方法请求实战"><a href="#2-4-HTTP其他提交方法请求实战" class="headerlink" title="2.4-HTTP其他提交方法请求实战"></a>2.4-HTTP其他提交方法请求实战</h3><p><strong>简介：讲解http请求post，put, delete提交方式</strong></p><h4 id="2-4-1-Post请求"><a href="#2-4-1-Post请求" class="headerlink" title="2.4.1-Post请求"></a>2.4.1-Post请求</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/v1/login"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">login</span><span class="token punctuation">(</span>String id<span class="token punctuation">,</span> String pwd<span class="token punctuation">)</span> <span class="token punctuation">{</span>        params<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"pwd"</span><span class="token punctuation">,</span> pwd<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> params<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="2-4-2-Put请求"><a href="#2-4-2-Put请求" class="headerlink" title="2.4.2-Put请求"></a>2.4.2-Put请求</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@PutMapping</span><span class="token punctuation">(</span><span class="token string">"/v1/put"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">put</span><span class="token punctuation">(</span>String id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        params<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> params<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="2-4-3-Delete请求"><a href="#2-4-3-Delete请求" class="headerlink" title="2.4.3-Delete请求"></a>2.4.3-Delete请求</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span><span class="token string">"/v1/del"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">del</span><span class="token punctuation">(</span>String id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        params<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> params<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="2-5-Jackson使用"><a href="#2-5-Jackson使用" class="headerlink" title="2.5-Jackson使用"></a>2.5-Jackson使用</h3><p><strong>简介：介绍常用json框架和注解的使用，自定义返回json结构和格式</strong></p><ul><li>常用框架 阿里 fastjson,谷歌gson等</li><li>JavaBean序列化为Json，<ul><li>性能：Jackson &gt; FastJson &gt; Gson &gt; Json-lib 同个结构</li><li>Jackson、FastJson、Gson类库各有优点，各有自己的专长</li><li>空间换时间，时间换空间</li></ul></li><li>jackson处理相关自动<ul><li>指定字段不返回：@JsonIgnore</li><li>指定日期格式：@JsonFormat(pattern=”yyyy-MM-dd hh:mm:ss”,locale=”zh”,timezone=”GMT+8”)</li><li>空字段不返回：@JsonInclude(Include.NON_NUll)</li><li>指定别名：@JsonProperty</li></ul></li></ul><h3 id="2-6-SpringBoot目录文件结构"><a href="#2-6-SpringBoot目录文件结构" class="headerlink" title="2.6-SpringBoot目录文件结构"></a>2.6-SpringBoot目录文件结构</h3><p><strong>简介：讲解SpringBoot目录文件结构和官方推荐的目录规范</strong></p><ul><li><p>目录讲解</p><ul><li>src/main/java：存放代码</li><li>src/main/resources</li><li>static: 存放静态文件，比如 css、js、image, （访问方式 <a href="http://localhost:8080/js/main.js）" target="_blank" rel="noopener">http://localhost:8080/js/main.js）</a></li><li>templates:存放静态页面jsp,html,tpl</li><li>config:存放配置文件,application.properties</li><li>resources:</li></ul></li><li><p>引入依赖 Thymeleaf</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-thymeleaf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>//注意：如果不引人这个依赖包，html文件应该放在默认加载文件夹里面，//比如resources、static、public这个几个文件夹，才可以访问</code></pre></li><li><p>同个文件的加载顺序,静态资源文件 Spring Boot 默认会挨个从</p><ul><li>META/resources &gt;</li><li>resources &gt;</li><li>static &gt;</li><li>public</li></ul><p>里面找是否存在相应的资源，如果有则直接返回。</p></li><li><p>默认配置</p><ul><li>官网地址：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content</a></li><li>spring.resources.static-locations = classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/</li></ul></li><li><p>静态资源文件存储在CDN</p></li></ul><h3 id="2-7-SpringBoot文件上传实战"><a href="#2-7-SpringBoot文件上传实战" class="headerlink" title="2.7-SpringBoot文件上传实战"></a>2.7-SpringBoot文件上传实战</h3><p><strong>简介：讲解HTML页面文件上传和后端处理实战</strong></p><ul><li><p>springboot文件上传 MultipartFile file，源自SpringMVC</p><ul><li>静态页面直接访问：localhost:8080/index.html<ul><li>注意点：如果想要直接访问html页面，则需要把html放在springboot默认加载的文件夹下面</li></ul></li><li>MultipartFile 对象的transferTo方法，用于文件保存（效率和操作比原先用FileOutStream方便和高效）</li></ul><p>访问路径 <a href="http://localhost:8080/images/39020dbb-9253-41b9-8ff9-403309ff3f19.jpeg" target="_blank" rel="noopener">http://localhost:8080/images/39020dbb-9253-41b9-8ff9-403309ff3f19.jpeg</a></p></li><li><p><img src="/2019/12/25/springboot-bi-ji-er/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0.png" alt="文件上传"></p></li></ul><h3 id="2-8-jar包方式运行web项目文件上传和访问"><a href="#2-8-jar包方式运行web项目文件上传和访问" class="headerlink" title="2.8-jar包方式运行web项目文件上传和访问"></a>2.8-jar包方式运行web项目文件上传和访问</h3><p><strong>简介：讲解SpingBoot2.x使用 java -jar运行方式的图片上传和访问处理</strong></p><ul><li><p>文件大小配置，启动类里面配置</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>  <span class="token keyword">public</span> MultipartConfigElement <span class="token function">multipartConfigElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      MultipartConfigFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MultipartConfigFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//单个文件最大  </span>    factory<span class="token punctuation">.</span><span class="token function">setMaxFileSize</span><span class="token punctuation">(</span><span class="token string">"10240KB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//KB,MB  </span>    <span class="token comment" spellcheck="true">// 设置总上传数据总大小  </span>    factory<span class="token punctuation">.</span><span class="token function">setMaxRequestSize</span><span class="token punctuation">(</span><span class="token string">"1024000KB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> factory<span class="token punctuation">.</span><span class="token function">createMultipartConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  </code></pre></li><li><p>打包成jar包，需要增加maven依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span></code></pre></li></ul><p>  如果没加相关依赖，执行maven打包，运行后会报错:no main manifest attribute, in XXX.jar<br>  GUI：反编译工具，作用就是用于把class文件转换成java文件</p><pre><code>- 文件上传和访问需要指定磁盘路径  ```properties  application.properties中增加下面配置  1) web.images-path=/Users/jack/Desktop  2) spring.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,classpath:/test/,file:${web.upload-path} </code></pre><ul><li>文件服务器：fastdfs，阿里云oss，nginx搭建一个简单的文件服务器等</li></ul><h2 id="3-SpringBoot热部署devtool和配置文件自动注入实战"><a href="#3-SpringBoot热部署devtool和配置文件自动注入实战" class="headerlink" title="3-SpringBoot热部署devtool和配置文件自动注入实战"></a>3-SpringBoot热部署devtool和配置文件自动注入实战</h2><h3 id="3-1-使用Dev-tool热部署"><a href="#3-1-使用Dev-tool热部署" class="headerlink" title="3.1-使用Dev-tool热部署"></a>3.1-使用Dev-tool热部署</h3><p><strong>简介:介绍什么是热部署，使用springboot结合dev-tool工具，快速加载启动应用</strong></p><ul><li><p>什么是热部署？</p><ul><li><p>在应用运行的时升级软件，无需重新启动的方式有两种，<code>热部署</code>和<code>热加载</code>。</p><p>对于Java应用程序来说，<code>热部署</code>就是在服务器运行时重新部署项目，<code>热加载</code>即在在运行时重新加载class，从而升级应用。</p></li><li><p><code>热加载</code>的实现原理主要依赖java的类加载机制，在实现方式可以概括为在容器启动的时候起一条后台线程，定时的检测类文件的时间戳变化，如果类的时间戳变掉了，则将类重新载入。</p><p>对比反射机制，反射是在运行时获取类信息，通过动态的调用来改变程序行为； 热加载则是在运行时通过重新加载改变类信息，直接改变程序行为。</p><p><code>热部署</code>原理类似，但它是直接重新加载整个应用，这种方式会释放内存，比热加载更加干净彻底，但同时也更费时间。</p></li></ul></li><li><p>添加依赖</p><ul><li><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li></ul></li><li><p>添加配置</p><ul><li><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#热部署</span><span class="token attr-name">spring.devtools.restart.enabled</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.devtools.restart.additional-paths</span><span class="token punctuation">=</span><span class="token attr-value">src/main/java</span><span class="token comment" spellcheck="true">#关闭缓存，及时刷新</span><span class="token comment" spellcheck="true">#spring.thymeleaf.cache=false</span><span class="token comment" spellcheck="true">#排除无需热部署目录</span><span class="token comment" spellcheck="true">#spring.devtools.restart.exclude=static/**,public/**</span><span class="token comment" spellcheck="true">#srping.devtools.restart.exclude=WEB-INF/**</span></code></pre></li></ul></li><li><p>IDEA配置</p><p><img src="/2019/12/25/springboot-bi-ji-er/IDEA%E9%85%8D%E7%BD%AE.png" alt="IDEA配置"></p></li><li><p>不被热部署的文件 :</p><p>1、/META-INF/maven, /META-INF/resources, /resources, /static, /public, or /templates </p><p>2、指定文件不进行热部署 spring.devtools.restart.exclude=static/** ,public/** </p><p>3、手工触发重启 <code>spring.devtools.restart.trigger-file=trigger.txt</code> 改代码不重启，通过一个文本去控制</p><p><a href="https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-devtools-restart-exclude" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-devtools-restart-exclude</a></p><p><code>注意点</code>：生产环境不要开启这个功能，如果用java -jar启动，springBoot是不会进行热部署的</p></li></ul><h3 id="3-2-SpringBoot配置文件"><a href="#3-2-SpringBoot配置文件" class="headerlink" title="3.2-SpringBoot配置文件"></a>3.2-SpringBoot配置文件</h3><p><strong>简介：SpringBoot2.x常见的配置文件 xml、yml、properties的区别和使用</strong></p><ul><li>xml、properties、json、yaml</li><li>常见的配置文件 xx.yml, xx.properties，<ul><li>1)YAML（Yet Another Markup Language） 写 YAML 要比写 XML 快得多(无需关注标签或引号) 使用空格 Space 缩进表示分层，不同层次之间的缩进可以使用不同的空格数目 注意：key后面的冒号，后面一定要跟一个空格,树状结构 application.properties示例 server.port=8090<br>server.session-timeout=30<br>server.tomcat.max-threads=0<br>server.tomcat.uri-encoding=UTF-8</li></ul></li><li>application.yml示例 server:<br>port: 8090<br>session-timeout: 30<br>tomcat.max-threads: 0<br>tomcat.uri-encoding: UTF-8</li><li>默认示例文件仅作为指导。 不要将整个内容复制并粘贴到您的应用程序中，只挑选您需要的属性。</li><li>参考：<a href="https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#common-application-properties</a></li><li>如果需要修改，直接复制对应的配置文件，加到application.properties里面</li></ul><h3 id="3-3-SpringBoot注解配置文件自动映射到属性和实体类"><a href="#3-3-SpringBoot注解配置文件自动映射到属性和实体类" class="headerlink" title="3.3-SpringBoot注解配置文件自动映射到属性和实体类"></a>3.3-SpringBoot注解配置文件自动映射到属性和实体类</h3><p><strong>简介：讲解使用@value注解配置文件自动映射到属性和实体类</strong></p><ul><li><p>1、配置文件加载</p><ul><li><p>方式一</p><ul><li><p>1、Controller上面配置 </p><p><code>@PropertySource({&quot;classpath:resource.properties&quot;})</code></p></li><li><p>2、增加属性</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${test.name}"</span><span class="token punctuation">)</span> <span class="token keyword">private</span> String name<span class="token punctuation">;</span></code></pre></li></ul></li></ul></li></ul><ul><li><p>方式二：实体类配置文件</p><ul><li><p>1、添加 @Component 注解；</p></li><li><p>2、使用 @PropertySource 注解指定配置文件位置；</p></li><li><p>3、使用 @ConfigurationProperties 注解，设置相关属性；</p></li><li><p>4、必须 通过注入IOC对象Resource 进来 ， 才能在类中使用获取的配置文件值。</p><p> <code>@Autowired private ServerSettings serverSettings</code>;</p></li></ul></li></ul><ul><li><p>例子</p><p>1.配置类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Setter</span><span class="token annotation punctuation">@Getter</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"classpath:application.properties"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerSettings</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//应用名称</span>  <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${test.name}"</span><span class="token punctuation">)</span>     <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//域名地址</span>  <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${test.domain}"</span><span class="token punctuation">)</span>     <span class="token keyword">private</span> String domain<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2.配置文件application.properties</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#配置文件注入</span><span class="token attr-name">test.name</span><span class="token punctuation">=</span><span class="token attr-value">springboot</span><span class="token attr-name">test.domain</span><span class="token punctuation">=</span><span class="token attr-value">www.fangpeng.com</span></code></pre><p>3.注入测试</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Autowired</span>   <span class="token keyword">private</span> ServerSettings serverSettings<span class="token punctuation">;</span>  <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/v1/test_properties"</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> Object <span class="token function">testProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> serverSettings<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>常见问题：<span class="token number">1</span>、配置文件注入失败，Could not resolve placeholder解决：根据springboot启动流程，会有自动扫描包没有扫描到相关注解<span class="token punctuation">,</span> 默认Spring框架实现会从声明<span class="token annotation punctuation">@ComponentScan</span>所在的类的<span class="token keyword">package</span>进行扫描，来自动注入，因此启动类最好放在根路径下面，或者指定扫描包范围spring<span class="token operator">-</span>boot扫描启动类对应的目录和子目录<span class="token number">2</span>、注入bean的方式，属性名称和配置文件里面的key一一对应，就用加<span class="token annotation punctuation">@Value</span> 这个注解如果不一样，就要加<span class="token annotation punctuation">@value</span><span class="token punctuation">(</span><span class="token string">"${XXX}"</span><span class="token punctuation">)</span></code></pre><p><img src="/2019/12/25/springboot-bi-ji-er/%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95.png" alt="配置测试"></p></li><li><p>第二种方式</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix<span class="token operator">=</span><span class="token string">"test"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//配置文件的属性前缀</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"classpath:resource.properties"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerSettings</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> String name<span class="token punctuation">;</span>  <span class="token keyword">private</span> String domain<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><h2 id="4-Springboot单元测试进阶实战和自定义异常处理"><a href="#4-Springboot单元测试进阶实战和自定义异常处理" class="headerlink" title="4-Springboot单元测试进阶实战和自定义异常处理"></a>4-Springboot单元测试进阶实战和自定义异常处理</h2><h3 id="4-1-SpringBootTest单元测试实战"><a href="#4-1-SpringBootTest单元测试实战" class="headerlink" title="4.1-SpringBootTest单元测试实战"></a>4.1-SpringBootTest单元测试实战</h3><p><strong>简介：讲解SpringBoot的单元测试</strong></p><p>1、引入相关依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--springboot程序测试依赖，如果是自动创建项目默认添加--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>2、编写单元测试用例</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>classes <span class="token operator">=</span> <span class="token punctuation">{</span>ApiApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//启动整个springboot工程</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringBootTestDemo</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Test</span> <span class="token comment" spellcheck="true">//Test注解标记方法为测试方法，以便构建工具和IDE能够识别并执行它们</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testOne</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"test hello 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/** 其他注解     * @BeforeAll——只执行一次，执行的时机是在所有测试和@BeforeEach注解方法之前     * @BeforeEach——在每个测试执行之前执行     * @AfterEach——在每个测试执行之后执行     * @AfterAll——只执行一次，执行时机是在所有测试和@AfterEach注解方法之后     **/</span>    <span class="token annotation punctuation">@BeforeAll</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testBeforeAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"testBefore"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@AfterAll</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAfterAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"testAfter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3、Junit5断言</p><ul><li><strong>assertAll</strong>：断言所有提供的可执行文件都不会抛出异常。若提供的标题(heading),其将包含在MultipleFailuresError的消息字符串中。</li><li><strong>assertArrayEquals</strong>：断言期望的和实际的XX类型数组是相等的。若失败，将显示提供的失败消息。</li><li><strong>assertDoesNotThrow</strong>：虽然从测试方法抛出的任何异常都会导致测试失败，但在某些用例中，显式断言测试方法中的给定代码块不会抛出异常会很有用。若提供的标题(heading),其将包含在MultipleFailuresError的消息字符串中。</li><li><strong>assertEquals</strong>：断言预期和实际是相等的。如有必要，将从提供的messageSupplier中懒惰地检索失败消息。</li><li><strong>assertFalse</strong>：断言提供的条件不是真。失败并显示提供的失败消息。</li><li><strong>assertIterableEquals</strong>：断言预期和实际的迭代是完全相同的。类似于检查assertArrayEquals(Object []，Object []，String)中的完全相等，如果遇到两个迭代(包括期望和实际)，则它们的迭代器必须以相同的顺序返回相等的元素。注意：这意味着迭代器不需要是同一类型。</li><li><strong>assertNotNull</strong>：断言提供的条件不为null。</li><li><strong>assertNotSame</strong>：断言预期和实际不会引用同一个对象。</li><li><strong>assertNull</strong>：断言提供的实际为null。</li><li><strong>assertSame</strong>：断言预期和实际引用同一个对象。</li><li><strong>assertThrows</strong>：断言所提供的可执行代码块的执行会引发expectedType的异常并返回异常。如果没有抛出异常，或者抛出了不同类型的异常，则此方法将失败。如果不想对异常实例执行其他检查，只需忽略返回值。</li><li><strong>assertTimeout</strong>：断言在超出给定超时之前，所提供的可执行代码块的执行完成。注意：可执行代码块将在与调用代码相同的线程中执行。因此，如果超过超时，则不会抢先中止执行可执行代码块。</li><li><strong>assertTimeoutPreemptively</strong>：断言在超出给定超时之前，所提供的可执行代码块的执行完成。注意：可执行代码块将在与调用代码不同的线程中执行。此外，如果超过超时，则可抢占地执行可执行代码块。</li><li><strong>assertTrue</strong>：断言提供的条件为true。</li><li><strong>fail</strong>：使用给定的失败消息以及根本原因进行测试失败。泛型返回类型V允许此方法直接用作单语句lambda表达式，从而避免需要实现具有显式返回值的代码块。 由于此方法在其return语句之前抛出AssertionFailedError，因此该方法实际上永远不会向其调用者返回值。</li></ul><h3 id="4-2-SpringBoot测试之MockMvc讲解"><a href="#4-2-SpringBoot测试之MockMvc讲解" class="headerlink" title="4.2-SpringBoot测试之MockMvc讲解"></a>4.2-SpringBoot测试之MockMvc讲解</h3><p><strong>简介: 讲解MockMvc类的使用和模拟Http请求实战</strong></p><ul><li>增加类注解 <code>@AutoConfigureMockMvc</code> 和 <code>@SpringBootTest</code></li><li>相关API <ul><li>perform：执行一个RequestBuilder请求 </li><li>andExpect：添加ResultMatcher-&gt;MockMvcResultMatchers验证规则 andReturn：最后返回相应的MvcResult-&gt;Response</li><li>andReturn：最后返回相应的MvcResult-&gt;Response</li></ul></li></ul><h4 id="4-2-1-什么是Mock？"><a href="#4-2-1-什么是Mock？" class="headerlink" title="4.2.1-什么是Mock？"></a>4.2.1-什么是Mock？</h4><p>在面向对象的程序设计中，模拟对象（英语：<code>mock object</code>）是以可控的方式模拟真实对象行为的假对象。在编程过程中，通常通过模拟一些输入数据，来验证程序是否达到预期结果。</p><h4 id="4-2-2-为什么使用Mock对象？"><a href="#4-2-2-为什么使用Mock对象？" class="headerlink" title="4.2.2-为什么使用Mock对象？"></a>4.2.2-为什么使用Mock对象？</h4><p>使用模拟对象，可以模拟复杂的、真实的对象行为。如果在单元测试中无法使用真实对象，可采用模拟对象进行替代。</p><p><strong>在以下情况可以采用模拟对象来替代真实对象：</strong></p><ul><li>真实对象的行为是不确定的（例如，当前的时间或温度）；</li><li>真实对象很难搭建起来；</li><li>真实对象的行为很难触发（例如，网络错误）；</li><li>真实对象速度很慢（例如，一个完整的数据库，在测试之前可能需要初始化）；</li><li>真实的对象是用户界面，或包括用户界面在内；</li><li>真实的对象使用了回调机制；</li><li>真实对象可能还不存在；</li><li>真实对象可能包含不能用作测试（而不是为实际工作）的信息和方法。</li></ul><p><strong>注：使用Mockito一般分三个步骤：</strong></p><ol><li>模拟测试类所需的外部依赖；</li><li>执行测试代码；</li><li>判断执行结果是否达到预期；</li></ol><h4 id="4-2-3-MockMvc"><a href="#4-2-3-MockMvc" class="headerlink" title="4.2.3-MockMvc"></a>4.2.3-MockMvc</h4><p><code>MockMvc</code>是由spring-test包提供，实现了对Http请求的模拟，能够直接使用网络的形式，转换到Controller的调用，使得测试速度快、不依赖网络环境。同时提供了一套验证的工具，结果的验证十分方便。</p><p><strong>接口<code>MockMvcBuilder</code>，提供一个唯一的<code>build</code>方法，用来构造MockMvc。</strong></p><p>主要有两个实现：<code>StandaloneMockMvcBuilder</code>和<code>DefaultMockMvcBuilder</code>，分别对应两种测试方式，即独立安装和集成Web环境测试（并不会集成真正的web环境，而是通过相应的Mock API进行模拟测试，无须启动服务器）。MockMvcBuilders提供了对应的创建方法standaloneSetup方法和webAppContextSetup方法，在使用时直接调用即可。</p><h4 id="4-2-4-在SpringBoot中使用"><a href="#4-2-4-在SpringBoot中使用" class="headerlink" title="4.2.4-在SpringBoot中使用"></a>4.2.4-在SpringBoot中使用</h4><ol><li>引入依赖（jar包），创建SpringBoot项目中默认引入的spring-boot-starter-test间接引入了spring-test，因此无需再额外引入jar包。</li></ol><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ol start="2"><li>创建Controller类并编写相关方法</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestController</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//测试MockMvc</span>  <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/test/mockmvc"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">testMock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"test_mockmvc"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="3"><li><p>编写测试类。实例化MockMvc有两种形式，一种是使用StandaloneMockMvcBuilder，另外一种是使用DefaultMockMvcBuilder。</p><ul><li><p>测试类及初始化MockMvc初始化：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token annotation punctuation">@AutoConfigureMockMvc</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorldTest</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> MockMvc mockMvc<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> WebApplicationContext webApplicationContext<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Before</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 实例化方式一</span>        mockMvc <span class="token operator">=</span> MockMvcBuilders<span class="token punctuation">.</span><span class="token function">standaloneSetup</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HelloWorldController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 实例化方式二</span><span class="token comment" spellcheck="true">//        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();</span>    <span class="token punctuation">}</span></code></pre></li><li><p>单元测试方法</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>classes <span class="token operator">=</span> <span class="token punctuation">{</span>ApiApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@AutoConfigureMockMvc</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MockMvcTestDemo</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> MockMvc mockMvc<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">apiTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        MvcResult mvcResult <span class="token operator">=</span> mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span>MockMvcRequestBuilders<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/test/mockmvc"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span>MockMvcResultMatchers<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">andReturn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> status <span class="token operator">=</span> mvcResult<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/*         * 1、mockMvc.perform执行一个请求。         * 2、MockMvcRequestBuilders.get("XXX")构造一个请求。         * 3、ResultActions.param添加请求传值         * 4、ResultActions.accept(MediaType.TEXT_HTML_VALUE))设置返回类型         * 5、ResultActions.andExpect添加执行完成后的断言。         * 6、ResultActions.andDo添加一个结果处理器，表示要对结果做点什么事情         *   比如此处使用MockMvcResultHandlers.print()输出整个响应结果信息。         * 7、ResultActions.andReturn表示执行完成后返回相应的结果。         */</span>        mockMvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span>MockMvcRequestBuilders                <span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 设置返回值类型为utf-8，否则默认为ISO-8859-1</span>                <span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>MediaType<span class="token punctuation">.</span>APPLICATION_JSON_UTF8_VALUE<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">param</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span>MockMvcResultMatchers<span class="token punctuation">.</span><span class="token function">status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isOk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">andExpect</span><span class="token punctuation">(</span>MockMvcResultMatchers<span class="token punctuation">.</span><span class="token function">content</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"Hello Tom!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">andDo</span><span class="token punctuation">(</span>MockMvcResultHandlers<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul></li></ol><h3 id="4-3-SpringBoot个性化启动banner设置和debug日志"><a href="#4-3-SpringBoot个性化启动banner设置和debug日志" class="headerlink" title="4.3-SpringBoot个性化启动banner设置和debug日志"></a>4.3-SpringBoot个性化启动banner设置和debug日志</h3><p><strong>简介：自定义应用启动的趣味性日志图标和查看调试日志</strong></p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">1、启动获取更多信息</span> <span class="token attr-value">java -jar xxx.jar --debug</span>2、修改启动的banner信息        1）在类路径下增加一个banner.txt，里面是启动要输出的信息<span class="token attr-name">        2）在applicatoin.properties增加banner文件的路径地址</span> <span class="token attr-name">            spring.banner.location</span><span class="token punctuation">=</span><span class="token attr-value">banner.txt</span><span class="token attr-name">        3）官网地址</span> <span class="token attr-value">https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-banners</span></code></pre><ul><li><p>输出denbug日志</p><ol><li><p>修改application.properties配置文件</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">logging.level.root</span><span class="token punctuation">=</span><span class="token attr-value">debug</span><span class="token attr-name">或者</span> <span class="token attr-value">指定路径</span><span class="token attr-name">logging.level.com.XXX.XXX.mapper</span><span class="token punctuation">=</span><span class="token attr-value">debug</span></code></pre></li><li><p>修改logback-spring.xml配置文件</p><p>增加<code>&lt;logger name=&quot;com.XXX.XXX.mapper&quot; level=&quot;DEBUG&quot;&gt;&lt;/logger&gt;</code></p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span> <span class="token attr-name">debug</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>LOG_HOME<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/test/log<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 控制台输出 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.encoder.PatternLayoutEncoder<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 按照每天生成日志文件 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FILE<span class="token punctuation">"</span></span>  <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--日志文件输出的文件名--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FileNamePattern</span><span class="token punctuation">></span></span>${LOG_HOME}/TestWeb.log.%d{yyyy-MM-dd}.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>FileNamePattern</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--日志文件保留天数--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MaxHistory</span><span class="token punctuation">></span></span>30<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MaxHistory</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.encoder.PatternLayoutEncoder<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--日志文件最大的大小--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>triggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>MaxFileSize</span><span class="token punctuation">></span></span>10MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>MaxFileSize</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>triggeringPolicy</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- show parameters for hibernate sql 专为 Hibernate 定制 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.hibernate.type.descriptor.sql.BasicBinder<span class="token punctuation">"</span></span>  <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TRACE<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.hibernate.type.descriptor.sql.BasicExtractor<span class="token punctuation">"</span></span>  <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DEBUG<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.hibernate.SQL<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DEBUG<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.hibernate.engine.QueryParameters<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DEBUG<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>org.hibernate.engine.query.HQLQueryPlan<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DEBUG<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--myibatis log configure--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.apache.ibatis<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>TRACE<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.sql.Connection<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DEBUG<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.sql.Statement<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DEBUG<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.sql.PreparedStatement<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>DEBUG<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 日志输出级别 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>INFO<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>STDOUT<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>FILE<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre></li></ol></li></ul><h3 id="4-4-SpringBoot配置全局异常"><a href="#4-4-SpringBoot配置全局异常" class="headerlink" title="4.4-SpringBoot配置全局异常"></a>4.4-SpringBoot配置全局异常</h3><h4 id="4-4-1-模拟全局异常"><a href="#4-4-1-模拟全局异常" class="headerlink" title="4.4.1-模拟全局异常"></a>4.4.1-模拟全局异常</h4><ol><li><p>编写异常代码段</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/api/v1/test_ext"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"11"</span><span class="token punctuation">,</span> <span class="token string">"123456"</span><span class="token punctuation">,</span> <span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p>返回结果如下</p><p><img src="/2019/12/25/springboot-bi-ji-er/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8.png" alt="全局异常结果"></p></li></ol><h4 id="4-4-2-异常注解介绍"><a href="#4-4-2-异常注解介绍" class="headerlink" title="4.4.2-异常注解介绍"></a>4.4.2-异常注解介绍</h4><p><code>@ControllerAdvice</code> 顾名思义，这是一个增强的 Controller。需要配合@ExceptionHandler使用，<br>当将异常抛到controller时,可以对异常进行统一处理,规定返回的json格式或是跳转到一个错误页面。</p><p>使用这个 Controller ，可以实现三个方面的功能：</p><ol><li>全局异常处理</li><li>全局数据绑定</li><li>全局数据预处理</li></ol><p>如果是返回json数据 则用 <code>RestControllerAdvice</code>,就可以不加 @ResponseBody</p><p>//捕获全局异常,处理所有不可知的异常<br><code>@ExceptionHandler(value=Exception.class)</code>注解用来指明异常的处理类型</p><h4 id="4-4-3-处理全局异常"><a href="#4-4-3-处理全局异常" class="headerlink" title="4.4.3-处理全局异常"></a>4.4.3-处理全局异常</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestControllerAdvice</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomExceptionHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger LOGGER <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>CustomExceptionHandler<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//捕获全局异常，处理所有不可知的异常</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>value <span class="token operator">=</span> Exception<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">handleException</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LOGGER<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"url {}, msg {}"</span><span class="token punctuation">,</span>request<span class="token punctuation">.</span><span class="token function">getRequestURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getRequestURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> map<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>返回结果如下：</strong></p><p><img src="/2019/12/25/springboot-bi-ji-er/%E5%A4%84%E7%90%86%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8.png" alt="处理全局异常结果"></p><h4 id="4-4-4-处理自定义异常"><a href="#4-4-4-处理自定义异常" class="headerlink" title="4.4.4-处理自定义异常"></a>4.4.4-处理自定义异常</h4><ol><li><p>自定义异常类</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//自定义异常类</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeException</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String code<span class="token punctuation">;</span>    <span class="token keyword">private</span> String msg<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">MyException</span><span class="token punctuation">(</span>String code<span class="token punctuation">,</span> String msg<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">MyException</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>msg <span class="token operator">=</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>处理自定义异常</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//处理自定义异常</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>value <span class="token operator">=</span> MyException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">handleMyException</span><span class="token punctuation">(</span>MyException e<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span><span class="token function">getRequestURL</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> map<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li><li><p>返回自定义页面</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//处理自定义异常</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>MyException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">handleMyExceptio</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ModelAndView modelAndView <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modelAndView<span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"error.html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        modelAndView<span class="token punctuation">.</span><span class="token function">addObject</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> modelAndView<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><img src="/2019/12/25/springboot-bi-ji-er/%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A1%B5%E9%9D%A2.png" alt="自定义页面"></p></li></ol><h2 id="5-SpringBoot部署war项目到tomcat9和启动原理"><a href="#5-SpringBoot部署war项目到tomcat9和启动原理" class="headerlink" title="5-SpringBoot部署war项目到tomcat9和启动原理"></a>5-SpringBoot部署war项目到tomcat9和启动原理</h2><h3 id="5-1-SpringBoot启动方式和部署war项目到tomcat9"><a href="#5-1-SpringBoot启动方式和部署war项目到tomcat9" class="headerlink" title="5.1-SpringBoot启动方式和部署war项目到tomcat9"></a>5.1-SpringBoot启动方式和部署war项目到tomcat9</h3><ol><li><p>IDE启动</p></li><li><p>jar包方式启动</p><pre class=" language-xml"><code class="language-xml">//maven插件:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span></code></pre><p>如果没有加，则执行jar包 ，报错如下</p><pre class=" language-java"><code class="language-java">java <span class="token operator">-</span>jar spring<span class="token operator">-</span>boot<span class="token operator">-</span>demo<span class="token operator">-</span><span class="token number">0.0</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-</span>SNAPSHOT<span class="token punctuation">.</span>jar                no main manifest attribute<span class="token punctuation">,</span> in spring<span class="token operator">-</span>boot<span class="token operator">-</span>demo<span class="token operator">-</span><span class="token number">0.0</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-</span>SNAPSHOT<span class="token punctuation">.</span>jar</code></pre><p>jar包项目结构</p><pre class=" language-xml"><code class="language-xml">example.jar                 |                 +-META-INF                 |  +-MANIFEST.MF                 +-org                 |  +-springframework                 |     +-boot                 |        +-loader                 |           +-<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>spring</span> <span class="token attr-name">boot</span> <span class="token attr-name">loader</span> <span class="token attr-name">classes</span><span class="token punctuation">></span></span>                 +-BOOT-INF                    +-classes                    |  +-mycompany                    |     +-project                    |        +-YourClasses.class                    +-lib                       +-dependency1.jar                       +-dependency2.jar</code></pre><p>目录结构讲解<br><a href="https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#executable-jar-jar-file-structure" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#executable-jar-jar-file-structure</a></p></li><li><p>war包方式启动</p><ul><li><p>在pom.xml中将打包形式 <code>jar</code> 修改为<code>war</code>  <packaging>war</packaging></p><p>构建项目名称 <finalName>springboot_demo</finalName></p></li><li><p>tocmat下载和安装 <a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-90.cgi</a></p></li><li><p>修改启动类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DemoApplication</span> <span class="token keyword">extends</span> <span class="token class-name">SpringBootServletInitializer</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">protected</span> SpringApplicationBuilder <span class="token function">configure</span><span class="token punctuation">(</span>SpringApplicationBuilder application<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> application<span class="token punctuation">.</span><span class="token function">sources</span><span class="token punctuation">(</span>DemoApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>                SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>DemoApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre></li><li><p>打包项目，启动tomcat</p></li></ul></li></ol><h3 id="5-2-SpringBoot启动原理"><a href="#5-2-SpringBoot启动原理" class="headerlink" title="5.2-SpringBoot启动原理"></a>5.2-SpringBoot启动原理</h3><h2 id="6-SpringBoot拦截器和-Servlet3-0自定义Filter、Listener"><a href="#6-SpringBoot拦截器和-Servlet3-0自定义Filter、Listener" class="headerlink" title="6-SpringBoot拦截器和 Servlet3.0自定义Filter、Listener"></a>6-SpringBoot拦截器和 Servlet3.0自定义Filter、Listener</h2><h3 id="6-1-SpringBoot过滤器和Servlet3-0配置过滤器"><a href="#6-1-SpringBoot过滤器和Servlet3-0配置过滤器" class="headerlink" title="6.1-SpringBoot过滤器和Servlet3.0配置过滤器"></a>6.1-SpringBoot过滤器和Servlet3.0配置过滤器</h3><ol><li>SpringBoot启动默认加载的Filter </li></ol><pre><code>characterEncodingFilterhiddenHttpMethodFilterhttpPutFormContentFilterrequestContextFilter</code></pre><ol start="2"><li>Filter优先级</li></ol><p><code>Ordered.HIGHEST_PRECEDENCE</code><br><code>Ordered.LOWEST_PRECEDENCE</code></p><p>低位值意味着更高的优先级 Higher values are interpreted as lower priority<br>自定义Filter，避免和默认的Filter优先级一样，不然会冲突</p><p>注册Filter的bean FilterRegistrationBean<br>同模块里面有相关默认Filter<br>            web-&gt;servlet-&gt;filter</p><ol start="3"><li>自定义Filter<ul><li>使用Servlet3.0的注解进行配置</li><li>启动类里面增加 @ServletComponentScan，进行扫描</li><li>新建一个Filter类，implements Filter，并实现对应的接口</li><li><code>@WebFilter</code> 标记一个类为filter，被spring进行扫描<br> <code>urlPatterns</code>：拦截规则，支持正则</li><li>控制chain.doFilter的方法的调用，来实现是否通过放行<br>不放行，web应用resp.sendRedirect(“/index.html”);<br>场景：权限控制、用户登录(非前端后端分离场景)等</li></ul></li></ol><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@WebFilter</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token string">"/api/*"</span><span class="token punctuation">,</span> filterName <span class="token operator">=</span> <span class="token string">"loginFilter"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//容器加载的时候调用</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>FilterConfig filterConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"init loginFilter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//请求被拦截的时候调用</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span>ServletRequest servletRequest<span class="token punctuation">,</span> ServletResponse servletResponse<span class="token punctuation">,</span> FilterChain filterChain<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ServletException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"doFilter loginFilter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpServletRequest request <span class="token operator">=</span> <span class="token punctuation">(</span>HttpServletRequest<span class="token punctuation">)</span> servletRequest<span class="token punctuation">;</span>        HttpServletResponse response <span class="token operator">=</span> <span class="token punctuation">(</span>HttpServletResponse<span class="token punctuation">)</span> servletResponse<span class="token punctuation">;</span>        String username <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"fangpeng"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            filterChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>servletRequest<span class="token punctuation">,</span> servletResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            response<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span><span class="token string">"/index.html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//容器被销毁的时候调用</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"destroy loginFilter"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="6-2-Servlet3-0注解自定义原生Servlet"><a href="#6-2-Servlet3-0注解自定义原生Servlet" class="headerlink" title="6.2-Servlet3.0注解自定义原生Servlet"></a>6.2-Servlet3.0注解自定义原生Servlet</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@WebServlet</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"userServlet"</span><span class="token punctuation">,</span>urlPatterns <span class="token operator">=</span> <span class="token string">"/test/customs"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServlet</span> <span class="token keyword">extends</span> <span class="token class-name">HttpServlet</span><span class="token punctuation">{</span>             <span class="token annotation punctuation">@Override</span>           <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doGet</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> HttpServletResponse resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>                 resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"custom sevlet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 resp<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest req<span class="token punctuation">,</span> HttpServletResponse resp<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>                 <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doGet</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> resp<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><h3 id="6-3-自定义监听器Listener"><a href="#6-3-自定义监听器Listener" class="headerlink" title="6.3-自定义监听器Listener"></a>6.3-自定义监听器Listener</h3><ul><li><p>常用的监听器</p><p><code>servletContextListener</code>、<code>httpSessionListener</code>、<code>servletRequestListener</code></p></li><li><p>Servlet注解自定义监听器</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@WebListener</span>        <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RequestListener</span> <span class="token keyword">implements</span> <span class="token class-name">ServletRequestListener</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">requestDestroyed</span><span class="token punctuation">(</span>ServletRequestEvent sre<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======requestDestroyed========"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">requestInitialized</span><span class="token punctuation">(</span>ServletRequestEvent sre<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======requestInitialized========"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@WebListener</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomContextListener</span> <span class="token keyword">implements</span> <span class="token class-name">ServletContextListener</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextInitialized</span><span class="token punctuation">(</span>ServletContextEvent sce<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"======contextInitialized======"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextDestroyed</span><span class="token punctuation">(</span>ServletContextEvent sce<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"contextDestroyed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul><h3 id="6-4-自定义拦截器Interceptor"><a href="#6-4-自定义拦截器Interceptor" class="headerlink" title="6.4-自定义拦截器Interceptor"></a>6.4-自定义拦截器Interceptor</h3><ol><li><p>@Configuration</p><ul><li>继承WebMvcConfigurationAdapter(SpringBoot2.X之前旧版本)</li><li>SpringBoot2.X 新版本配置拦截器 implements <code>WebMvcConfigurer</code></li></ul></li><li><p>自定义拦截器 HandlerInterceptor</p><ul><li>preHandle：调用Controller某个方法之前</li><li>postHandle：Controller之后调用，视图渲染之前，如果控制器Controller出现了异常，则不会执行此方法</li><li>afterCompletion：不管有没有异常，这个afterCompletion都会被调用，用于资源清理</li></ul></li><li><p>按照注册顺序进行拦截，先注册，先被拦截</p></li><li><p>拦截器不生效常见问题：</p><ul><li>是否有加@Configuration</li><li>拦截路径是否有问题 <code>**</code>  和 <code>*</code> </li><li>拦截器最后路径一定要 “/**”， 如果是目录的话则是 ”/ */“</li></ul></li><li><p>Filter</p><p>是基于函数回调 doFilter()，而Interceptor则是基于AOP思想<br>Filter在只在Servlet前后起作用，而Interceptor够深入到方法前后、异常抛出前后等</p><p>依赖于Servlet容器即web应用中，而Interceptor不依赖于Servlet容器所以可以运行在多种环境。</p><p>在接口调用的生命周期里，Interceptor可以被多次调用，而Filter只能在容器初始化时调用一次。</p></li></ol><p>   Filter和Interceptor的执行顺序：</p><p>   过滤前-&gt;拦截前-&gt;action执行-&gt;拦截后-&gt;过滤后</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//进入controller方法之前</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LoginInterceptor=====>preHandle"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> HandlerInterceptor<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">preHandle</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//调用完controller之后，试图渲染之前</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> ModelAndView modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LoginInterceptor====>postHandle"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HandlerInterceptor<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">postHandle</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> modelAndView<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> Exception ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LoginInterceptor====>afterCompletion"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HandlerInterceptor<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">afterCompletion</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomWebMvcConfigure</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span>InterceptorRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoginInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">"/api/*/**"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">/</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">excludePathPatterns</span><span class="token punctuation">(</span><span class="token string">"/api/*/**"</span><span class="token punctuation">)</span> <span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span><span class="token operator">></span> 排除某路径不被拦截        <span class="token comment" spellcheck="true">//拦截全部 </span><span class="token comment" spellcheck="true">/*/*/</span><span class="token operator">*</span><span class="token operator">*</span>        WebMvcConfigurer<span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">addInterceptors</span><span class="token punctuation">(</span>registry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="7-数据库操作之整合Mybatis和事务"><a href="#7-数据库操作之整合Mybatis和事务" class="headerlink" title="7-数据库操作之整合Mybatis和事务"></a>7-数据库操作之整合Mybatis和事务</h2><h3 id="7-1-SpringBoot持久化数据方式"><a href="#7-1-SpringBoot持久化数据方式" class="headerlink" title="7.1-SpringBoot持久化数据方式"></a>7.1-SpringBoot持久化数据方式</h3><ol><li><p>原始java访问数据库JDBC（开发流程会很麻烦）</p><ul><li><p>注册驱动/加载驱动——<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code></p></li><li><p>建立连接</p><p><code>Connection con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/dbname&quot;,&quot;root&quot;,&quot;root&quot;);</code></p></li><li><p>创建Statement</p></li><li><p>执行SQL语句</p></li><li><p>处理结果集</p></li><li><p>关闭连接，释放资源</p></li></ul></li><li><p>apache dbutils框架</p><p>比JDBC简单点<br>官网:<a href="https://commons.apache.org/proper/commons-dbutils/" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-dbutils/</a></p></li><li><p>jpa框架</p><p><code>spring-data-jpa</code><br>jpa在复杂查询的时候性能不是很好</p></li><li><p>Hiberante </p><p>解释：ORM：对象关系映射Object Relational Mapping<br>企业大都喜欢使用hibernate</p></li><li><p>Mybatis框架</p><p>互联网行业通常使用mybatis<br>不提供对象和关系模型的直接映射,半ORM</p></li></ol><h3 id="7-2-SpringBoot2-x整合Mybatis3-x注解实战"><a href="#7-2-SpringBoot2-x整合Mybatis3-x注解实战" class="headerlink" title="7.2-SpringBoot2.x整合Mybatis3.x注解实战"></a>7.2-SpringBoot2.x整合Mybatis3.x注解实战</h3><ol><li><p>使用starter, maven仓库地址：<a href="http://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter" target="_blank" rel="noopener">http://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter</a></p></li><li><p>加入依赖(可以用 <a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a> 下载)</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 引入starter--></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>                                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>         <span class="token comment" spellcheck="true">&lt;!-- MySQL的JDBC驱动包    --></span>                     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>         <span class="token comment" spellcheck="true">&lt;!-- 引入第三方数据源 --></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>druid<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.1.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>加入配置文件</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#mybatis.type-aliases-package=com.fangpeng.base_project.domain</span><span class="token comment" spellcheck="true">#可以自动识别</span><span class="token comment" spellcheck="true">#spring.datasource.driver-class-name =com.mysql.jdbc.Driver</span><span class="token attr-name">spring.datasource.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/spring?useUnicode=true&amp;characterEncoding=utf-8</span><span class="token attr-name">spring.datasource.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">spring.datasource.password</span><span class="token punctuation">=</span><span class="token attr-value">password</span><span class="token comment" spellcheck="true">#如果不使用默认的数据源 （com.zaxxer.hikari.HikariDataSource）</span><span class="token attr-name">spring.datasource.type</span> <span class="token punctuation">=</span><span class="token attr-value">com.alibaba.druid.pool.DruidDataSource</span></code></pre><p>加载配置，注入到<code>sqlSessionFactory</code>等都是springBoot帮我们完成</p></li><li><p>启动类增加mapper扫描</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">"com.fangpeng.base_project.mapper"</span><span class="token punctuation">)</span>技巧：保存对象，获取数据库自增id <span class="token annotation punctuation">@Options</span><span class="token punctuation">(</span>useGeneratedKeys<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">,</span> keyProperty<span class="token operator">=</span><span class="token string">"id"</span><span class="token punctuation">,</span> keyColumn<span class="token operator">=</span><span class="token string">"id"</span><span class="token punctuation">)</span></code></pre></li><li><p>开发mapper<br>参考语法 <a href="http://www.mybatis.org/mybatis-3/zh/java-api.html" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/java-api.html</a></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//推荐使用#{}取值，不要用${}取值，因为存在SQL注入风险</span>    <span class="token annotation punctuation">@Insert</span><span class="token punctuation">(</span><span class="token string">"INSERT INTO user(name,phone,create_time,age) VALUES(#{name}, #{phone}, #{createTime}, #{age})"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Options</span><span class="token punctuation">(</span>useGeneratedKeys <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> keyProperty <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">,</span> keyColumn <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">)</span>    <span class="token keyword">int</span> <span class="token function">insert</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>开发service</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserMapper userMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>开发controller</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api/v1/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserService userService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserMapper userMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setCreateTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"kobe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setPhone</span><span class="token punctuation">(</span><span class="token string">"10086"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> id <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> JsonData<span class="token punctuation">.</span><span class="token function">buildSuccess</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>sql脚本</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span><span class="token keyword">user</span><span class="token punctuation">`</span> <span class="token punctuation">(</span>          <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> unsigned <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>          <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'名称'</span><span class="token punctuation">,</span>          <span class="token punctuation">`</span>phone<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'用户手机号'</span><span class="token punctuation">,</span>          <span class="token punctuation">`</span>create_time<span class="token punctuation">`</span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建时间'</span><span class="token punctuation">,</span>          <span class="token punctuation">`</span>age<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'年龄'</span><span class="token punctuation">,</span>          <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">18</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span></code></pre><p><strong>相关资料：</strong></p><pre><code>http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/#Configuration</code></pre><p>​    <a href="https://github.com/mybatis/spring-boot-starter/tree/master/mybatis-spring-boot-samples" target="_blank" rel="noopener">https://github.com/mybatis/spring-boot-starter/tree/master/mybatis-spring-boot-samples</a></p><p><strong>整合问题集合：</strong></p><p>​    <a href="https://my.oschina.net/hxflar1314520/blog/1800035" target="_blank" rel="noopener">https://my.oschina.net/hxflar1314520/blog/1800035</a><br>​    <a href="https://blog.csdn.net/tingxuetage/article/details/80179772" target="_blank" rel="noopener">https://blog.csdn.net/tingxuetage/article/details/80179772</a></p></li></ol><h3 id="7-3-SpringBoot整合Mybatis实操和打印SQL语句"><a href="#7-3-SpringBoot整合Mybatis实操和打印SQL语句" class="headerlink" title="7.3-SpringBoot整合Mybatis实操和打印SQL语句"></a>7.3-SpringBoot整合Mybatis实操和打印SQL语句</h3><ol><li><p>控制台打印sql语句        </p><pre><code>#增加打印sql语句，一般用于本地开发测试   `mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl`</code></pre></li><li><p>增加mapper代码    </p><pre class=" language-java"><code class="language-java">        <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"SELECT * FROM user"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Results</span><span class="token punctuation">(</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>column <span class="token operator">=</span> <span class="token string">"create_time"</span><span class="token punctuation">,</span>property <span class="token operator">=</span> <span class="token string">"createTime"</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//javaType = java.util.Date.class        </span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    List<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"SELECT * FROM user WHERE id = #{id}"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Results</span><span class="token punctuation">(</span><span class="token punctuation">{</span>         <span class="token annotation punctuation">@Result</span><span class="token punctuation">(</span>column <span class="token operator">=</span> <span class="token string">"create_time"</span><span class="token punctuation">,</span>property <span class="token operator">=</span> <span class="token string">"createTime"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    User <span class="token function">findById</span><span class="token punctuation">(</span>Long id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Update</span><span class="token punctuation">(</span><span class="token string">"UPDATE user SET name=#{name} WHERE id =#{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Delete</span><span class="token punctuation">(</span><span class="token string">"DELETE FROM user WHERE id =#{userId}"</span><span class="token punctuation">)</span>    <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>Long userId<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>增加API</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"find_all"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> JsonData<span class="token punctuation">.</span><span class="token function">buildSuccess</span><span class="token punctuation">(</span>userMapper<span class="token punctuation">.</span><span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"find_by_Id"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">findById</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> JsonData<span class="token punctuation">.</span><span class="token function">buildSuccess</span><span class="token punctuation">(</span>userMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"del_by_id"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">delById</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>    userMapper<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> JsonData<span class="token punctuation">.</span><span class="token function">buildSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"update"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Object <span class="token function">update</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        userMapper<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> JsonData<span class="token punctuation">.</span><span class="token function">buildSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre></li></ol><h3 id="7-4-事务介绍和常见的隔离级别，传播行为"><a href="#7-4-事务介绍和常见的隔离级别，传播行为" class="headerlink" title="7.4-事务介绍和常见的隔离级别，传播行为"></a>7.4-事务介绍和常见的隔离级别，传播行为</h3><ol><li><p>什么是事务？</p><p>指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<br>简单的说，事务就是并发控制的单位，是用户定义的一个操作序列。<br>而一个逻辑工作单元要成为事务，就必须满足ACID属性。<br>A：原子性（Atomicity）</p><pre><code>事务中的操作要么都不做，要么就全做。</code></pre><p>C：一致性（Consistency）</p><pre><code>事务执行的结果必须是从数据库从一个一致性状态转换到另一个一致性状态。</code></pre><p>I：隔离性（Isolation）</p><pre><code>一个事务的执行不能被其他事务干扰</code></pre><p>D：持久性（Durability）</p><pre><code>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的</code></pre></li><li><p>事务的隔离级别</p><ul><li><p>读未提交（<code>Read Uncommitted</code>）：保证了读取过程中不会读取到非法数据</p><p>​             引发脏读（读取了未提交的数据）</p></li><li><p>读已提交（<code>Read Committed</code>）</p><pre><code>        这是大多数数据库系统默认的隔离级别，但不是MySQL默认的        只能看见已经提交事务所做的改变        引发不可重复读，不可重读读意味着我们同一事务执行完全相同的select语句时可能看到不一样的结果。        ——&gt;导致这种情况的原因可能有：(1)有一个交叉的事务有新的commit，导致了数据的改变;(2)一个数据库被多个实例操作时,同一事务的其他实例在该实例处理其间可能会有新的commit                多个commit提交时，只读一次出现结果不一致</code></pre></li><li><p>可重复读（<code>Repeatable Read</code>）：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据</p><p>​        这是MySQL的默认事务隔离级别<br>​        它确保同一事务的多个实例在并发读取数据时，看到同样的数据行<br>​        此级别可能出现的问题–幻读（Phantom Read），当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行<br>​        InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题</p></li><li><p>可串行化（<code>Serializable</code>）：最严格，串行处理，消耗资源大</p><p>​            这是最高的隔离级别<br>​            它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它在每个读的数据行上加上共享锁。<br>​            可能导致大量的超时现象和锁竞争</p></li></ul></li><li><p>常见的传播行为</p><pre class=" language-properties"><code class="language-properties">PROPAGATION_REQUIRED--支持当前事务，如果当前没有事务，就新建一个事务,最常见的选择。PROPAGATION_SUPPORTS--支持当前事务，如果当前没有事务，就以非事务方式执行。PROPAGATION_MANDATORY--支持当前事务，如果当前没有事务，就抛出异常。<span class="token attr-name">PROPAGATION_REQUIRES_NEW--新建事务，如果当前存在事务，把当前事务挂起,</span> <span class="token attr-value">两个事务之间没有关系，一个异常，一个提交，不会同时回滚</span>PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。PROPAGATION_NEVER--以非事务方式执行，如果当前存在事务，则抛出异常</code></pre></li></ol><h3 id="7-5-SpringBoot整合mybatis之事务处理实战"><a href="#7-5-SpringBoot整合mybatis之事务处理实战" class="headerlink" title="7.5-SpringBoot整合mybatis之事务处理实战"></a>7.5-SpringBoot整合mybatis之事务处理实战</h3><ul><li>service逻辑引入事务</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">addAccount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setCreateTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"事务测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setPhone</span><span class="token punctuation">(</span><span class="token string">"000121212"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="8-SpringBoot整合Redis"><a href="#8-SpringBoot整合Redis" class="headerlink" title="8-SpringBoot整合Redis"></a>8-SpringBoot整合Redis</h2><h3 id="8-1-分布式缓存Redis介绍"><a href="#8-1-分布式缓存Redis介绍" class="headerlink" title="8.1-分布式缓存Redis介绍"></a>8.1-分布式缓存Redis介绍</h3><p>REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。</p><p>Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><p>它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><ol><li><p>redis官网 <a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a></p></li><li><p>新手入门redis在线测试工具：<a href="http://try.redis.io/" target="_blank" rel="noopener">http://try.redis.io/</a></p></li></ol><h3 id="8-2-源码编译安装Redis4-x"><a href="#8-2-源码编译安装Redis4-x" class="headerlink" title="8.2-源码编译安装Redis4.x"></a>8.2-源码编译安装Redis4.x</h3><ol><li><p>快速安装  <a href="https://redis.io/download#installation" target="_blank" rel="noopener">https://redis.io/download#installation</a></p><pre><code>    wget http://download.redis.io/releases/redis-4.0.9.tar.gz       tar xzf redis-4.0.9.tar.gz       cd redis-4.0.9       make</code></pre><p> 启动服务端：src/redis-server<br> 启动客户端：src/redis-cli</p></li><li><p>默认是本地访问的，需要开放外网访问</p><pre><code>1）打开redis.conf文件在NETWORK部分修改      注释掉bind 127.0.0.1可以使所有的ip访问redis      修改 protected-mode，值改为no</code></pre></li></ol><h3 id="8-3-SpringBoot整合redis实战"><a href="#8-3-SpringBoot整合redis实战" class="headerlink" title="8.3-SpringBoot整合redis实战"></a>8.3-SpringBoot整合redis实战</h3><ol><li><p>官网：<a href="https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-redis" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-redis</a><br>集群文档：<a href="https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#cluster" target="_blank" rel="noopener">https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/#cluster</a></p></li><li><p>springboot整合redis相关依赖引入</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>相关配置文件配置</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#=========redis基础配置=========</span><span class="token attr-name">spring.redis.database</span><span class="token punctuation">=</span><span class="token attr-value">0</span><span class="token attr-name">spring.redis.host</span><span class="token punctuation">=</span><span class="token attr-value">127.0.0.1</span><span class="token attr-name">spring.redis.port</span><span class="token punctuation">=</span><span class="token attr-value">6379</span><span class="token comment" spellcheck="true"># 连接超时时间 单位 ms（毫秒）</span><span class="token attr-name">spring.redis.timeout</span><span class="token punctuation">=</span><span class="token attr-value">3000</span><span class="token comment" spellcheck="true">#=========redis线程池设置=========</span><span class="token comment" spellcheck="true"># 连接池中的最大空闲连接，默认值也是8。</span><span class="token attr-name">spring.redis.pool.max-idle</span><span class="token punctuation">=</span><span class="token attr-value">200</span><span class="token comment" spellcheck="true">#连接池中的最小空闲连接，默认值也是0。</span><span class="token attr-name">spring.redis.pool.min-idle</span><span class="token punctuation">=</span><span class="token attr-value">200</span><span class="token comment" spellcheck="true"># 如果赋值为-1，则表示不限制；pool已经分配了maxActive个jedis实例，则此时pool的状态为exhausted(耗尽)。</span><span class="token attr-name">spring.redis.pool.max-active</span><span class="token punctuation">=</span><span class="token attr-value">2000</span><span class="token comment" spellcheck="true"># 等待可用连接的最大时间，单位毫秒，默认值为-1，表示永不超时</span><span class="token attr-name">spring.redis.pool.max-wait</span><span class="token punctuation">=</span><span class="token attr-value">1000</span></code></pre></li><li><p>常见redistemplate种类讲解和缓存实操(使用自动注入)</p><ul><li><p>注入模板</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span>        <span class="token keyword">private</span> StirngRedisTemplate strTplRedis</code></pre></li><li><p>类型String,List,Hash,Set,ZSet</p><pre><code>对应的方法分别是opsForValue()、opsForList()、opsForHash()、opsForSet()、opsForZSet()</code></pre></li></ul></li></ol><h3 id="8-5-Redis配置类和工具类"><a href="#8-5-Redis配置类和工具类" class="headerlink" title="8.5-Redis配置类和工具类"></a>8.5-Redis配置类和工具类</h3><ol><li><p>RedisTemplate的自动配置（源代码如下）</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token punctuation">(</span>    proxyBeanMethods <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span>RedisOperations<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span><span class="token punctuation">{</span>RedisProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>LettuceConnectionConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> JedisConnectionConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">RedisAutoConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>        name <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"redisTemplate"</span><span class="token punctuation">}</span>    <span class="token punctuation">)</span>    <span class="token keyword">public</span> RedisTemplate<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span>RedisConnectionFactory redisConnectionFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> UnknownHostException <span class="token punctuation">{</span>        RedisTemplate<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span>    <span class="token keyword">public</span> StringRedisTemplate <span class="token function">stringRedisTemplate</span><span class="token punctuation">(</span>RedisConnectionFactory redisConnectionFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> UnknownHostException <span class="token punctuation">{</span>        StringRedisTemplate template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过源码可以看出，SpringBoot自动帮我们在容器中生成了一个<code>RedisTemplate</code>和一个<code>StringRedisTemplate</code>。但是，这个RedisTemplate的泛型是&lt;Object,Object&gt;，写代码不方便，需要写好多类型转换的代码；我们需要一个泛型为&lt;String,Object&gt;形式的RedisTemplate。并且，这个RedisTemplate没有设置数据存在Redis时，key及value的序列化方式。</p><pre><code>    看到这个@ConditionalOnMissingBean注解后，就知道如果Spring容器中有了RedisTemplate对象了，这个自动配置的RedisTemplate不会实例化。因此我们可以直接自己写个配置类，配置RedisTemplate。</code></pre></li><li><p>重新写一个Redis配置类</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Redis配置类</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span>RedisConnectionFactory factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span><span class="token punctuation">;</span>        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ObjectMapper objectMapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        objectMapper<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span>PropertyAccessor<span class="token punctuation">.</span>ALL<span class="token punctuation">,</span> JsonAutoDetect<span class="token punctuation">.</span>Visibility<span class="token punctuation">.</span>ANY<span class="token punctuation">)</span><span class="token punctuation">;</span>        objectMapper<span class="token punctuation">.</span><span class="token function">enableDefaultTyping</span><span class="token punctuation">(</span>ObjectMapper<span class="token punctuation">.</span>DefaultTyping<span class="token punctuation">.</span>NON_FINAL<span class="token punctuation">)</span><span class="token punctuation">;</span>        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>objectMapper<span class="token punctuation">)</span><span class="token punctuation">;</span>        StringRedisSerializer stringRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringRedisSerializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// key采用String的序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash的key也采用String的序列化方式</span>        template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span>stringRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// value序列化方式采用jackson</span>        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash的value序列化方式采用jackson</span>        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>        template<span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> template<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>封装Redis工具类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">RedisUtil</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> redisTemplate<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// =============================common============================</span>    <span class="token comment" spellcheck="true">/**     * 指定缓存失效时间     *     * @param key  键     * @param time 时间(秒)     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">expire</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                redisTemplate<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> time<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 根据key 获取过期时间     *     * @param key 键 不能为null     * @return 时间(秒) 返回0代表为永久有效     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getExpire</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">getExpire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断key是否存在     *     * @param key 键     * @return true 存在 false不存在     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasKey</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">hasKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除缓存     *     * @param key 可以传一个值 或多个     */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">del</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                redisTemplate<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">arrayToList</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// ============================String=============================</span>    <span class="token comment" spellcheck="true">/**     * 普通缓存获取     *     * @param key 键     * @return 值     */</span>    <span class="token keyword">public</span> Object <span class="token function">get</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> key <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 普通缓存放入     *     * @param key   键     * @param value 值     * @return true成功 false失败     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">set</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 普通缓存放入并设置时间     *     * @param key   键     * @param value 值     * @param time  时间(秒) time要大于0 如果time小于等于0 将设置无限期     * @return true成功 false 失败     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">set</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object value<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> time<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 递增     *     * @param key   键     * @param delta 要增加几(大于0)     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">incr</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> <span class="token keyword">long</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"递增因子必须大于0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 递减     *     * @param key   键     * @param delta 要减少几(小于0)     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">decr</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> <span class="token keyword">long</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>delta <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"递减因子必须大于0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">-</span>delta<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// ================================Map=================================</span>    <span class="token comment" spellcheck="true">/**     * HashGet     *     * @param key  键 不能为null     * @param item 项 不能为null     * @return 值     */</span>    <span class="token keyword">public</span> Object <span class="token function">hget</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> String item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取hashKey对应的所有键值     *     * @param key 键     * @return 对应的多个键值     */</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">hmget</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * HashSet     *     * @param key 键     * @param map 对应多个键值     * @return true 成功 false 失败     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hmset</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * HashSet 并设置时间     *     * @param key  键     * @param map  对应多个键值     * @param time 时间(秒)     * @return true成功 false失败     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hmset</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 向一张hash表中放入数据,如果不存在将创建     *     * @param key   键     * @param item  项     * @param value 值     * @return true 成功 false失败     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hset</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> String item<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 向一张hash表中放入数据,如果不存在将创建     *     * @param key   键     * @param item  项     * @param value 值     * @param time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间     * @return true 成功 false失败     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hset</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> String item<span class="token punctuation">,</span> Object value<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除hash表中的值     *     * @param key  键 不能为null     * @param item 项 可以使多个 不能为null     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">hdel</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 判断hash表中是否有该项的值     *     * @param key  键 不能为null     * @param item 项 不能为null     * @return true 存在 false不存在     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hHasKey</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> String item<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasKey</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * hash递增 如果不存在,就会创建一个 并把新增后的值返回     *     * @param key  键     * @param item 项     * @param by   要增加几(大于0)     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">hincr</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> String item<span class="token punctuation">,</span> <span class="token keyword">double</span> by<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">,</span> by<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * hash递减     *     * @param key  键     * @param item 项     * @param by   要减少记(小于0)     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">hdecr</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> String item<span class="token punctuation">,</span> <span class="token keyword">double</span> by<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> item<span class="token punctuation">,</span> <span class="token operator">-</span>by<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// ============================set=============================</span>    <span class="token comment" spellcheck="true">/**     * 根据key获取Set中的所有值     *     * @param key 键     * @return     */</span>    <span class="token keyword">public</span> Set<span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token function">sGet</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">members</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 根据value从一个set中查询,是否存在     *     * @param key   键     * @param value 值     * @return true 存在 false不存在     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sHasKey</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isMember</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将数据放入set缓存     *     * @param key    键     * @param values 值 可以是多个     * @return 成功个数     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sSet</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将set数据放入缓存     *     * @param key    键     * @param time   时间(秒)     * @param values 值 可以是多个     * @return 成功个数     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sSetAndTime</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Long count <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> count<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取set缓存的长度     *     * @param key 键     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sGetSetSize</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 移除值为value的     *     * @param key    键     * @param values 值 可以是多个     * @return 移除的个数     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">setRemove</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Long count <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> values<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> count<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// ===============================list=================================</span>    <span class="token comment" spellcheck="true">/**     * 获取list缓存的内容     *     * @param key   键     * @param start 开始     * @param end   结束 0 到 -1代表所有值     * @return     */</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token function">lGet</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> <span class="token keyword">long</span> start<span class="token punctuation">,</span> <span class="token keyword">long</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取list缓存的长度     *     * @param key 键     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">lGetListSize</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过索引 获取list中的值     *     * @param key   键     * @param index 索引 index>=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推     * @return     */</span>    <span class="token keyword">public</span> Object <span class="token function">lGetIndex</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> <span class="token keyword">long</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将list放入缓存     *     * @param key   键     * @param value 值     * @param time  时间(秒)     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lSet</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPush</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将list放入缓存     *     * @param key   键     * @param value 值     * @param time  时间(秒)     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lSet</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> Object value<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPush</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将list放入缓存     *     * @param key   键     * @param value 值     * @param time  时间(秒)     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lSet</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPushAll</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将list放入缓存     * å     *     * @param key   键     * @param value 值     * @param time  时间(秒)     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lSet</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> value<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rightPushAll</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>time <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 根据索引修改list中的某条数据     *     * @param key   键     * @param index 索引     * @param value 值     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">lUpdateIndex</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> <span class="token keyword">long</span> index<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> index<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 移除N个值为value     *     * @param key   键     * @param count 移除多少个     * @param value 值     * @return 移除的个数     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">lRemove</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span> <span class="token keyword">long</span> count<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Long remove <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> count<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> remove<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="9-SpringBoot整合定时任务和异步任务"><a href="#9-SpringBoot整合定时任务和异步任务" class="headerlink" title="9-SpringBoot整合定时任务和异步任务"></a>9-SpringBoot整合定时任务和异步任务</h2><h3 id="9-1-SpringBoot定时任务schedule"><a href="#9-1-SpringBoot定时任务schedule" class="headerlink" title="9.1-SpringBoot定时任务schedule"></a>9.1-SpringBoot定时任务schedule</h3><ol><li><p>常见定时任务</p><ul><li><p>Java自带的java.util.Timer类</p><p>timer:配置比较麻烦，时间延后问题<br>timertask:不推荐</p></li><li><p>Quartz框架</p><p>配置更简单<br>xml或者注解</p></li><li><p>SpringBoot使用注解方式开启定时任务</p><ul><li>启动类里面 @EnableScheduling开启定时任务，自动扫描</li><li>定时任务业务类 加注解 @Component被容器扫描</li><li>定时执行的方法加上注解 @Scheduled(fixedRate=2000) 定期执行一次</li></ul></li></ul></li><li><p>定时任务schedule</p><p>SpringBoot内置了定时任务Scheduled，能够很好的实现定时任务。</p><ul><li>在SpringBoot应用添加<code>@EnableScheduling</code>注解启动定时任务</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableScheduling</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringbootTestApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringbootTestApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>添加测试定时任务的代码</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScheduledTask</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>cron <span class="token operator">=</span> <span class="token string">"5 0 0 * * ?"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduledTask1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"定时任务1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>initialDelay <span class="token operator">=</span>  <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">,</span>fixedDelay <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduledTask2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务2执行时间："</span><span class="token operator">+</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"定时任务2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务2结束时间："</span><span class="token operator">+</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>initialDelay <span class="token operator">=</span>  <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">,</span>fixedRate <span class="token operator">=</span> <span class="token number">1000</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scheduledTask3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务3执行时间："</span><span class="token operator">+</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"定时任务3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务3结束时间："</span><span class="token operator">+</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>注：</strong></p><ul><li>corn表达式在linux使用广泛，具体可以参考<a href="https://www.cnblogs.com/javahr/p/8318728.html" target="_blank" rel="noopener">cron表达式详解</a>以及在线<a href="https://tool.lu/crontab/" target="_blank" rel="noopener">Cron表达式生成器</a></li><li>initialDelay：启动后多久开始执行，单位时毫秒</li><li>fixedRate：下次执行时间，任务开始运行的时候就计时</li><li>fixedDelay：下次执行时间，fixedDelay等任务进行完了才开始计时，上一次执行结束时间点后xx秒再次执行</li><li>fixedDelayString:  字符串形式，可以通过配置文件指定</li></ul></li></ol><h3 id="9-2-SpringBoot异步任务"><a href="#9-2-SpringBoot异步任务" class="headerlink" title="9.2-SpringBoot异步任务"></a>9.2-SpringBoot异步任务</h3><ol><li><p>启动类里面使用@EnableAsync注解开启功能，自动扫描</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@EnableAsync</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Application<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="2"><li><p>定义异步任务类并使用@Component标记组件被容器扫描,异步方法加上@Async</p><pre><code>    注意点：           1）要把异步任务封装到类里面，不能直接写到Controller           2）增加Future&lt;String&gt; 返回结果 AsyncResult&lt;String&gt;(&quot;task执行完成&quot;);             3）如果需要拿到结果 需要判断全部的 task.isDone()</code></pre><p><code>@EnableAsync</code> 表示支持异步任务，springboot对于异步，定时，缓存，切面等的配置都是通过在启动类上加 @EnableXXX来配置的。</p><p><code>@Async</code>表示该方法会异步执行，也就是说主线程会直接跳过该方法，而是使用线程池中的线程来执行该方法。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AsyncTask</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Async</span>    <span class="token keyword">public</span> Future<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">execTaskA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"TaskA开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> star <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"TaskA结束，耗时毫秒数："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> star<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AsyncResult</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"TaskA结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Async</span>    <span class="token keyword">public</span> Future<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">execTaskB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"TaskB开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> star <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"TaskB结束，耗时毫秒数："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> star<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AsyncResult</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"TaskB结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Async</span>    <span class="token keyword">public</span> Future<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">execTaskC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"TaskC开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> star <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">4000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"TaskC结束，耗时毫秒数："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> star<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AsyncResult</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"TaskC结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="3"><li><p>通过注入方式，注入到controller里面，如果测试前后区别则改为同步则把Async注释掉</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TaskController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> AsyncTask asyncTask<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/testTask"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务开始，当前时间"</span> <span class="token operator">+</span>star <span class="token punctuation">)</span><span class="token punctuation">;</span>        Future<span class="token operator">&lt;</span>String<span class="token operator">></span> taskA <span class="token operator">=</span> asyncTask<span class="token punctuation">.</span><span class="token function">execTaskA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Future<span class="token operator">&lt;</span>String<span class="token operator">></span> taskB <span class="token operator">=</span> asyncTask<span class="token punctuation">.</span><span class="token function">execTaskB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Future<span class="token operator">&lt;</span>String<span class="token operator">></span> taskC <span class="token operator">=</span> asyncTask<span class="token punctuation">.</span><span class="token function">execTaskC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//间隔一秒轮询 直到 A B C 全部完成</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>taskA<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> taskB<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> taskC<span class="token punctuation">.</span><span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"任务结束，当前时间"</span> <span class="token operator">+</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"总耗时："</span><span class="token operator">+</span><span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="9-3-SpringBootz整合Quartz"><a href="#9-3-SpringBootz整合Quartz" class="headerlink" title="9.3-SpringBootz整合Quartz"></a>9.3-SpringBootz整合Quartz</h3><p>Quartz是一款功能强大的任务调度器，可以实现较为复杂的调度功能，如每月一号执行、每天凌晨执行、每周五执行等等，还支持分布式调度。本文使用Springboot+Mybatis+Quartz实现对定时任务的增、删、改、查、启用、停用等功能。并把定时任务持久化到数据库以及支持集群。</p><h4 id="Quartz的3个基本要素"><a href="#Quartz的3个基本要素" class="headerlink" title="Quartz的3个基本要素"></a>Quartz的3个基本要素</h4><ul><li>Scheduler：调度器。所有的调度都是由它控制。</li><li>Trigger： 触发器。决定什么时候来执行任务。</li><li>JobDetail &amp; Job： JobDetail定义的是任务数据，而真正的执行逻辑是在Job中。使用JobDetail + Job而不是Job，这是因为任务是有可能并发执行，如果Scheduler直接使用Job，就会存在对同一个Job实例并发访问的问题。而JobDetail &amp; Job 方式，sheduler每次执行，都会根据JobDetail创建一个新的Job实例，这样就可以规避并发访问的问题。</li></ul><ol><li><p>引入依赖jar包</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--QuartZ--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-quartz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li></ol><ol start="2"><li><p>添加配置application-quartz.yml</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#配置数据源</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.jdbc.Driver    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/testquartz<span class="token punctuation">?</span>serverTimezone=UTC<span class="token important">&amp;useSSL</span>=false<span class="token important">&amp;useUnicode</span>=true<span class="token important">&amp;characterEncoding</span>=UTF<span class="token punctuation">-</span><span class="token number">8</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> root    <span class="token key atrule">password</span><span class="token punctuation">:</span> password  <span class="token key atrule">quartz</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#持久化到数据库方式</span>    <span class="token key atrule">job-store-type</span><span class="token punctuation">:</span> jdbc    <span class="token key atrule">initialize-schema</span><span class="token punctuation">:</span> embedded    <span class="token key atrule">properties</span><span class="token punctuation">:</span>      <span class="token key atrule">org</span><span class="token punctuation">:</span>        <span class="token key atrule">quartz</span><span class="token punctuation">:</span>          <span class="token key atrule">scheduler</span><span class="token punctuation">:</span>            <span class="token key atrule">instanceName</span><span class="token punctuation">:</span> MyScheduler            <span class="token key atrule">instanceId</span><span class="token punctuation">:</span> AUTO          <span class="token key atrule">jobStore</span><span class="token punctuation">:</span>            <span class="token key atrule">class</span><span class="token punctuation">:</span> org.quartz.impl.jdbcjobstore.JobStoreTX            <span class="token key atrule">driverDelegateClass</span><span class="token punctuation">:</span> org.quartz.impl.jdbcjobstore.StdJDBCDelegate            <span class="token key atrule">tablePrefix</span><span class="token punctuation">:</span> QRTZ_            <span class="token key atrule">isClustered</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>            <span class="token key atrule">clusterCheckinInterval</span><span class="token punctuation">:</span> <span class="token number">10000</span>            <span class="token key atrule">useProperties</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>          <span class="token key atrule">threadPool</span><span class="token punctuation">:</span>            <span class="token key atrule">class</span><span class="token punctuation">:</span> org.quartz.simpl.SimpleThreadPool            <span class="token key atrule">threadCount</span><span class="token punctuation">:</span> <span class="token number">10</span>         <span class="token key atrule">threadPriority</span><span class="token punctuation">:</span> <span class="token number">5</span>            <span class="token key atrule">threadsInheritContextClassLoaderOfInitializingThread</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre></li><li><p>实现<code>Job</code>接口并且在<code>execute</code>方法中实现自己的业务逻辑</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloworldJob</span> <span class="token keyword">extends</span> <span class="token class-name">QuartzJobBean</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    HelloworldService helloworldService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">executeInternal</span><span class="token punctuation">(</span>JobExecutionContext jobExecutionContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> JobExecutionException <span class="token punctuation">{</span>        helloworldService<span class="token punctuation">.</span><span class="token function">printHelloWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello world! :"</span> <span class="token operator">+</span> jobExecutionContext<span class="token punctuation">.</span><span class="token function">getJobDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>添加配置类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuartzConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> JobDetail <span class="token function">myJobDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        JobDetail jobDetail <span class="token operator">=</span> JobBuilder<span class="token punctuation">.</span><span class="token function">newJob</span><span class="token punctuation">(</span>HiJob<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span><span class="token string">"myJob1"</span><span class="token punctuation">,</span><span class="token string">"myJobGroup1"</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//JobDataMap可以给任务execute传递参数</span>                <span class="token punctuation">.</span><span class="token function">usingJobData</span><span class="token punctuation">(</span><span class="token string">"job_param"</span><span class="token punctuation">,</span><span class="token string">"job_param1"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">storeDurably</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> jobDetail<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Trigger <span class="token function">myTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Trigger trigger <span class="token operator">=</span> TriggerBuilder<span class="token punctuation">.</span><span class="token function">newTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">forJob</span><span class="token punctuation">(</span><span class="token function">myJobDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">withIdentity</span><span class="token punctuation">(</span><span class="token string">"myTrigger1"</span><span class="token punctuation">,</span><span class="token string">"myTriggerGroup1"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">usingJobData</span><span class="token punctuation">(</span><span class="token string">"job_trigger_param"</span><span class="token punctuation">,</span><span class="token string">"job_trigger_param1"</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">startNow</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//.withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(5).repeatForever())</span>                <span class="token punctuation">.</span><span class="token function">withSchedule</span><span class="token punctuation">(</span>CronScheduleBuilder<span class="token punctuation">.</span><span class="token function">cronSchedule</span><span class="token punctuation">(</span><span class="token string">"0/5 * * * * ? 2018"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> trigger<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>Quartz使用同一组数据库表作集群只需要配置相同的<code>instanceName</code>实例名称，以及设置<code>org.quartz.jobStore.isClustered = true</code><br>启动两个节点后关闭其中正在跑任务的节点，另一个节点会自动检测继续运行定时任务</p></li></ol><p>注：多任务的问题，多个<code>JobDetail</code>使用同一个<code>Trigger</code>报错：<code>Trigger does not reference given job!</code></p><p>​        一个Job可以对应多个Trigger，但多个Job绑定一个Trigger报错。</p><h2 id="10-Logback日志框架介绍和SpringBoot整合"><a href="#10-Logback日志框架介绍和SpringBoot整合" class="headerlink" title="10-Logback日志框架介绍和SpringBoot整合"></a>10-Logback日志框架介绍和SpringBoot整合</h2><h3 id="10-1-新日志框架LogBack介绍"><a href="#10-1-新日志框架LogBack介绍" class="headerlink" title="10.1-新日志框架LogBack介绍"></a>10.1-新日志框架LogBack介绍</h3><ol><li><p>常用处理java的日志组件 slf4j,log4j,logback,common-logging 等</p></li><li><p>logback介绍：</p><p>​    基于Log4j基础上大量改良，不能单独使用，推荐配合日志框架SLF4J来使用<br>​    logback当前分成三个模块：logback-core,logback-classic和logback-access;<br>​    logback-core是其它两个模块的基础模块</p></li><li><p>Logback的核心对象：</p><pre><code>Logger：日志记录器   Appender：指定日志输出的目的地，目的地可以是控制台，文件   Layout：日志布局 格式化日志信息的输出</code></pre></li><li><p>日志级别：DEBUG &lt; INFO &lt; WARN &lt; ERROR</p><pre class=" language-properties"><code class="language-properties"><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span>log4j示例<span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span><span class="token punctuation">=</span>        <span class="token comment" spellcheck="true">### 设置###</span><span class="token attr-name">log4j.rootLogger</span> <span class="token punctuation">=</span> <span class="token attr-value">debug,stdout,D,E</span><span class="token comment" spellcheck="true">### 输出信息到控制抬 ###</span><span class="token attr-name">log4j.appender.stdout</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.ConsoleAppender</span><span class="token attr-name">log4j.appender.stdout.Target</span> <span class="token punctuation">=</span> <span class="token attr-value">System.out</span><span class="token attr-name">log4j.appender.stdout.layout</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.stdout.layout.ConversionPattern</span> <span class="token punctuation">=</span> <span class="token attr-value">[%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n</span><span class="token comment" spellcheck="true">### 输出DEBUG 级别以上的日志到=D://logs/error.log ###</span><span class="token attr-name">log4j.appender.D</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.DailyRollingFileAppender</span><span class="token attr-name">log4j.appender.D.File</span> <span class="token punctuation">=</span> <span class="token attr-value">D://logs/log.log</span><span class="token attr-name">log4j.appender.D.Append</span> <span class="token punctuation">=</span> <span class="token attr-value">true</span><span class="token attr-name">log4j.appender.D.Threshold</span> <span class="token punctuation">=</span> <span class="token attr-value">DEBUG </span><span class="token attr-name">log4j.appender.D.layout</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.D.layout.ConversionPattern</span> <span class="token punctuation">=</span> <span class="token attr-value">%-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n</span><span class="token comment" spellcheck="true">### 输出ERROR 级别以上的日志到=D://logs/error.log ###</span><span class="token attr-name">log4j.appender.E</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.DailyRollingFileAppender</span><span class="token attr-name">log4j.appender.E.File</span> <span class="token punctuation">=</span><span class="token attr-value">E://logs/error.log </span><span class="token attr-name">log4j.appender.E.Append</span> <span class="token punctuation">=</span> <span class="token attr-value">true</span><span class="token attr-name">log4j.appender.E.Threshold</span> <span class="token punctuation">=</span> <span class="token attr-value">ERROR </span><span class="token attr-name">log4j.appender.E.layout</span> <span class="token punctuation">=</span> <span class="token attr-value">org.apache.log4j.PatternLayout</span><span class="token attr-name">log4j.appender.E.layout.ConversionPattern</span> <span class="token punctuation">=</span> <span class="token attr-value">%-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n </span></code></pre></li><li><p>Log4j日志转换为logback在线工具（支持log4j.properties转换为logback.xml,不支持 log4j.xml转换为logback.xml） <a href="https://logback.qos.ch/translator/" target="_blank" rel="noopener">https://logback.qos.ch/translator/</a></p></li></ol><h3 id="10-2-SpringBoot2-x日志讲解和Logback"><a href="#10-2-SpringBoot2-x日志讲解和Logback" class="headerlink" title="10.2-SpringBoot2.x日志讲解和Logback"></a>10.2-SpringBoot2.x日志讲解和Logback</h3><ol><li><p>官网介绍：<a href="https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-logging" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-logging</a></p><p>各个组件案例：<a href="https://logback.qos.ch/manual/index.html" target="_blank" rel="noopener">https://logback.qos.ch/manual/index.html</a></p></li><li><p>分析SpringBoot启动日志</p><ul><li>默认情况下，Spring Boot将日志输出到控制台</li></ul></li><li><p>整合Logback实战</p><ul><li>创建 日志文件logback-spring.xml，官方推荐 -spring.xml结尾<br>默认加载加载配置顺序 logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy</li></ul></li><li><p>注释：</p><pre><code>&lt;configuration&gt; 子节点   &lt;appender&gt;&lt;/appender&gt;                          &lt;logger&gt;&lt;/logger&gt;   &lt;root&gt;&lt;/root&gt;(要加在最后)        </code></pre></li></ol><p><code>Logback.xml</code></p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span> <span class="token attr-name">debug</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">scan</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name">scanPeriod</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1 seconds<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>contextName</span><span class="token punctuation">></span></span>logback<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>contextName</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--定义参数,后面可以通过${app.name}使用--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app.name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>logback_test<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--ConsoleAppender 用于在屏幕上输出日志--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stdout<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--定义了一个过滤器,在LEVEL之下的日志输出不会被打印出来--></span>        <span class="token comment" spellcheck="true">&lt;!--这里定义了DEBUG，也就是控制台不会输出比ERROR级别小的日志--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.filter.ThresholdFilter<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>level</span><span class="token punctuation">></span></span>DEBUG<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>level</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- encoder 默认配置为PatternLayoutEncoder --></span>        <span class="token comment" spellcheck="true">&lt;!--定义控制台输出格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d [%thread] %-5level %logger{36} [%file : %line] - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--定义日志输出的路径--></span>        <span class="token comment" spellcheck="true">&lt;!--这里的scheduler.manager.server.home 没有在上面的配置中设定，所以会使用java启动时配置的值--></span>        <span class="token comment" spellcheck="true">&lt;!--比如通过 java -Dscheduler.manager.server.home=/path/to XXXX 配置该属性--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>file</span><span class="token punctuation">></span></span>${scheduler.manager.server.home}/logs/${app.name}.log<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>file</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--定义日志滚动的策略--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>rollingPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--定义文件滚动时的文件名的格式--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>fileNamePattern</span><span class="token punctuation">></span></span>${scheduler.manager.server.home}/logs/${app.name}.%d{yyyy-MM-dd.HH}.log.gz            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>fileNamePattern</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--60天的时间周期，日志量最大20GB--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxHistory</span><span class="token punctuation">></span></span>60<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxHistory</span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!-- 该属性在 1.1.6版本后 才开始支持--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>totalSizeCap</span><span class="token punctuation">></span></span>20GB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>totalSizeCap</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>rollingPolicy</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>triggeringPolicy</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token comment" spellcheck="true">&lt;!--每个日志文件最大100MB--></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>maxFileSize</span><span class="token punctuation">></span></span>100MB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>maxFileSize</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>triggeringPolicy</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--定义输出格式--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>encoder</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d [%thread] %-5level %logger{36} [%file : %line] - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>encoder</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--root是默认的logger 这里设定输出级别是debug--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>root</span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>trace<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--定义了两个appender，日志会通过往这两个appender里面写--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stdout<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>root</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--对于类路径以 com.example.logback 开头的Logger,输出级别设置为warn,并且只输出到控制台--></span>    <span class="token comment" spellcheck="true">&lt;!--这个logger没有指定appender，它会继承root节点中定义的那些appender--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.example.logback<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>warn<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--通过 LoggerFactory.getLogger("mytest") 可以获取到这个logger--></span>    <span class="token comment" spellcheck="true">&lt;!--由于这个logger自动继承了root的appender，root中已经有stdout的appender了，自己这边又引入了stdout的appender--></span>    <span class="token comment" spellcheck="true">&lt;!--如果没有设置 additivity="false" ,就会导致一条日志在控制台输出两次的情况--></span>    <span class="token comment" spellcheck="true">&lt;!--additivity表示要不要使用rootLogger配置的appender进行输出--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mytest<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span> <span class="token attr-name">additivity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender-ref</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stdout<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>logger</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--由于设置了 additivity="false" ，所以输出时不会使用rootLogger的appender--></span>    <span class="token comment" spellcheck="true">&lt;!--但是这个logger本身又没有配置appender，所以使用这个logger输出日志的话就不会输出到任何地方--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>logger</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mytest2<span class="token punctuation">"</span></span> <span class="token attr-name">level</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info<span class="token punctuation">"</span></span> <span class="token attr-name">additivity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre><h2 id="11-搜索框架ElasticSearch介绍和整合SpringBoot"><a href="#11-搜索框架ElasticSearch介绍和整合SpringBoot" class="headerlink" title="11-搜索框架ElasticSearch介绍和整合SpringBoot"></a>11-搜索框架ElasticSearch介绍和整合SpringBoot</h2><h3 id="11-1-搜索知识"><a href="#11-1-搜索知识" class="headerlink" title="11.1-搜索知识"></a>11.1-搜索知识</h3><ul><li><p>mysql：like 模糊，性能问题</p></li><li><p>solr:针对企业，Lucene</p></li><li><p><code>elasticsearch：</code></p><p>针对数据量特别大，PB,TB<br>纯java开发，springboot使用，5.6版本<br>es升级4-&gt;5版本，改动大，但是5版本后，改动不大</p></li></ul><h3 id="11-2-ElasticSearch介绍"><a href="#11-2-ElasticSearch介绍" class="headerlink" title="11.2-ElasticSearch介绍"></a>11.2-ElasticSearch介绍</h3><p>Elasticsearch(ES)是一个基于Apache的开源索引库Lucene而构建的开源、分布式、具有RESTful接口的全文搜索引擎, 还是一个分布式文档数据库.</p><p>ES可以轻松扩展数以百计的服务器(水平扩展), 用于存储和处理数据. 它可以在很短的时间内存储、搜索和分析海量数据, 通常被作为复杂搜索场景下的核心引擎.</p><p><strong>由于Lucene提供的API操作起来非常繁琐, 需要编写大量的代码, Elasticsearch对Lucene进行了封装与优化, 并提供了REST风格的操作接口, 开箱即用, 很大程度上方便了开发人员的使用.</strong></p><ul><li>elasticSearch主要特点<ol><li>特点：全文检索，结构化检索，数据统计、分析，接近实时处理，分布式搜索(可部署数百台服务器)，处理PB级别的数据，搜索纠错，自动完成</li><li>使用场景：日志搜索，数据聚合，数据监控，报表统计分析</li><li>国内外使用者：维基百科，Stack Overflow，GitHub</li></ol></li></ul><h3 id="11-3-SpringBoot整合ElasticSearch"><a href="#11-3-SpringBoot整合ElasticSearch" class="headerlink" title="11.3-SpringBoot整合ElasticSearch"></a>11.3-SpringBoot整合ElasticSearch</h3><ol><li>添加依赖</li></ol><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--elasticsearch--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-elasticsearch<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ol start="2"><li>配置文件</li></ol><pre class=" language-yml"><code class="language-yml">spring:  data:    elasticsearch:      cluster-name: esCluster      cluster-nodes: 127.0.0.1:9300       #配置es节点信息，逗号分隔，如果没有指定，则启动ClientNode（9200端口是http查询使用的。9300集群使用。这里使用9300.）</code></pre><ol start="3"><li>创建实体类bean</li></ol><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@Document</span><span class="token punctuation">(</span>indexName <span class="token operator">=</span> <span class="token string">"testgoods"</span><span class="token punctuation">,</span> type <span class="token operator">=</span> <span class="token string">"goods"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestGoodsBo</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//@Field(type = FieldType.Text)</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> BigDecimal price<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> stock<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Version</span>    <span class="token keyword">private</span> Long version<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>@Document注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Persistent</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Document</span> <span class="token punctuation">{</span>    String <span class="token function">indexName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//索引库的名称，个人建议以项目的名称命名</span>    String <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//类型，个人建议以实体的名称命名</span>    <span class="token keyword">short</span> <span class="token function">shards</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认分区数</span>    <span class="token keyword">short</span> <span class="token function">replicas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//每个分区默认的备份数</span>    String <span class="token function">refreshInterval</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"1s"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//刷新间隔</span>    String <span class="token function">indexStoreType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"fs"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//索引文件存储类型</span><span class="token punctuation">}</span></code></pre><p><code>@Document</code>作用于类上，经测试代码初始化时若es中没有对应的索引，则会在es中创建一个。</p></li><li><p>@Field注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Field</span> <span class="token punctuation">{</span>    FieldType <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> FieldType<span class="token punctuation">.</span>Auto<span class="token punctuation">;</span>#自动检测属性的类型    FieldIndex <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> FieldIndex<span class="token punctuation">.</span>analyzed<span class="token punctuation">;</span>#默认情况下分词    DateFormat <span class="token function">format</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> DateFormat<span class="token punctuation">.</span>none<span class="token punctuation">;</span>    String <span class="token function">pattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> <span class="token function">store</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>#默认情况下不存储原文    String <span class="token function">searchAnalyzer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>#指定字段搜索时使用的分词器    String <span class="token function">indexAnalyzer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>#指定字段建立索引时指定的分词器    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">ignoreFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>#如果某个字段需要被忽略    <span class="token keyword">boolean</span> <span class="token function">includeInParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>@Field</code>作用于属性上，经测试该注解的属性有时会与现有的属性冲突，造成异常，错误信息如下，所以建议es中映射已建立的情况下，不要使用该注解。</p></li><li><p><code>@Id</code>和<code>@Version</code>分别用来绑定es中的<code>_id</code>和<code>_version</code>字段。</p></li></ul><ol start="4"><li>创建Repository(接口继承ElasticSearchRepository)</li></ol><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">GoodsRepository</span> <span class="token keyword">extends</span> <span class="token class-name">ElasticsearchRepository</span><span class="token operator">&lt;</span>TestGoodsBo<span class="token punctuation">,</span>Long<span class="token operator">></span> <span class="token punctuation">,</span> PagingAndSortingRepository<span class="token operator">&lt;</span>TestGoodsBo<span class="token punctuation">,</span>Long<span class="token operator">></span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>TestGoodsBo<span class="token operator">></span> <span class="token function">findByNameAndPrice</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Long price<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>TestGoodsBo<span class="token operator">></span> <span class="token function">findByNameOrPrice</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Long price<span class="token punctuation">)</span><span class="token punctuation">;</span>        Page<span class="token operator">&lt;</span>TestGoodsBo<span class="token operator">></span> <span class="token function">findByName</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span>Pageable page<span class="token punctuation">)</span><span class="token punctuation">;</span>        Page<span class="token operator">&lt;</span>TestGoodsBo<span class="token operator">></span> <span class="token function">findByNameNot</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span>Pageable page<span class="token punctuation">)</span><span class="token punctuation">;</span>        Page<span class="token operator">&lt;</span>TestGoodsBo<span class="token operator">></span> <span class="token function">findByPriceBetween</span><span class="token punctuation">(</span><span class="token keyword">long</span> price<span class="token punctuation">,</span>Pageable page<span class="token punctuation">)</span><span class="token punctuation">;</span>        Page<span class="token operator">&lt;</span>TestGoodsBo<span class="token operator">></span> <span class="token function">findByNameLike</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span>Pageable page<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Query</span><span class="token punctuation">(</span><span class="token string">"{\"bool\" : {\"must\" : {\"term\" : {\"message\" : \"?0\"}}}}"</span><span class="token punctuation">)</span>        Page<span class="token operator">&lt;</span>TestGoodsBo<span class="token operator">></span> <span class="token function">findByMessage</span><span class="token punctuation">(</span>String message<span class="token punctuation">,</span> Pageable pageable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>es的操作主要通过自定义的Repository对象完成，该对象可以通过继承模板接口<code>ElasticsearchRepository</code>实现，该模板提供了<code>save</code>、<code>findById</code>、<code>findAll</code>和<code>search</code>等通用方法的实现，同时还支持通过规定的名称格式自定义操作方法.</p><ol start="5"><li>使用</li></ol><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/search"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SearchController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> GoodsRepository repository<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ElasticsearchTemplate elasticsearchTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/insert"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> TestGoodsBo <span class="token function">insert</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> TestGoodsBo bo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        repository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>bo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bo<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/get"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> TestGoodsBo <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Optional<span class="token operator">&lt;</span>TestGoodsBo<span class="token operator">></span> result <span class="token operator">=</span> repository<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>1L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/find"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>TestGoodsBo<span class="token operator">></span> <span class="token function">find</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span>Pageable page<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> repository<span class="token punctuation">.</span><span class="token function">findByName</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/search"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Page<span class="token operator">&lt;</span>TestGoodsBo<span class="token operator">></span> <span class="token function">search</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token annotation punctuation">@PageableDefault</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">,</span> sort <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"id"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> direction <span class="token operator">=</span> Sort<span class="token punctuation">.</span>Direction<span class="token punctuation">.</span>DESC<span class="token punctuation">)</span>Pageable pageable<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//        //通过ElasticsearchTemplate实现</span><span class="token comment" spellcheck="true">//        QueryBuilder queryBuilder = QueryBuilders.matchQuery("name", name);</span><span class="token comment" spellcheck="true">//        SearchQuery searchQuery = new NativeSearchQueryBuilder().withQuery(queryBuilder).withHighlightFields().build();</span><span class="token comment" spellcheck="true">//        Page&lt;TestGoodsBo> sampleEntities = elasticsearchTemplate.queryForPage(searchQuery, TestGoodsBo.class);</span><span class="token comment" spellcheck="true">//        //Pageable对象的手动实现</span><span class="token comment" spellcheck="true">//        Sort sort = new Sort(Sort.Direction.ASC,"name");</span><span class="token comment" spellcheck="true">//        Pageable page = PageRequest.of(0,10,sort);</span>        Page<span class="token operator">&lt;</span>TestGoodsBo<span class="token operator">></span> sampleEntities <span class="token operator">=</span> repository<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>QueryBuilders<span class="token punctuation">.</span><span class="token function">matchQuery</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">,</span>pageable<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sampleEntities<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol start="6"><li>Pageable对象</li></ol><p>该对象可以帮助我们完成分页和排序操作，有手动和自动两种方式实现：</p><ul><li><p>手动</p><pre class=" language-java"><code class="language-java"> Sort sort <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sort</span><span class="token punctuation">(</span>Sort<span class="token punctuation">.</span>Direction<span class="token punctuation">.</span>ASC<span class="token punctuation">,</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Pageable page <span class="token operator">=</span> PageRequest<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span>sort<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>自动</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/search"</span><span class="token punctuation">)</span><span class="token keyword">public</span> Page<span class="token operator">&lt;</span>TestGoodsBo<span class="token operator">></span> <span class="token function">search</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token annotation punctuation">@PageableDefault</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">,</span> sort <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">"id"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> direction <span class="token operator">=</span> Sort<span class="token punctuation">.</span>Direction<span class="token punctuation">.</span>DESC<span class="token punctuation">)</span>Pageable pageable<span class="token punctuation">)</span></code></pre><p>自动方式可以在request传参的同时就根据传入的参数来组装<code>Pageable</code>对象，同时还能使用<code>@PageableDefault</code>注解设定默认值，因此更推荐使用。</p><p>Spring支持的request参数如下：</p><ul><li><p>page，第几页，从0开始，默认为第0页</p></li><li><p>size，每一页的大小，默认为20</p></li><li><p>sort，排序相关的信息，例如sort=firstname&amp;sort=lastname,desc表示在按firstname正序排列基础上按lastname倒序排列</p></li></ul></li></ul><h2 id="12-消息队列介绍和SpringBoot整合RockketMQ、ActiveMQ"><a href="#12-消息队列介绍和SpringBoot整合RockketMQ、ActiveMQ" class="headerlink" title="12-消息队列介绍和SpringBoot整合RockketMQ、ActiveMQ"></a>12-消息队列介绍和SpringBoot整合RockketMQ、ActiveMQ</h2><h3 id="12-1-JMS介绍和使用场景及基础编程模型"><a href="#12-1-JMS介绍和使用场景及基础编程模型" class="headerlink" title="12.1-JMS介绍和使用场景及基础编程模型"></a>12.1-JMS介绍和使用场景及基础编程模型</h3><ol><li><p>什么是JMS？</p><p>Java消息服务（Java Message Service),Java平台中关于面向消息中间件的接口</p></li><li><p>JMS是一种与厂商无关的 API，用来访问消息收发系统消息，它类似于JDBC(Java Database Connectivity)。这里，JDBC 是可以用来访问许多不同关系数据库的 API</p></li><li><p>使用场景</p><ul><li>跨平台 </li><li>多语言 </li><li>多项目</li><li>解耦</li><li>分布式事务</li><li>流量控制</li><li>最终一致性</li><li>RPC调用</li></ul></li><li><p>概念</p><ul><li>JMS提供者：Apache ActiveMQ、RabbitMQ、Kafka、Notify、MetaQ、RocketMQ</li><li>JMS生产者(Message Producer)</li><li>JMS消费者(Message Consumer)</li><li>JMS消息</li><li>JMS队列</li><li>JMS主题</li></ul><p>JMS消息通常有两种类型：<code>点对点</code>、<code>发布/订阅</code></p></li><li><p>编程模型</p><p>MQ中需要用的一些类</p><pre><code>ConnectionFactory ：连接工厂，JMS 用它创建连接Connection ：JMS 客户端到JMS Provider 的连接Session： 一个发送或接收消息的线程Destination ：消息的目的地;消息发送给谁MessageConsumer / MessageProducer： 消息接收者，消费者</code></pre></li></ol><h3 id="12-2-ActiveMQ消息队列基础介绍"><a href="#12-2-ActiveMQ消息队列基础介绍" class="headerlink" title="12.2-ActiveMQ消息队列基础介绍"></a>12.2-ActiveMQ消息队列基础介绍</h3><p>ActiveMQ是一种开源的基于JMS规范的一种消息中间件的实现，ActiveMQ的设计目标是提供标准的，面向消息的，能够跨越多语言和多系统的应用集成消息通信中间件。</p><p><strong>特点：</strong></p><ul><li>支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议</li><li>支持许多高级功能，如消息组，虚拟目标，通配符和复合目标</li><li>完全支持JMS 1.1和J2EE 1.4，支持瞬态，持久，事务和XA消息</li><li>Spring支持，ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置</li><li>支持在流行的J2EE服务器（如TomEE，Geronimo，JBoss，GlassFish和WebLogic）中进行测试</li><li>使用JDBC和高性能日志支持非常快速的持久化</li></ul><h3 id="12-3-SpringBoot2整合ActiveMQ实战之点对点消息"><a href="#12-3-SpringBoot2整合ActiveMQ实战之点对点消息" class="headerlink" title="12.3-SpringBoot2整合ActiveMQ实战之点对点消息"></a>12.3-SpringBoot2整合ActiveMQ实战之点对点消息</h3><ol><li><p>添加依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 整合消息队列ActiveMQ --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-activemq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- 如果配置线程池则加入 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.activemq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>activemq-pool<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>配置文件</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#整合jms测试，安装在别的机器，防火墙和端口号记得开放</span><span class="token attr-name">spring.activemq.broker-url</span><span class="token punctuation">=</span><span class="token attr-value">tcp://127.0.0.1:61616</span><span class="token comment" spellcheck="true">#集群配置</span><span class="token comment" spellcheck="true">#spring.activemq.broker-url=failover:(tcp://localhost:61616,tcp://localhost:61617)</span><span class="token attr-name">spring.activemq.user</span><span class="token punctuation">=</span><span class="token attr-value">admin</span><span class="token attr-name">spring.activemq.password</span><span class="token punctuation">=</span><span class="token attr-value">admin</span><span class="token comment" spellcheck="true">#下列配置要增加依赖</span><span class="token attr-name">spring.activemq.pool.enabled</span><span class="token punctuation">=</span><span class="token attr-value">true</span><span class="token attr-name">spring.activemq.pool.max-connections</span><span class="token punctuation">=</span><span class="token attr-value">100</span></code></pre></li><li><p>启动类添加@EnableJms注解</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableJms</span> <span class="token comment" spellcheck="true">//启动消息队列</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ProductApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>QueueConfig定义消息队列</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> javax<span class="token punctuation">.</span>jms<span class="token punctuation">.</span>Queue<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>activemq<span class="token punctuation">.</span>command<span class="token punctuation">.</span>ActiveMQQueue<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Bean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token punctuation">;</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QueueConfig</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//定义存放消息的队列</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Queue <span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ActiveMQQueue</span><span class="token punctuation">(</span><span class="token string">"ActiveMQQueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>ProviderController测试</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductController</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注入存放消息的队列，用于下列方法一</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> Queue queue<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//注入springboot封装的工具类</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"send"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//方法一：添加消息到消息队列</span>        jmsMessagingTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//方法二：这种方式不需要手动创建queue，系统会自行创建名为test的队列</span>        <span class="token comment" spellcheck="true">//jmsMessagingTemplate.convertAndSend("test", message);</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>消费者应用</p><p>application.properties 和 ConsumerApplication 同 provider类似，如下为不同的ActiveConsumer：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ActiveConsumer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用JmsListener配置消费者监听的队列，其中message是接收到的消息</span>    <span class="token annotation punctuation">@JmsListener</span><span class="token punctuation">(</span>destination <span class="token operator">=</span> <span class="token string">"ActiveMQQueue"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// SendTo 会将此方法返回的数据, 写入到 OutQueue 中去.</span>    <span class="token annotation punctuation">@SendTo</span><span class="token punctuation">(</span><span class="token string">"SQueue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">handleMessage</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"成功接受message"</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"成功接受message"</span> <span class="token operator">+</span> message<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="7"><li>模拟请求 <code>localhost:8080/send?msg=123</code></li></ol><h3 id="12-4-SpringBoot整合ActiveMQ实战之发布订阅模式"><a href="#12-4-SpringBoot整合ActiveMQ实战之发布订阅模式" class="headerlink" title="12.4-SpringBoot整合ActiveMQ实战之发布订阅模式"></a>12.4-SpringBoot整合ActiveMQ实战之发布订阅模式</h3><ol><li><p>需要加入配置文件，支持发布订阅模型，默认只支持点对点</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#default point to point</span><span class="token comment" spellcheck="true">#默认消费者并不会消费订阅发布类型的消息，这是由于springboot默认采用的是p2p模式进行消息的监听</span><span class="token attr-name">spring.jms.pub-sub-domain</span><span class="token punctuation">=</span><span class="token attr-value">true</span></code></pre></li><li><p>新建JMS配置类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JmsConfig</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String TOPIC <span class="token operator">=</span> <span class="token string">"springboot.topic.test"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> String QUEUE <span class="token operator">=</span> <span class="token string">"springboot.queue.test"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Topic <span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ActiveMQTopic</span><span class="token punctuation">(</span>TOPIC<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Queue <span class="token function">queue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ActiveMQQueue</span><span class="token punctuation">(</span>QUEUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// topic模式的ListenerContainer</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> JmsListenerContainerFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">jmsListenerContainerTopic</span><span class="token punctuation">(</span>ConnectionFactory activeMQConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        DefaultJmsListenerContainerFactory bean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultJmsListenerContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bean<span class="token punctuation">.</span><span class="token function">setPubSubDomain</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bean<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>activeMQConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// queue模式的ListenerContainer</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> JmsListenerContainerFactory<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">jmsListenerContainerQueue</span><span class="token punctuation">(</span>ConnectionFactory activeMQConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        DefaultJmsListenerContainerFactory bean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultJmsListenerContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bean<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>activeMQConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>生产者</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token punctuation">(</span><span class="token string">"producer"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> JmsMessagingTemplate jmsTemplate<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 发送消息，destination是发送到的队列，message是待发送的消息</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>Destination destination<span class="token punctuation">,</span> <span class="token keyword">final</span> String message<span class="token punctuation">)</span><span class="token punctuation">{</span>        jmsTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span>destination<span class="token punctuation">,</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>消费者类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>JMSConsumer3<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@JmsListener</span><span class="token punctuation">(</span>destination <span class="token operator">=</span> JmsConfig<span class="token punctuation">.</span>TOPIC<span class="token punctuation">,</span>containerFactory <span class="token operator">=</span> <span class="token string">"jmsListenerContainerTopic"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onTopicMessage1</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"接收到topic消息：{}"</span><span class="token punctuation">,</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token annotation punctuation">@JmsListener</span><span class="token punctuation">(</span>destination <span class="token operator">=</span> JmsConfig<span class="token punctuation">.</span>TOPIC<span class="token punctuation">,</span>containerFactory <span class="token operator">=</span> <span class="token string">"jmsListenerContainerTopic"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onTopicMessage2</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"接收到topic消息：{}"</span><span class="token punctuation">,</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@JmsListener</span><span class="token punctuation">(</span>destination <span class="token operator">=</span> JmsConfig<span class="token punctuation">.</span>QUEUE<span class="token punctuation">,</span>containerFactory <span class="token operator">=</span> <span class="token string">"jmsListenerContainerQueue"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onQueueMessage</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"接收到queue消息：{}"</span><span class="token punctuation">,</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>测试</p><pre class=" language-java"><code class="language-java">        <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> Topic topic<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> Queue queue<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testJms</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            jmsProducer<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span><span class="token string">"queue,world!"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            jmsProducer<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> <span class="token string">"topic,world!"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre></li></ol><h3 id="12-5-RocketMQ消息队列介绍"><a href="#12-5-RocketMQ消息队列介绍" class="headerlink" title="12.5-RocketMQ消息队列介绍"></a>12.5-RocketMQ消息队列介绍</h3><p>RocketMQ 是一款分布式、队列模型的消息中间件</p><p><strong>特点：</strong></p><ul><li>在高压下1毫秒内响应延迟超过99.6％。</li><li>适合金融类业务，高可用性跟踪和审计功能。</li><li>支持发布订阅模型，和点对点</li><li>支持拉pull和推push两种消息模式</li><li>单一队列百万消息</li><li>支持单master节点，多master节点，多master多slave节点</li></ul><p><strong>概念：</strong></p><ul><li>Producer:消息生产者</li><li>Producer Group:消息生产者组，发送同类消息的一个消息生产组</li><li>Consumer:消费者</li><li>Consumer Group:消费同个消息的多个实例</li><li>Tag:标签，子主题（二级分类）,用于区分同一个主题下的不同业务的消息</li><li>Topic:主题</li><li>Message：消息</li><li>Broker：MQ程序，接收生产的消息，提供给消费者消费的程序</li><li>Name Server：给生产和消费者提供路由信息，提供轻量级的服务发现和路由    </li></ul><p><strong>官网地址</strong>：<a href="http://rocketmq.apache.org/" target="_blank" rel="noopener">http://rocketmq.apache.org/</a></p><h3 id="12-6-Springboot2整合RocketMQ4-x实战"><a href="#12-6-Springboot2整合RocketMQ4-x实战" class="headerlink" title="12.6-Springboot2整合RocketMQ4.x实战"></a>12.6-Springboot2整合RocketMQ4.x实战</h3><ol><li><p>添加依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.rocketmq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>rocketmq-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>配置文件</p><pre class=" language-yml"><code class="language-yml">rocketmq:  # 生产者配置  producer:    isOnOff: on    # 发送同一类消息的设置为同一个group，保证唯一    groupName: FeePlatGroup    # 服务地址    namesrvAddr: 10.1.1.207:9876    # 消息最大长度 默认1024*4(4M)    maxMessageSize: 4096    # 发送消息超时时间,默认3000    sendMsgTimeout: 3000    # 发送消息失败重试次数，默认2    retryTimesWhenSendFailed: 2  # 消费者配置  consumer:    isOnOff: on    # 官方建议：确保同一组中的每个消费者订阅相同的主题。    groupName: FeePlatGroup    # 服务地址    namesrvAddr: 10.1.1.207:9876    # 接收该 Topic 下所有 Tag    topics: FangPlatTopic~*;    consumeThreadMin: 20    consumeThreadMax: 64    # 设置一次消费消息的条数，默认为1条    consumeMessageBatchMaxSize: 1# 配置 Group  Topic  Tagfang-plat:  fang-plat-group: FangPlatGroup  fang-plat-topic: FangPlatTopic  fang-account-tag: FangAccountTag</code></pre></li><li><p>生产者配置</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//RocketMQ生产者配置</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProducerConfig</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger LOG <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>ProducerConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${rocketmq.producer.groupName}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String groupName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${rocketmq.producer.namesrvAddr}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String namesrvAddr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${rocketmq.producer.maxMessageSize}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Integer maxMessageSize <span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${rocketmq.producer.sendMsgTimeout}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Integer sendMsgTimeout<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${rocketmq.producer.retryTimesWhenSendFailed}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> Integer retryTimesWhenSendFailed<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> DefaultMQProducer <span class="token function">getRocketMQProducer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        DefaultMQProducer producer<span class="token punctuation">;</span>        producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>groupName<span class="token punctuation">)</span><span class="token punctuation">;</span>        producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>namesrvAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果需要同一个jvm中不同的producer往不同的mq集群发送消息，需要设置不同的instanceName</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>maxMessageSize<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            producer<span class="token punctuation">.</span><span class="token function">setMaxMessageSize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>maxMessageSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sendMsgTimeout<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            producer<span class="token punctuation">.</span><span class="token function">setSendMsgTimeout</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sendMsgTimeout<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果发送消息失败，设置重试次数，默认为2次</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>retryTimesWhenSendFailed<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            producer<span class="token punctuation">.</span><span class="token function">setRetryTimesWhenSendFailed</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>retryTimesWhenSendFailed<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MQClientException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> producer<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>消费者配置</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//消费者配置</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsumerConfig</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger LOG <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>ConsumerConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${rocketmq.consumer.namesrvAddr}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String namesrvAddr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${rocketmq.consumer.groupName}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String groupName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${rocketmq.consumer.consumeThreadMin}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> consumeThreadMin<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${rocketmq.consumer.consumeThreadMax}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> consumeThreadMax<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${rocketmq.consumer.topics}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> String topics<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${rocketmq.consumer.consumeMessageBatchMaxSize}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> consumeMessageBatchMaxSize<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> RocketMsgListener msgListener<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> DefaultMQPushConsumer <span class="token function">getRocketMQConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        DefaultMQPushConsumer consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQPushConsumer</span><span class="token punctuation">(</span>groupName<span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span>namesrvAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">setConsumeThreadMin</span><span class="token punctuation">(</span>consumeThreadMin<span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">setConsumeThreadMax</span><span class="token punctuation">(</span>consumeThreadMax<span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">registerMessageListener</span><span class="token punctuation">(</span>msgListener<span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">setConsumeFromWhere</span><span class="token punctuation">(</span>ConsumeFromWhere<span class="token punctuation">.</span>CONSUME_FROM_LAST_OFFSET<span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">setConsumeMessageBatchMaxSize</span><span class="token punctuation">(</span>consumeMessageBatchMaxSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> topicTagsArr <span class="token operator">=</span> topics<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">";"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>String topicTags <span class="token operator">:</span> topicTagsArr<span class="token punctuation">)</span> <span class="token punctuation">{</span>                String<span class="token punctuation">[</span><span class="token punctuation">]</span> topicTag <span class="token operator">=</span> topicTags<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topicTag<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>topicTag<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            consumer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MQClientException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> consumer<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>消费者监听配置</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//消费监听配置</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RocketMsgListener</span> <span class="token keyword">implements</span> <span class="token class-name">MessageListenerConcurrently</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger LOGGER <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>RocketMsgListener<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> ParamConfigService paramConfigService <span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> ConsumeConcurrentlyStatus <span class="token function">consumeMessage</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>MessageExt<span class="token operator">></span> list<span class="token punctuation">,</span> ConsumeConcurrentlyContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> ConsumeConcurrentlyStatus<span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        MessageExt messageExt <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"接受到的消息为："</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>messageExt<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> reConsume <span class="token operator">=</span> messageExt<span class="token punctuation">.</span><span class="token function">getReconsumeTimes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 消息已经重试了3次，如果不需要再次消费，则返回成功</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>reConsume <span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> ConsumeConcurrentlyStatus<span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>messageExt<span class="token punctuation">.</span><span class="token function">getTopic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>paramConfigService<span class="token punctuation">.</span>feePlatTopic<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String tags <span class="token operator">=</span> messageExt<span class="token punctuation">.</span><span class="token function">getTags</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>            <span class="token keyword">switch</span> <span class="token punctuation">(</span>tags<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">case</span> <span class="token string">"FeeAccountTag"</span><span class="token operator">:</span>                    LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"开户 tag == >>"</span><span class="token operator">+</span>tags<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span> <span class="token punctuation">;</span>                <span class="token keyword">default</span><span class="token operator">:</span>                    LOGGER<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"未匹配到Tag == >>"</span><span class="token operator">+</span>tags<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 消息消费成功</span>        <span class="token keyword">return</span> ConsumeConcurrentlyStatus<span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>配置参数绑定</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ParamConfigService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${fang-plat.fang-plat-group}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String fangPlatGroup <span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${fang-plat.fang-plat-topic}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String fangPlatTopic <span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${fang-plat.fang-account-tag}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String fangAccountTag <span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>测试</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FeePlatMqServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">FeePlatMqService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> DefaultMQProducer defaultMQProducer<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Resource</span>    <span class="token keyword">private</span> ParamConfigService paramConfigService <span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> SendResult <span class="token function">openAccountMsg</span><span class="token punctuation">(</span>String msgInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 可以不使用Config中的Group</span>        defaultMQProducer<span class="token punctuation">.</span><span class="token function">setProducerGroup</span><span class="token punctuation">(</span>paramConfigService<span class="token punctuation">.</span>fangPlatGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>        SendResult sendResult <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Message sendMsg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span>paramConfigService<span class="token punctuation">.</span>fangPlatTopic<span class="token punctuation">,</span>                                          paramConfigService<span class="token punctuation">.</span>fangAccountTag<span class="token punctuation">,</span>                                         <span class="token string">"fang_open_account_key"</span><span class="token punctuation">,</span> msgInfo<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            sendResult <span class="token operator">=</span> defaultMQProducer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>sendMsg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sendResult <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="13-SpringBoot多环境配置"><a href="#13-SpringBoot多环境配置" class="headerlink" title="13-SpringBoot多环境配置"></a>13-SpringBoot多环境配置</h2><h3 id="13-1-SpringBoot多环境配置介绍"><a href="#13-1-SpringBoot多环境配置介绍" class="headerlink" title="13.1-SpringBoot多环境配置介绍"></a>13.1-SpringBoot多环境配置介绍</h3><ol><li>不同环境使用不同配置<br>例如数据库配置，在开发的时候，我们一般用开发数据库，而在生产环境的时候，我们是用正式的数据</li><li>配置文件存放路径<br><code>classpath</code>根目录的“/config”包下<br><code>classpath</code>的根目录下</li><li>spring boot允许通过命名约定按照一定的格式<code>(application-{profile}.properties)</code>来定义多个配置文件</li><li><code>spring.profiles.active=dev</code>来指定加载哪个环境的配置文件</li></ol><h2 id="14-SpringBoot2-0响应式编程（Webflux）"><a href="#14-SpringBoot2-0响应式编程（Webflux）" class="headerlink" title="14-SpringBoot2.0响应式编程（Webflux）"></a>14-SpringBoot2.0响应式编程（Webflux）</h2><h3 id="14-1-什么是reactive响应式编程（反应式编程）？"><a href="#14-1-什么是reactive响应式编程（反应式编程）？" class="headerlink" title="14.1-什么是reactive响应式编程（反应式编程）？"></a>14.1-什么是reactive响应式编程（反应式编程）？</h3><p>是一种异步编程范式，它关注数据流和变化的传播。这意味着可以通过使用编程语言轻松地表示静态（例如数组）和动态（例如事件发射器）数据流。</p><p>响应式编程是一种流行的编程方法，编写代码是基于对变化的反应。它的灵感来自于我们的日常生活，也即我们如何采取行动以及与他人沟通。</p><p>我们在执行日常生活活动时，我们会尽可能多任务，但大脑无法处理多任务，不管我们如何努力去做。我们人类实现多任务的唯一办法是在时间线上在任务之间切换。事实上，我们总是切换任务，即使我们没有意识到它。</p><p>例如，要执行一个任务：在星巴克喝一杯咖啡饮料，你需要发出一个命令，等待它准备好，然后接受你的饮料。当你在等待的时候，你很可能会找到别的事情做。这是最简单的执行任务的反应(响应)形式，你会在你等待来自咖啡师的“响应”时做别的事情，当你的咖啡已经准备好后，会叫你的名字时。</p><p>响应编程能够简化编程，它依赖于事件，代码运行的顺序不是代码行的顺序，而是和一个以上的事件有关，这些事件发生是以随着时间的推移的序列。我们把这一系列事件称为“流”。</p><p>何为事件？例如，你知道某个名人总是在发送有趣微博，每次他推发一条微博我们可以称之为一个“事件”。如果你看看这位名人微博系列，你会发现其实是一个随着时间的推移（一系列的事件）发生的一序列的“事件”，响应式编程就是因为我们得“响应”这些事件而得以命名。</p><ul><li>依赖于事件，事件驱动(Event-driven)</li><li>一系列事件称为“流”</li><li>异步</li><li>非阻塞</li><li>观察者模式</li></ul><p><strong>例子</strong></p><p><code>int A = B + C;</code></p><p>A被赋值为B和C的值。这时，如果我们改变B的值，A的值并不会随之改变。而如果我们运用一种机制，当B或者C的值发现变化的时候，A的值也随之改变，这样就实现了”响应式“。</p><h3 id="14-2-SpringBoot2-x响应式编程webflux介绍"><a href="#14-2-SpringBoot2-x响应式编程webflux介绍" class="headerlink" title="14.2-SpringBoot2.x响应式编程webflux介绍"></a>14.2-SpringBoot2.x响应式编程webflux介绍</h3><ol><li><p>Spring WebFlux是Spring Framework 5.0中引入的新的反应式Web框架，与Spring MVC不同，它不需要Servlet API，完全异步和非阻塞，并 通过Reactor项目实现Reactive Streams规范。</p><ul><li><p>传统的Servlet</p><p>servlet由servlet container进行生命周期管理。container启动时构造servlet对象并调用servlet init()进行初始化；container关闭时调用servlet destory()销毁servlet；container运行时接受请求，并为每个请求分配一个线程（一般从线程池中获取空闲线程）然后调用service()。</p><p><img src="/2019/12/25/springboot-bi-ji-er/servlet.png" alt="Servlet结构"></p></li></ul></li></ol><pre><code> **缺点：** servlet是一个简单的网络编程模型，当请求进入servlet container时，servlet container就会为其绑定一个线程，在并发不高的场景下这种模型是适用的，但是一旦并发上升，线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大）严重影响请求的处理时间。在一些简单的业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型就较为吃力。 **例如：** spring webmvc是基于servlet之上的一个路由模型，即spring实现了处理所有request请求的一个servlet（DispatcherServlet），并由该servlet进行路由。所以spring webmvc无法摆脱servlet模型的弊端。</code></pre><ul><li><p>Webflux</p><p>Webflux模式替换了旧的Servlet线程模型。用少量的线程处理request和response io操作，这些线程称为Loop线程，而业务交给响应式编程框架处理，响应式编程是非常灵活的，用户可以将业务中阻塞的操作提交到响应式框架的work线程中执行，而不阻塞的操作依然可以在Loop线程中进行处理，大大提高了Loop线程的利用率。</p><p><img src="/2019/12/25/springboot-bi-ji-er/webflux.png" alt="webflux"></p><p>Spring WebFlux是Spring Framework 5.0中引入的新的反应式Web框架，与Spring MVC不同，它不需要Servlet API，完全异步和非阻塞，并 通过Reactor项目实现Reactive Streams规范。</p><p><img src="/2019/12/25/springboot-bi-ji-er/mvc%E5%92%8Cwebflux.png" alt="mvc和webflux"></p><p><strong>响应式与非响应式区别：</strong></p><p><img src="/2019/12/25/springboot-bi-ji-er/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%92%8C%E9%9D%9E%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8C%BA%E5%88%AB.png" alt="SpringBoot中响应式和非响应式"></p></li></ul><ol start="2"><li><p>Flux和Mono</p><ul><li><p>简单业务而言：和其他普通对象差别不大，复杂请求业务，就可以提升性能</p></li><li><p>通俗理解：</p><ul><li><p>Mono 表示的是包含 0 或者 1 个元素的异步序列</p><p><code>mono-&gt;单一对象 User  如： redis-&gt;用户ID-&gt;唯一的用户Mono&lt;User&gt;</code> </p></li><li><p>Flux 表示的是包含 0 到 N 个元素的异步序列</p><p><code>flux-&gt;数组列表对象 List&lt;User&gt;  如： redis-&gt;男性用户-&gt;Flux&lt;User&gt;</code></p></li><li><p>Flux 和 Mono 之间可以进行转换</p></li></ul></li></ul></li><li><p>Spring WebFlux有两种风格：基于功能和基于注解的。基于注解非常接近Spring MVC模型</p><ul><li><p>基于注解的方式</p><p><strong>业务层Service：</strong>调用了ReactiveRedisTemplate对数据进行操作</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReactiveServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">ReactiveService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ReactiveRedisTemplate reactiveRedisTemplate<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String USER_KEY <span class="token operator">=</span> <span class="token string">"entity:user"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Flux<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> reactiveRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span>USER_KEY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">queryByUUID</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> reactiveRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>USER_KEY<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> <span class="token function">add</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String uuid <span class="token operator">=</span> <span class="token function">generateUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setUuid</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> reactiveRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>USER_KEY<span class="token punctuation">,</span>user<span class="token punctuation">.</span><span class="token function">getUuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> String <span class="token function">generateUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> <span class="token function">update</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> reactiveRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>USER_KEY<span class="token punctuation">,</span>user<span class="token punctuation">.</span><span class="token function">getUuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> <span class="token function">delete</span><span class="token punctuation">(</span>String uuid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> reactiveRedisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>Controller层：</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReactiveController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ReactiveService reactiveService<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 查询所有</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/find/all"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Flux<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> reactiveService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 查询单个</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/query/{uuid}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">queryByName</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"uuid"</span><span class="token punctuation">)</span> String uuid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> reactiveService<span class="token punctuation">.</span><span class="token function">queryByUUID</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 添加用户</span>    <span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/add"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> reactiveService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 更新用户</span>    <span class="token annotation punctuation">@PutMapping</span><span class="token punctuation">(</span><span class="token string">"/update"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> reactiveService<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 删除用户</span>    <span class="token annotation punctuation">@DeleteMapping</span><span class="token punctuation">(</span><span class="token string">"/delete/{uuid}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>Boolean<span class="token operator">></span> <span class="token function">delete</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"uuid"</span><span class="token punctuation">)</span> String uuid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> reactiveService<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>和使用mvc没有任何的区别，唯一的区别在于返回的对象是<code>Mono</code>和<code>Flux</code>，简单点理解，返回单个数据就是<code>Mono</code>，多个就使用<code>Flux</code>。</p><p>启动项目可以看到实际上使用的是<code>Netty</code>服务器</p></li><li><p>基于功能（函数式）</p><p>处理请求的类，实现具体的业务逻辑，接口 <code>ServerRequest</code> 表示的是一个 HTTP 请求体。通过ServerRequest 对象可获取到请求的相关信息，如请求路径、查询参数和请求内容等。方法 的返回值是一个 Mono<T extends serverresponse>对象。接口 <code>ServerResponse</code> 用来表示 HTTP 响应。ServerResponse 中包含了很多静态方法来创建不同 HTTP 状态码的响应对象。</T></p><p>涉及几个比较重要的类如：<code>RouterFunction、HandlerFunction和DispatcherHandler</code></p><p><code>RouterFunction</code>就是一个路由函数，可以理解为将请求和具体的<code>HandlerFunction</code>做一个映射；</p><ol><li><p>先创建<code>RouterFunction</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserFunctionRouter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserHandler userHandler<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"userRouter"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> RouterFunction <span class="token function">router</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        RouterFunction<span class="token operator">&lt;</span>ServerResponse<span class="token operator">></span> routerFunction <span class="token operator">=</span> <span class="token function">route</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/user/find/all"</span><span class="token punctuation">,</span> <span class="token function">accept</span><span class="token punctuation">(</span>MediaType<span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">,</span> userHandler<span class="token operator">:</span><span class="token operator">:</span>findAll<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token string">"/user/query/{uuid}"</span><span class="token punctuation">,</span> <span class="token function">accept</span><span class="token punctuation">(</span>MediaType<span class="token punctuation">.</span>APPLICATION_JSON<span class="token punctuation">)</span><span class="token punctuation">,</span> userHandler<span class="token operator">:</span><span class="token operator">:</span>queryByName<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">POST</span><span class="token punctuation">(</span><span class="token string">"/user/add"</span><span class="token punctuation">,</span> <span class="token function">accept</span><span class="token punctuation">(</span>MediaType<span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">,</span>userHandler<span class="token operator">:</span><span class="token operator">:</span>add<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">PUT</span><span class="token punctuation">(</span><span class="token string">"/user/update"</span><span class="token punctuation">,</span> <span class="token function">accept</span><span class="token punctuation">(</span>MediaType<span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">,</span>userHandler<span class="token operator">:</span><span class="token operator">:</span>update<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">DELETE</span><span class="token punctuation">(</span><span class="token string">"/user/delete/{uuid}"</span><span class="token punctuation">,</span><span class="token function">accept</span><span class="token punctuation">(</span>MediaType<span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">,</span> userHandler<span class="token operator">:</span><span class="token operator">:</span>delete<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> routerFunction<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>将具体的请求路径和具体的handler做了映射，这样会根据用户具体的请求路径找具体的handler，其实就是具体的方法。和mvc的@RequestMapping功能上是一样的。但是这个需要注意的是返回的结果是ServerResponse，请求是ServerRequest，这个也可以和mvc的HttpServletRequest、HttpServletResponse对应起来，都是封装用户的请求信息，其实和mvc都还是能对应起来的，只是编程方式不太一样。</p></li><li><p>然后创建<code>HandlerFunction</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserRepository userRepository<span class="token punctuation">;</span>    <span class="token keyword">public</span> Mono <span class="token function">findAll</span><span class="token punctuation">(</span>ServerRequest serverRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Flux<span class="token operator">&lt;</span>User<span class="token operator">></span> flux <span class="token operator">=</span> userRepository<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ServerResponse<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span>MediaType<span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span>flux<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 查询单个</span>    <span class="token keyword">public</span> Mono <span class="token function">queryByUUID</span><span class="token punctuation">(</span>ServerRequest serverRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String uuid <span class="token operator">=</span> serverRequest<span class="token punctuation">.</span><span class="token function">pathVariable</span><span class="token punctuation">(</span><span class="token string">"uuid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ServerResponse<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span>MediaType<span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span>userRepository<span class="token punctuation">.</span><span class="token function">queryByUUID</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span><span class="token punctuation">,</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 添加用户</span>    <span class="token keyword">public</span> Mono <span class="token function">add</span><span class="token punctuation">(</span>ServerRequest serverRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将请求体转成指定Momo对象</span>        Mono<span class="token operator">&lt;</span>User<span class="token operator">></span> mono <span class="token operator">=</span> serverRequest<span class="token punctuation">.</span><span class="token function">bodyToMono</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String uuid <span class="token operator">=</span> <span class="token function">generateUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 方法2</span>        Mono<span class="token operator">&lt;</span>Object<span class="token operator">></span> safeUser <span class="token operator">=</span> mono<span class="token punctuation">.</span><span class="token function">doOnNext</span><span class="token punctuation">(</span>u <span class="token operator">-</span><span class="token operator">></span> u<span class="token punctuation">.</span><span class="token function">setUuid</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>user <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span><span class="token keyword">return</span> userRepository<span class="token punctuation">.</span><span class="token function">saveUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        User user = createUser(serverRequest);</span>        <span class="token keyword">return</span> ServerResponse<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contentType</span><span class="token punctuation">(</span>MediaType<span class="token punctuation">.</span>APPLICATION_JSON_UTF8<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span>safeUser<span class="token punctuation">,</span>Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//方法1</span><span class="token comment" spellcheck="true">//        Mono&lt;User> userMono = mono.doOnNext(u -> u.setUuid(uuid)).doOnSuccess(user -> userRepository.saveNoReturn(user));</span><span class="token comment" spellcheck="true">//        return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON_UTF8).body(userMono,User.class);</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> User <span class="token function">createUser</span><span class="token punctuation">(</span>ServerRequest serverRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> userId <span class="token operator">=</span> serverRequest<span class="token punctuation">.</span><span class="token function">queryParam</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> userName <span class="token operator">=</span> serverRequest<span class="token punctuation">.</span><span class="token function">queryParam</span><span class="token punctuation">(</span><span class="token string">"userName"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> age <span class="token operator">=</span> serverRequest<span class="token punctuation">.</span><span class="token function">queryParam</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> sex <span class="token operator">=</span> serverRequest<span class="token punctuation">.</span><span class="token function">queryParam</span><span class="token punctuation">(</span><span class="token string">"sex"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> uuid <span class="token operator">=</span> serverRequest<span class="token punctuation">.</span><span class="token function">queryParam</span><span class="token punctuation">(</span><span class="token string">"uuid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>userId<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> user<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>userName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> user<span class="token punctuation">.</span><span class="token function">setUserName</span><span class="token punctuation">(</span>userName<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>age<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>age<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sex<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> user<span class="token punctuation">.</span><span class="token function">setSex</span><span class="token punctuation">(</span>sex<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            user<span class="token punctuation">.</span><span class="token function">setUuid</span><span class="token punctuation">(</span>uuid<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            user<span class="token punctuation">.</span><span class="token function">setUuid</span><span class="token punctuation">(</span><span class="token function">generateUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> user<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 更新用户</span>    <span class="token keyword">public</span> Mono <span class="token function">update</span><span class="token punctuation">(</span>ServerRequest serverRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Mono<span class="token operator">&lt;</span>User<span class="token operator">></span> mono <span class="token operator">=</span> serverRequest<span class="token punctuation">.</span><span class="token function">bodyToMono</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token function">createUser</span><span class="token punctuation">(</span>serverRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ServerResponse<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span>userRepository<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">,</span>Boolean<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 删除用户</span>    <span class="token keyword">public</span> Mono <span class="token function">delete</span><span class="token punctuation">(</span>ServerRequest serverRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String uuid <span class="token operator">=</span> serverRequest<span class="token punctuation">.</span><span class="token function">pathVariable</span><span class="token punctuation">(</span><span class="token string">"uuid"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ServerResponse<span class="token punctuation">.</span><span class="token function">ok</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span>userRepository<span class="token punctuation">.</span><span class="token function">delete</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span><span class="token punctuation">,</span>Long<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> String <span class="token function">generateUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol></li></ul></li><li><p>Spring WebFlux应用程序不严格依赖于Servlet API，因此它们不能作为war文件部署，也不能使用src/main/webapp目录</p></li><li><p>可以整合多个模板引擎</p><pre><code>除了REST Web服务外，您还可以使用Spring WebFlux提供动态HTML内容。Spring WebFlux支持各种模板技术，包括Thymeleaf，FreeMarker。</code></pre></li></ol><h3 id="14-3-SpringBoot2-x-webflux实战"><a href="#14-3-SpringBoot2-x-webflux实战" class="headerlink" title="14.3-SpringBoot2.x webflux实战"></a>14.3-SpringBoot2.x webflux实战</h3><ol><li><p>WebFlux中，请求和响应不再是WebMVC中的ServletRequest和ServletResponse，而是ServerRequest和ServerResponse</p></li><li><p>加入依赖，如果同时存在spring-boot-starter-web，则会优先用spring-boot-starter-web</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-webflux<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>编写测试类UserController</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api/v1/user"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/test"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Mono<span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span><span class="token string">"hello webflux!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>启动方式默认是Netty,8080端口</p><p>测试:localhost:8080/api/v1/user/test</p><p><img src="/2019/12/25/springboot-bi-ji-er/webflux%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png" alt="webflux测试结果"></p></li></ol><h3 id="14-4-WebFlux客户端WebClient"><a href="#14-4-WebFlux客户端WebClient" class="headerlink" title="14.4-WebFlux客户端WebClient"></a>14.4-WebFlux客户端WebClient</h3><p>WebClient是一个响应式客户端，它提供了RestTemplate的替代方法。它公开了一个功能齐全、流畅的API，并依赖于非阻塞I / O，使其能够比RestTemplate更高效地支持高并发性。WebClient非常适合流式的传输方案，并且依赖于较低级别的HTTP客户端库来执行请求，是可插拔的。</p><p><strong>与RestTemplate相比，WebClient是：</strong></p><ul><li>非阻塞，Reactive的，并支持更高的并发性和更少的硬件资源。</li><li>提供利用Java 8 lambdas的函数API。</li><li>支持同步和异步方案。</li><li>支持从服务器向上或向下流式传输。</li></ul><p>RestTemplate不适合在非阻塞应用程序中使用，因此Spring WebFlux应用程序应始终使用WebClient。在大多数高并发场景中，WebClient也应该是Spring MVC中的首选，并且用于编写一系列远程，相互依赖的调用。</p><p>Reactive方法：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> WebClient client <span class="token operator">=</span> WebClient<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"http://localhost:8080"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> Mono<span class="token operator">&lt;</span>User<span class="token operator">></span> <span class="token function">getUser</span><span class="token punctuation">(</span>Long id<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> client<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">uri</span><span class="token punctuation">(</span><span class="token string">"/user/{id}"</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>MediaType<span class="token punctuation">.</span>APPLICATION_JSON<span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">retrieve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span><span class="token function">bodyToMono</span><span class="token punctuation">(</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="15-SpringBoot2-0服务器端主动推送SSE技术"><a href="#15-SpringBoot2-0服务器端主动推送SSE技术" class="headerlink" title="15-SpringBoot2.0服务器端主动推送SSE技术"></a>15-SpringBoot2.0服务器端主动推送SSE技术</h2><h3 id="15-1-服务端推送常用技术介绍"><a href="#15-1-服务端推送常用技术介绍" class="headerlink" title="15.1-服务端推送常用技术介绍"></a>15.1-服务端推送常用技术介绍</h3><ol><li><p>客户端轮询:ajax定时拉取</p><p>ajax长时间和服务端保持通讯太占内存</p></li><li><p>服务端主动推送:WebSocket</p><pre><code>全双工的，本质上是一个额外的tcp连接，建立和关闭时握手使用http协议，其他数据传输不使用http协议   更加复杂一些，适用于需要进行复杂双向数据通讯的场景</code></pre><p>​    websocket可以进行服务端和前端双向通讯,写法较为复杂</p></li><li><p>服务端主动推送:SSE (Server Send Event)</p><pre><code>html5新标准，用来从服务端实时推送数据到浏览器端，   直接建立在当前http连接上，本质上是保持一个http长连接，轻量协议   简单的服务器数据推送的场景，使用服务器推送事件       学习资料：http://www.w3school.com.cn/html5/html_5_serversentevents.asp</code></pre></li></ol><h3 id="15-2-SpringBoot2-x服务端主动推送SSE"><a href="#15-2-SpringBoot2-x服务端主动推送SSE" class="headerlink" title="15.2-SpringBoot2.x服务端主动推送SSE"></a>15.2-SpringBoot2.x服务端主动推送SSE</h3><ol><li><p>后端代码</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SSEController</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//produces = "text/event-stream;charset=UTF-8"一定要带上</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/get_data"</span><span class="token punctuation">,</span> produces <span class="token operator">=</span> <span class="token string">"text/event-stream;charset=UTF-8"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">try</span> <span class="token punctuation">{</span>              Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token keyword">double</span> moeny <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%.2f"</span><span class="token punctuation">,</span>moeny<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          DecimalFormat df <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DecimalFormat</span><span class="token punctuation">(</span><span class="token string">".00"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          String price <span class="token operator">=</span> df<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>moeny<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//！！！注意，EventSource返回的参数必须以data:开头，"\n\n"结尾，不然onmessage方法无法执行。</span>          <span class="token keyword">return</span> <span class="token string">"data:猪肉价格行情:"</span> <span class="token operator">+</span> price <span class="token operator">+</span><span class="token string">"元"</span><span class="token operator">+</span> <span class="token string">"\n\n"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>前段代码</p><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Insert title here<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript">  <span class="token comment" spellcheck="true">//需要判断浏览器支不支持，可以去w3c进行查看</span><span class="token keyword">var</span> source <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventSource</span><span class="token punctuation">(</span><span class="token string">'/get_data'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>source<span class="token punctuation">.</span>onmessage <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> event<span class="token punctuation">.</span>data<span class="token punctuation">}</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>result<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre></li></ol><h2 id="16-SpringBoot2-x监控Actuator"><a href="#16-SpringBoot2-x监控Actuator" class="headerlink" title="16-SpringBoot2.x监控Actuator"></a>16-SpringBoot2.x监控Actuator</h2><p><code>Spring Boot Actuator</code>是<code>spring boot</code>项目一个监控模块，提供了很多原生的端点，包含了对应用系统的自省和监控的集成功能，可以查看应用配置的详细信息，比如<strong>应用程序上下文里全部的Bean</strong>、<strong>健康指标</strong>、<strong>环境变量</strong>及<strong>各类重要度量指标</strong>等等，这些都是使用可<code>HTTP</code>进行请求访问。通过这些监控信息，我们就能随时了解应用的运行情况了。</p><p>Actuator 是 Spring Boot 提供的对应用系统的自省和监控功能。通过 Actuator，可以使用数据化的指标去度量应用的运行情况，比如查看服务器的磁盘、内存、CPU等信息，系统的线程、gc、运行状态等等。</p><p>Actuator 通常通过使用 HTTP 和 JMX 来管理和监控应用，大多数情况使用 HTTP 的方式。</p><ol><li><p>添加依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>添加配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8080</span>  <span class="token key atrule">servlet</span><span class="token punctuation">:</span>    <span class="token key atrule">context-path</span><span class="token punctuation">:</span> /demo<span class="token comment" spellcheck="true"># actuator 监控配置</span><span class="token key atrule">management</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true">#actuator端口 如果不配置做默认使用上面8080端口</span>  <span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">9090</span>  <span class="token key atrule">endpoints</span><span class="token punctuation">:</span>    <span class="token key atrule">web</span><span class="token punctuation">:</span>      <span class="token key atrule">exposure</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#默认值访问health,info端点  用*可以包含全部端点</span>        <span class="token key atrule">include</span><span class="token punctuation">:</span> <span class="token string">"*"</span>      <span class="token comment" spellcheck="true">#修改访问路径 2.0之前默认是/; 2.0默认是/actuator可以通过这个属性值修改</span>      <span class="token key atrule">base-path</span><span class="token punctuation">:</span> /actuator</code></pre><p>配置完成启动项目后就可以通过postman或者直接在预览器输入路径等方式来查看应用的运行状态了。<br> 当项目启动时，访问<code>[http://127.0.0.1:9090/actuator]</code>地址</p><h5 id="注意：如果没有配置-actuator端口-采用默认访问地址：http-127-0-0-1-8080-demo-actuator"><a href="#注意：如果没有配置-actuator端口-采用默认访问地址：http-127-0-0-1-8080-demo-actuator" class="headerlink" title="注意：如果没有配置 actuator端口,采用默认访问地址：http://127.0.0.1:8080/demo/actuator"></a><code>注意：如果没有配置 actuator端口,采用默认访问地址：http://127.0.0.1:8080/demo/actuator</code></h5><p>如果看到类似下面的内容，说明actuator已经生效了</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>    <span class="token property">"_links"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"self"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"auditevents"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/auditevents"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"beans"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/beans"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"caches-cache"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/caches/{cache}"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"caches"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/caches"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"health"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/health"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"health-component"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/health/{component}"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"health-component-instance"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/health/{component}/{instance}"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"conditions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/conditions"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"configprops"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/configprops"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"env"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/env"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"env-toMatch"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/env/{toMatch}"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"info"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/info"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"loggers"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/loggers"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"loggers-name"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/loggers/{name}"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"heapdump"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/heapdump"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"threaddump"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/threaddump"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"metrics-requiredMetricName"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/metrics/{requiredMetricName}"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"metrics"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/metrics"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"scheduledtasks"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/scheduledtasks"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"httptrace"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/httptrace"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"mappings"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://127.0.0.1:9090/actuator/mappings"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>建议</p><ul><li><p>只能访问几个url</p><ul><li><p>访问的url在SpringBoot2.0版本需要加上actuator</p></li><li><p>需要在配置文件中加入下列配置<br><code>management.endpoints.web.exposure.include=*</code></p></li><li><p>官网说明：<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security-actuator" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security-actuator</a></p></li></ul><p><strong>原因：</strong><br>出于安全考虑，除/ health和/ info之外的所有执行器默认都是禁用的。  <code>management.endpoints.web.exposure.include</code>属性可用于启用执行器</p></li><li><p>建议<br>在设置management.endpoints.web.exposure.include之前，请确保暴露的执行器不包含敏感信息和/<br>或通过将其放置在防火墙进行控制，不对外进行使用</p><p>禁用的端点将从应用程序上下文中完全删除。如果您只想更改端点所暴露的技术，请改用 include和exclude属性<br><strong>例子：</strong></p><pre><code>开启全部：`management.endpoints.web.exposure.include=*`开启某个：`management.endpoints.web.exposure.include=metrics`关闭某个：`management.endpoints.web.exposure.exclude=metrics`</code></pre><p>或者用springadmin进行管理</p><pre><code>相关资料：https://www.cnblogs.com/ityouknow/p/8440455.html</code></pre><p>或者用自己编写脚本监控</p><pre><code>CPU、内存、磁盘、nginx的http响应状态码200,404,5xx </code></pre></li><li><p>介绍常用的几个</p><pre><code>`/health`     查看应用健康指标  `/actuator/metrics`    查看应用基本指标列表  `/actuator/metrics/{name}`        通过上述列表，查看具体 查看具体指标  `/actuator/env`        显示来自Spring的 ConfigurableEnvironment的属性    </code></pre></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot学习笔记1</title>
      <link href="/2019/12/25/springboot-bi-ji-yi/"/>
      <url>/2019/12/25/springboot-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="1、Spring-Boot概述"><a href="#1、Spring-Boot概述" class="headerlink" title="1、Spring Boot概述"></a>1、Spring Boot概述</h1><h2 id="1-1-Spring-Boot简介"><a href="#1-1-Spring-Boot简介" class="headerlink" title="1.1-Spring Boot简介"></a>1.1-Spring Boot简介</h2><ul><li>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程，J2EE开发的一站式解决方案。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</li><li>我们在使用Spring Boot时只需要配置相应的Spring Boot就可以用所有的Spring组件，简单的说，spring boot就是整合了很多优秀的框架，不用我们自己手动的去写一堆xml配置然后进行配置。从本质上来说，Spring Boot就是Spring，它做了那些没有它你也会去做的Spring Bean配置。</li></ul><h2 id="1-2-Spring-Boot特点"><a href="#1-2-Spring-Boot特点" class="headerlink" title="1.2-Spring Boot特点"></a>1.2-Spring Boot特点</h2><ol><li>为基于Spring的开发提供更快的入门体验</li><li>创建可以独立运行的Spring应用</li><li>直接嵌入Servlet容器Tomcat或Jetty服务器,不需要打包成WAR文件</li><li>提供推荐的基础POM文件来简化Apache Maven配置</li><li>尽可能的根据项目依赖来自动配置Spring框架</li><li>大量的自动配置，简化开发，也可以修改默认值</li><li>准生产环境的运行时应用监控，提供可以直接在生产环境中使用的功能,如性能指标,应用信息和应用健康检查</li><li>开箱即用,没有代码生成,也无需配置XML文件.同时可以修改默认值来特定需求</li><li>与云计算天然集成</li></ol><h2 id="1-3-单体应用与微服务"><a href="#1-3-单体应用与微服务" class="headerlink" title="1.3-单体应用与微服务"></a>1.3-单体应用与微服务</h2><h3 id="1-3-1-单体应用"><a href="#1-3-1-单体应用" class="headerlink" title="1.3.1. 单体应用"></a>1.3.1. 单体应用</h3><p>单体应用是把所有的应用模块都写在一个应用中，导致项目越写越大，模块之间的耦合度也会越来越高。<br></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><ul><li>便于共享：单个归档文件包含所有功能，便于在团队之间以及不同的部署阶段之间共享。</li><li>易于测试：单体应用一旦部署，所有的服务或特性就都可以使用了，这简化了测试过程，因为没有额外的依赖，每项测试都可以在部署完成后立刻开始。</li><li>易于部署：只需将单个归档文件复制到单个目录下。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>复杂性高：由于是单个归档文件，所以整个项目文件包含的模块非常多，导致模块的边界模糊、依赖关系不清晰、代码的质量参差不齐，混乱的堆在一起，使得整个项目非常复杂。以致每次修改代码，都非常小心，可能添加一个简单的功能，或者修改一个Bug都会带来隐藏的缺陷。</li><li>技术债务：随着时间的推移、需求的变更和技术人员的更替，会逐渐形成应用程序的技术债务，并且越积越多。</li><li>扩展能力受限：单体应用只能作为一个整体进行扩展，无法根据业务模块的需要进行伸缩。</li><li>阻碍技术创新：对于单体应用来说，技术是在开发之前经过慎重评估后选定的，每个团队成员都必须使用相同的开发语言、持久化存储及消息系统。</li></ul><h3 id="1-3-2-微服务"><a href="#1-3-2-微服务" class="headerlink" title="1.3.2. 微服务"></a>1.3.2. 微服务</h3><p>微服务是一种架构风格，用微服务可以将应用的模块单独部署，对不同的模块进行不同的管理操作，不同的模块生成小型服务，每个功能元素最后都可以成为一个可以独立替换、独立升级的功能单元，各个小型服务之间通过http进行通信。<br><br>微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制。这些服务围绕业务能力构建并且可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，服务可用不同的语言开发，使用不同的数据存储技术。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>易于开发和维护：一个微服务只会关注一个特定的业务功能，所以业务清晰、代码量较少。开发和维护单个微服务相对简单。</li><li>单个微服务应用启动较快。</li><li>局部修改容易部署：单体应用只要有修改，就得重新部署整个应用。微服务解决了这样的问题。一般来说，对某个微服务进行修改，只需要重新部署这个服务即可。</li><li>技术栈不受限制：在微服务架构中，可以结合项目业务及团队的特点，合理的选择技术栈。</li><li>按需伸缩：可根据需求，实现细粒度的扩展。</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>运维要求高：更多的服务意味着要投入更多的运维。</li><li>分布式固有的复杂性：使用微服务构建的是分布式系统。对于一个分布式系统，系统容错、网络延迟、分布式事务等都会带来巨大的问题。</li><li>接口调整成本高：微服务之间通过接口进行通信。如果修改某一个微服务的API，可能所有用到这个接口的微服务都需要进行调整。</li></ul><h2 id="1-4-Spring-Boot与微服务"><a href="#1-4-Spring-Boot与微服务" class="headerlink" title="1.4 Spring Boot与微服务"></a>1.4 Spring Boot与微服务</h2><ol><li>Spring boot不是微服务技术，Spring Cloud才是微服务技术。</li><li>spring boot只是一个用于加速开发spring应用的基础框架，简化工作，开发单块应用很适合。</li><li>如果要直接基于spring boot做微服务，相当于需要自己开发很多微服务的基础设施，比如基于zookeeper来实现服务注册和发现。</li></ol><h1 id="2、Spring-Boot入门"><a href="#2、Spring-Boot入门" class="headerlink" title="2、Spring Boot入门"></a>2、Spring Boot入门</h1><h2 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1-环境准备"></a>2.1-环境准备</h2><p>–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version “1.8.0_221”</p><p>–maven3.x：maven 3.3以上版本；Apache Maven 3.6.3</p><p>–IntelliJIDEA2019：IntelliJ IDEA 2019.3.2 x64、STS</p><h2 id="2-2-Hello-World"><a href="#2-2-Hello-World" class="headerlink" title="2.2-Hello World"></a>2.2-Hello World</h2><p>功能：浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p><ul><li>创建一个Maven工程（jar包）</li><li>导入spring boot相关的依赖</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.5.9.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><ul><li>编写一个启动类程序：用来启动Spring Boot应用</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *  @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorldMainApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Spring应用启动起来</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>HelloWorldMainApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>编写相关的Service和Controller</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloController</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>运行HelloWorld启动类进行测试</li><li>简化部署</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span></code></pre><p>使用这个插件将应用打成jar包，直接使用java -jar的命令进行执行；\</p><h2 id="2-3-Hello-World探究"><a href="#2-3-Hello-World探究" class="headerlink" title="2.3-Hello World探究"></a>2.3-Hello World探究</h2><h3 id="2-3-1-Pom-xml文件"><a href="#2-3-1-Pom-xml文件" class="headerlink" title="2.3.1-Pom.xml文件"></a>2.3.1-Pom.xml文件</h3><ol><li>父项目</li></ol><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.5.9.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>他的父项目是<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.5.9.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">></span></span>../../spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>relativePath</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span>他来真正管理Spring Boot应用里面的所有依赖版本；</code></pre><p>Spring Boot的版本仲裁中心；</p><p>以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p><ol start="2"><li>导入的依赖（启动器）</li></ol><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p><p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p><h3 id="2-3-2-主程序类（主入口类）"><a href="#2-3-2-主程序类（主入口类）" class="headerlink" title="2.3.2-主程序类（主入口类）"></a>2.3.2-主程序类（主入口类）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** *  @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用 */</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorldMainApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Spring应用启动起来</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>HelloWorldMainApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>@SpringBootApplication:</strong> Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> TypeExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>      <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> AutoConfigurationExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span></code></pre><p>@<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</p><p> 标注在某个类上，表示这是一个Spring Boot的配置类；@SpringBootConfiguration继承自@Configuration，二者功能也一致，标注当前类是配置类，<br>并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。</p><p> @<strong>Configuration</strong>:配置类上来标注这个注解；</p><p> 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component，@Configuration注解中是包含@Component注解的，被@Configuration修饰的类被定义为一个Spring容器（应用上下文）</p><p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p><p> 以前我们需要配置的东西，Spring Boot帮我们自动配置；@EnableAutoConfiguration告诉SpringBoot开启自动配置功能；这样自动配置才能生效；<br><br><br>SpringBoot一个最核心的观点就是，约定大于配置，这种看似降低了灵活度的方法，却大大简化了SpringBoot的开发过程。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@AutoConfigurationPackage</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>EnableAutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span> <span class="token punctuation">{</span>    String ENABLED_OVERRIDE_PROPERTY <span class="token operator">=</span> <span class="token string">"spring.boot.enableautoconfiguration"</span><span class="token punctuation">;</span></code></pre><p>@<strong>AutoConfigurationPackage</strong>：自动配置包</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;​ @<strong>Import(AutoConfigurationPackages.Registrar.class)</strong>：</p><p> Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；</p><p> <strong>将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</strong></p><p> @<strong>Import(EnableAutoConfigurationImportSelector.class)</strong>；</p><p> 给容器中导入组件,在这个类中，提供了一个getCandidateConfigurations()方法用来加载配置文件。借助Spring提供的工具类SpringFactories的loadFactoryNames()方法加载配置文件。扫描的默认路径位于META-INF/spring.factories中。</p><p> <strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p><p> 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；</p><p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p><p> <strong>SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)</strong>；</p><p>Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；以前我们需要自己配置的东西，自动配置类都帮我们；</p><p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；</p><h2 id="2-4-使用Spring-Initializer快速创建Spring-Boot项目"><a href="#2-4-使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="2.4 -使用Spring Initializer快速创建Spring Boot项目"></a>2.4 -使用Spring Initializer快速创建Spring Boot项目</h2><p>IDEA：使用 Spring Initializer快速创建项目<br>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p><p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p><p>默认生成的Spring Boot项目；</p><p>主程序已经生成好了，我们只需要我们自己的逻辑<br>resources文件夹中目录结构<br>static：保存所有的静态资源； js css images；<br>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；<br>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</p><h2 id="2-5-配置文件"><a href="#2-5-配置文件" class="headerlink" title="2.5-配置文件"></a>2.5-配置文件</h2><p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p><p>•application.properties</p><p>•application.yml</p><p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p><p>YAML（YAML Ain’t Markup Language）</p><p> YAML A Markup Language：是一个标记语言</p><p> YAML isn’t Markup Language：不是一个标记语言；</p><p>标记语言：</p><p> 以前的配置文件；大多都使用的是 xxxx.xml文件；</p><p> YAML：以数据为中心，比json、xml等更适合做配置文件；</p><p> YAML：配置例子</p><pre class=" language-yml"><code class="language-yml">server:  port: 8081</code></pre><p>XML：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>server</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>port</span><span class="token punctuation">></span></span>8081<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>port</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>server</span><span class="token punctuation">></span></span></code></pre><h2 id="2-6-Yaml语法"><a href="#2-6-Yaml语法" class="headerlink" title="2.6-Yaml语法"></a>2.6-Yaml语法</h2><h3 id="2-6-1-基本语法"><a href="#2-6-1-基本语法" class="headerlink" title="2.6.1-基本语法"></a>2.6.1-基本语法</h3><p>k:(空格)v：表示一对键值对（空格必须有）；</p><p>以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span> /hello</code></pre><p>属性和值也是大小写敏感；</p><h3 id="2-6-2-值的写法"><a href="#2-6-2-值的写法" class="headerlink" title="2.6.2-值的写法"></a>2.6.2-值的写法</h3><p>字面量：普通的值（数字，字符串，布尔）<br>​ k: v：字面直接来写；</p><p> 字符串默认不用加上单引号或者双引号；</p><p> “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p><ul><li><p>name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi</p><p>‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p></li><li><p>name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi</p></li></ul><p>对象、Map（属性和值）（键值对）：<br>​ k: v：在下一行来写对象的属性和值的关系；注意缩进</p><p> 对象还是k: v的方式</p><pre class=" language-yml"><code class="language-yml">friends:    lastName: zhangsan    age: 20</code></pre><p>行内写法：</p><pre class=" language-yml"><code class="language-yml">friends: {lastName: zhangsan,age: 18}</code></pre><p>数组（List、Set）：<br>用- 值表示数组中的一个元素</p><pre class=" language-yml"><code class="language-yml">pets: - cat - dog - pig</code></pre><p>行内写法：</p><pre class=" language-yml"><code class="language-yml">pets: [cat,dog,pig]</code></pre><h2 id="2-7-配置文件值注入"><a href="#2-7-配置文件值注入" class="headerlink" title="2.7-配置文件值注入"></a>2.7-配置文件值注入</h2><ul><li>配置文件：</li></ul><pre class=" language-yml"><code class="language-yml">person:    lastName: hello    age: 18    boss: false    birth: 2017/12/12    maps: {k1: v1,k2: 12}    lists:      - lisi      - zhaoliu    dog:      name: 小狗      age: 12</code></pre><ul><li>JavaBean</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； * */</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token keyword">private</span> Boolean boss<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birth<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> maps<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> lists<span class="token punctuation">;</span>    <span class="token keyword">private</span> Dog dog<span class="token punctuation">;</span></code></pre><p>我们可以导入配置文件处理器，以后编写配置就有提示了</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-configuration-processor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="2-7-1-Value获取值和-ConfigurationProperties获取值比较"><a href="#2-7-1-Value获取值和-ConfigurationProperties获取值比较" class="headerlink" title="2.7.1- @Value获取值和@ConfigurationProperties获取值比较"></a>2.7.1- @Value获取值和@ConfigurationProperties获取值比较</h3><table><thead><tr><th>header 1</th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个制定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p>配置文件yml还是properties他们都能获取到值；</p><ul><li>松散语法<br><ol><li>person.firstName: 使用标准模式</li><li>person.first-name: 大写用-</li><li>person.first_name: 大写用_</li><li>PERSON_FIRST_NAME: 推荐属性使用这种写法</li></ol></li></ul><p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p><p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p><h3 id="2-7-2-配置文件注入值数据校验"><a href="#2-7-2-配置文件注入值数据校验" class="headerlink" title="2.7.2-配置文件注入值数据校验"></a>2.7.2-配置文件注入值数据校验</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Validated</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * &lt;bean class="Person">     *      &lt;property name="lastName" value="字面量/${key}从环境变量、配置文件中获取值/#{SpEL}">&lt;/property>     * &lt;bean/>     */</span>   <span class="token comment" spellcheck="true">//lastName必须是邮箱格式</span>    <span class="token annotation punctuation">@Email</span>    <span class="token comment" spellcheck="true">//@Value("${person.last-name}")</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//@Value("#{11*2}")</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//@Value("true")</span>    <span class="token keyword">private</span> Boolean boss<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birth<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> maps<span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> lists<span class="token punctuation">;</span>    <span class="token keyword">private</span> Dog dog<span class="token punctuation">;</span></code></pre><h3 id="2-7-3-PropertySource-amp-ImportResource-amp-Bean"><a href="#2-7-3-PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="2.7.3-@PropertySource&amp;@ImportResource&amp;@Bean"></a>2.7.3-@PropertySource&amp;@ImportResource&amp;@Bean</h3><ul><li>@<strong>PropertySource</strong>：加载指定的属性文件（*.properties）到 Spring 的 Environment 中。</li></ul><ol><li>可以配合 @Value 和 @ConfigurationProperties 使用。<br>@PropertySource 和 @Value 组合使用，可以将自定义属性文件中的属性变量值注入到当前类的使用@Value注解的成员变量中。</li><li>@PropertySource 和 @ConfigurationProperties 组合使用，可以将属性文件与一个Java类绑定，将属性文件中的变量值注入到该Java类的成员变量中。</li></ol><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能； *  @ConfigurationProperties(prefix = "person")默认从全局配置文件中获取值； * */</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"classpath:person.properties"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//@Validated</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * &lt;bean class="Person">     *      &lt;property name="lastName" value="字面量/${key}从环境变量、配置文件中获取值/#{SpEL}">&lt;/property>     * &lt;bean/>     */</span>   <span class="token comment" spellcheck="true">//lastName必须是邮箱格式</span>   <span class="token comment" spellcheck="true">// @Email</span>    <span class="token comment" spellcheck="true">//@Value("${person.last-name}")</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//@Value("#{11*2}")</span>    <span class="token keyword">private</span> Integer age<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//@Value("true")</span>    <span class="token keyword">private</span> Boolean boss<span class="token punctuation">;</span></code></pre><ul><li>@ImportResource：导入Spring的配置文件，让配置文件里面的内容生效；</li></ul><p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p><p>想让Spring的配置文件生效，加载进来；@ImportResource标注在一个配置类上</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ImportResource</span><span class="token punctuation">(</span>locations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"classpath:beans.xml"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>导入Spring的配置文件让其生效</code></pre><p>不来编写Spring的配置文件</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>       <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>helloService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.atguigu.springboot.service.HelloService<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span></code></pre><p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p><p>1、配置类@<strong>Configuration</strong>——&gt;Spring配置文件</p><p>2、使用@<strong>Bean给容器中添加组件</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件 * * 在配置文件中用&lt;bean>&lt;bean/>标签添加组件 * */</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAppConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> HelloService <span class="token function">helloService02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"配置类@Bean给容器中添加组件了..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HelloService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-7-4-配置文件占位符"><a href="#2-7-4-配置文件占位符" class="headerlink" title="2.7.4-配置文件占位符"></a>2.7.4-配置文件占位符</h3><h4 id="1、随机数"><a href="#1、随机数" class="headerlink" title="1、随机数"></a>1、随机数</h4><pre class=" language-java"><code class="language-java">$<span class="token punctuation">{</span>random<span class="token punctuation">.</span>value<span class="token punctuation">}</span>、$<span class="token punctuation">{</span>random<span class="token punctuation">.</span><span class="token keyword">int</span><span class="token punctuation">}</span>、$<span class="token punctuation">{</span>random<span class="token punctuation">.</span><span class="token keyword">long</span><span class="token punctuation">}</span>$<span class="token punctuation">{</span>random<span class="token punctuation">.</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">}</span>、$<span class="token punctuation">{</span>random<span class="token punctuation">.</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">,</span><span class="token number">65536</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h4 id="2、占位符获取之前配置的值，如果没有可以是用-指定默认值"><a href="#2、占位符获取之前配置的值，如果没有可以是用-指定默认值" class="headerlink" title="2、占位符获取之前配置的值，如果没有可以是用:指定默认值"></a>2、占位符获取之前配置的值，如果没有可以是用:指定默认值</h4><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">person.dog.name</span><span class="token punctuation">=</span><span class="token attr-value">${person.hello:hello}_dog</span></code></pre><h2 id="2-8-Profile"><a href="#2-8-Profile" class="headerlink" title="2.8-Profile"></a>2.8-Profile</h2><p>Profile是Spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境</p><h3 id="2-8-1-多Profile文件"><a href="#2-8-1-多Profile文件" class="headerlink" title="2.8.1-多Profile文件"></a>2.8.1-多Profile文件</h3><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml</p><ul><li>application-dev.properties、application-st.properties、application-prod.properties</li></ul><p>默认使用application.properties的配置；</p><h3 id="2-8-2-yml支持多文档块方式"><a href="#2-8-2-yml支持多文档块方式" class="headerlink" title="2.8.2-yml支持多文档块方式"></a>2.8.2-yml支持多文档块方式</h3><pre class=" language-yml"><code class="language-yml">server:  port: 8081spring:  profiles:    active: prod---server:  port: 8083spring:  profiles: dev---server:  port: 8084spring:  profiles: prod  #指定属于哪个环境</code></pre><h3 id="2-8-3-激活指定profile"><a href="#2-8-3-激活指定profile" class="headerlink" title="2.8.3-激活指定profile"></a>2.8.3-激活指定profile</h3><ol><li><p>在配置文件中指定 </p><p><code>spring.profiles.active=dev</code></p></li><li><p>命令行：</p><p>java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev；</p><p>可以直接在测试的时候，配置传入命令行参数</p></li><li><p>虚拟机参数；</p><p><code>-Dspring.profiles.active=dev</code></p></li></ol><h2 id="2-9-配置文件加载位置"><a href="#2-9-配置文件加载位置" class="headerlink" title="2.9-配置文件加载位置"></a>2.9-配置文件加载位置</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><ul><li><p>file：当前项目根路径（<strong>访问路径需要加上项目名</strong>）</p></li><li><p>classpath：类路径（resources）</p><p>–file:./config/</p><p>–file:./</p><p>–classpath:/config/</p><p>–classpath:/</p></li></ul><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p><p>SpringBoot会从这四个位置全部加载主配置文件；互补配置；</p><p><code>我们还可以通过spring.config.location来改变默认的配置文件位置</code></p><p>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –spring.config.location=D:/application.properties</p><h2 id="2-10-外部配置加载顺序"><a href="#2-10-外部配置加载顺序" class="headerlink" title="2.10-外部配置加载顺序"></a>2.10-外部配置加载顺序</h2><p><code>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</code></p><p>1.命令行参数</p><p>所有的配置都可以在命令行上进行指定</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc</p><p>多个配置用空格分开； –配置项=值</p><p>2.来自java:comp/env的JNDI属性</p><p>3.Java系统属性（System.getProperties()）</p><p>4.操作系统环境变量</p><p>5.RandomValuePropertySource配置的random.*属性值</p><p><code>由jar包外向jar包内进行寻找；</code></p><p><code>优先加载带profile</code></p><p>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p><p>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</p><p><code>再来加载不带profile</code></p><p>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</p><p>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</p><p>10.@Configuration注解类上的@PropertySource</p><p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源：<a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p><h1 id="3-自动配置原理"><a href="#3-自动配置原理" class="headerlink" title="3-自动配置原理"></a>3-自动配置原理</h1><p>配置文件到底能写什么？怎么写？自动配置原理；<br>参考官方文档<a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件可以配置的属性参考</a></p><h2 id="3-1-自动配置原理"><a href="#3-1-自动配置原理" class="headerlink" title="3.1-自动配置原理"></a>3.1-自动配置原理</h2><p><strong>1. 当SpringBoot应用启动的时候，就从主方法里面进行启动的。</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringBootAutoConfigApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringBootAutoConfigApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。</p><p><strong>2. @EnableAutoConfiguration作用：</strong></p><ul><li>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？ </li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>EnableAutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span> </code></pre><ul><li>可以查看selectImports()方法的内容；</li><li>List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置</li></ul><pre class=" language-properties"><code class="language-properties">SpringFactoriesLoader.loadFactoryNames()<span class="token attr-name">扫描所有jar包类路径下</span> <span class="token attr-value"> META-INF/spring.factories</span>把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</code></pre><p><strong>3. 导入了哪些组件呢？</strong><br><br>我们来看EnableAutoConfigurationImportSelector这个类的父类<code>selectImports</code>;</p><p>父类里面规定了一个方法叫selectImports这个方法，查看了<code>selectImports这个方法</code>里面的代码内容就能知道导入了哪些组件了。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectImports</span><span class="token punctuation">(</span>AnnotationMetadata annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> NO_IMPORTS<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            AutoConfigurationMetadata autoConfigurationMetadata <span class="token operator">=</span> AutoConfigurationMetadataLoader                    <span class="token punctuation">.</span><span class="token function">loadMetadata</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>beanClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>            AnnotationAttributes attributes <span class="token operator">=</span> <span class="token function">getAttributes</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> configurations <span class="token operator">=</span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span>                    attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>            configurations <span class="token operator">=</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span>            configurations <span class="token operator">=</span> <span class="token function">sort</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> autoConfigurationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>            Set<span class="token operator">&lt;</span>String<span class="token operator">></span> exclusions <span class="token operator">=</span> <span class="token function">getExclusions</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">checkExcludedClasses</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>            configurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>            configurations <span class="token operator">=</span> <span class="token function">filter</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> autoConfigurationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">fireAutoConfigurationImportEvents</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> configurations<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>configurations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><p><code>这个configurations它是获取候选的配置。</code></p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> configurations <span class="token operator">=</span>        <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span>attributes<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>这个configurations方法的作用就是利用SpringFactoriesLoader.loadFactoryNames从类路径下得到一个个资源</code></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">loadFactoryNames</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> factoryClass<span class="token punctuation">,</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String factoryClassName <span class="token operator">=</span> factoryClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span> urls <span class="token operator">=</span> <span class="token punctuation">(</span>classLoader <span class="token operator">!=</span> null <span class="token operator">?</span> classLoader<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span> <span class="token operator">:</span>                    ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>4. 那么可以获取到哪些资源呢？</strong><br><br>它是扫描java <code>jar包类路径下</code>的“META-INF/spring.factories”这个文件</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * The location to look for factories.     * &lt;p>Can be present in multiple JAR files.     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String FACTORIES_RESOURCE_LOCATION <span class="token operator">=</span> <span class="token string">"META-INF/spring.factories"</span><span class="token punctuation">;</span></code></pre><ul><li><strong>扫描到的这些文件作用</strong>：是把这个文件的url拿到之后并把这些urls每一个遍历，最终把这些文件整成一个properties对象</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">loadFactoryNames</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> factoryClass<span class="token punctuation">,</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String factoryClassName <span class="token operator">=</span> factoryClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            Enumeration<span class="token operator">&lt;</span>URL<span class="token operator">></span> urls <span class="token operator">=</span> <span class="token punctuation">(</span>classLoader <span class="token operator">!=</span> null <span class="token operator">?</span> classLoader<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span> <span class="token operator">:</span>                    ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemResources</span><span class="token punctuation">(</span>FACTORIES_RESOURCE_LOCATION<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            List<span class="token operator">&lt;</span>String<span class="token operator">></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>urls<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                URL url <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Properties properties <span class="token operator">=</span> PropertiesLoaderUtils<span class="token punctuation">.</span><span class="token function">loadProperties</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UrlResource</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                String factoryClassNames <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span>factoryClassName<span class="token punctuation">)</span><span class="token punctuation">;</span>                result<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span>factoryClassNames<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span></code></pre><p>然后它从properties对象里边获取一些值，把这些获取到的值来加载我们最终要返回的这个结果，这个结果就是我们要交给Spring容器中的所有组件，这相当于这factoryClassName就是我们传过来的Class的这个类名。</p><p>而传过来的Class是调用这个getSpringFactoriesLoaderFactoryClass()这个方法得到从properties中获取到EnableAutoConfiguration.class类名对应的值，然后把它们添加在容器中</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getSpringFactoriesLoaderFactoryClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> EnableAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>5. 然后来到第二个Spring<br>jar包的META-INF下的spring.factories这个文件找到配置所有EnableAutoConfiguration的值加入到Spring容器中</strong></p><pre class=" language-java"><code class="language-java"># Auto Configureorg<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>EnableAutoConfiguration<span class="token operator">=</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>admin<span class="token punctuation">.</span>SpringApplicationAdminJmxAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>aop<span class="token punctuation">.</span>AopAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>amqp<span class="token punctuation">.</span>RabbitAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>batch<span class="token punctuation">.</span>BatchAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>CacheAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>cassandra<span class="token punctuation">.</span>CassandraAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>cloud<span class="token punctuation">.</span>CloudAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ConfigurationPropertiesAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>context<span class="token punctuation">.</span>MessageSourceAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>context<span class="token punctuation">.</span>PropertyPlaceholderAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>couchbase<span class="token punctuation">.</span>CouchbaseAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>dao<span class="token punctuation">.</span>PersistenceExceptionTranslationAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>cassandra<span class="token punctuation">.</span>CassandraDataAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>cassandra<span class="token punctuation">.</span>CassandraRepositoriesAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>couchbase<span class="token punctuation">.</span>CouchbaseDataAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>couchbase<span class="token punctuation">.</span>CouchbaseRepositoriesAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>ElasticsearchAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>ElasticsearchDataAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>ElasticsearchRepositoriesAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>JpaRepositoriesAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>ldap<span class="token punctuation">.</span>LdapDataAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>ldap<span class="token punctuation">.</span>LdapRepositoriesAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>mongo<span class="token punctuation">.</span>MongoDataAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>mongo<span class="token punctuation">.</span>MongoRepositoriesAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>neo4j<span class="token punctuation">.</span>Neo4jDataAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>neo4j<span class="token punctuation">.</span>Neo4jRepositoriesAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>solr<span class="token punctuation">.</span>SolrRepositoriesAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>RedisAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>RedisRepositoriesAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>rest<span class="token punctuation">.</span>RepositoryRestMvcAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>data<span class="token punctuation">.</span>web<span class="token punctuation">.</span>SpringDataWebAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>elasticsearch<span class="token punctuation">.</span>jest<span class="token punctuation">.</span>JestAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>freemarker<span class="token punctuation">.</span>FreeMarkerAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>gson<span class="token punctuation">.</span>GsonAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>h2<span class="token punctuation">.</span>H2ConsoleAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>hateoas<span class="token punctuation">.</span>HypermediaAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>hazelcast<span class="token punctuation">.</span>HazelcastAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>hazelcast<span class="token punctuation">.</span>HazelcastJpaDependencyAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>info<span class="token punctuation">.</span>ProjectInfoAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>integration<span class="token punctuation">.</span>IntegrationAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jackson<span class="token punctuation">.</span>JacksonAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>DataSourceAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>JdbcTemplateAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>JndiDataSourceAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>XADataSourceAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>DataSourceTransactionManagerAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jms<span class="token punctuation">.</span>JmsAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jmx<span class="token punctuation">.</span>JmxAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jms<span class="token punctuation">.</span>JndiConnectionFactoryAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jms<span class="token punctuation">.</span>activemq<span class="token punctuation">.</span>ActiveMQAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jms<span class="token punctuation">.</span>artemis<span class="token punctuation">.</span>ArtemisAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>flyway<span class="token punctuation">.</span>FlywayAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>groovy<span class="token punctuation">.</span>template<span class="token punctuation">.</span>GroovyTemplateAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jersey<span class="token punctuation">.</span>JerseyAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>jooq<span class="token punctuation">.</span>JooqAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>KafkaAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>ldap<span class="token punctuation">.</span>embedded<span class="token punctuation">.</span>EmbeddedLdapAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>ldap<span class="token punctuation">.</span>LdapAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>liquibase<span class="token punctuation">.</span>LiquibaseAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>MailSenderAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>mail<span class="token punctuation">.</span>MailSenderValidatorAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>mobile<span class="token punctuation">.</span>DeviceResolverAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>mobile<span class="token punctuation">.</span>DeviceDelegatingViewResolverAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>mobile<span class="token punctuation">.</span>SitePreferenceAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>mongo<span class="token punctuation">.</span>embedded<span class="token punctuation">.</span>EmbeddedMongoAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>mongo<span class="token punctuation">.</span>MongoAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>mustache<span class="token punctuation">.</span>MustacheAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>orm<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>HibernateJpaAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>reactor<span class="token punctuation">.</span>ReactorAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>security<span class="token punctuation">.</span>SecurityAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>security<span class="token punctuation">.</span>SecurityFilterAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>security<span class="token punctuation">.</span>FallbackWebSecurityAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>security<span class="token punctuation">.</span>oauth2<span class="token punctuation">.</span>OAuth2AutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>sendgrid<span class="token punctuation">.</span>SendGridAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>session<span class="token punctuation">.</span>SessionAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>social<span class="token punctuation">.</span>SocialWebAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>social<span class="token punctuation">.</span>FacebookAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>social<span class="token punctuation">.</span>LinkedInAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>social<span class="token punctuation">.</span>TwitterAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>solr<span class="token punctuation">.</span>SolrAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>thymeleaf<span class="token punctuation">.</span>ThymeleafAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>TransactionAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>transaction<span class="token punctuation">.</span>jta<span class="token punctuation">.</span>JtaAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>validation<span class="token punctuation">.</span>ValidationAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>DispatcherServletAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>EmbeddedServletContainerAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>ErrorMvcAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>HttpEncodingAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>HttpMessageConvertersAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>MultipartAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>ServerPropertiesAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>WebClientAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>web<span class="token punctuation">.</span>WebMvcAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>websocket<span class="token punctuation">.</span>WebSocketAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>websocket<span class="token punctuation">.</span>WebSocketMessagingAutoConfiguration<span class="token punctuation">,</span>\org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>autoconfigure<span class="token punctuation">.</span>webservices<span class="token punctuation">.</span>WebServicesAutoConfiguration</code></pre><p>每一个xxxAutoConfiguration类都是容器中的一个组件，并都加入到容器中。</p><p>加入到容器中之后的作用就是用它们来做自动配置，这就是Springboot自动配置之源，也就是自动配置的开始，只有这些自动配置类进入到容器中以后，接下来这个自动配置类才开始进行启动；<br></p><p><strong>6. 每一个自动配置类进行自动配置功能</strong><br></p><ul><li>以<strong>HttpEncodingAutoConfiguration</strong>(Http编码自动配置)为例解释自动配置原理；</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>   <span class="token comment" spellcheck="true">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span>HttpEncodingProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span><span class="token comment" spellcheck="true">//Spring底层@Conditional注解，根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span>CharacterEncodingFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</span><span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.http.encoding"</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"enabled"</span><span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span><span class="token comment" spellcheck="true">//即使我们配置文件中不配置spring.http.encoding.enabled=true，也是默认生效的；</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpEncodingAutoConfiguration</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//他已经和SpringBoot的配置文件映射了</span>      <span class="token keyword">private</span> <span class="token keyword">final</span> HttpEncodingProperties properties<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span>      <span class="token keyword">public</span> <span class="token function">HttpEncodingAutoConfiguration</span><span class="token punctuation">(</span>HttpEncodingProperties properties<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>properties <span class="token operator">=</span> properties<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Bean</span>       <span class="token comment" spellcheck="true">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>CharacterEncodingFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//判断容器没有这个组件？</span>    <span class="token keyword">public</span> CharacterEncodingFilter <span class="token function">characterEncodingFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        CharacterEncodingFilter filter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderedCharacterEncodingFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        filter<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span><span class="token function">getCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        filter<span class="token punctuation">.</span><span class="token function">setForceRequestEncoding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span><span class="token function">shouldForce</span><span class="token punctuation">(</span>Type<span class="token punctuation">.</span>REQUEST<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        filter<span class="token punctuation">.</span><span class="token function">setForceResponseEncoding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span><span class="token function">shouldForce</span><span class="token punctuation">(</span>Type<span class="token punctuation">.</span>RESPONSE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> filter<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>配置文件中该配置什么，我们就按照它的这个旨意，它要配spring.http.encoding这个属性，这个属性里边能配置什么值，就对应HttpEncodingProperties这个类来配置，所有的配置文件中能配置的属性都是在xxx.Properties类中封装着</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.http.encoding"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpEncodingProperties</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Charset DEFAULT_CHARSET <span class="token operator">=</span> Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Charset of HTTP requests and responses. Added to the "Content-Type" header if not     * set explicitly.     */</span>    <span class="token keyword">private</span> Charset charset <span class="token operator">=</span> DEFAULT_CHARSET<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Force the encoding to the configured charset on HTTP requests and responses.     */</span>    <span class="token keyword">private</span> Boolean force<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Force the encoding to the configured charset on HTTP requests. Defaults to true     * when "force" has not been specified.     */</span>    <span class="token keyword">private</span> Boolean forceRequest<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Force the encoding to the configured charset on HTTP responses.     */</span>    <span class="token keyword">private</span> Boolean forceResponse<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Locale to Encoding mapping.     */</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Locale<span class="token punctuation">,</span> Charset<span class="token operator">></span> mapping<span class="token punctuation">;</span>    <span class="token keyword">public</span> Charset <span class="token function">getCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>charset<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCharset</span><span class="token punctuation">(</span>Charset charset<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>charset <span class="token operator">=</span> charset<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isForce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Boolean<span class="token punctuation">.</span>TRUE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>force<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setForce</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> force<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>force <span class="token operator">=</span> force<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isForceRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Boolean<span class="token punctuation">.</span>TRUE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>forceRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setForceRequest</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> forceRequest<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>forceRequest <span class="token operator">=</span> forceRequest<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isForceResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Boolean<span class="token punctuation">.</span>TRUE<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>forceResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setForceResponse</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> forceResponse<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>forceResponse <span class="token operator">=</span> forceResponse<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>Locale<span class="token punctuation">,</span> Charset<span class="token operator">></span> <span class="token function">getMapping</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mapping<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMapping</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>Locale<span class="token punctuation">,</span> Charset<span class="token operator">></span> mapping<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mapping <span class="token operator">=</span> mapping<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>所以说配置文件能配置什么就可以参照某一个功能对应的这个属性类</code></p><p><strong>7. 这个HttpEncodingProperties类就是根据当前不同的条件判断，决定这个配置类是否生效。</strong></p><p>如果一旦生效了，所有的配置类都成功了，就给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，而这properties类里边的每一个属性又是和配置文件绑定的</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>      <span class="token comment" spellcheck="true">//给容器中添加一个组件。</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>CharacterEncodingFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//添加一个我们自己来new这个CharacterEncodingFilter，把这个filter添加过去，但是注意这个filter里边要获取字符集的名字（filter.setEncoding(this.properties.getCharset().name());)，你是UTF8编码还是什么编码，它要从properties中进行获取，意思就是这个组件的某些值需要从properties中获取</span>    <span class="token keyword">public</span> CharacterEncodingFilter <span class="token function">characterEncodingFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        CharacterEncodingFilter filter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OrderedCharacterEncodingFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        filter<span class="token punctuation">.</span><span class="token function">setEncoding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span><span class="token function">getCharset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        filter<span class="token punctuation">.</span><span class="token function">setForceRequestEncoding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span><span class="token function">shouldForce</span><span class="token punctuation">(</span>Type<span class="token punctuation">.</span>REQUEST<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        filter<span class="token punctuation">.</span><span class="token function">setForceResponseEncoding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>properties<span class="token punctuation">.</span><span class="token function">shouldForce</span><span class="token punctuation">(</span>Type<span class="token punctuation">.</span>RESPONSE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> filter<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>我们可以再深入的看一下properties</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span>HttpEncodingProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span>CharacterEncodingFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.http.encoding"</span><span class="token punctuation">,</span>           value <span class="token operator">=</span> <span class="token string">"enabled"</span><span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpEncodingAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> HttpEncodingProperties properties<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//它已经和SpringBoot配置文件进行映射了。</span>    <span class="token comment" spellcheck="true">//只有一个有参构造器</span>    <span class="token keyword">public</span> <span class="token function">HttpEncodingAutoConfiguration</span><span class="token punctuation">(</span>HttpEncodingProperties properties<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>properties <span class="token operator">=</span> properties<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>我们看到properties是HttpEncodingProperties，也就是说HttpEncodingProperties这个对象的值它是获取配置文件的值的，所以我们在配置这个filter到底要用什么编码的时候是从properties获取的。</p><ul><li>而且值得注意的是：<br>这个HttpEncodingAutoConfiguration只有一个有参构造器，在只有一个有参构造器的情况下，参数的值就会从容器中拿</li></ul><p><strong>8. 而容器中它怎么去拿到呢？</strong></p><p>相当于是前面的这个<code>@EnableConfigurationProperties(HttpEncodingProperties.class) 注解</code>，这个@EnableConfigurationProperties注解的作用就是把HttpEncodingProperties.class和配置文件进行绑定起来并把HttpEncodingProperties加入到容器中。</p><p>接下来这个自动配置类，通过一个有参构造器把这个属性拿到，而这个属性已经和SpringBoot映射了，接下来要用什么编码，就是拿到HttpEncodingProperties这个类里边的属性。</p><p>所以SpringBoot能配置什么，它要设置编码，它是获取properties里边getCharset里边的name值。</p><p>filter.setEncoding(this.properties.getCharset().name());</p><p>所以就以此类推，配置一个Spring配置，就可以照着HttpEncodingProperties这里边的来配置。</p><p>比如在application.properties配置文件下配置一个http.encoding.enabled属性：</p><p><code>spring.http.encoding.enabled=true</code>  //能配置这个就相当于是我们之前的判断属性</p><p>还能配置其他的一些属性。</p><p>比如：<br><code>spring.http.encoding.charset=UTF-8</code></p><p>所以我们能够配置哪些属性，都是来源于这个功能的properties类</p><p>有了这个自动配置类，自动配置类就给容器中添加这个filter，然后这个filter就会起作用了。</p><p><code>需要把握几点：</code></p><ul><li>SpringBoot启动会加载大量的自动配置类</li><li>所要做的就是我们需要的功能SpringBoot有没有帮我们写好的自动配置类：</li><li>如果有就再来看这个自动配置类中到底配置了哪些组件（Springboot自动配置类里边只要我们要用的组件有，我们就不需要再来配置了，但是如果说没有我们所需要的组件，那么我们就需要自己来写一个配置类来把我们相应的组件配置起来）</li><li>给容器中自动配置类添加组件的时候，会从properties类中获取某些属性，而这些属性我们就可以在配置文件指定这些属性的值</li></ul><p><code>细节</code></p><h4 id="1-Conditional派生注解"><a href="#1-Conditional派生注解" class="headerlink" title="1. @Conditional派生注解"></a>1. @Conditional派生注解</h4><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th>@Conditional派生注解</th><th>作用（判断是否满足当前条件）</th></tr></thead><tbody><tr><td>@@Conditional派生注解</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>NDI存在指定项</td></tr></tbody></table><p><code>自动配置类必须在一定的条件下才能生效；</code></p><p>我们怎么知道哪些自动配置类生效；</p><p>我们可以通过启用 <code>debug=true</code>属性；来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效；</p><pre class=" language-java"><code class="language-java"><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>AUTO<span class="token operator">-</span>CONFIGURATION REPORT<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Positive matches<span class="token operator">:</span>（自动配置类启用的）<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>   DispatcherServletAutoConfiguration matched<span class="token operator">:</span>      <span class="token operator">-</span> <span class="token annotation punctuation">@ConditionalOnClass</span> found required <span class="token keyword">class</span> <span class="token string">'org.springframework.web.servlet.DispatcherServlet'</span><span class="token punctuation">;</span> <span class="token annotation punctuation">@ConditionalOnMissingClass</span> did not find unwanted <span class="token keyword">class</span> <span class="token punctuation">(</span>OnClassCondition<span class="token punctuation">)</span>      <span class="token operator">-</span> <span class="token annotation punctuation">@ConditionalOnWebApplication</span> <span class="token punctuation">(</span>required<span class="token punctuation">)</span> found <span class="token function">StandardServletEnvironment</span> <span class="token punctuation">(</span>OnWebApplicationCondition<span class="token punctuation">)</span>Negative matches<span class="token operator">:</span>（没有启动，没有匹配成功的自动配置类）<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>   ActiveMQAutoConfiguration<span class="token operator">:</span>      Did not match<span class="token operator">:</span>         <span class="token operator">-</span> <span class="token annotation punctuation">@ConditionalOnClass</span> did not find required classes <span class="token string">'javax.jms.ConnectionFactory'</span><span class="token punctuation">,</span> <span class="token string">'org.apache.activemq.ActiveMQConnectionFactory'</span> <span class="token punctuation">(</span>OnClassCondition<span class="token punctuation">)</span>   AopAutoConfiguration<span class="token operator">:</span>      Did not match<span class="token operator">:</span>         <span class="token operator">-</span> <span class="token annotation punctuation">@ConditionalOnClass</span> did not find required classes <span class="token string">'org.aspectj.lang.annotation.Aspect'</span><span class="token punctuation">,</span> <span class="token string">'org.aspectj.lang.reflect.Advice'</span> <span class="token punctuation">(</span>OnClassCondition<span class="token punctuation">)</span></code></pre><h1 id="4-日志"><a href="#4-日志" class="headerlink" title="4-日志"></a>4-日志</h1><h2 id="4-1-日志框架"><a href="#4-1-日志框架" class="headerlink" title="4.1-日志框架"></a>4.1-日志框架</h2><p>小张；开发一个大型系统；</p><p> 1、System.out.println(“”)；将关键数据打印在控制台；去掉？写在一个文件？</p><p> 2、框架来记录系统的一些运行时信息；日志框架 ； zhanglogging.jar；</p><p> 3、高大上的几个功能？异步模式？自动归档？xxxx？ zhanglogging-good.jar？</p><p> 4、将以前框架卸下来？换上新的框架，重新修改之前相关的API；zhanglogging-prefect.jar；</p><p> 5、JDBC—数据库驱动；</p><p> 写了一个统一的接口层；日志门面（日志的一个抽象层）；logging-abstract.jar；</p><p> 给项目中导入具体的日志实现就行了；我们之前的日志框架都是实现的抽象层；</p><p>市面上的日志框架；</p><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j….</p><table><thead><tr><th>日志门面（日志的抽象层）</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL（Jakarta Commons Logging）</del> SLF4j（Simple Logging Facade for Java） <del>jboss-logging</del></td><td>Log4j JUL（java.util.logging） Log4j2 Logback</td></tr></tbody></table><p>左边选一个门面（抽象层）、右边来选一个实现；</p><p>日志门面： SLF4J；</p><p>日志实现：Logback；</p><p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；‘</p><p> <code>SpringBoot选用 SLF4j和logback；</code></p><h2 id="4-2-SLF4J的使用"><a href="#4-2-SLF4J的使用" class="headerlink" title="4.2-SLF4J的使用"></a>4.2-SLF4J的使用</h2><h3 id="4-2-1-如何在系统中使用SLF4J-参考-https-www-slf4j-org"><a href="#4-2-1-如何在系统中使用SLF4J-参考-https-www-slf4j-org" class="headerlink" title="4.2.1-如何在系统中使用SLF4J  参考-https://www.slf4j.org"></a>4.2.1-如何在系统中使用SLF4J  参考-<a href="https://www.slf4j.org" target="_blank" rel="noopener">https://www.slf4j.org</a></h3><p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p><p>给系统里面导入slf4j的jar和 logback的实现jar</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>HelloWorld<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Hello World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架自己本身的配置文件；</p><h3 id="4-2-2-遗留问题"><a href="#4-2-2-遗留问题" class="headerlink" title="4.2.2-遗留问题"></a>4.2.2-遗留问题</h3><p>Spring Boot：（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p><p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p><p>如何让系统中所有的日志都统一到slf4j；</p><p>1、将系统中其他日志框架先排除出去；</p><p>2、用中间包来替换原有的日志框架；</p><p>3、我们导入slf4j其他的实现</p><h2 id="4-3-SpringBoot使用日志"><a href="#4-3-SpringBoot使用日志" class="headerlink" title="4.3-SpringBoot使用日志"></a>4.3-SpringBoot使用日志</h2><ul><li>添加依赖</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ol><li>SpringBoot底层也是使用slf4j+logback的方式进行日志记录</li><li>SpringBoot也把其他的日志都替换成了slf4j；</li><li>中间替换包：</li></ol><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"rawtypes"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">LogFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J <span class="token operator">=</span> <span class="token string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> LogFactory logFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SLF4JLogFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol start="4"><li>如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</li></ol><p>例如：​ Spring框架用的是commons-logging；</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><code>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；</code></p><h2 id="4-4-日志的使用"><a href="#4-4-日志的使用" class="headerlink" title="4.4-日志的使用"></a>4.4-日志的使用</h2><h3 id="4-4-1-默认配置"><a href="#4-4-1-默认配置" class="headerlink" title="4.4-1 默认配置"></a>4.4-1 默认配置</h3><p>SpringBoot默认帮我们配好了日志</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//记录器</span>    Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">contextLoads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//System.out.println();</span>        <span class="token comment" spellcheck="true">//日志的级别；</span>        <span class="token comment" spellcheck="true">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span>        <span class="token comment" spellcheck="true">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span>        logger<span class="token punctuation">.</span><span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">"这是trace日志..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"这是debug日志..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span>        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"这是info日志..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"这是warn日志..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"这是error日志..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"> 日志输出格式：        <span class="token operator">%</span>d表示日期时间，        <span class="token operator">%</span>thread表示线程名，        <span class="token operator">%</span><span class="token operator">-</span>5level：级别从左显示<span class="token number">5</span>个字符宽度        <span class="token operator">%</span>logger<span class="token punctuation">{</span><span class="token number">50</span><span class="token punctuation">}</span> 表示logger名字最长<span class="token number">50</span>个字符，否则按照句点分割。         <span class="token operator">%</span>msg：日志消息，        <span class="token operator">%</span>n是换行符    <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">%</span>d<span class="token punctuation">{</span>yyyy<span class="token operator">-</span>MM<span class="token operator">-</span>dd HH<span class="token operator">:</span>mm<span class="token operator">:</span>ss<span class="token punctuation">.</span>SSS<span class="token punctuation">}</span> <span class="token punctuation">[</span><span class="token operator">%</span>thread<span class="token punctuation">]</span> <span class="token operator">%</span><span class="token operator">-</span>5level <span class="token operator">%</span>logger<span class="token punctuation">{</span><span class="token number">50</span><span class="token punctuation">}</span> <span class="token operator">-</span> <span class="token operator">%</span>msg<span class="token operator">%</span>n</code></pre><p>SpringBoot修改日志的默认的配置</p><pre class=" language-java"><code class="language-java">logging<span class="token punctuation">.</span>level<span class="token punctuation">.</span>com<span class="token punctuation">.</span>atguigu<span class="token operator">=</span>trace#logging<span class="token punctuation">.</span>path<span class="token operator">=</span># 不指定路径在当前项目下生成springboot<span class="token punctuation">.</span>log日志# 可以指定完整的路径；#logging<span class="token punctuation">.</span>file<span class="token operator">=</span>G<span class="token operator">:</span><span class="token operator">/</span>springboot<span class="token punctuation">.</span>log# 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring<span class="token punctuation">.</span>log 作为默认文件logging<span class="token punctuation">.</span>path<span class="token operator">=</span><span class="token operator">/</span>spring<span class="token operator">/</span>log#  在控制台输出的日志的格式logging<span class="token punctuation">.</span>pattern<span class="token punctuation">.</span>console<span class="token operator">=</span><span class="token operator">%</span>d<span class="token punctuation">{</span>yyyy<span class="token operator">-</span>MM<span class="token operator">-</span>dd<span class="token punctuation">}</span> <span class="token punctuation">[</span><span class="token operator">%</span>thread<span class="token punctuation">]</span> <span class="token operator">%</span><span class="token operator">-</span>5level <span class="token operator">%</span>logger<span class="token punctuation">{</span><span class="token number">50</span><span class="token punctuation">}</span> <span class="token operator">-</span> <span class="token operator">%</span>msg<span class="token operator">%</span>n# 指定文件中日志输出的格式logging<span class="token punctuation">.</span>pattern<span class="token punctuation">.</span>file<span class="token operator">=</span><span class="token operator">%</span>d<span class="token punctuation">{</span>yyyy<span class="token operator">-</span>MM<span class="token operator">-</span>dd<span class="token punctuation">}</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">%</span>thread<span class="token punctuation">]</span> <span class="token operator">==</span><span class="token operator">=</span> <span class="token operator">%</span><span class="token operator">-</span>5level <span class="token operator">==</span><span class="token operator">=</span> <span class="token operator">%</span>logger<span class="token punctuation">{</span><span class="token number">50</span><span class="token punctuation">}</span> <span class="token operator">==</span><span class="token operator">==</span> <span class="token operator">%</span>msg<span class="token operator">%</span>n</code></pre><table><thead><tr><th>logging.file</th><th>logging.path</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>none</td><td>none</td><td></td><td>只在控制台输出</td></tr><tr><td>指定文件名</td><td>none</td><td>my.log</td><td>输出日志到my.log文件</td></tr><tr><td>none</td><td>指定目录</td><td>/var/log</td><td>输出到指定目录的spring.log文件中</td></tr></tbody></table><h3 id="4-4-2-指定配置"><a href="#4-4-2-指定配置" class="headerlink" title="4.4-2 指定配置"></a>4.4-2 指定配置</h3><p><strong>给类路径下放上每个日志框架自己的配置文件即可</strong>；SpringBoot就不使用他默认配置的了</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td>logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy</td></tr><tr><td>Log4j2</td><td>log4j2-spring.xml or log4j2.xml</td></tr><tr><td>JDK (Java Util Logging)</td><td>logging.properties</td></tr></tbody></table><p>logback.xml：直接就被日志框架识别了；</p><p>logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>springProfile</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>staging<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- configuration to be enabled when the "staging" profile is active --></span>      可以指定某段配置只在某个环境下生效<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>springProfile</span><span class="token punctuation">></span></span></code></pre><p>如：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appender</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stdout<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.core.ConsoleAppender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--        日志输出格式：            %d表示日期时间，            %thread表示线程名，            %-5level：级别从左显示5个字符宽度            %logger{50} 表示logger名字最长50个字符，否则按照句点分割。             %msg：日志消息，            %n是换行符        --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layout</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ch.qos.logback.classic.PatternLayout<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>springProfile</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dev<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d{yyyy-MM-dd HH:mm:ss.SSS} ----> [%thread] ---> %-5level %logger{50} - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>springProfile</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>springProfile</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>!dev<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>pattern</span><span class="token punctuation">></span></span>%d{yyyy-MM-dd HH:mm:ss.SSS} ==== [%thread] ==== %-5level %logger{50} - %msg%n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>pattern</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>springProfile</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layout</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appender</span><span class="token punctuation">></span></span></code></pre><p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误</p><p>no applicable action for [springProfile]</p><h3 id="4-4-3-切换日志框架"><a href="#4-4-3-切换日志框架" class="headerlink" title="4.4-3 切换日志框架"></a>4.4-3 切换日志框架</h3><p>可以按照slf4j的日志适配图，进行相关的切换；</p><ul><li>slf4j+log4j的方式；</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>logback-classic<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>ch.qos.logback<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>log4j-over-slf4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.slf4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.slf4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>slf4j-log4j12<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ul><li>切换为log4j2</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-log4j2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h1 id="5-Web开发"><a href="#5-Web开发" class="headerlink" title="5-Web开发"></a>5-Web开发</h1><h2 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1-简介"></a>5.1-简介</h2><p>使用SpringBoot；</p><ul><li><p>创建SpringBoot应用，选中我们需要的模块；</p></li><li><p>SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定少量配置就可以运行起来</p></li><li><p>自己编写业务代码；</p></li></ul><p><strong>自动配置原理？</strong></p><p>这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？能不能扩展？xxx</p><pre class=" language-properties"><code class="language-properties">xxxxAutoConfiguration：帮我们给容器中自动配置组件；<span class="token attr-name">xxxxProperties</span><span class="token punctuation">:</span><span class="token attr-value">配置类来封装配置文件的内容；</span></code></pre><h2 id="5-2-SpringBoot对静态资源的映射规则"><a href="#5-2-SpringBoot对静态资源的映射规则" class="headerlink" title="5.2-SpringBoot对静态资源的映射规则"></a>5.2-SpringBoot对静态资源的映射规则</h2><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.resources"</span><span class="token punctuation">,</span> ignoreUnknownFields <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ResourceProperties</span> <span class="token keyword">implements</span> <span class="token class-name">ResourceLoaderAware</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//可以设置和静态资源有关的参数，缓存时间等</span></code></pre><pre class=" language-java"><code class="language-java">WebMvcAuotConfiguration：        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addResourceHandlers</span><span class="token punctuation">(</span>ResourceHandlerRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">isAddMappings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Default resource handling disabled"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            Integer cachePeriod <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">getCachePeriod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>registry<span class="token punctuation">.</span><span class="token function">hasMappingForPattern</span><span class="token punctuation">(</span><span class="token string">"/webjars/**"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">customizeResourceHandlerRegistration</span><span class="token punctuation">(</span>                        registry<span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span><span class="token string">"/webjars/**"</span><span class="token punctuation">)</span>                                <span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span>                                        <span class="token string">"classpath:/META-INF/resources/webjars/"</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">setCachePeriod</span><span class="token punctuation">(</span>cachePeriod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            String staticPathPattern <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getStaticPathPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token operator">/</span><span class="token operator">/</span>静态资源文件夹映射            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>registry<span class="token punctuation">.</span><span class="token function">hasMappingForPattern</span><span class="token punctuation">(</span>staticPathPattern<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">customizeResourceHandlerRegistration</span><span class="token punctuation">(</span>                        registry<span class="token punctuation">.</span><span class="token function">addResourceHandler</span><span class="token punctuation">(</span>staticPathPattern<span class="token punctuation">)</span>                                <span class="token punctuation">.</span><span class="token function">addResourceLocations</span><span class="token punctuation">(</span>                                        <span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">getStaticLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">setCachePeriod</span><span class="token punctuation">(</span>cachePeriod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token operator">/</span><span class="token operator">/</span>配置欢迎页映射        <span class="token annotation punctuation">@Bean</span>        <span class="token keyword">public</span> WelcomePageHandlerMapping <span class="token function">welcomePageHandlerMapping</span><span class="token punctuation">(</span>                ResourceProperties resourceProperties<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WelcomePageHandlerMapping</span><span class="token punctuation">(</span>resourceProperties<span class="token punctuation">.</span><span class="token function">getWelcomePage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getStaticPathPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>       <span class="token operator">/</span><span class="token operator">/</span>配置喜欢的图标        <span class="token annotation punctuation">@Configuration</span>        <span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"spring.mvc.favicon.enabled"</span><span class="token punctuation">,</span> matchIfMissing <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">FaviconConfiguration</span> <span class="token punctuation">{</span>            <span class="token keyword">private</span> <span class="token keyword">final</span> ResourceProperties resourceProperties<span class="token punctuation">;</span>            <span class="token keyword">public</span> <span class="token function">FaviconConfiguration</span><span class="token punctuation">(</span>ResourceProperties resourceProperties<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties <span class="token operator">=</span> resourceProperties<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Bean</span>            <span class="token keyword">public</span> SimpleUrlHandlerMapping <span class="token function">faviconHandlerMapping</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                SimpleUrlHandlerMapping mapping <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleUrlHandlerMapping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                mapping<span class="token punctuation">.</span><span class="token function">setOrder</span><span class="token punctuation">(</span>Ordered<span class="token punctuation">.</span>HIGHEST_PRECEDENCE <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token operator">/</span><span class="token operator">/</span>所有  <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">/</span>favicon<span class="token punctuation">.</span>ico                 mapping<span class="token punctuation">.</span><span class="token function">setUrlMap</span><span class="token punctuation">(</span>Collections<span class="token punctuation">.</span><span class="token function">singletonMap</span><span class="token punctuation">(</span><span class="token string">"**/favicon.ico"</span><span class="token punctuation">,</span>                        <span class="token function">faviconRequestHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> mapping<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token annotation punctuation">@Bean</span>            <span class="token keyword">public</span> ResourceHttpRequestHandler <span class="token function">faviconRequestHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ResourceHttpRequestHandler requestHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResourceHttpRequestHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                requestHandler                        <span class="token punctuation">.</span><span class="token function">setLocations</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resourceProperties<span class="token punctuation">.</span><span class="token function">getFaviconLocations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> requestHandler<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span></code></pre><p>1、所有 /webjars/** ，都去 classpath:/META-INF/resources/webjars/ 找资源；</p><p> webjars：以jar包的方式引入静态资源；</p><p>2、”/**” 访问当前项目的任何资源，都去（静态资源的文件夹）找映射</p><ul><li>加载顺序由上至下</li></ul><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">"classpath</span><span class="token punctuation">:</span><span class="token attr-value">/META-INF/resources/", </span><span class="token attr-name">"classpath</span><span class="token punctuation">:</span><span class="token attr-value">/resources/",</span><span class="token attr-name">"classpath</span><span class="token punctuation">:</span><span class="token attr-value">/static/", </span><span class="token attr-name">"classpath</span><span class="token punctuation">:</span><span class="token attr-value">/public/" </span>"/"：当前项目的根路径</code></pre><p>3、欢迎页； 静态资源文件夹下的所有index.html页面；被”/**”映射；</p><p>4、所有的 **/favicon.ico 都是在静态资源文件下找；</p><h2 id="5-3-模板引擎"><a href="#5-3-模板引擎" class="headerlink" title="5.3-模板引擎"></a>5.3-模板引擎</h2><p>模板引擎有JSP、Velocity、Freemarker、Thymeleaf等</p><p><strong>SpringBoot推荐的Thymeleaf，语法更简单，功能更强大；</strong></p><h3 id="5-3-1-引入thymeleaf"><a href="#5-3-1-引入thymeleaf" class="headerlink" title="5.3-1 引入thymeleaf"></a>5.3-1 引入thymeleaf</h3><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-thymeleaf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="5-3-2-Thymeleaf使用"><a href="#5-3-2-Thymeleaf使用" class="headerlink" title="5.3-2 Thymeleaf使用"></a>5.3-2 Thymeleaf使用</h3><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.thymeleaf"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThymeleafProperties</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Charset DEFAULT_ENCODING <span class="token operator">=</span> Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> MimeType DEFAULT_CONTENT_TYPE <span class="token operator">=</span> MimeType<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token string">"text/html"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DEFAULT_PREFIX <span class="token operator">=</span> <span class="token string">"classpath:/templates/"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DEFAULT_SUFFIX <span class="token operator">=</span> <span class="token string">".html"</span><span class="token punctuation">;</span></code></pre><p>只要我们把HTML页面放在classpath:/templates/，thymeleaf就能自动渲染；</p><p>使用：</p><ol><li>导入thymeleaf的名称空间</li></ol><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>th</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.thymeleaf.org<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><ol start="2"><li>使用thymeleaf语法</li></ol><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>th</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.thymeleaf.org<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>成功！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!--th:text 将div里面的文本内容设置为 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${hello}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>这是显示欢迎信息<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="5-3-3-thymeleaf语法规则"><a href="#5-3-3-thymeleaf语法规则" class="headerlink" title="5.3-3 thymeleaf语法规则"></a>5.3-3 thymeleaf语法规则</h3><ol><li>th:text；改变当前元素里面的文本内容；<code>th：任意html属性；</code>来替换原生属性的值</li><li>表达式<br><a href="https://fanlychie.github.io/post/thymeleaf.html" target="_blank" rel="noopener">详见此博客</a></li></ol><h2 id="5-4-SpringMVC自动配置"><a href="#5-4-SpringMVC自动配置" class="headerlink" title="5.4-SpringMVC自动配置"></a>5.4-SpringMVC自动配置</h2><h3 id="5-4-1-Spring-MVC-auto-configuration"><a href="#5-4-1-Spring-MVC-auto-configuration" class="headerlink" title="5.4-1 Spring MVC auto-configuration"></a>5.4-1 Spring MVC auto-configuration</h3><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:<code>（WebMvcAutoConfiguration）</code></p><ul><li>Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.<ul><li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li><li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li><li>如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；</li></ul></li><li>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</li><li>Static index.html support. 静态首页访问</li><li>Custom Favicon support (see below). favicon.ico</li><li>自动注册了 of Converter, GenericConverter, Formatter beans.<ul><li>Converter：转换器； public String hello(User user)：类型转换使用Converter</li><li>Formatter 格式化器； 2019.12.17===Date；</li></ul></li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>        <span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.mvc"</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"date-format"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//在文件中配置日期格式化的规则</span>        <span class="token keyword">public</span> Formatter<span class="token operator">&lt;</span>Date<span class="token operator">></span> <span class="token function">dateFormatter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DateFormatter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getDateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//日期格式化组件</span>        <span class="token punctuation">}</span></code></pre><p> 自己添加的格式化器转换器，我们只需要放在容器中即可</p><ul><li>Support for HttpMessageConverters (see below).<ul><li>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</li><li>HttpMessageConverters 是从容器中确定；获取所有的HttpMessageConverter；</li></ul></li></ul><p>自己给容器中添加<code>HttpMessageConverter</code>，只需要将自己的组件注册容器中（@Bean,@Component）</p><ul><li>Automatic registration of MessageCodesResolver (see below).定义错误代码生成规则</li><li>Automatic use of a ConfigurableWebBindingInitializer bean (see below).</li></ul><p>我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）</p><pre class=" language-properties"><code class="language-properties">初始化WebDataBinder；<span class="token attr-name">请求数据</span><span class="token punctuation">=</span><span class="token attr-value">====JavaBean；</span></code></pre><h3 id="5-4-2-扩展SpringMVC"><a href="#5-4-2-扩展SpringMVC" class="headerlink" title="5.4-2 扩展SpringMVC"></a>5.4-2 扩展SpringMVC</h3><pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>view-controller</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/hello<span class="token punctuation">"</span></span> <span class="token attr-name">view-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>success<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>interceptors</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>interceptor</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>mapping</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/hello<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>interceptor</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>interceptors</span><span class="token punctuation">></span></span></code></pre><p>编写一个配置类（@Configuration），是<code>WebMvcConfigurerAdapter</code>类型；不能标注@EnableWebMvc;</p><p>既保留了所有的自动配置，也能用我们扩展的配置；</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMvcConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurerAdapter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addViewControllers</span><span class="token punctuation">(</span>ViewControllerRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// super.addViewControllers(registry);</span>        <span class="token comment" spellcheck="true">//浏览器发送 /atguigu 请求来到 success</span>        registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>原理：</p><ol><li>WebMvcAutoConfiguration是SpringMVC的自动配置类</li><li>在做其他自动配置时会导入；@Import(EnableWebMvcConfiguration.class)</li></ol><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Configuration</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EnableWebMvcConfiguration</span> <span class="token keyword">extends</span> <span class="token class-name">DelegatingWebMvcConfiguration</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">final</span> WebMvcConfigurerComposite configurers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebMvcConfigurerComposite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//从容器中获取所有的WebMvcConfigurer</span>      <span class="token annotation punctuation">@Autowired</span><span class="token punctuation">(</span>required <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setConfigurers</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>WebMvcConfigurer<span class="token operator">></span> configurers<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>configurers<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>configurers<span class="token punctuation">.</span><span class="token function">addWebMvcConfigurers</span><span class="token punctuation">(</span>configurers<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span>                <span class="token annotation punctuation">@Override</span>             <span class="token comment" spellcheck="true">// public void addViewControllers(ViewControllerRegistry registry) {</span>              <span class="token comment" spellcheck="true">//    for (WebMvcConfigurer delegate : this.delegates) {</span>               <span class="token comment" spellcheck="true">//       delegate.addViewControllers(registry);</span>               <span class="token comment" spellcheck="true">//   }</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><ol start="3"><li><p>容器中所有的WebMvcConfigurer都会一起起作用；</p></li><li><p>我们的配置类也会被调用；</p><p>效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p></li></ol><h3 id="5-4-3-全面接管SpringMVC"><a href="#5-4-3-全面接管SpringMVC" class="headerlink" title="5.4-3 全面接管SpringMVC"></a>5.4-3 全面接管SpringMVC</h3><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p><p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><span class="token annotation punctuation">@EnableWebMvc</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMvcConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurerAdapter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addViewControllers</span><span class="token punctuation">(</span>ViewControllerRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// super.addViewControllers(registry);</span>        <span class="token comment" spellcheck="true">//浏览器发送 /atguigu 请求来到 success</span>        registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>原理：</p><p>为什么@EnableWebMvc自动配置就失效了；</p><ol><li>@EnableWebMvc的核心</li></ol><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>DelegatingWebMvcConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableWebMvc</span> <span class="token punctuation">{</span></code></pre><ol start="2"><li><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelegatingWebMvcConfiguration</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurationSupport</span> <span class="token punctuation">{</span></code></pre></li><li></li></ol><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span><span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span> Servlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> DispatcherServlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        WebMvcConfigurerAdapter<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//容器中没有这个组件的时候，这个自动配置类才生效</span><span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>WebMvcConfigurationSupport<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@AutoConfigureOrder</span><span class="token punctuation">(</span>Ordered<span class="token punctuation">.</span>HIGHEST_PRECEDENCE <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token annotation punctuation">@AutoConfigureAfter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> DispatcherServletAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>        ValidationAutoConfiguration<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebMvcAutoConfiguration</span> <span class="token punctuation">{</span></code></pre><ol start="4"><li><p>@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p></li><li><p>导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p></li></ol><h3 id="5-4-4-如何修改SpringBoot的默认配置"><a href="#5-4-4-如何修改SpringBoot的默认配置" class="headerlink" title="5.4-4 如何修改SpringBoot的默认配置"></a>5.4-4 如何修改SpringBoot的默认配置</h3><p>模式：</p><ol><li>SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</li><li>在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</li><li>在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</li></ol><h2 id="5-5-Restful-CRUD"><a href="#5-5-Restful-CRUD" class="headerlink" title="5.5 Restful CRUD"></a>5.5 Restful CRUD</h2><h3 id="5-5-1-默认访问首页"><a href="#5-5-1-默认访问首页" class="headerlink" title="5.5-1 默认访问首页"></a>5.5-1 默认访问首页</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><span class="token comment" spellcheck="true">//@EnableWebMvc   不要接管SpringMVC</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMvcConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebMvcConfigurerAdapter</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addViewControllers</span><span class="token punctuation">(</span>ViewControllerRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// super.addViewControllers(registry);</span>        <span class="token comment" spellcheck="true">//浏览器发送 /atguigu 请求来到 success</span>        registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/atguigu"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"success"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//所有的WebMvcConfigurerAdapter组件都会一起起作用</span>    <span class="token annotation punctuation">@Bean</span> <span class="token comment" spellcheck="true">//将组件注册在容器</span>    <span class="token keyword">public</span> WebMvcConfigurerAdapter <span class="token function">webMvcConfigurerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        WebMvcConfigurerAdapter adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebMvcConfigurerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addViewControllers</span><span class="token punctuation">(</span>ViewControllerRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>                registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/index.html"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> adapter<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-5-2-国际化"><a href="#5-5-2-国际化" class="headerlink" title="5.5-2 国际化"></a>5.5-2 国际化</h3><ol><li>编写国际化配置文件；</li><li>使用ResourceBundleMessageSource管理国际化资源文件</li><li>在页面使用fmt:message取出国际化内容</li></ol><p><strong>步骤：</strong></p><ul><li>编写国际化配置文件，抽取页面需要显示的国际化消息</li><li>SpringBoot自动配置好了管理国际化资源文件的组件</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.messages"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageSourceAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * Comma-separated list of basenames (essentially a fully-qualified classpath     * location), each following the ResourceBundle convention with relaxed support for     * slash based locations. If it doesn't contain a package qualifier (such as     * "org.mypackage"), it will be resolved from the classpath root.     */</span>    <span class="token keyword">private</span> String basename <span class="token operator">=</span> <span class="token string">"messages"</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//我们的配置文件可以直接放在类路径下叫messages.properties；</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> MessageSource <span class="token function">messageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ResourceBundleMessageSource messageSource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResourceBundleMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">hasText</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>basename<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//设置国际化资源文件的基础名（去掉语言国家代码的）</span>            messageSource<span class="token punctuation">.</span><span class="token function">setBasenames</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">commaDelimitedListToStringArray</span><span class="token punctuation">(</span>                    StringUtils<span class="token punctuation">.</span><span class="token function">trimAllWhitespace</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>basename<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>encoding <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            messageSource<span class="token punctuation">.</span><span class="token function">setDefaultEncoding</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>encoding<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        messageSource<span class="token punctuation">.</span><span class="token function">setFallbackToSystemLocale</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>fallbackToSystemLocale<span class="token punctuation">)</span><span class="token punctuation">;</span>        messageSource<span class="token punctuation">.</span><span class="token function">setCacheSeconds</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>cacheSeconds<span class="token punctuation">)</span><span class="token punctuation">;</span>        messageSource<span class="token punctuation">.</span><span class="token function">setAlwaysUseMessageFormat</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>alwaysUseMessageFormat<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> messageSource<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><ul><li>去页面获取国际化的值</li></ul><pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span>  <span class="token attr-name"><span class="token namespace">xmlns:</span>th</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.thymeleaf.org<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Content-Type<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/html; charset<span class="token punctuation">=</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1, shrink-to-fit<span class="token punctuation">=</span>no<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>description<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>author<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Signin Template for Bootstrap<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- Bootstrap core CSS --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>asserts/css/bootstrap.min.css<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{/webjars/bootstrap/4.0.0/css/bootstrap.css}<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!-- Custom styles for this template --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>asserts/css/signin.css<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{/asserts/css/signin.css}<span class="token punctuation">"</span></span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text-center<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-signin<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dashboard.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mb-4<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@{/asserts/img/bootstrap-solid.svg}<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>asserts/img/bootstrap-solid.svg<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>72<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>72<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>h3 mb-3 font-weight-normal<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{login.tip}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Please sign in<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sr-only<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{login.username}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Username<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-control<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Username<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{login.username}<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span> <span class="token attr-name">autofocus</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sr-only<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{login.password}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Password<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>form-control<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Password<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>placeholder</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{login.password}<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox mb-3<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span><span class="token punctuation">></span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>remember-me<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span> [[#{login.remember}]]        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn btn-lg btn-primary btn-block<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#{login.btn}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>Sign in<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mt-5 mb-3 text-muted<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>© 2017-2018<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn btn-sm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>中文<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>btn btn-sm<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>English<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>效果：根据浏览器语言设置的信息切换了国际化；</p><p><strong>原理：</strong></p><p> 国际化Locale（区域信息对象）；LocaleResolver（获取区域信息对象）</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>        <span class="token annotation punctuation">@ConditionalOnMissingBean</span>        <span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.mvc"</span><span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"locale"</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> LocaleResolver <span class="token function">localeResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties                    <span class="token punctuation">.</span><span class="token function">getLocaleResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> WebMvcProperties<span class="token punctuation">.</span>LocaleResolver<span class="token punctuation">.</span>FIXED<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FixedLocaleResolver</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getLocale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            AcceptHeaderLocaleResolver localeResolver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AcceptHeaderLocaleResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            localeResolver<span class="token punctuation">.</span><span class="token function">setDefaultLocale</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mvcProperties<span class="token punctuation">.</span><span class="token function">getLocale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> localeResolver<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        默认的就是根据请求头带来的区域信息获取Locale进行国际化</code></pre><ul><li>点击链接切换国际化</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 可以在连接上携带区域信息 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyLocaleResolver</span> <span class="token keyword">implements</span> <span class="token class-name">LocaleResolver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Locale <span class="token function">resolveLocale</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String l <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"l"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Locale locale <span class="token operator">=</span> Locale<span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> split <span class="token operator">=</span> l<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"_"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            locale <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Locale</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>split<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> locale<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLocale</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Locale locale<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> LocaleResolver <span class="token function">localeResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyLocaleResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-5-3-登陆"><a href="#5-5-3-登陆" class="headerlink" title="5.5-3 登陆"></a>5.5-3 登陆</h3><p>开发期间模板引擎页面修改以后，要实时生效</p><ul><li>禁用模板引擎的缓存</li></ul><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 禁用缓存</span><span class="token attr-name">spring.thymeleaf.cache</span><span class="token punctuation">=</span><span class="token attr-value">false </span></code></pre><ul><li>页面修改完成以后ctrl+f9：重新编译；</li></ul><p>登陆错误消息的显示</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span> red</span><span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${msg}<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>if</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>${not #strings.isEmpty(msg)}<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span></code></pre><h3 id="5-5-4-拦截器进行登陆检查"><a href="#5-5-4-拦截器进行登陆检查" class="headerlink" title="5.5-4 拦截器进行登陆检查"></a>5.5-4 拦截器进行登陆检查</h3><ul><li><strong>拦截器</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 登陆检查， */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginHandlerInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//目标方法执行之前</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Object user <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"loginUser"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//未登陆，返回登陆页面</span>            request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span><span class="token string">"没有权限请先登陆"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            request<span class="token punctuation">.</span><span class="token function">getRequestDispatcher</span><span class="token punctuation">(</span><span class="token string">"/index.html"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//已登陆，放行请求</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> ModelAndView modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpServletResponse response<span class="token punctuation">,</span> Object handler<span class="token punctuation">,</span> Exception ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><strong>注册拦截器</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//所有的WebMvcConfigurerAdapter组件都会一起起作用</span>    <span class="token annotation punctuation">@Bean</span> <span class="token comment" spellcheck="true">//将组件注册在容器</span>    <span class="token keyword">public</span> WebMvcConfigurerAdapter <span class="token function">webMvcConfigurerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        WebMvcConfigurerAdapter adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebMvcConfigurerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addViewControllers</span><span class="token punctuation">(</span>ViewControllerRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>                registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/index.html"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                registry<span class="token punctuation">.</span><span class="token function">addViewController</span><span class="token punctuation">(</span><span class="token string">"/main.html"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setViewName</span><span class="token punctuation">(</span><span class="token string">"dashboard"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//注册拦截器</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span>InterceptorRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//super.addInterceptors(registry);</span>                <span class="token comment" spellcheck="true">//静态资源；  *.css , *.js</span>                <span class="token comment" spellcheck="true">//SpringBoot已经做好了静态资源映射</span>                registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoginHandlerInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">excludePathPatterns</span><span class="token punctuation">(</span><span class="token string">"/index.html"</span><span class="token punctuation">,</span><span class="token string">"/"</span><span class="token punctuation">,</span><span class="token string">"/user/login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> adapter<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="5-5-5-CRUD-员工列表"><a href="#5-5-5-CRUD-员工列表" class="headerlink" title="5.5-5 CRUD-员工列表"></a>5.5-5 CRUD-员工列表</h3><p>实验要求：</p><p><strong>RestfulCRUD：CRUD满足Rest风格；</strong></p><p>URI： /资源名称/资源标识 HTTP请求方式区分对资源CRUD操作</p><p><strong>| 普通CRUD（uri来区分操作） | RestfulCRUD</strong></p><p>—|—|—<br>查询 | getEmp | emp—GET<br>添加 | addEmp?xxx | emp—POST<br>修改 | updateEmp?id=xxx&amp;xxx=xx | emp/{id}—PUT<br>删除 | deleteEmp?id=1 | emp/{id}—DELETE</p><h1 id="6-错误处理机制"><a href="#6-错误处理机制" class="headerlink" title="6-错误处理机制"></a>6-错误处理机制</h1><h2 id="6-1-SpringBoot默认的错误处理机制"><a href="#6-1-SpringBoot默认的错误处理机制" class="headerlink" title="6.1-SpringBoot默认的错误处理机制"></a>6.1-SpringBoot默认的错误处理机制</h2><p>默认效果：</p><ol><li><p>浏览器，返回一个默认的错误页面</p><p><img src="/2019/12/25/springboot-bi-ji-yi/%E9%94%99%E8%AF%AF.png" alt="错误"></p></li></ol><p>浏览器发送请求的请求头：</p><p><img src="/2019/12/25/springboot-bi-ji-yi/%E8%AF%B7%E6%B1%82%E5%A4%B4.png" alt="请求头"></p><ol start="2"><li><p>如果是其他客户端，默认响应一个json数据</p><p><strong>原理：</strong></p><p> 可以参照ErrorMvcAutoConfiguration；错误处理的自动配置；</p></li></ol><p>   <strong>给容器中添加了以下组件</strong></p><p>   1、DefaultErrorAttributes：</p><pre class=" language-java"><code class="language-java">   帮我们在页面共享信息；   <span class="token annotation punctuation">@Override</span>       <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">getErrorAttributes</span><span class="token punctuation">(</span>RequestAttributes requestAttributes<span class="token punctuation">,</span>               <span class="token keyword">boolean</span> includeStackTrace<span class="token punctuation">)</span> <span class="token punctuation">{</span>           Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> errorAttributes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           errorAttributes<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"timestamp"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token function">addStatus</span><span class="token punctuation">(</span>errorAttributes<span class="token punctuation">,</span> requestAttributes<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token function">addErrorDetails</span><span class="token punctuation">(</span>errorAttributes<span class="token punctuation">,</span> requestAttributes<span class="token punctuation">,</span> includeStackTrace<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token function">addPath</span><span class="token punctuation">(</span>errorAttributes<span class="token punctuation">,</span> requestAttributes<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">return</span> errorAttributes<span class="token punctuation">;</span>       <span class="token punctuation">}</span></code></pre><pre><code>2、BasicErrorController：处理默认/error请求</code></pre><pre class=" language-java"><code class="language-java">   <span class="token annotation punctuation">@Controller</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"${server.error.path:${error.path:/error}}"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BasicErrorController</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractErrorController</span> <span class="token punctuation">{</span>       <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>produces <span class="token operator">=</span> <span class="token string">"text/html"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//产生html类型的数据；浏览器发送的请求来到这个方法处理</span>       <span class="token keyword">public</span> ModelAndView <span class="token function">errorHtml</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>               HttpServletResponse response<span class="token punctuation">)</span> <span class="token punctuation">{</span>           HttpStatus status <span class="token operator">=</span> <span class="token function">getStatus</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>           Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> model <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span><span class="token function">getErrorAttributes</span><span class="token punctuation">(</span>                   request<span class="token punctuation">,</span> <span class="token function">isIncludeStackTrace</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> MediaType<span class="token punctuation">.</span>TEXT_HTML<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           response<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//去哪个页面作为错误页面；包含页面地址和页面内容</span>           ModelAndView modelAndView <span class="token operator">=</span> <span class="token function">resolveErrorView</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> status<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">return</span> <span class="token punctuation">(</span>modelAndView <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span><span class="token string">"error"</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span> <span class="token operator">:</span> modelAndView<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token annotation punctuation">@RequestMapping</span>       <span class="token annotation punctuation">@ResponseBody</span>    <span class="token comment" spellcheck="true">//产生json数据，其他客户端来到这个方法处理；</span>       <span class="token keyword">public</span> ResponseEntity<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">>></span> <span class="token function">error</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token punctuation">{</span>           Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> body <span class="token operator">=</span> <span class="token function">getErrorAttributes</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>                   <span class="token function">isIncludeStackTrace</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> MediaType<span class="token punctuation">.</span>ALL<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           HttpStatus status <span class="token operator">=</span> <span class="token function">getStatus</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ResponseEntity</span><span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">>></span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span></code></pre><pre><code>3、ErrorPageCustomizer：</code></pre><pre><code>       @Value(&quot;${error.path:/error}&quot;)       private String path = &quot;/error&quot;;  系统出现错误以后来到error请求进行处理；（web.xml注册的错误页面规则）</code></pre><pre><code>4、DefaultErrorViewResolver：</code></pre><pre class=" language-java"><code class="language-java">   <span class="token annotation punctuation">@Override</span>       <span class="token keyword">public</span> ModelAndView <span class="token function">resolveErrorView</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span> HttpStatus status<span class="token punctuation">,</span>               Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> model<span class="token punctuation">)</span> <span class="token punctuation">{</span>           ModelAndView modelAndView <span class="token operator">=</span> <span class="token function">resolve</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>modelAndView <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> SERIES_VIEWS<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">series</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               modelAndView <span class="token operator">=</span> <span class="token function">resolve</span><span class="token punctuation">(</span>SERIES_VIEWS<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">series</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">return</span> modelAndView<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">private</span> ModelAndView <span class="token function">resolve</span><span class="token punctuation">(</span>String viewName<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> model<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">//默认SpringBoot可以去找到一个页面？  error/404</span>           String errorViewName <span class="token operator">=</span> <span class="token string">"error/"</span> <span class="token operator">+</span> viewName<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//模板引擎可以解析这个页面地址就用模板引擎解析</span>           TemplateAvailabilityProvider provider <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>templateAvailabilityProviders                   <span class="token punctuation">.</span><span class="token function">getProvider</span><span class="token punctuation">(</span>errorViewName<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>provider <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">//模板引擎可用的情况下返回到errorViewName指定的视图地址</span>               <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ModelAndView</span><span class="token punctuation">(</span>errorViewName<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token comment" spellcheck="true">//模板引擎不可用，就在静态资源文件夹下找errorViewName对应的页面   error/404.html</span>           <span class="token keyword">return</span> <span class="token function">resolveResource</span><span class="token punctuation">(</span>errorViewName<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span></code></pre><pre><code>步骤：一但系统出现4xx或者5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则）；就会来到/error请求；就会被**BasicErrorController**处理；1）响应页面；去哪个页面是由**DefaultErrorViewResolver**解析得到的；</code></pre><pre class=" language-java"><code class="language-java">   <span class="token keyword">protected</span> ModelAndView <span class="token function">resolveErrorView</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>         HttpServletResponse response<span class="token punctuation">,</span> HttpStatus status<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> model<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//所有的ErrorViewResolver得到ModelAndView</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>ErrorViewResolver resolver <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>errorViewResolvers<span class="token punctuation">)</span> <span class="token punctuation">{</span>         ModelAndView modelAndView <span class="token operator">=</span> resolver<span class="token punctuation">.</span><span class="token function">resolveErrorView</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> status<span class="token punctuation">,</span> model<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>modelAndView <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> modelAndView<span class="token punctuation">;</span>         <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> null<span class="token punctuation">;</span>   <span class="token punctuation">}</span></code></pre><h2 id="6-2-如果定制错误响应："><a href="#6-2-如果定制错误响应：" class="headerlink" title="6.2-如果定制错误响应："></a>6.2-如果定制错误响应：</h2><h3 id="6-2-1-如何定制错误的页面；"><a href="#6-2-1-如何定制错误的页面；" class="headerlink" title="6.2-1 如何定制错误的页面；"></a><strong>6.2-1 如何定制错误的页面；</strong></h3><ol><li>有模板引擎的情况下；error/状态码; </li></ol><p>【将错误页面命名为 错误状态码.html 放在模板引擎文件夹里面的 error文件夹下】，发生此状态码的错误就会来到 对应的页面；</p><p> 我们可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）；</p><p> 页面能获取的信息；</p><p> timestamp：时间戳</p><p> status：状态码</p><p> error：错误提示</p><p> exception：异常对象</p><p> message：异常消息</p><p> errors：JSR303数据校验的错误都在这里</p><ol start="2"><li><p>没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找；</p></li><li><p>以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面；</p></li></ol><h3 id="6-2-2-如何定制错误的json数据；"><a href="#6-2-2-如何定制错误的json数据；" class="headerlink" title="6.2-2. 如何定制错误的json数据；"></a>6.2-2. 如何定制错误的json数据；</h3><ol><li>自定义异常处理&amp;返回定制json数据；</li></ol><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyExceptionHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@ResponseBody</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>UserNotExistException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> <span class="token function">handleException</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">,</span><span class="token string">"user.notexist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> map<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//没有自适应效果...</span></code></pre><ol start="2"><li>转发到/error进行自适应响应效果处理</li></ol><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>UserNotExistException<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">handleException</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">,</span> HttpServletRequest request<span class="token punctuation">)</span><span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程</span>        <span class="token comment" spellcheck="true">/**         * Integer statusCode = (Integer) request         .getAttribute("javax.servlet.error.status_code");         */</span>        request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"javax.servlet.error.status_code"</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">,</span><span class="token string">"user.notexist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//转发到/error</span>        <span class="token keyword">return</span> <span class="token string">"forward:/error"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="6-2-3-将我们的定制数据携带出去；"><a href="#6-2-3-将我们的定制数据携带出去；" class="headerlink" title="6.2-3 将我们的定制数据携带出去；"></a>6.2-3 将我们的定制数据携带出去；</h3><p>出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；</p><p> 1、完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；</p><p> 2、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到；</p><p> 容器中DefaultErrorAttributes.getErrorAttributes()；默认进行数据处理的；</p><p>自定义ErrorAttributes</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给容器中加入我们自己定义的ErrorAttributes</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyErrorAttributes</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultErrorAttributes</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">getErrorAttributes</span><span class="token punctuation">(</span>RequestAttributes requestAttributes<span class="token punctuation">,</span> <span class="token keyword">boolean</span> includeStackTrace<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getErrorAttributes</span><span class="token punctuation">(</span>requestAttributes<span class="token punctuation">,</span> includeStackTrace<span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"company"</span><span class="token punctuation">,</span><span class="token string">"fangfpeng"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> map<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，</p><h1 id="7-配置嵌入式的Servlet容器"><a href="#7-配置嵌入式的Servlet容器" class="headerlink" title="7- 配置嵌入式的Servlet容器"></a>7- 配置嵌入式的Servlet容器</h1><p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；</p><h3 id="7-1-如何定制和修改Servlet容器的相关配置"><a href="#7-1-如何定制和修改Servlet容器的相关配置" class="headerlink" title="7.1  如何定制和修改Servlet容器的相关配置"></a>7.1  如何定制和修改Servlet容器的相关配置</h3><ol><li><p>修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）</p><pre class=" language-java"><code class="language-java">server<span class="token punctuation">.</span>port<span class="token operator">=</span><span class="token number">8081</span>server<span class="token punctuation">.</span>context<span class="token operator">-</span>path<span class="token operator">=</span><span class="token operator">/</span>crudserver<span class="token punctuation">.</span>tomcat<span class="token punctuation">.</span>uri<span class="token operator">-</span>encoding<span class="token operator">=</span>UTF<span class="token operator">-</span><span class="token number">8</span><span class="token comment" spellcheck="true">//通用的Servlet容器设置</span>server<span class="token punctuation">.</span>xxx<span class="token comment" spellcheck="true">//Tomcat的设置</span>server<span class="token punctuation">.</span>tomcat<span class="token punctuation">.</span>xxx</code></pre></li></ol><ol start="2"><li><p>编写一个<strong>EmbeddedServletContainerCustomizer</strong>：嵌入式的Servlet容器的定制器；来修改Servlet容器的配置</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>  <span class="token comment" spellcheck="true">//一定要将这个定制器加入到容器中</span><span class="token keyword">public</span> EmbeddedServletContainerCustomizer <span class="token function">embeddedServletContainerCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">EmbeddedServletContainerCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//定制嵌入式的Servlet容器相关的规则</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">customize</span><span class="token punctuation">(</span>ConfigurableEmbeddedServletContainer container<span class="token punctuation">)</span> <span class="token punctuation">{</span>            container<span class="token punctuation">.</span><span class="token function">setPort</span><span class="token punctuation">(</span><span class="token number">8083</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="7-2-注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#7-2-注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="7.2  注册Servlet三大组件【Servlet、Filter、Listener】"></a>7.2  注册Servlet三大组件【Servlet、Filter、Listener】</h3><p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。</p><p>注册三大组件用以下方式</p><p><code>ServletRegistrationBean：</code></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//注册三大组件</span><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> ServletRegistrationBean <span class="token function">myServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ServletRegistrationBean registrationBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletRegistrationBean</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"/myServlet"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> registrationBean<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>FilterRegistrationBean：</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> FilterRegistrationBean <span class="token function">myFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    FilterRegistrationBean registrationBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterRegistrationBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    registrationBean<span class="token punctuation">.</span><span class="token function">setFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    registrationBean<span class="token punctuation">.</span><span class="token function">setUrlPatterns</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span><span class="token string">"/myServlet"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> registrationBean<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>ServletListenerRegistrationBean：</code></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> ServletListenerRegistrationBean <span class="token function">myListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    ServletListenerRegistrationBean<span class="token operator">&lt;</span>MyListener<span class="token operator">></span> registrationBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletListenerRegistrationBean</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> registrationBean<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；DIspatcherServlet；</p><p>DispatcherServletAutoConfiguration中：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME<span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnBean</span><span class="token punctuation">(</span>value <span class="token operator">=</span> DispatcherServlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> name <span class="token operator">=</span> DEFAULT_DISPATCHER_SERVLET_BEAN_NAME<span class="token punctuation">)</span><span class="token keyword">public</span> ServletRegistrationBean <span class="token function">dispatcherServletRegistration</span><span class="token punctuation">(</span>      DispatcherServlet dispatcherServlet<span class="token punctuation">)</span> <span class="token punctuation">{</span>   ServletRegistrationBean registration <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletRegistrationBean</span><span class="token punctuation">(</span>         dispatcherServlet<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>serverProperties<span class="token punctuation">.</span><span class="token function">getServletMapping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp</span>    <span class="token comment" spellcheck="true">//可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径</span>   registration<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>DEFAULT_DISPATCHER_SERVLET_BEAN_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>   registration<span class="token punctuation">.</span><span class="token function">setLoadOnStartup</span><span class="token punctuation">(</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>webMvcProperties<span class="token punctuation">.</span><span class="token function">getServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLoadOnStartup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>multipartConfig <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      registration<span class="token punctuation">.</span><span class="token function">setMultipartConfig</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>multipartConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> registration<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="7-3-替换为其他嵌入式Servlet容器"><a href="#7-3-替换为其他嵌入式Servlet容器" class="headerlink" title="7.3  替换为其他嵌入式Servlet容器"></a>7.3  替换为其他嵌入式Servlet容器</h3><p>默认支持：</p><ul><li>Tomcat（默认使用）</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><ul><li>Jetty</li></ul><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- 引入web模块 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-tomcat<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--引入其他的Servlet容器--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-jetty<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><h3 id="7-4-嵌入式Servlet容器自动配置原理"><a href="#7-4-嵌入式Servlet容器自动配置原理" class="headerlink" title="7.4  嵌入式Servlet容器自动配置原理"></a>7.4  嵌入式Servlet容器自动配置原理</h3><p>EmbeddedServletContainerAutoConfiguration：嵌入式的Servlet容器自动配置</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@AutoConfigureOrder</span><span class="token punctuation">(</span>Ordered<span class="token punctuation">.</span>HIGHEST_PRECEDENCE<span class="token punctuation">)</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConditionalOnWebApplication</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>BeanPostProcessorsRegistrar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件</span><span class="token comment" spellcheck="true">//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：</span><span class="token comment" spellcheck="true">//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EmbeddedServletContainerAutoConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Configuration</span>    <span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span> Servlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Tomcat<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断当前是否引入了Tomcat依赖；</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>value <span class="token operator">=</span> EmbeddedServletContainerFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> search <span class="token operator">=</span> SearchStrategy<span class="token punctuation">.</span>CURRENT<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EmbeddedTomcat</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Bean</span>        <span class="token keyword">public</span> TomcatEmbeddedServletContainerFactory <span class="token function">tomcatEmbeddedServletContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TomcatEmbeddedServletContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Nested configuration if Jetty is being used.     */</span>    <span class="token annotation punctuation">@Configuration</span>    <span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span> Servlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Server<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Loader<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>            WebAppContext<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>value <span class="token operator">=</span> EmbeddedServletContainerFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> search <span class="token operator">=</span> SearchStrategy<span class="token punctuation">.</span>CURRENT<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EmbeddedJetty</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Bean</span>        <span class="token keyword">public</span> JettyEmbeddedServletContainerFactory <span class="token function">jettyEmbeddedServletContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JettyEmbeddedServletContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Nested configuration if Undertow is being used.     */</span>    <span class="token annotation punctuation">@Configuration</span>    <span class="token annotation punctuation">@ConditionalOnClass</span><span class="token punctuation">(</span><span class="token punctuation">{</span> Servlet<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> Undertow<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> SslClientAuthMode<span class="token punctuation">.</span><span class="token keyword">class</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>value <span class="token operator">=</span> EmbeddedServletContainerFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> search <span class="token operator">=</span> SearchStrategy<span class="token punctuation">.</span>CURRENT<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">EmbeddedUndertow</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Bean</span>        <span class="token keyword">public</span> UndertowEmbeddedServletContainerFactory <span class="token function">undertowEmbeddedServletContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">UndertowEmbeddedServletContainerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><ol><li><p>EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EmbeddedServletContainerFactory</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//获取嵌入式的Servlet容器</span>   EmbeddedServletContainer <span class="token function">getEmbeddedServletContainer</span><span class="token punctuation">(</span>         ServletContextInitializer<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initializers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><ol start="2"><li>EmbeddedServletContainer：（嵌入式的Servlet容器）</li></ol><ol start="3"><li>以<strong>TomcatEmbeddedServletContainerFactory</strong>为例</li></ol><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> EmbeddedServletContainer <span class="token function">getEmbeddedServletContainer</span><span class="token punctuation">(</span>      ServletContextInitializer<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initializers<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建一个Tomcat</span>   Tomcat tomcat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tomcat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//配置Tomcat的基本环节</span>   File baseDir <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>baseDirectory <span class="token operator">!=</span> null <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>baseDirectory         <span class="token operator">:</span> <span class="token function">createTempDir</span><span class="token punctuation">(</span><span class="token string">"tomcat"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   tomcat<span class="token punctuation">.</span><span class="token function">setBaseDir</span><span class="token punctuation">(</span>baseDir<span class="token punctuation">.</span><span class="token function">getAbsolutePath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   Connector connector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Connector</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//连接器,引擎等等</span>   tomcat<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addConnector</span><span class="token punctuation">(</span>connector<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">customizeConnector</span><span class="token punctuation">(</span>connector<span class="token punctuation">)</span><span class="token punctuation">;</span>   tomcat<span class="token punctuation">.</span><span class="token function">setConnector</span><span class="token punctuation">(</span>connector<span class="token punctuation">)</span><span class="token punctuation">;</span>   tomcat<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAutoDeploy</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">configureEngine</span><span class="token punctuation">(</span>tomcat<span class="token punctuation">.</span><span class="token function">getEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>Connector additionalConnector <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>additionalTomcatConnectors<span class="token punctuation">)</span> <span class="token punctuation">{</span>      tomcat<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addConnector</span><span class="token punctuation">(</span>additionalConnector<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token function">prepareContext</span><span class="token punctuation">(</span>tomcat<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> initializers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器</span>   <span class="token keyword">return</span> <span class="token function">getTomcatEmbeddedServletContainer</span><span class="token punctuation">(</span>tomcat<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h1 id="8-SpringBoot与数据访问"><a href="#8-SpringBoot与数据访问" class="headerlink" title="8-SpringBoot与数据访问"></a>8-SpringBoot与数据访问</h1><h2 id="8-1-JDBC"><a href="#8-1-JDBC" class="headerlink" title="8.1  JDBC"></a>8.1  JDBC</h2><ol><li><p>加入依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-jdbc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre></li><li><p>配置</p><pre class=" language-yml"><code class="language-yml">spring:  datasource:    username: root    password: 123456    url: jdbc:mysql://192.168.15.22:3306/jdbc    driver-class-name: com.mysql.jdbc.Driver</code></pre><ul><li><p>效果：</p><p> 默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p><p> 数据源的相关配置都在DataSourceProperties里面；</p><p>自动配置原理：</p><p>org.springframework.boot.autoconfigure.jdbc：</p></li></ul><p>（1）参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；</p><p>（2）SpringBoot默认可以支持；</p><pre class=" language-java"><code class="language-java">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>tomcat<span class="token punctuation">.</span>jdbc<span class="token punctuation">.</span>pool<span class="token punctuation">.</span>DataSource、HikariDataSource、BasicDataSource、</code></pre><p>（3）自定义数据源类型</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Generic DataSource configuration. */</span><span class="token annotation punctuation">@ConditionalOnMissingBean</span><span class="token punctuation">(</span>DataSource<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"spring.datasource.type"</span><span class="token punctuation">)</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Generic</span> <span class="token punctuation">{</span>   <span class="token annotation punctuation">@Bean</span>   <span class="token keyword">public</span> DataSource <span class="token function">dataSource</span><span class="token punctuation">(</span>DataSourceProperties properties<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性</span>      <span class="token keyword">return</span> properties<span class="token punctuation">.</span><span class="token function">initializeDataSourceBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（4）<strong>DataSourceInitializer：ApplicationListener</strong>；</p><ul><li><p>作用</p><p>a、runSchemaScripts();运行建表语句；</p><p>b、runDataScripts();运行插入数据的sql语句；</p><p>默认只需要将文件命名为：</p><pre class=" language-properties"><code class="language-properties">schema-*.sql、data-*.sql默认规则：schema.sql，schema-all.sql；<span class="token attr-name">可以使用</span> <span class="token attr-value">  </span><span class="token attr-name">    schema</span><span class="token punctuation">:</span><span class="token attr-name">      -</span> <span class="token attr-value">classpath:department.sql</span>      指定位置</code></pre></li></ul><p>（5）操作数据库：自动配置了JdbcTemplate操作数据库</p></li></ol><h2 id="8-2-整合Druid数据源"><a href="#8-2-整合Druid数据源" class="headerlink" title="8.2  整合Druid数据源"></a>8.2  整合Druid数据源</h2><ul><li>导入druid数据源</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DruidConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//这两参数是为了把我们自己的bean绑定起来</span>    <span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"spring.datasource"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//配置文件的路径</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> DataSource <span class="token function">druid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span>  <span class="token keyword">new</span> <span class="token class-name">DruidDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//配置Druid的监控</span>    <span class="token comment" spellcheck="true">//1、配置一个管理后台的Servlet</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ServletRegistrationBean <span class="token function">statViewServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注册一个servlet. StaViewServlet就是进入后台管理的Servlet</span>        ServletRegistrationBean bean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServletRegistrationBean</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StatViewServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"/druid/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//处理diuid下面的所有请求就进入了管理后台</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> initParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"loginUsername"</span><span class="token punctuation">,</span><span class="token string">"admin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用户名</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"loginPassword"</span><span class="token punctuation">,</span><span class="token string">"123456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//密码</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"allow"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//默认就是允许所有访问 在StaViewServlet里面的参数</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"deny"</span><span class="token punctuation">,</span><span class="token string">"192.168.15.21"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拒绝这个路径访问</span>        bean<span class="token punctuation">.</span><span class="token function">setInitParameters</span><span class="token punctuation">(</span>initParams<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//2、配置一个web监控的filter</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> FilterRegistrationBean <span class="token function">webStatFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//注册一个Filter</span>        FilterRegistrationBean bean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FilterRegistrationBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bean<span class="token punctuation">.</span><span class="token function">setFilter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WebStatFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置初始化参数</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> initParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//排除那些请求</span>        initParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"exclusions"</span><span class="token punctuation">,</span><span class="token string">"*.js,*.css,/druid/*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bean<span class="token punctuation">.</span><span class="token function">setInitParameters</span><span class="token punctuation">(</span>initParams<span class="token punctuation">)</span><span class="token punctuation">;</span>        bean<span class="token punctuation">.</span><span class="token function">setUrlPatterns</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"/*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拦截所有请求</span>        <span class="token keyword">return</span>  bean<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加在bean中</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> </code></pre><h2 id="8-3-整合MyBatis"><a href="#8-3-整合MyBatis" class="headerlink" title="8.3  整合MyBatis"></a>8.3  整合MyBatis</h2><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><code>步骤：</code></p><ol><li><p>配置数据源相关属性（见上一节Druid）</p></li><li><p>给数据库建表</p></li><li><p>创建JavaBean</p></li><li><p><strong>注解版</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//指定这是一个操作数据库的mapper</span><span class="token annotation punctuation">@Mapper</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DepartmentMapper</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select * from department where id=#{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Department <span class="token function">getDeptById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Delete</span><span class="token punctuation">(</span><span class="token string">"delete from department where id=#{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">deleteDeptById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取到自增的主键,是否是自增=true ,那个是主键 id</span>    <span class="token annotation punctuation">@Options</span><span class="token punctuation">(</span>useGeneratedKeys <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>keyProperty <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Insert</span><span class="token punctuation">(</span><span class="token string">"insert into department(departmentName) values(#{departmentName})"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">insertDept</span><span class="token punctuation">(</span>Department department<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Update</span><span class="token punctuation">(</span><span class="token string">"update department set departmentName=#{departmentName} where id=#{id}"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">updateDept</span><span class="token punctuation">(</span>Department department<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p>自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@org</span><span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Configuration<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBatisConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> ConfigurationCustomizer <span class="token function">configurationCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConfigurationCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//配置驼峰命名 法</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">customize</span><span class="token punctuation">(</span>Configuration configuration<span class="token punctuation">)</span> <span class="token punctuation">{</span>                configuration<span class="token punctuation">.</span><span class="token function">setMapUnderscoreToCamelCase</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>使用MapperScan批量扫描所有的Mapper接口；</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"com.atguigu.springboot.mapper"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringBoot06DataMybatisApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringBoot06DataMybatisApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>配置文件版</p><pre class=" language-yml"><code class="language-yml">mybatis:  config-location: classpath:mybatis/mybatis-config.xml 指定全局配置文件的位置  mapper-locations: classpath:mybatis/mapper/*.xml  指定sql映射文件的位置</code></pre><p>更多使用参照</p><p><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p></li></ol><h2 id="8-4-整合SpringData-JPA"><a href="#8-4-整合SpringData-JPA" class="headerlink" title="8.4  整合SpringData JPA"></a>8.4  整合SpringData JPA</h2><h3 id="8-4-1-SpringData简介"><a href="#8-4-1-SpringData简介" class="headerlink" title="8.4-1  SpringData简介"></a>8.4-1  SpringData简介</h3><p><img src="/2019/12/25/springboot-bi-ji-yi/jpa.png" alt="jpa"></p><h3 id="8-4-2-整合SpringData-JPA"><a href="#8-4-2-整合SpringData-JPA" class="headerlink" title="8.4-2  整合SpringData JPA"></a>8.4-2  整合SpringData JPA</h3><ol><li><p>编写一个实体类（bean）和数据表进行映射，并且配置好映射关系</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//使用JPA注解配置映射关系</span><span class="token annotation punctuation">@Entity</span> <span class="token comment" spellcheck="true">//告诉JPA这是一个实体类（和数据表映射的类）</span><span class="token annotation punctuation">@Table</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"tbl_user"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//@Table来指定和哪个数据表对应;如果省略默认表名就是user；</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span> <span class="token comment" spellcheck="true">//这是一个主键</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> GenerationType<span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//自增主键</span>    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"last_name"</span><span class="token punctuation">,</span>length <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这是和数据表对应的一个列</span>    <span class="token keyword">private</span> String lastName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span> <span class="token comment" spellcheck="true">//省略默认列名就是属性名</span>    <span class="token keyword">private</span> String email<span class="token punctuation">;</span></code></pre></li><li><p>编写一个Dao接口来操作实体类对应的数据表（Repository）</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//继承JpaRepository来完成对数据库的操作</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserRepository</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token operator">&lt;</span>User<span class="token punctuation">,</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li><li><p>基本的配置JpaProperties</p><pre class=" language-yml"><code class="language-yml">spring:   jpa:    hibernate:            #更新或者创建数据表结构      ddl-auto: update        #控制台显示SQL    show-sql: true</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
