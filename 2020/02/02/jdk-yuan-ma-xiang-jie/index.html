<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JDK源码详解, 空白格的博客">
    <meta name="description" content="JDK源码详解1-基础1.1-String、Long 源码解析和面试题String 和 Long 大家都很熟悉，本小节主要结合实际的工作场景，来一起看下 String 和 Long 的底层源码实现，看看平时我们使用时，有无需要注意的点，总结">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>JDK源码详解 | 空白格的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="空白格的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">空白格的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">空白格的博客</div>
        <div class="logo-desc">
            
            个人技术博客：主要是一些技术杂谈和学习笔记的分享
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/fangpeng12" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #36b3ec;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/fangpeng12" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/17.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        JDK源码详解
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JDK-%E6%BA%90%E7%A0%81/">
                                <span class="chip bg-color">JDK 源码</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java%E6%BA%90%E7%A0%81/" class="post-category">
                                Java源码
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-02-02
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    67.1k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    254 分
                </div>
                
				
                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="JDK源码详解"><a href="#JDK源码详解" class="headerlink" title="JDK源码详解"></a>JDK源码详解</h1><h2 id="1-基础"><a href="#1-基础" class="headerlink" title="1-基础"></a>1-基础</h2><h3 id="1-1-String、Long-源码解析和面试题"><a href="#1-1-String、Long-源码解析和面试题" class="headerlink" title="1.1-String、Long 源码解析和面试题"></a>1.1-String、Long 源码解析和面试题</h3><p>String 和 Long 大家都很熟悉，本小节主要结合实际的工作场景，来一起看下 String 和 Long 的底层源码实现，看看平时我们使用时，有无需要注意的点，总结一下这些 API 都适用于哪些场景。</p>
<h4 id="1-1-1-String"><a href="#1-1-1-String" class="headerlink" title="1.1.1-String"></a>1.1.1-String</h4><ol>
<li><h5 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a><strong>不变性</strong></h5><p>我们常常听人说，HashMap 的 key 建议使用不可变类，比如说 String 这种不可变类。这里说的不可变指的是类值一旦被初始化，就不能再被改变了，如果被修改，将会是新的类，我们写个 demo 来演示一下。</p>
<pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">;</span>
s <span class="token operator">=</span><span class="token string">"world"</span><span class="token punctuation">;</span></code></pre>
<p>从代码上来看，s 的值好像被修改了，但从 debug 的日志来看，其实是 s 的内存地址已经被修改了，也就说 s =“world” 这个看似简单的赋值，其实已经把 s 的引用指向了新的 String，debug 的截图显示内存地址已经被修改，两张截图如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/String1.jpeg" alt="String1"></p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/String2.jpeg" alt="String2"></p>
<p>我们从源码上查看一下原因：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
    <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>    </code></pre>
<p>我们可以看出来两点：</p>
<ul>
<li>String 被 final 修饰，说明 String 类绝不可能被继承了，也就是说任何对 String 的操作方法，都不会被继承覆写；</li>
<li>String 中保存数据的是一个 char 的数组 value。我们发现 value 也是被 final 修饰的，也就是说 value 一旦被赋值，内存地址是绝对无法修改的，而且 value 的权限是 private 的，外部绝对访问不到，String 也没有开放出可以对 value 进行赋值的方法，所以说 value 一旦产生，内存地址就根本无法被修改。</li>
</ul>
<p>以上两点就是 String 不变性的原因，充分利用了 final 关键字的特性，如果你自定义类时，希望也是不可变的，也可以模仿 String 的这两点操作。</p>
<p><strong>因为 String 具有不变性，所以 String 的大多数操作方法，都会返回新的 String，</strong>如下面这种写法是不对的：</p>
<pre class=" language-java"><code class="language-java">String str <span class="token operator">=</span><span class="token string">"hello world !!"</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 这种写法是替换不掉的，必须接受 replace 方法返回的参数才行，这样才行：str = str.replace("l","dd");</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"l"</span><span class="token punctuation">,</span><span class="token string">"dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</li>
<li><h5 id="字符串乱码"><a href="#字符串乱码" class="headerlink" title="字符串乱码"></a><strong>字符串乱码</strong></h5><p>在生活中，我们经常碰到这样的场景，进行二进制转化操作时，本地测试的都没有问题，到其它环境机器上时，有时会出现字符串乱码的情况，这个主要是因为在二进制转化操作时，并没有强制规定文件编码，而不同的环境默认的文件编码不一致导致的。</p>
<p>我们也写了一个 demo 来模仿一下字符串乱码：</p>
<pre class=" language-java"><code class="language-java">String str  <span class="token operator">=</span><span class="token string">"nihao 你好 喬亂"</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 字符串转化成 byte 数组</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// byte 数组转化成字符串</span>
String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 结果打印为：</span>
nihao <span class="token operator">?</span><span class="token operator">?</span> <span class="token operator">?</span><span class="token operator">?</span></code></pre>
<p>打印的结果为？？，这就是常见的乱码表现形式。这时候有同学说，是不是我把代码修改成 <code>String s2 = new String(bytes,&quot;ISO-8859-1&quot;);</code> 就可以了？这是不行的。主要是因为 ISO-8859-1 这种编码对中文的支持有限，导致中文会显示乱码。唯一的解决办法，就是在所有需要用到编码的地方，都统一使用 UTF-8，对于 String 来说，getBytes 和 new String 两个方法都会使用到编码，我们把这两处的编码替换成 UTF-8 后，打印出的结果就正常了。</p>
</li>
</ol>
<ol start="3">
<li><h5 id="首字母大小写"><a href="#首字母大小写" class="headerlink" title="首字母大小写"></a><strong>首字母大小写</strong></h5><p>如果我们的项目被 Spring 托管的话，有时候我们会通过 <code>applicationContext.getBean(className);</code> 这种方式得到 SpringBean，这时 className 必须是要满足首字母小写的，除了该场景，在反射场景下面，我们也经常要使类属性的首字母小写，这时候我们一般都会这么做：</p>
<p><code>name.substring(0, 1).toLowerCase() + name.substring(1);</code>，使用 substring 方法，该方法主要是为了截取字符串连续的一部分，substring 有两个方法：</p>
<ul>
<li><code>public String substring(int beginIndex, int endIndex)</code> beginIndex：开始位置，endIndex：结束位置；</li>
<li><code>public String substring(int beginIndex)</code>beginIndex：开始位置，结束位置为文本末尾。</li>
</ul>
<p>substring 方法的底层使用的是字符数组范围截取的方法 ：<code>Arrays.copyOfRange(字符数组, 开始位置, 结束位置);</code> 从字符数组中进行一段范围的拷贝。</p>
<p>相反的，如果要修改成首字母大写，只需要修改成 <code>name.substring(0, 1).toUpperCase() + name.substring(1)</code> 即可。</p>
</li>
</ol>
<ol start="4">
<li><h5 id="相等判断"><a href="#相等判断" class="headerlink" title="相等判断"></a><strong>相等判断</strong></h5><p>我们判断相等有两种办法，equals 和 equalsIgnoreCase。后者判断相等时，会忽略大小写，近期看见一些面试题在问：如果让你写判断两个 String 相等的逻辑，应该如何写，我们来一起看下 equals 的源码，整理一下思路：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 判断内存地址是否相同</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 待比较的对象是否是 String，如果不是 String，直接返回不相等</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String anotherString <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 两个字符串的长度是否相等，不等则直接返回不相等</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 依次比较每个字符是否相等，若有一个不等，直接返回不相等</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从 equals 的源码可以看出，逻辑非常清晰，完全是根据 String 底层的结构来编写出相等的代码。这也提供了一种思路给我们：如果有人问如何判断两者是否相等时，我们可以从两者的底层结构出发，这样可以迅速想到一种贴合实际的思路和方法，就像 String 底层的数据结构是 char 的数组一样，判断相等时，就挨个比较 char 数组中的字符是否相等即可。</p>
</li>
</ol>
<ol start="5">
<li><h5 id="替换、删除"><a href="#替换、删除" class="headerlink" title="替换、删除"></a><strong>替换、删除</strong></h5><p>替换在工作中也经常使用，有 replace 替换所有字符、replaceAll 批量替换字符串、replaceFirst 替换遇到的第一个字符串三种场景。</p>
<p>其中在使用 replace 时需要注意，replace 有两个方法，一个入参是 char，一个入参是 String，前者表示替换所有字符，如：<code>name.replace(&#39;a&#39;,&#39;b&#39;)</code>，后者表示替换所有字符串，如：<code>name.replace(&quot;a&quot;,&quot;b&quot;)</code>，两者就是单引号和多引号的区别。</p>
<p>需要注意的是， replace 并不只是替换一个，是替换所有匹配到的字符或字符串哦。</p>
<p>写了一个 demo 演示一下三种场景：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReplace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  String str <span class="token operator">=</span><span class="token string">"hello word !!"</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"替换之前 :{}"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'l'</span><span class="token punctuation">,</span><span class="token string">'d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"替换所有字符 :{}"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">,</span><span class="token string">"l"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"替换全部 :{}"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
  str <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">replaceFirst</span><span class="token punctuation">(</span><span class="token string">"l"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"替换第一个 l :{}"</span><span class="token punctuation">,</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//输出的结果是：</span>
替换之前 <span class="token operator">:</span>hello word <span class="token operator">!</span><span class="token operator">!</span>
替换所有字符 <span class="token operator">:</span>heddo word <span class="token operator">!</span><span class="token operator">!</span>
替换全部 <span class="token operator">:</span>hello worl <span class="token operator">!</span><span class="token operator">!</span>
替换第一个 <span class="token operator">:</span>helo worl <span class="token operator">!</span><span class="token operator">!</span></code></pre>
<p>当然我们想要删除某些字符，也可以使用 replace 方法，把想删除的字符替换成 “” 即可。</p>
</li>
</ol>
<ol start="6">
<li><h5 id="拆分和合并"><a href="#拆分和合并" class="headerlink" title="拆分和合并"></a><strong>拆分和合并</strong></h5><p>拆分我们使用 split 方法，该方法有两个入参数。第一个参数是我们拆分的标准字符，第二个参数是一个 int 值，叫 limit，来限制我们需要拆分成几个元素。如果 limit 比实际能拆分的个数小，按照 limit 的个数进行拆分。</p>
<p>我们演示一个 demo：</p>
<pre class=" language-java"><code class="language-java">String s <span class="token operator">=</span><span class="token string">"boo:and:foo"</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 我们对 s 进行了各种拆分，演示的代码和结果是：</span>
s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"boo"</span><span class="token punctuation">,</span><span class="token string">"and"</span><span class="token punctuation">,</span><span class="token string">"foo"</span><span class="token punctuation">]</span>
s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"boo"</span><span class="token punctuation">,</span><span class="token string">"and:foo"</span><span class="token punctuation">]</span>
s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"boo"</span><span class="token punctuation">,</span><span class="token string">"and"</span><span class="token punctuation">,</span><span class="token string">"foo"</span><span class="token punctuation">]</span>
s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"boo"</span><span class="token punctuation">,</span><span class="token string">"and"</span><span class="token punctuation">,</span><span class="token string">"foo"</span><span class="token punctuation">]</span>
s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"o"</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">":and:f"</span><span class="token punctuation">]</span>
s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"o"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"o:and:foo"</span><span class="token punctuation">]</span></code></pre>
<p>从演示的结果来看，limit 对拆分的结果，是具有限制作用的，还有就是拆分结果里面不会出现被拆分的字段。</p>
<p>那如果字符串里面有一些空值呢，拆分的结果如下：</p>
<pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span><span class="token string">",a,,b,"</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span> 结果<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">]</span></code></pre>
<p>从拆分结果中，我们可以看到，空值是拆分不掉的，仍然成为结果数组的一员，如果我们想删除空值，只能自己拿到结果后再做操作，但 Guava（Google 开源的技术工具） 提供了一些可靠的工具类，可以帮助我们快速去掉空值，如下：</p>
<pre class=" language-java"><code class="language-java">String a <span class="token operator">=</span><span class="token string">",a, ,  b  c ,"</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Splitter 是 Guava 提供的 API </span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Splitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">trimResults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 去掉空格</span>
    <span class="token punctuation">.</span><span class="token function">omitEmptyStrings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 去掉空值</span>
    <span class="token punctuation">.</span><span class="token function">splitToList</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Guava 去掉空格的分割方法：{}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 打印出的结果为：</span>
<span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"b  c"</span><span class="token punctuation">]</span></code></pre>
<p>从打印的结果中，可以看到去掉了空格和空值，这正是我们工作中常常期望的结果，所以推荐使用 Guava 的 API 对字符串进行分割。</p>
<p>合并我们使用 join 方法，此方法是静态的，我们可以直接使用。方法有两个入参，参数一是合并的分隔符，参数二是合并的数据源，数据源支持数组和 List，在使用的时候，我们发现有两个不太方便的地方：</p>
<ul>
<li>不支持依次 join 多个字符串，比如我们想依次 join 字符串 s 和 s1，如果你这么写的话 <code>String.join(&quot;,&quot;,s).join(&quot;,&quot;,s1)</code> 最后得到的是 s1 的值，第一次 join 的值被第二次 join 覆盖了；</li>
<li>如果 join 的是一个 List，无法自动过滤掉 null 值。</li>
</ul>
<p>而 Guava 正好提供了 API，解决上述问题，我们来演示一下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 依次 join 多个字符串，Joiner 是 Guava 提供的 API</span>
Joiner joiner <span class="token operator">=</span> Joiner<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skipNulls</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
String result <span class="token operator">=</span> joiner<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token string">"china"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"依次 join 多个字符串:{}"</span><span class="token punctuation">,</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>

List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"hello"</span><span class="token punctuation">,</span><span class="token string">"china"</span><span class="token punctuation">,</span>null<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"自动删除 list 中空值:{}"</span><span class="token punctuation">,</span>joiner<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 输出的结果为；</span>
依次 join 多个字符串<span class="token operator">:</span>hello<span class="token punctuation">,</span>china
自动删除 list 中空值<span class="token operator">:</span>hello<span class="token punctuation">,</span>china</code></pre>
<p>从结果中，我们可以看到 Guava 不仅仅支持多个字符串的合并，还帮助我们去掉了 List 中的空值，这就是我们在工作中常常需要得到的结果。</p>
</li>
</ol>
<h4 id="1-1-2-Long"><a href="#1-1-2-Long" class="headerlink" title="1.1.2-Long"></a>1.1.2-Long</h4><ol>
<li><h5 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a><strong>缓存</strong></h5><p>Long 最被我们关注的就是 Long 的缓存问题，Long 自己实现了一种缓存机制，缓存了从 -128 到 127 内的所有 Long 值，如果是这个范围内的 Long 值，就不会初始化，而是从缓存中拿，缓存初始化源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LongCache</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token function">LongCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 缓存，范围从 -128 到 127，+1 是因为有个 0</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> Long cache<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">127</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 容器初始化时，进行加载</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 缓存 Long 值，注意这里是 i - 128 ，所以再拿的时候就需要 + 128</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Long</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">128</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ol>
<h4 id="1-1-3-面试题"><a href="#1-1-3-面试题" class="headerlink" title="1.1.3-面试题"></a>1.1.3-面试题</h4><ol>
<li><h5 id="为什么使用-Long-时，大家推荐多使用-valueOf-方法，少使用-parseLong-方法"><a href="#为什么使用-Long-时，大家推荐多使用-valueOf-方法，少使用-parseLong-方法" class="headerlink" title="为什么使用 Long 时，大家推荐多使用 valueOf 方法，少使用 parseLong 方法"></a><strong>为什么使用 Long 时，大家推荐多使用 valueOf 方法，少使用 parseLong 方法</strong></h5><p>答：因为 Long 本身有缓存机制，缓存了 -128 到 127 范围内的 Long，valueOf 方法会从缓存中去拿值，如果命中缓存，会减少资源的开销，parseLong 方法就没有这个机制。</p>
</li>
<li><h5 id="如何解决-String-乱码的问题"><a href="#如何解决-String-乱码的问题" class="headerlink" title="如何解决 String 乱码的问题"></a><strong>如何解决 String 乱码的问题</strong></h5><p>答：乱码的问题的根源主要是两个：字符集不支持复杂汉字、二进制进行转化时字符集不匹配，所以在 String 乱码时我们可以这么做：</p>
<ul>
<li>所有可以指定字符集的地方强制指定字符集，比如 new String 和 getBytes 这两个地方；</li>
<li>我们应该使用 UTF-8 这种能完整支持复杂汉字的字符集。</li>
</ul>
</li>
<li><h5 id="为什么大家都说-String-是不可变的"><a href="#为什么大家都说-String-是不可变的" class="headerlink" title="为什么大家都说 String 是不可变的"></a><strong>为什么大家都说 String 是不可变的</strong></h5><p>答：主要是因为 String 和保存数据的 char 数组，都被 final 关键字所修饰，所以是不可变的，具体细节描述可以参考上文。</p>
</li>
<li><h5 id="String-一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题"><a href="#String-一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题" class="headerlink" title="String 一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题"></a><strong>String 一些常用操作问题，如问如何分割、合并、替换、删除、截取等等问题</strong></h5><p>答：这些都属于问 String 的基本操作题目，考察我们平时对 String 的使用熟练程度，可以参考上文。</p>
</li>
</ol>
<h3 id="1-2-Java常用关键字详解"><a href="#1-2-Java常用关键字详解" class="headerlink" title="1.2-Java常用关键字详解"></a>1.2-Java常用关键字详解</h3><p>Java 中的关键字很多，大约有 50+，在命名上我们不能和这些关键字冲突的，编译会报错，每个关键字都代表着不同场景下的不同含义，接下来我们挑选 6 个比较重要的关键字，深入学习一下。</p>
<h4 id="1-2-1-static"><a href="#1-2-1-static" class="headerlink" title="1.2.1-static"></a>1.2.1-static</h4><p>意思是静态的、全局的，一旦被修饰，说明被修饰的东西在一定范围内是共享的，谁都可以访问，这时候需要注意并发读写的问题。</p>
<ol>
<li><h5 id="修饰的对象"><a href="#修饰的对象" class="headerlink" title="修饰的对象"></a><strong>修饰的对象</strong></h5><p>static 只能修饰类变量、方法和方法块。</p>
<p><strong>当 static 修饰类变量时</strong>，如果该变量是 public 的话，表示该变量任何类都可以直接访问，而且无需初始化类，直接使用 <strong>类名.static 变量</strong> 这种形式访问即可。</p>
<p>这时候我们非常需要注意的一点就是线程安全的问题了，因为当多个线程同时对共享变量进行读写时，很有可能会出现并发问题，如我们定义了：<code>public static List list = new ArrayList();</code>这样的共享变量。这个 list 如果同时被多个线程访问的话，就有线程安全的问题，这时候一般有两个解决办法：</p>
<ul>
<li>把线程不安全的 ArrayList 换成 线程安全的 CopyOnWriteArrayList；</li>
<li>每次访问时，手动加锁。</li>
</ul>
<p>所以在使用 static 修饰类变量时，如何保证线程安全是我们常常需要考虑的。</p>
<p><strong>当 static 修饰方法时</strong>，代表该方法和当前类是无关的，任意类都可以直接访问（如果权限是 public 的话）。</p>
<p>有一点需要注意的是，该方法内部只能调用同样被 static 修饰的方法，不能调用普通方法，我们常用的 util 类里面的各种方法，我们比较喜欢用 static 修饰方法，好处就是调用特别方便。</p>
<p>static 方法内部的变量在执行时是没有线程安全问题的。方法执行时，数据运行在栈里面，栈的数据每个线程都是隔离开的，所以不会有线程安全的问题，所以 util 类的各个 static 方法，我们是可以放心使用的。</p>
<p><strong>当 static 修饰方法块时</strong>，我们叫做静态块，静态块常常用于在类启动之前，初始化一些值。</p>
<p>比如：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 进行一些初始化的工作</span>
<span class="token keyword">static</span> <span class="token punctuation">{</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这段代码演示了静态块做一些初始化的工作，但需要注意的是，静态块只能调用同样被 static 修饰的变量，并且 static 的变量需要写在静态块的前面，不然编译也会报错。</p>
</li>
</ol>
<ol start="2">
<li><h5 id="初始化时机"><a href="#初始化时机" class="headerlink" title="初始化时机"></a><strong>初始化时机</strong></h5><p>对于被 static 修饰的类变量、方法块和静态方法的初始化时机。</p>
<p>我们写了一个测试 demo，如下图：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/static.jpeg" alt="static"></p>
<p>打印出来的结果是：</p>
<pre class=" language-java"><code class="language-java">父类静态变量初始化
父类静态块初始化
子类静态变量初始化
子类静态块初始化
main 方法执行
父类构造器初始化
子类构造器初始化</code></pre>
<p>从结果中，我们可以看出两点：</p>
<ul>
<li>父类的静态变量和静态块比子类优先初始化；</li>
<li>静态变量和静态块比类构造器优先初始化。</li>
</ul>
<p>被 static 修饰的方法，在类初始化的时候并不会初始化，只有当自己被调用时，才会被执行。</p>
</li>
</ol>
<h4 id="1-2-2-final"><a href="#1-2-2-final" class="headerlink" title="1.2.2-final"></a>1.2.2-final</h4><p>final 的意思是不变的，一般来说用于以下三种场景：</p>
<ol>
<li>被 final 修饰的类，表明该类是无法继承的；</li>
<li>被 final 修饰的方法，表明该方法是无法覆写的；</li>
<li>被 final 修饰的变量，说明该变量在声明的时候，就必须初始化完成，而且以后也不能修改其内存地址。</li>
</ol>
<p>第三点注意下，我们说的是无法修改其内存地址，并没有说无法修改其值。因为对于 List、Map 这些集合类来说，被 final 修饰后，是可以修改其内部值的，但却无法修改其初始化时的内存地址。</p>
<p>例子我们就不举了，1-1 小节 String 的不变性就是一个很好的例子。</p>
<h4 id="1-2-3-try、catch、finally"><a href="#1-2-3-try、catch、finally" class="headerlink" title="1.2.3-try、catch、finally"></a>1.2.3-try、catch、finally</h4><p>这三个关键字常用于我们捕捉异常的一整套流程，try 用来确定代码执行的范围，catch 捕捉可能会发生的异常，finally 用来执行一定要执行的代码块，除了这些，我们还需要清楚，每个地方如果发生异常会怎么办。</p>
<p>我们举一个例子来演示一下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testCatchFinally</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"try is run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"try exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"catch is run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"catch exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"finally is run"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这个代码演示了在 try、catch 中都遇到了异常，代码的执行顺序为：try -&gt; catch -&gt; finally。</p>
<p>输出的结果如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/try-catch.jpeg" alt="try-catch"></p>
<p>可以看到两点：</p>
<ul>
<li>finally 先执行后，再抛出 catch 的异常；</li>
<li>最终捕获的异常是 catch 的异常，try 抛出来的异常已经被 catch 吃掉了，所以当我们遇见 catch 也有可能会抛出异常时，我们可以先打印出 try 的异常，这样 try 的异常在日志中就会有所体现。</li>
</ul>
<h4 id="1-2-4-volatile"><a href="#1-2-4-volatile" class="headerlink" title="1.2.4-volatile"></a>1.2.4-volatile</h4><p>volatile 的意思是可见的，常用来修饰某个共享变量，意思是当共享变量的值被修改后，会及时通知到其它线程上，其它线程就能知道当前共享变量的值已经被修改了。</p>
<p>我们再说原理之前，先说下基础知识。就是在多核 CPU 下，为了提高效率，线程在拿值时，是直接和 CPU 缓存打交道的，而不是内存。主要是因为 CPU 缓存执行速度更快，比如线程要拿值 C，会直接从 CPU 缓存中拿， CPU 缓存中没有，就会从内存中拿，所以线程读的操作永远都是拿 CPU 缓存的值。</p>
<p>这时候会产生一个问题，CPU 缓存中的值和内存中的值可能并不是时刻都同步，导致线程计算的值可能不是最新的，共享变量的值有可能已经被其它线程所修改了，但此时修改是机器内存的值，CPU 缓存的值还是老的，导致计算会出现问题。</p>
<p>这时候有个机制，就是内存会主动通知 CPU 缓存。当前共享变量的值已经失效了，你需要重新来拉取一份，CPU 缓存就会重新从内存中拿取一份最新的值。</p>
<p>volatile 关键字就会触发这种机制，加了 volatile 关键字的变量，就会被识别成共享变量，内存中值被修改后，会通知到各个 CPU 缓存，使 CPU 缓存中的值也对应被修改，从而保证线程从 CPU 缓存中拿取出来的值是最新的。</p>
<p>我们画了一个图来说明一下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/volatile.jpeg" alt="volatile"></p>
<p>从图中我们可以看到，线程 1 和线程 2 一开始都读取了 C 值，CPU 1 和 CPU 2 缓存中也都有了 C 值，然后线程 1 把 C 值修改了，这时候内存的值和 CPU 2 缓存中的 C 值就不等了，内存这时发现 C 值被 volatile 关键字修饰，发现其是共享变量，就会使 CPU 2 缓存中的 C 值状态置为无效，CPU 2 会从内存中重新拉取最新的值，这时候线程 2 再来读取 C 值时，读取的已经是内存中最新的值了。</p>
<h4 id="1-2-5-transient"><a href="#1-2-5-transient" class="headerlink" title="1.2.5-transient"></a>1.2.5-transient</h4><p>transient 关键字我们常用来修饰类变量，意思是当前变量是无需进行序列化的。在序列化时，就会忽略该变量，这些在序列化工具底层，就已经对 transient 进行了支持。</p>
<h4 id="1-2-6-default"><a href="#1-2-6-default" class="headerlink" title="1.2.6-default"></a>1.2.6-default</h4><p>default 关键字一般会用在接口的方法上，意思是对于该接口，子类是无需强制实现的，但自己必须有默认实现，我们举个例子如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/default.jpeg" alt="default"></p>
<p>default 关键字被很多源码使用，我们后面会说。</p>
<h4 id="1-2-7-面试题"><a href="#1-2-7-面试题" class="headerlink" title="1.2.7-面试题"></a>1.2.7-面试题</h4><ol>
<li><h5 id="如何证明-static-静态变量和类无关？"><a href="#如何证明-static-静态变量和类无关？" class="headerlink" title="如何证明 static 静态变量和类无关？"></a><strong>如何证明 static 静态变量和类无关？</strong></h5><p>答：从三个方面就可以看出静态变量和类无关。</p>
<ol>
<li>我们不需要初始化类就可直接使用静态变量；</li>
<li>我们在类中写个 main 方法运行，即便不写初始化类的代码，静态变量都会自动初始化；</li>
<li>静态变量只会初始化一次，初始化完成之后，不管我再 new 多少个类出来，静态变量都不会再初始化了。</li>
</ol>
<p>不仅仅是静态变量，静态方法块也和类无关。</p>
</li>
<li><h5 id="常常看见变量和方法被-static-和-final-两个关键字修饰，为什么这么做？"><a href="#常常看见变量和方法被-static-和-final-两个关键字修饰，为什么这么做？" class="headerlink" title="常常看见变量和方法被 static 和 final 两个关键字修饰，为什么这么做？"></a><strong>常常看见变量和方法被 static 和 final 两个关键字修饰，为什么这么做？</strong></h5><p>答：这么做有两个目的：</p>
<ol>
<li>变量和方法于类无关，可以直接使用，使用比较方便；</li>
<li>强调变量内存地址不可变，方法不可继承覆写，强调了方法内部的稳定性。</li>
</ol>
</li>
<li><h5 id="catch-中发生了未知异常，finally-还会执行么？"><a href="#catch-中发生了未知异常，finally-还会执行么？" class="headerlink" title="catch 中发生了未知异常，finally 还会执行么？"></a><strong>catch 中发生了未知异常，finally 还会执行么？</strong></h5><p>答：会的，catch 发生了异常，finally 还会执行的，并且是 finally 执行完成之后，才会抛出 catch 中的异常。</p>
<p>不过 catch 会吃掉 try 中抛出的异常，为了避免这种情况，在一些可以预见 catch 中会发生异常的地方，先把 try 抛出的异常打印出来，这样从日志中就可以看到完整的异常了。</p>
</li>
<li><h5 id="volatile-关键字的作用和原理"><a href="#volatile-关键字的作用和原理" class="headerlink" title="volatile 关键字的作用和原理"></a><strong>volatile 关键字的作用和原理</strong></h5><p>答：这个上文说的比较清楚，可以参考上文。</p>
</li>
</ol>
<h4 id="1-2-8-总结"><a href="#1-2-8-总结" class="headerlink" title="1.2.8-总结"></a>1.2.8-总结</h4><p>Java 的关键字属于比较基础的内容，我们需要清晰明确其含义，才能在后续源码阅读和工作中碰到这些关键字时了然于心，才能明白为什么会在这里使用这样的关键字。比如 String 源码是如何使用 final 关键字达到起不变性的，比如 Java 8 集合中 Map 是如何利用 default 关键字新增各种方法的，这些我们在后续内容都会提到。</p>
<h3 id="1-3-Arrays、Collections、Objects-常用方法源码解析"><a href="#1-3-Arrays、Collections、Objects-常用方法源码解析" class="headerlink" title="1.3-Arrays、Collections、Objects 常用方法源码解析"></a>1.3-Arrays、Collections、Objects 常用方法源码解析</h3><p>我们在工作中都会写工具类，但如何才能使写出来的工具类更好用，也是有一些技巧的。本章内容以三种平时工作中经常使用的工具类为例，从使用案例出发，再看看底层源码的实现，看看能否学习到一些工具类的技巧，以及三种工具类的实际使用场景。</p>
<h4 id="1-3-1-工具类通用的特征"><a href="#1-3-1-工具类通用的特征" class="headerlink" title="1.3.1-工具类通用的特征"></a>1.3.1-工具类通用的特征</h4><p>再看细节之前，我们先总结一下好的工具类都有哪些通用的特征写法：</p>
<ol>
<li>构造器必须是私有的。这样的话，工具类就无法被 new 出来，因为工具类在使用的时候，无需初始化，直接使用即可，所以不会开放出构造器出来。</li>
<li>工具类的工具方法必须被 static、final 关键字修饰。这样的话就可以保证方法不可变，并且可以直接使用，非常方便。</li>
</ol>
<p>我们需要注意的是，尽量不在工具方法中，对共享变量有做修改的操作访问（如果必须要做的话，必须加锁），因为会有线程安全的问题。除此之外，工具类方法本身是没有线程安全问题的，可以放心使用。</p>
<h4 id="1-3-2-Arrays"><a href="#1-3-2-Arrays" class="headerlink" title="1.3.2-Arrays"></a>1.3.2-Arrays</h4><p>Arrays 主要对数组提供了一些高效的操作，比如说排序、查找、填充、拷贝、相等判断等等。</p>
<ol>
<li><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a><strong>排序</strong></h5><p>Arrays.sort 方法主要用于排序，入参支持 int、long、double 等各种基本类型的数组，也支持自定义类的数组，下面我们写个 demo 来演示一下自定义类数组的排序：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span>
<span class="token comment" spellcheck="true">// 自定义类</span>
<span class="token keyword">class</span> <span class="token class-name">SortDTO</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> String sortTarget<span class="token punctuation">;</span>

  <span class="token keyword">public</span> <span class="token function">SortDTO</span><span class="token punctuation">(</span>String sortTarget<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>sortTarget <span class="token operator">=</span> sortTarget<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  List<span class="token operator">&lt;</span>SortDTO<span class="token operator">></span> list <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>
      <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"300"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"50"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"200"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"220"</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 我们先把数组的大小初始化成 list 的大小，保证能够正确执行 toArray</span>
  SortDTO<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>

  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"排序之前：{}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> Comparator<span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span>SortDTO<span class="token operator">:</span><span class="token operator">:</span>getSortTarget<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"排序之后：{}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
输出结果为：
排序之前：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"300"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"50"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"200"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"220"</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
排序之后：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"200"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"220"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"300"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"50"</span><span class="token punctuation">}</span><span class="token punctuation">]</span></code></pre>
<p>从输出的结果中可以看到，排序之后的数组已经是有顺序的了，也可以看到 sort 方法支持两个入参：要排序的数组和外部排序器。</p>
<p>大家都说 sort 方法排序的性能较高，主要原因是 sort 使用了双轴快速排序算法，具体算法就不细说了。</p>
</li>
</ol>
<ol start="2">
<li><h5 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a><strong>二分查找法</strong></h5><p>Arrays.binarySearch 方法主要用于快速从数组中查找出对应的值。其支持的入参类型非常多，如 byte、int、long 各种类型的数组。返回参数是查找到的对应数组下标的值，如果查询不到，则返回负数。</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95.jpeg" alt="二分查找法"></p>
<p>我们写了一个 demo 如下：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>SortDTO<span class="token operator">></span> list <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>
    <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"300"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"50"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"200"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"220"</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

SortDTO<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>

log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"搜索之前：{}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> Comparator<span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span>SortDTO<span class="token operator">:</span><span class="token operator">:</span>getSortTarget<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"先排序，结果为：{}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> index <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">binarySearch</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SortDTO</span><span class="token punctuation">(</span><span class="token string">"200"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    Comparator<span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span>SortDTO<span class="token operator">:</span><span class="token operator">:</span>getSortTarget<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>index<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"没有找到 200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"搜索结果：{}"</span><span class="token punctuation">,</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

输出的结果为：
搜索之前：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"300"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"50"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"200"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"220"</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
先排序，结果为：<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"200"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"220"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"300"</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"50"</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
搜索结果：<span class="token punctuation">{</span><span class="token string">"sortTarget"</span><span class="token operator">:</span><span class="token string">"200"</span><span class="token punctuation">}</span></code></pre>
<p>从上述代码中我们需要注意两点：</p>
<ul>
<li>如果被搜索的数组是无序的，一定要先排序，否则二分搜索很有可能搜索不到，我们 demo 里面也先对数组进行了排序；</li>
<li>搜索方法返回的是数组的下标值。如果搜索不到，返回的下标值就会是负数，这时我们需要判断一下正负。如果是负数，还从数组中获取数据的话，会报数组越界的错误。demo 中对这种情况进行了判断，如果是负数，会提前抛出明确的异常。</li>
</ul>
<p>接下来，我们来看下二分法底层代码的实现：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// a：我们要搜索的数组，fromIndex：从那里开始搜索，默认是0； toIndex：搜索到何时停止，默认是数组大小</span>
<span class="token comment" spellcheck="true">// key：我们需要搜索的值 c：外部比较器</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">int</span> <span class="token function">binarySearch0</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">,</span>
                                     T key<span class="token punctuation">,</span> Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 如果比较器 c 是空的，直接使用 key 的 Comparable.compareTo 方法进行排序</span>
    <span class="token comment" spellcheck="true">// 假设 key 类型是 String 类型，String 默认实现了 Comparable 接口，就可以直接使用 compareTo 方法进行排序</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 这是另外一个方法，使用内部排序器进行比较的方法</span>
        <span class="token keyword">return</span> <span class="token function">binarySearch0</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> fromIndex<span class="token punctuation">,</span> toIndex<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> low <span class="token operator">=</span> fromIndex<span class="token punctuation">;</span>
    <span class="token keyword">int</span> high <span class="token operator">=</span> toIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 开始位置小于结束位置，就会一直循环搜索</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 假设 low =0，high =10，那么 mid 就是 5，所以说二分的意思主要在这里，每次都是计算索引的中间值</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> high<span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>
        T midVal <span class="token operator">=</span> a<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 比较数组中间值和给定的值的大小关系</span>
        <span class="token keyword">int</span> cmp <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>midVal<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果数组中间值小于给定的值，说明我们要找的值在中间值的右边</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 我们要找的值在中间值的左边</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
        <span class="token comment" spellcheck="true">// 找到了</span>
            <span class="token keyword">return</span> mid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// key found</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 返回的值是负数，表示没有找到</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token punctuation">(</span>low <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// key not found.</span>
<span class="token punctuation">}</span></code></pre>
<p>二分的主要意思是每次查找之前，都找到中间值，然后拿我们要比较的值和中间值比较，根据结果修改比较的上限或者下限，通过循环最终找到相等的位置索引，以上代码实现比较简洁，大家可以在自己理解的基础上，自己复写一遍。</p>
</li>
</ol>
<ol start="3">
<li><h5 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a><strong>拷贝</strong></h5><p>数组拷贝我们经常遇到，有时需要拷贝整个数组，有时需要拷贝部分，比如 ArrayList 在 add（扩容） 或 remove（删除元素不是最后一个） 操作时，会进行一些拷贝。拷贝整个数组我们可以使用 copyOf 方法，拷贝部分我们可以使用 copyOfRange 方法，以 copyOfRange 为例，看下底层源码的实现：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// original 原始数组数据</span>
<span class="token comment" spellcheck="true">// from 拷贝起点</span>
<span class="token comment" spellcheck="true">// to 拷贝终点</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOfRange</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 需要拷贝的长度</span>
    <span class="token keyword">int</span> newLength <span class="token operator">=</span> to <span class="token operator">-</span> from<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newLength <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span>from <span class="token operator">+</span> <span class="token string">" > "</span> <span class="token operator">+</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 初始化新数组</span>
    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>newLength<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 调用 native 方法进行拷贝，参数的意思分别是：</span>
    <span class="token comment" spellcheck="true">// 被拷贝的数组、从数组那里开始、目标数组、从目的数组那里开始拷贝、拷贝的长度</span>
    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> from<span class="token punctuation">,</span> copy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
                     Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span>length <span class="token operator">-</span> from<span class="token punctuation">,</span> newLength<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> copy<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码中，我们发现，Arrays 的拷贝方法，实际上底层调用的是 System.arraycopy 这个 native 方法，如果你自己对底层拷贝方法比较熟悉的话，也可以直接使用。</p>
</li>
</ol>
<h4 id="1-3-3-Collections"><a href="#1-3-3-Collections" class="headerlink" title="1.3.3-Collections"></a>1.3.3-Collections</h4><p>Collections 是为了方便使用集合而产生的工具类，Arrays 方便数组使用，Collections 是方便集合使用。</p>
<p>Collections 也提供了 sort 和 binarySearch 方法，sort 底层使用的就是 Arrays.sort 方法，binarySearch 底层是自己重写了二分查找算法，实现的逻辑和 Arrays 的二分查找算法完全一致，这两个方法上 Collections 和 Arrays 的内部实现很类似，接下来我们来看下 Collections 独有的特性。</p>
<ol>
<li><h5 id="求集合中最大、小值"><a href="#求集合中最大、小值" class="headerlink" title="求集合中最大、小值"></a><strong>求集合中最大、小值</strong></h5><p>提供了 max 方法来取得集合中的最大值，min 方法来取得集合中的最小值，max 和 min 方法很相似的，我们以 max 方法为例来说明一下，max 提供了两种类型的方法，一个需要传外部排序器，一个不需要传排序器，但需要集合中的元素强制实现 Comparable 接口，后者的泛型定义很有意思，我们来看下（从右往左看）：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E6%B1%82%E9%9B%86%E5%90%88%E6%9C%80%E5%A4%A7%E5%80%BC%E6%9C%80%E5%B0%8F%E5%80%BC.jpeg" alt="求集合最大值最小值"></p>
<p>从这段源码中，我们可以学习到两点：</p>
<ul>
<li>max 方法泛型 T 定义得非常巧妙，意思是泛型必须继承 Object 并且实现 Comparable 的接口。一般让我们来定义的话，我们可以会在方法里面去判断有无实现 Comparable 的接口，这种是在运行时才能知道结果。而这里泛型直接定义了必须实现 Comparable 接口，在编译的时候就可告诉使用者，当前类没有实现 Comparable 接口，使用起来很友好；</li>
<li>给我们提供了实现两种排序机制的好示例：自定义类实现 Comparable 接口和传入外部排序器。两种排序实现原理类似，但实现有所差别，我们在工作中如果需要些排序的工具类时，可以效仿。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><h5 id="多种类型的集合"><a href="#多种类型的集合" class="headerlink" title="多种类型的集合"></a><strong>多种类型的集合</strong></h5><p>Collections 对原始集合类进行了封装，提供了更好的集合类给我们，一种是线程安全的集合，一种是不可变的集合，针对 List、Map、Set 都有提供，我们先来看下线程安全的集合：</p>
<ul>
<li><p><strong>线程安全的集合</strong></p>
<p>线程安全的集合方法都是 synchronized 打头的，如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E6%96%B9%E6%B3%95.jpeg" alt="线程安全的集合方法"></p>
<p>从方法命名我们都可以看出来，底层是通过 synchronized 轻量锁来实现的，我们以 synchronizedList 为例来说明下底层的实现：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/synchronizedList.jpeg" alt="synchronizedList"></p>
<p>可以看到 List 的所有操作方法都被加上了 synchronized 锁，所以多线程对集合同时进行操作，是线程安全的。</p>
</li>
<li><p><strong>不可变的集合</strong></p>
<p>得到不可变集合的方法都是以 unmodifiable 开头的。这类方法的意思是，我们会从原集合中，得到一个不可变的新集合，新集合只能访问，无法修改；一旦修改，就会抛出异常。这主要是因为只开放了查询方法，其余任何修改操作都会抛出异常，我们以 unmodifiableList 为例来看下底层实现机制：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/unmodifiableList.jpeg" alt="unmodifiableList"></p>
</li>
<li><p><strong>小结</strong></p>
<p>以上两种 List 其实解决了工作中的一些困惑，比如说 ArrayList 是线程不安全的，然后其内部数组很容易被修改，有的时候，我们希望 List 一旦生成后，就不能被修改，Collections 对 List 重新进行了封装，提供了两种类型的集合封装形式，从而解决了工作中的一些烦恼，如果你平时使用 List 时有一些烦恼，也可以学习此种方式，自己对原始集合进行封装，来解决 List 使用过程中的不方便。</p>
</li>
</ul>
</li>
</ol>
<h4 id="1-3-4-Objects"><a href="#1-3-4-Objects" class="headerlink" title="1.3.4-Objects"></a>1.3.4-Objects</h4><p>对于 Objects，我们经常使用的就是两个场景，相等判断和判空。</p>
<ol>
<li><h5 id="相等判断-1"><a href="#相等判断-1" class="headerlink" title="相等判断"></a><strong>相等判断</strong></h5><p>Objects 有提供 equals 和 deepEquals 两个方法来进行相等判断，前者是判断基本类型和自定义类的，后者是用来判断数组的，我们来看下底层的源码实现：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Objects-equals.jpeg" alt="Objects-equals"></p>
<p>从源码中，可以看出 Objects 对基本类型和复杂类型的对象，都有着比较细粒度的判断，可以放心使用。</p>
</li>
</ol>
<ol start="2">
<li><h5 id="为空判断"><a href="#为空判断" class="headerlink" title="为空判断"></a><strong>为空判断</strong></h5><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Objects-isNull.jpeg" alt="Objects-isNull"></p>
<p>Objects 提供了各种关于空的一些判断，isNull 和 nonNull 对于对象是否为空返回 Boolean 值，requireNonNull 方法更加严格，如果一旦为空，会直接抛出异常，我们需要根据生活的场景选择使用。</p>
</li>
</ol>
<h4 id="1-3-5-面试题"><a href="#1-3-5-面试题" class="headerlink" title="1.3.5-面试题"></a>1.3.5-面试题</h4><ol>
<li><h5 id="工作中有没有遇到特别好用的工具类，如何写好一个工具类"><a href="#工作中有没有遇到特别好用的工具类，如何写好一个工具类" class="headerlink" title="工作中有没有遇到特别好用的工具类，如何写好一个工具类"></a>工作中有没有遇到特别好用的工具类，如何写好一个工具类</h5><p>答：有的，像 Arrays 的排序、二分查找、Collections 的不可变、线程安全集合类、Objects 的判空相等判断等等工具类，好的工具类肯定很好用，比如说使用 static final 关键字对方法进行修饰，工具类构造器必须是私有等等手段来写好工具类。</p>
</li>
<li><h5 id="写一个二分查找算法的实现"><a href="#写一个二分查找算法的实现" class="headerlink" title="写一个二分查找算法的实现"></a>写一个二分查找算法的实现</h5><p>答：可以参考 Arrays 的 binarySearch 方法的源码实现。</p>
</li>
<li><h5 id="如果我希望-ArrayList-初始化之后，不能被修改，该怎么办"><a href="#如果我希望-ArrayList-初始化之后，不能被修改，该怎么办" class="headerlink" title="如果我希望 ArrayList 初始化之后，不能被修改，该怎么办"></a>如果我希望 ArrayList 初始化之后，不能被修改，该怎么办</h5><p>答：可以使用 Collections 的 unmodifiableList 的方法，该方法会返回一个不能被修改的内部类集合，这些集合类只开放查询的方法，对于调用修改集合的方法会直接抛出异常。</p>
</li>
</ol>
<h4 id="1-3-6-总结"><a href="#1-3-6-总结" class="headerlink" title="1.3.6-总结"></a>1.3.6-总结</h4><p>从三大工具类中，我们不仅学习到了如何写好一个工具类，还熟悉了三大工具类的具体使用姿势，甚至了解了其底层的源码实现，有兴趣的话，可以自己也可以仿照写个好用的工具类加深学习。</p>
<h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2-集合"></a>2-集合</h2><h3 id="2-1-ArrayList-源码解析和设计思路"><a href="#2-1-ArrayList-源码解析和设计思路" class="headerlink" title="2.1-ArrayList 源码解析和设计思路"></a>2.1-ArrayList 源码解析和设计思路</h3><p>ArrayList 我们几乎每天都会使用到，但真正面试的时候，发现还是有不少人对源码细节说不清楚，给面试官留下比较差的印象，本小节就和大家一起看看面试中和 ArrayList 相关的源码。</p>
<h4 id="2-1-1-整体架构"><a href="#2-1-1-整体架构" class="headerlink" title="2.1.1-整体架构"></a>2.1.1-整体架构</h4><p>ArrayList 整体架构比较简单，就是一个数组结构，比较简单，如下图：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayList.jpeg" alt="ArrayList"></p>
<p>图中展示是长度为 10 的数组，从 1 开始计数，index 表示数组的下标，从 0 开始计数，elementData 表示数组本身，源码中除了这两个概念，还有以下三个基本概念：</p>
<ul>
<li>DEFAULT_CAPACITY 表示数组的初始大小，默认是 10，这个数字要记住；</li>
<li>size 表示当前数组的大小，类型 int，没有使用 volatile 修饰，非线程安全的；</li>
<li>modCount 统计当前数组被修改的版本次数，数组结构有变动，就会 +1。</li>
</ul>
<p><strong>类注释</strong></p>
<p>看源码，首先要看类注释，我们看看类注释上面都说了什么，如下：</p>
<ul>
<li>允许 put null 值，会自动扩容；</li>
<li>size、isEmpty、get、set、add 等方法时间复杂度都是 O (1)；</li>
<li>是非线程安全的，多线程情况下，推荐使用线程安全类：Collections#synchronizedList；</li>
<li>增强 for 循环，或者使用迭代器迭代过程中，如果数组大小被改变，会快速失败，抛出异常。</li>
</ul>
<p>除了上述注释中提到的 4 点，初始化、扩容的本质、迭代器等问题也经常被问，接下来我们从源码出发，一一解析。</p>
<h4 id="2-1-2-源码解析"><a href="#2-1-2-源码解析" class="headerlink" title="2.1.2-源码解析"></a>2.1.2-源码解析</h4><ol>
<li><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h5><p>我们有三种初始化办法：<strong>无参数直接初始化</strong>、<strong>指定大小初始化</strong>、<strong>指定初始数据初始化</strong>。</p>
<p>源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//无参数直接初始化，数组大小为空</span>
<span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//指定初始数据初始化</span>
<span class="token keyword">public</span> <span class="token function">ArrayList</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//elementData 是保存数组的容器，默认为 null</span>
    elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//如果给定的集合（c）数据有值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>
        <span class="token comment" spellcheck="true">//如果集合元素类型不是 Object 类型，我们会转成 Object</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 给定集合（c）无值，则默认空数组</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>除了源码的中文注释，我们补充两点：</p>
<ul>
<li><p>ArrayList 无参构造器初始化时，默认大小是空数组，并不是大家常说的 10，10 是在第一次 add 的时候扩容的数组值。</p>
</li>
<li><p>指定初始数据初始化时，我们发现一个这样子的注释 see 6260652，这是 Java 的一个 bug，意思是当给定集合内的元素不是 Object 类型时，我们会转化成 Object 的类型。一般情况下都不会触发此 bug，只有在下列场景下才会触发：ArrayList 初始化之后（ArrayList 元素非 Object 类型），再次调用 toArray 方法，得到 Object 数组，并且往 Object 数组赋值时，才会触发此 bug。</p>
<p>代码和原因如图：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayList-%E5%88%9D%E5%A7%8B%E5%8C%96Bug.jpeg" alt="ArrayList-初始化Bug"></p>
<p>官方查看文档地址：<a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652，问题在" target="_blank" rel="noopener">https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6260652，问题在</a> Java 9 中被解决。</p>
</li>
</ul>
</li>
</ol>
<ol start="2">
<li><h5 id="新增和扩容实现"><a href="#新增和扩容实现" class="headerlink" title="新增和扩容实现"></a><strong>新增和扩容实现</strong></h5><p>新增就是往数组中添加元素，主要分成两步：</p>
<ul>
<li>判断是否需要扩容，如果需要执行扩容操作；</li>
<li>直接赋值。</li>
</ul>
<p>两步源码体现如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//确保数组大小是否足够，不够执行扩容，size 为当前数组的大小</span>
  <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Increments modCount!!</span>
  <span class="token comment" spellcheck="true">//直接赋值，线程不安全的</span>
  elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>我们先看下扩容（ensureCapacityInternal）的源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    minCapacity <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>DEFAULT_CAPACITY<span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">//确保容积足够</span>
  <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//记录数组被修改</span>
  modCount<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//扩容，并把现有数据拷贝到新的数组里面去</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// oldCapacity >> 1 是把 oldCapacity 除以 2 的意思</span>
  <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 如果扩容后的值 > jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> MAX_ARRAY_SIZE <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 通过复制进行扩容</span>
  elementData <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>注解应该比较详细，我们需要注意的四点是：</p>
<ul>
<li>扩容的规则并不是翻倍，是原来容量大小 + 容量大小的一半，直白来说，扩容后的大小是原来容量的 1.5 倍；</li>
<li>ArrayList 中的数组的最大值是 Integer.MAX_VALUE，超过这个值，JVM 就不会给数组分配内存空间了。</li>
<li>新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的。</li>
</ul>
<p>从新增和扩容源码中，下面这点值得我们借鉴：</p>
<ul>
<li>源码在扩容的时候，有数组大小溢出意识，就是说扩容后数组的大小下界不能小于 0，上界不能大于 Integer 的最大值，这种意识我们可以学习。</li>
</ul>
<p>扩容完成之后，赋值是非常简单的，直接往数组上添加元素即可：elementData [size++] = e。也正是通过这种简单赋值，没有任何锁控制，所以这里的操作是线程不安全的。</p>
<p>对于新增和扩容的实现，画了一个动图，如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayList-%E6%96%B0%E5%A2%9E%E5%92%8C%E6%89%A9%E5%AE%B9.jpeg" alt="ArrayList-新增和扩容"></p>
</li>
</ol>
<ol start="3">
<li><h5 id="扩容的本质"><a href="#扩容的本质" class="headerlink" title="扩容的本质"></a><strong>扩容的本质</strong></h5><p>扩容是通过这行代码来实现的：<code>Arrays.copyOf(elementData, newCapacity);</code>，这行代码描述的本质是数组之间的拷贝，扩容是会先新建一个符合我们预期容量的新数组，然后把老数组的数据拷贝过去，我们通过 System.arraycopy 方法进行拷贝，此方法是 native 的方法。</p>
<p>源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * @param src     被拷贝的数组
 * @param srcPos  从数组那里开始
 * @param dest    目标数组
 * @param destPos 从目标数组那个索引位置开始拷贝
 * @param length  拷贝的长度 
 * 此方法是没有返回值的，通过 dest 的引用进行传值
 */</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span>Object src<span class="token punctuation">,</span> <span class="token keyword">int</span> srcPos<span class="token punctuation">,</span>
                                    Object dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span>
                                    <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>我们可以通过下面这行代码进行调用，newElementData 表示新的数组：</p>
<pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>elementData<span class="token punctuation">.</span>length<span class="token punctuation">,</span>newCapacity</code></pre>
</li>
<li><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h5><p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理和思路都差不多，我们选取根据值删除方式来进行源码说明：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 如果要删除的值是 null，找到第一个值是 null 的删除</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 如果要删除的值不为 null，找到第一个和要删除的值相等的删除</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token comment" spellcheck="true">// 这里是根据  equals 来判断值相等的，相等后再根据索引位置进行删除</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>我们需要注意的两点是：</p>
<ul>
<li>新增的时候是没有对 null 进行校验的，所以删除的时候也是允许删除 null 值的；</li>
<li>找到值在数组中的索引位置，是通过 equals 来判断的，如果数组元素不是基本类型，需要我们关注 equals 的具体实现。</li>
</ul>
<p>上面代码已经找到要删除元素的索引位置了，下面代码是根据索引位置进行元素的删除：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 记录数组的结构要发生变动了</span>
  modCount<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// numMoved 表示删除 index 位置的元素后，需要从 index 后移动多少个元素到前面去</span>
  <span class="token comment" spellcheck="true">// 减 1 的原因，是因为 size 从 1 开始算起，index 从 0开始算起</span>
  <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 从 index +1 位置开始被拷贝，拷贝的起始位置是 index，长度是 numMoved</span>
    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//数组最后一个位置赋值 null，帮助 GC</span>
  elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码中，我们可以看出，某一个元素被删除后，为了维护数组结构，我们都会把数组后面的元素往前移动，下面动图也演示了其过程：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayList-%E5%88%A0%E9%99%A4%E8%BF%87%E7%A8%8B.jpeg" alt="ArrayList-删除过程"></p>
</li>
</ol>
<ol start="5">
<li><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><strong>迭代器</strong></h5><p>如果要自己实现迭代器，实现 java.util.Iterator 类就好了，ArrayList 也是这样做的，我们来看下迭代器的几个总要的参数：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> cursor<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 迭代过程中，下一个元素的位置，默认从 0 开始。</span>
<span class="token keyword">int</span> lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 新增场景：表示上一次迭代过程中，索引的位置；删除场景：为 -1。</span>
<span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// expectedModCount 表示迭代过程中，期望的版本号；modCount 表示数组实际的版本号。</span></code></pre>
<p>迭代器一般来说有三个方法：</p>
<ul>
<li>hasNext 还有没有值可以迭代</li>
<li>next 如果有值可以迭代，迭代的值是多少</li>
<li>remove 删除当前迭代的值</li>
</ul>
<p>我们来分别看下三个方法的源码：</p>
<p><strong>hasNext</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> cursor <span class="token operator">!=</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//cursor 表示下一个元素的位置，size 表示实际大小，如果两者相等，说明已经没有元素可以迭代了，如果不等，说明还可以迭代</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>next</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span>
  <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//本次迭代过程中，元素的索引位置</span>
  <span class="token keyword">int</span> i <span class="token operator">=</span> cursor<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> size<span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 下一次迭代时，元素的位置，为下一次迭代做准备</span>
  cursor <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 返回元素值</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>lastRet <span class="token operator">=</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 版本号比较</span>
<span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码中可以看到，next 方法就干了两件事情，第一是检验能不能继续迭代，第二是找到迭代的值，并为下一次迭代做准备（cursor+1）。</p>
<p><strong>remove</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 如果上一次操作时，数组的位置已经小于 0 了，说明数组已经被删除完了</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lastRet <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">//迭代过程中，判断版本号有无被修改，有被修改，抛 ConcurrentModificationException 异常</span>
  <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    ArrayList<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>lastRet<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cursor <span class="token operator">=</span> lastRet<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// -1 表示元素已经被删除，这里也防止重复删除</span>
    lastRet <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 删除元素时 modCount 的值已经发生变化，在此赋值给 expectedModCount</span>
    <span class="token comment" spellcheck="true">// 这样下次迭代时，两者的值是一致的了</span>
    expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IndexOutOfBoundsException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这里我们需要注意的两点是：</p>
<ul>
<li>lastRet = -1 的操作目的，是防止重复删除操作</li>
<li>删除元素成功，数组当前 modCount 就会发生变化，这里会把 expectedModCount 重新赋值，下次迭代时两者的值就会一致了</li>
</ul>
</li>
</ol>
<ol start="6">
<li><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>从我们上面新增或删除方法的源码解析，对数组元素的操作，只需要根据数组索引，直接新增和删除，所以时间复杂度是 O (1)。</p>
</li>
</ol>
<ol start="7">
<li><h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><p>我们需要强调的是，只有当 ArrayList 作为共享变量时，才会有线程安全问题，当 ArrayList 是方法内的局部变量时，是没有线程安全的问题的。</p>
<p>ArrayList 有线程安全问题的本质，是因为 ArrayList 自身的 elementData、size、modConut 在进行各种操作时，都没有加锁，而且这些变量的类型并非是可见（volatile）的，所以如果多个线程对这些变量进行操作时，可能会有值被覆盖的情况。</p>
<p>类注释中推荐我们使用 Collections#synchronizedList 来保证线程安全，SynchronizedList 是通过在每个方法上面加上锁来实现，虽然实现了线程安全，但是性能大大降低，具体实现源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// synchronized 是一种轻量锁，mutex 表示一个当前 SynchronizedList</span>
        <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
</li>
</ol>
<h4 id="2-1-3-总结"><a href="#2-1-3-总结" class="headerlink" title="2.1.3-总结"></a>2.1.3-总结</h4><p>本文从 ArrayList 整体架构出发，落地到初始化、新增、扩容、删除、迭代等核心源码实现，我们发现 ArrayList 其实就是围绕底层数组结构，各个 API 都是对数组的操作进行封装，让使用者无需感知底层实现，只需关注如何使用即可。</p>
<h3 id="2-2-LinkedList-源码解析"><a href="#2-2-LinkedList-源码解析" class="headerlink" title="2.2-LinkedList 源码解析"></a>2.2-LinkedList 源码解析</h3><p>LinkedList 适用于集合元素先入先出和先入后出的场景，在队列源码中被频繁使用，面试也经常问到，本小节让我们通过源码来加深对 LinkedList 的了解。</p>
<h4 id="2-2-1-整体架构"><a href="#2-2-1-整体架构" class="headerlink" title="2.2.1-整体架构"></a>2.2.1-整体架构</h4><p>LinkedList 底层数据结构是一个双向链表，整体结构如下图所示：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/LinkedList.jpeg" alt="LinkedList"></p>
<p>上图代表了一个双向链表结构，链表中的每个节点都可以向前或者向后追溯，我们有几个概念如下：</p>
<ul>
<li>链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，代表后一个节点的位置；</li>
<li>first 是双向链表的头节点，它的前一个节点是 null。</li>
<li>last 是双向链表的尾节点，它的后一个节点是 null；</li>
<li>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；</li>
<li>因为是个双向链表，只要机器内存足够强大，是没有大小限制的。</li>
</ul>
<p>链表中的元素叫做 Node，我们看下 Node 的组成部分：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    E item<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 节点值</span>
    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向的下一个节点</span>
    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指向的前一个节点</span>

    <span class="token comment" spellcheck="true">// 初始化参数顺序分别是：前一个节点、本身节点值、后一个节点</span>
    <span class="token function">Node</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> prev<span class="token punctuation">,</span> E element<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>item <span class="token operator">=</span> element<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="2-2-2-源码解析"><a href="#2-2-2-源码解析" class="headerlink" title="2.2.2-源码解析"></a>2.2.2-源码解析</h4><h5 id="1-新增"><a href="#1-新增" class="headerlink" title="1.新增"></a>1.新增</h5><p>追加节点时，我们可以选择追加到链表头部，还是追加到链表尾部，add 方法默认是从尾部开始追加，addFirst 方法是从头部开始追加，我们分别来看下两种不同的追加方式：</p>
<p><strong>从尾部追加（add）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 从尾部开始追加节点</span>
<span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 把尾节点数据暂存</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 新建新的节点，初始化入参含义：</span>
    <span class="token comment" spellcheck="true">// l 是新节点的前一个节点，当前值是尾节点值</span>
    <span class="token comment" spellcheck="true">// e 表示当前新增节点，当前新增节点后一个节点是 null</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 新建节点追加到尾部</span>
    last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//如果链表为空（l 是尾节点，尾节点为空，链表即空），头部和尾部是同一个节点，都是新建的节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> null<span class="token punctuation">)</span>
        first <span class="token operator">=</span> newNode<span class="token punctuation">;</span><span class="token operator">!</span><span class="token punctuation">[</span>图片描述<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">//img.mukewang.com/5d5fc69600013e4803600240.gif)</span>
    <span class="token comment" spellcheck="true">//否则把前尾节点的下一个节点，指向当前尾节点。</span>
    <span class="token keyword">else</span>
        l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//大小和版本更改</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码上来看，尾部追加节点比较简单，只需要简单地把指向位置修改下即可，我们做个动图来描述下整个过程：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/LinkedList-%E6%96%B0%E5%A2%9E.jpeg" alt="LinkedList-新增"></p>
<p><strong>从头部追加（addFirst）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 从头部追加</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkFirst</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 头节点赋值给临时变量</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f <span class="token operator">=</span> first<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 新建节点，前一个节点指向null，e 是新建节点，f 是新建节点的下一个节点，目前值是头节点的值</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> e<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 新建节点成为头节点</span>
    first <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 头节点为空，就是链表为空，头尾节点是一个节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">==</span> null<span class="token punctuation">)</span>
        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//上一个头节点的前一个节点指向当前节点</span>
    <span class="token keyword">else</span>
        f<span class="token punctuation">.</span>prev <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    size<span class="token operator">++</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>头部追加节点和尾部追加节点非常类似，只是前者是移动头节点的 prev 指向，后者是移动尾节点的 next 指向。</p>
<h5 id="2-节点删除"><a href="#2-节点删除" class="headerlink" title="2.节点删除"></a>2.节点删除</h5><p>节点删除的方式和追加类似，我们可以选择从头部删除，也可以选择从尾部删除，删除操作会把节点的值，前后指向节点都置为 null，帮助 GC 进行回收。</p>
<p><strong>从头部删除</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//从头删除节点 f 是链表头节点</span>
<span class="token keyword">private</span> E <span class="token function">unlinkFirst</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 拿出头节点的值，作为方法的返回值</span>
    <span class="token keyword">final</span> E element <span class="token operator">=</span> f<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 拿出头节点的下一个节点</span>
    <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//帮助 GC 回收头节点</span>
    f<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span>
    f<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 头节点的下一个节点成为头节点</span>
    first <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//如果 next 为空，表明链表为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>
        last <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//链表不为空，头节点的前一个节点指向 null</span>
    <span class="token keyword">else</span>
        next<span class="token punctuation">.</span>prev <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//修改链表大小和版本</span>
    size<span class="token operator">--</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> element<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从尾部删除节点代码也是类似的，就不贴了。</p>
<p><strong>从源码中我们可以了解到，链表结构的节点新增、删除都非常简单，仅仅把前后节点的指向修改下就好了，所以 LinkedList 新增和删除速度很快。</strong></p>
<h5 id="3-节点查询"><a href="#3-节点查询" class="headerlink" title="3.节点查询"></a>3.节点查询</h5><p>链表查询某一个节点是比较慢的，需要挨个循环查找才行，我们看看 LinkedList 的源码是如何寻找节点的：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 根据链表索引位置查询节点</span>
Node<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">node</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 如果 index 处于队列的前半部分，从头开始找，size >> 1 是 size 除以 2 的意思。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token punctuation">(</span>size <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> first<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 直到 for 循环到 index 的前一个 node 停止</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> index<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            x <span class="token operator">=</span> x<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 如果 index 处于队列的后半部分，从尾开始找</span>
        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> x <span class="token operator">=</span> last<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 直到 for 循环到 index 的后一个 node 停止</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> index<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
            x <span class="token operator">=</span> x<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码中我们可以发现，LinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，首先看看 index 是在链表的前半部分，还是后半部分。如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能，这种思想值得我们借鉴。</p>
<h5 id="4-方法对比"><a href="#4-方法对比" class="headerlink" title="4.方法对比"></a>4.方法对比</h5><p>LinkedList 实现了 Queue 接口，在新增、删除、查询等方面增加了很多新的方法，这些方法在平时特别容易混淆，在链表为空的情况下，返回值也不太一样，我们列一个表格，方便大家记录：</p>
<table>
<thead>
<tr>
<th align="left">方法含义</th>
<th align="left">返回异常</th>
<th align="left">返回特殊值</th>
<th align="left">底层实现</th>
</tr>
</thead>
<tbody><tr>
<td align="left">新增</td>
<td align="left">add(e)</td>
<td align="left">offer(e)</td>
<td align="left">底层实现相同</td>
</tr>
<tr>
<td align="left">删除</td>
<td align="left">remove()</td>
<td align="left">poll(e)</td>
<td align="left">链表为空时，remove 会抛出异常，poll 返回 null。</td>
</tr>
<tr>
<td align="left">查找</td>
<td align="left">element()</td>
<td align="left">peek()</td>
<td align="left">链表为空时，element 会抛出异常，peek 返回 null。</td>
</tr>
</tbody></table>
<p>PS：Queue 接口注释建议 add 方法操作失败时抛出异常，但 LinkedList 实现的 add 方法一直返回 true。<br>LinkedList 也实现了 Deque 接口，对新增、删除和查找都提供从头开始，还是从尾开始两种方向的方法，比如 remove 方法，Deque 提供了 removeFirst 和 removeLast 两种方向的使用方式，但当链表为空时的表现都和 remove 方法一样，都会抛出异常。</p>
<h5 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5.迭代器"></a>5.迭代器</h5><p>因为 LinkedList 要实现双向的迭代访问，所以我们使用 Iterator 接口肯定不行了，因为 Iterator 只支持从头到尾的访问。Java 新增了一个迭代接口，叫做：ListIterator，这个接口提供了向前和向后的迭代方法，如下所示：</p>
<table>
<thead>
<tr>
<th align="left">迭代顺序</th>
<th align="left">方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">从尾到头迭代方法</td>
<td align="left">hasPrevious、previous、previousIndex</td>
</tr>
<tr>
<td align="left">从头到尾迭代方法</td>
<td align="left">hasNext、next、nextIndex</td>
</tr>
</tbody></table>
<p>LinkedList 实现了 ListIterator 接口，如下所示：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 双向迭代器</span>
<span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">ListItr</span> <span class="token keyword">implements</span> <span class="token class-name">ListIterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> lastReturned<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//上一次执行 next() 或者 previos() 方法时的节点位置</span>
    <span class="token keyword">private</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下一个节点</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> nextIndex<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下一个节点的位置</span>
    <span class="token comment" spellcheck="true">//expectedModCount：期望版本号；modCount：目前最新版本号</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
    …………
<span class="token punctuation">}</span></code></pre>
<p>我们先来看下从头到尾方向的迭代：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 判断还有没有下一个元素</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> nextIndex <span class="token operator">&lt;</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 下一个节点的索引小于链表的大小，就有</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 取下一个元素</span>
<span class="token keyword">public</span> E <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//检查期望版本号有无发生变化</span>
    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//再次检查</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// next 是当前节点，在上一次执行 next() 方法时被赋值的。</span>
    <span class="token comment" spellcheck="true">// 第一次执行时，是在初始化迭代器的时候，next 被赋值的</span>
    lastReturned <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// next 是下一个节点了，为下次迭代做准备</span>
    next <span class="token operator">=</span> next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    nextIndex<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>上述源码的思路就是直接取当前节点的下一个节点，而从尾到头迭代稍微复杂一点，如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果上次节点索引位置大于 0，就还有节点可以迭代</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> nextIndex <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 取前一个节点</span>
<span class="token keyword">public</span> E <span class="token function">previous</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasPrevious</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// next 为空场景：1:说明是第一次迭代，取尾节点(last);2:上一次操作把尾节点删除掉了</span>
    <span class="token comment" spellcheck="true">// next 不为空场景：说明已经发生过迭代了，直接取前一个节点即可(next.prev)</span>
    lastReturned <span class="token operator">=</span> next <span class="token operator">=</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> last <span class="token operator">:</span> next<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 索引位置变化</span>
    nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> lastReturned<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这里复杂点体现在需要判断 next 不为空和为空的场景，代码注释中有详细的描述。</p>
<p><strong>迭代器删除</strong></p>
<p>LinkedList 在删除元素时，也推荐通过迭代器进行删除，删除过程如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">checkForComodification</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// lastReturned 是本次迭代需要删除的值，分以下空和非空两种情况：</span>
    <span class="token comment" spellcheck="true">// lastReturned 为空，说明调用者没有主动执行过 next() 或者 previos()，直接报错</span>
    <span class="token comment" spellcheck="true">// lastReturned 不为空，是在上次执行 next() 或者 previos()方法时赋的值</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lastReturned <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> lastNext <span class="token operator">=</span> lastReturned<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//删除当前节点</span>
    <span class="token function">unlink</span><span class="token punctuation">(</span>lastReturned<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// next == lastReturned 的场景分析：从尾到头递归顺序，并且是第一次迭代，并且要删除最后一个元素的情况下</span>
    <span class="token comment" spellcheck="true">// 这种情况下，previous() 方法里面设置了 lastReturned = next = last,所以 next 和 lastReturned会相等</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> lastReturned<span class="token punctuation">)</span>
        <span class="token comment" spellcheck="true">// 这时候 lastReturned 是尾节点，lastNext 是 null，所以 next 也是 null，这样在 previous() 执行时，发现 next 是 null，就会把尾节点赋值给 next</span>
        next <span class="token operator">=</span> lastNext<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
        nextIndex<span class="token operator">--</span><span class="token punctuation">;</span>
    lastReturned <span class="token operator">=</span> null<span class="token punctuation">;</span>
    expectedModCount<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="2-2-3-总结"><a href="#2-2-3-总结" class="headerlink" title="2.2.3-总结"></a>2.2.3-总结</h4><p>LinkedList 适用于要求有顺序、并且会按照顺序进行迭代的场景，主要是依赖于底层的链表结构，在面试中的频率还是蛮高的，相信理清楚上面的源码后，应对面试应该没有问题。</p>
<h3 id="2-3-List-源码会问哪些面试题"><a href="#2-3-List-源码会问哪些面试题" class="headerlink" title="2.3-List 源码会问哪些面试题"></a>2.3-List 源码会问哪些面试题</h3><p>List 作为工作中最常见的集合类型，在面试过程中，也是经常会被问到各种各样的面试题，一般来说，只要你看过源码，心中对 List 的总体结构和细节有所了解的话，基本问题都不大。</p>
<h4 id="2-3-1-面试题"><a href="#2-3-1-面试题" class="headerlink" title="2.3.1-面试题"></a>2.3.1-面试题</h4><h5 id="1-说说你自己对-ArrayList-的理解？"><a href="#1-说说你自己对-ArrayList-的理解？" class="headerlink" title="1. 说说你自己对 ArrayList 的理解？"></a>1. 说说你自己对 ArrayList 的理解？</h5><p>很多面试官喜欢这样子开头，考察面试同学对 ArrayList 有没有总结经验，介于 ArrayList 内容很多，建议先回答总体架构，再从某个细节出发作为突破口，比如这样：<br>ArrayList 底层数据结构是个数组，其 API 都做了一层对数组底层访问的封装，比如说 add 方法的过程是……（这里可以引用我们在 ArrayList 源码解析中 add 的过程）。</p>
<p>一般面试官看你回答得井井有条，并且没啥漏洞的话，基本就不会深究了，这样面试的主动权就掌握在自己手里面了，如果你回答得支支吾吾，那么面试官可能就会开启自己面试的套路了。</p>
<p>说说你自己对 LinkedList 的理解也是同样套路。</p>
<h5 id="2-扩容类问题"><a href="#2-扩容类问题" class="headerlink" title="2.扩容类问题"></a>2.扩容类问题</h5><h6 id="2-1-ArrayList-无参数构造器构造，现在-add-一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？"><a href="#2-1-ArrayList-无参数构造器构造，现在-add-一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？" class="headerlink" title="2.1-ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？"></a>2.1-ArrayList 无参数构造器构造，现在 add 一个值进去，此时数组的大小是多少，下一次扩容前最大可用大小是多少？</h6><p>答：此处数组的大小是 1，下一次扩容前最大可用大小是 10，因为 ArrayList 第一次扩容时，是有默认值的，默认值是 10，在第一次 add 一个值进去时，数组的可用大小被扩容到 10 了。</p>
<h6 id="2-2-如果我连续往-list-里面新增值，增加到第-11-个的时候，数组的大小是多少？"><a href="#2-2-如果我连续往-list-里面新增值，增加到第-11-个的时候，数组的大小是多少？" class="headerlink" title="2.2-如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？"></a>2.2-如果我连续往 list 里面新增值，增加到第 11 个的时候，数组的大小是多少？</h6><p>答：这里的考查点就是扩容的公式，当增加到 11 的时候，此时我们希望数组的大小为 11，但实际上数组的最大容量只有 10，不够了就需要扩容，扩容的公式是：oldCapacity + (oldCapacity&gt;&gt; 1)，oldCapacity 表示数组现有大小，目前场景计算公式是：10 + 10 ／2 = 15，然后我们发现 15 已经够用了，所以数组的大小会被扩容到 15。</p>
<h6 id="2-3-数组初始化，被加入一个值后，如果我使用-addAll-方法，一下子加入-15-个值，那么最终数组的大小是多少？"><a href="#2-3-数组初始化，被加入一个值后，如果我使用-addAll-方法，一下子加入-15-个值，那么最终数组的大小是多少？" class="headerlink" title="2.3-数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？"></a>2.3-数组初始化，被加入一个值后，如果我使用 addAll 方法，一下子加入 15 个值，那么最终数组的大小是多少？</h6><p>答：第一题中我们已经计算出来数组在加入一个值后，实际大小是 1，最大可用大小是 10 ，现在需要一下子加入 15 个值，那我们期望数组的大小值就是 16，此时数组最大可用大小只有 10，明显不够，需要扩容，扩容后的大小是：10 + 10 ／2 = 15，这时候发现扩容后的大小仍然不到我们期望的值 16，这时候源码中有一种策略如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// newCapacity 本次扩容的大小，minCapacity 我们期望的数组最小大小</span>
<span class="token comment" spellcheck="true">// 如果扩容后的值 &lt; 我们的期望值，我们的期望值就等于本次扩容的大小</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span></code></pre>
<p>所以最终数组扩容后的大小为 16。</p>
<h6 id="2-4-现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？"><a href="#2-4-现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？" class="headerlink" title="2.4-现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？"></a>2.4-现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？</h6><p>答：因为原数组比较大，如果新建新数组的时候，不指定数组大小的话，就会频繁扩容，频繁扩容就会有大量拷贝的工作，造成拷贝的性能低下，所以回答说新建数组时，指定新数组的大小为 5k 即可。</p>
<h6 id="2-5-为什么说扩容会消耗性能？"><a href="#2-5-为什么说扩容会消耗性能？" class="headerlink" title="2.5-为什么说扩容会消耗性能？"></a>2.5-为什么说扩容会消耗性能？</h6><p>答：扩容底层使用的是 System.arraycopy 方法，会把原数组的数据全部拷贝到新数组上，所以性能消耗比较严重。</p>
<h6 id="2-6-源码扩容过程有什么值得借鉴的地方？"><a href="#2-6-源码扩容过程有什么值得借鉴的地方？" class="headerlink" title="2.6-源码扩容过程有什么值得借鉴的地方？"></a>2.6-源码扩容过程有什么值得借鉴的地方？</h6><p>答：有两点：</p>
<ul>
<li>是扩容的思想值得学习，通过自动扩容的方式，让使用者不用关心底层数据结构的变化，封装得很好，1.5 倍的扩容速度，可以让扩容速度在前期缓慢上升，在后期增速较快，大部分工作中要求数组的值并不是很大，所以前期增长缓慢有利于节省资源，在后期增速较快时，也可快速扩容。</li>
<li>扩容过程中，有数组大小溢出的意识，比如要求扩容后的数组大小，不能小于 0，不能大于 Integer 的最大值。</li>
</ul>
<p>这两点在我们平时设计和写代码时都可以借鉴。</p>
<h5 id="3-删除类问题"><a href="#3-删除类问题" class="headerlink" title="3.删除类问题"></a>3.删除类问题</h5><h6 id="3-1-有一个-ArrayList，数据是-2、3、3、3、4，中间有三个-3，现在我通过-for-int-i-0-i-lt-list-size-i-的方式，想把值是-3-的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下："><a href="#3-1-有一个-ArrayList，数据是-2、3、3、3、4，中间有三个-3，现在我通过-for-int-i-0-i-lt-list-size-i-的方式，想把值是-3-的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下：" class="headerlink" title="3.1-有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，现在我通过 for (int i=0;i&lt;list.size ();i++) 的方式，想把值是 3 的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下："></a>3.1-有一个 ArrayList，数据是 2、3、3、3、4，中间有三个 3，现在我通过 for (int i=0;i&lt;list.size ();i++) 的方式，想把值是 3 的元素删除，请问可以删除干净么？最终删除的结果是什么，为什么？删除代码如下：</h6><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>答：不能删除干净，最终删除的结果是 2、3、4，有一个 3 删除不掉，原因我们看下图：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayList-%E5%88%A0%E9%99%A4%E5%8E%9F%E5%9B%A0.jpeg" alt="ArrayList-删除原因"></p>
<p>从图中我们可以看到，每次删除一个元素后，该元素后面的元素就会往前移动，而此时循环的 i 在不断地增长，最终会使每次删除 3 的后一个 3 被遗漏，导致删除不掉。</p>
<h6 id="3-2-还是上面的-ArrayList-数组，我们通过增强-for-循环进行删除，可以么？"><a href="#3-2-还是上面的-ArrayList-数组，我们通过增强-for-循环进行删除，可以么？" class="headerlink" title="3.2-还是上面的 ArrayList 数组，我们通过增强 for 循环进行删除，可以么？"></a>3.2-还是上面的 ArrayList 数组，我们通过增强 for 循环进行删除，可以么？</h6><p>答：不可以，会报错。因为增强 for 循环过程其实调用的就是迭代器的 next () 方法，当你调用 list#remove () 方法进行删除时，modCount 的值会 +1，而这时候迭代器中的 expectedModCount 的值却没有变，导致在迭代器下次执行 next () 方法时，expectedModCount != modCount 就会报 ConcurrentModificationException 的错误。</p>
<h6 id="3-3-还是上面的数组，如果删除时使用-Iterator-remove-方法可以删除么，为什么？"><a href="#3-3-还是上面的数组，如果删除时使用-Iterator-remove-方法可以删除么，为什么？" class="headerlink" title="3.3-还是上面的数组，如果删除时使用 Iterator.remove () 方法可以删除么，为什么？"></a>3.3-还是上面的数组，如果删除时使用 Iterator.remove () 方法可以删除么，为什么？</h6><p>答：可以的，因为 Iterator.remove () 方法在执行的过程中，会把最新的 modCount 赋值给 expectedModCount，这样在下次循环过程中，modCount 和 expectedModCount 两者就会相等。</p>
<h6 id="3-4-以上三个问题对于-LinkedList-也是同样的结果么？"><a href="#3-4-以上三个问题对于-LinkedList-也是同样的结果么？" class="headerlink" title="3.4-以上三个问题对于 LinkedList 也是同样的结果么？"></a>3.4-以上三个问题对于 LinkedList 也是同样的结果么？</h6><p>答：是的，虽然 LinkedList 底层结构是双向链表，但对于上述三个问题，结果和 ArrayList 是一致的。</p>
<h5 id="4-对比类问题"><a href="#4-对比类问题" class="headerlink" title="4.对比类问题"></a>4.对比类问题</h5><h6 id="4-1-ArrayList-和-LinkedList-有何不同？"><a href="#4-1-ArrayList-和-LinkedList-有何不同？" class="headerlink" title="4.1-ArrayList 和 LinkedList 有何不同？"></a>4.1-ArrayList 和 LinkedList 有何不同？</h6><p>答：可以先从底层数据结构开始说起，然后以某一个方法为突破口深入，比如：最大的不同是两者底层的数据结构不同，ArrayList 底层是数组，LinkedList 底层是双向链表，两者的数据结构不同也导致了操作的 API 实现有所差异，拿新增实现来说，ArrayList 会先计算并决定是否扩容，然后把新增的数据直接赋值到数组上，而 LinkedList 仅仅只需要改变插入节点和其前后节点的指向位置关系即可。</p>
<h6 id="4-2-ArrayList-和-LinkedList-应用场景有何不同"><a href="#4-2-ArrayList-和-LinkedList-应用场景有何不同" class="headerlink" title="4.2-ArrayList 和 LinkedList 应用场景有何不同"></a>4.2-ArrayList 和 LinkedList 应用场景有何不同</h6><p>答：ArrayList 更适合于快速的查找匹配，不适合频繁新增删除，像工作中经常会对元素进行匹配查询的场景比较合适，LinkedList 更适合于经常新增和删除，对查询反而很少的场景。</p>
<h6 id="4-3-ArrayList-和-LinkedList-两者有没有最大容量"><a href="#4-3-ArrayList-和-LinkedList-两者有没有最大容量" class="headerlink" title="4.3-ArrayList 和 LinkedList 两者有没有最大容量"></a>4.3-ArrayList 和 LinkedList 两者有没有最大容量</h6><p>答：ArrayList 有最大容量的，为 Integer 的最大值，大于这个值 JVM 是不会为数组分配内存空间的，LinkedList 底层是双向链表，理论上可以无限大。但源码中，LinkedList 实际大小用的是 int 类型，这也说明了 LinkedList 不能超过 Integer 的最大值，不然会溢出。</p>
<h6 id="4-4-ArrayList-和-LinkedList-是如何对-null-值进行处理的"><a href="#4-4-ArrayList-和-LinkedList-是如何对-null-值进行处理的" class="headerlink" title="4.4-ArrayList 和 LinkedList 是如何对 null 值进行处理的"></a>4.4-ArrayList 和 LinkedList 是如何对 null 值进行处理的</h6><p>答：ArrayList 允许 null 值新增，也允许 null 值删除。删除 null 值时，是从头开始，找到第一值是 null 的元素删除；LinkedList 新增删除时对 null 值没有特殊校验，是允许新增和删除的。</p>
<h6 id="4-5-ArrayList-和-LinedList-是线程安全的么，为什么？"><a href="#4-5-ArrayList-和-LinedList-是线程安全的么，为什么？" class="headerlink" title="4.5-ArrayList 和 LinedList 是线程安全的么，为什么？"></a>4.5-ArrayList 和 LinedList 是线程安全的么，为什么？</h6><p>答：当两者作为非共享变量时，比如说仅仅是在方法里面的局部变量时，是没有线程安全问题的，只有当两者是共享变量时，才会有线程安全问题。主要的问题点在于多线程环境下，所有线程任何时刻都可对数组和链表进行操作，这会导致值被覆盖，甚至混乱的情况。</p>
<p>如果有线程安全问题，在迭代的过程中，会频繁报 ConcurrentModificationException 的错误，意思是在我当前循环的过程中，数组或链表的结构被其它线程修改了。</p>
<h6 id="4-6-如何解决线程安全问题？"><a href="#4-6-如何解决线程安全问题？" class="headerlink" title="4.6-如何解决线程安全问题？"></a>4.6-如何解决线程安全问题？</h6><p>Java 源码中推荐使用 Collections#synchronizedList 进行解决，Collections#synchronizedList 的返回值是 List 的每个方法都加了 synchronized 锁，保证了在同一时刻，数组和链表只会被一个线程所修改，或者采用 CopyOnWriteArrayList 并发 List 来解决，这个类我们后面会说。</p>
<h5 id="5-其他类型问题"><a href="#5-其他类型问题" class="headerlink" title="5.其他类型问题"></a>5.其他类型问题</h5><h6 id="5-1-你能描述下双向链表么？"><a href="#5-1-你能描述下双向链表么？" class="headerlink" title="5.1-你能描述下双向链表么？"></a>5.1-你能描述下双向链表么？</h6><p>答：如果和面试官面对面沟通的话，你可以去画一下，可以把 《LinkedList 源码解析》中的 LinkedList 的结构画出来，如果是电话面试，可以这么描述：双向链表中双向的意思是说前后节点之间互相有引用，链表的节点我们称为 Node。Node 有三个属性组成：其前一个节点，本身节点的值，其下一个节点，假设 A、B 节点相邻，A 节点的下一个节点就是 B，B 节点的上一个节点就是 A，两者互相引用，在链表的头部节点，我们称为头节点。头节点的前一个节点是 null，尾部称为尾节点，尾节点的后一个节点是 null，如果链表数据为空的话，头尾节点是同一个节点，本身是 null，指向前后节点的值也是 null。</p>
<h6 id="5-2-描述下双向链表的新增和删除"><a href="#5-2-描述下双向链表的新增和删除" class="headerlink" title="5.2-描述下双向链表的新增和删除"></a>5.2-描述下双向链表的新增和删除</h6><p>答：如果是面对面沟通，最好可以直接画图，如果是电话面试，可以这么描述：</p>
<p>新增：我们可以选择从链表头新增，也可以选择从链表尾新增，如果是从链表尾新增的话，直接把当前节点追加到尾节点之后，本身节点自动变为尾节点。</p>
<p>删除：把删除节点的后一个节点的 prev 指向其前一个节点，把删除节点的前一个节点的 next 指向其后一个节点，最后把删除的节点置为 null 即可。</p>
<h4 id="2-3-2-总结"><a href="#2-3-2-总结" class="headerlink" title="2.3.2-总结"></a>2.3.2-总结</h4><p>List 在工作中经常遇到，熟读源码不仅仅是为了应对面试，也为了在工作中使用起来得心应手，如果想更深入了解 List，可以看一遍 ArrayList 源码之后，自己重新实现一个 List。这样的话，就会对 List 底层的数据结构和操作细节理解更深。</p>
<h3 id="2-4-HashMap-源码解析"><a href="#2-4-HashMap-源码解析" class="headerlink" title="2.4-HashMap 源码解析"></a>2.4-HashMap 源码解析</h3><p>HashMap 源码很长，面试的问题也非常多，但这些面试问题，基本都是从源码中衍生出来的，所以我们只需要弄清楚其底层实现原理，回答这些问题就会游刃有余。</p>
<h4 id="2-4-1-整体架构"><a href="#2-4-1-整体架构" class="headerlink" title="2.4.1-整体架构"></a>2.4.1-整体架构</h4><p>HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时，链表会转化成红黑树，当红黑树的大小小于等于 6 时，红黑树会转化成链表，整体的数据结构如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/HashMap.jpeg" alt="HashMap"></p>
<p>图中左边竖着的是 HashMap 的数组结构，数组的元素可能是单个 Node，也可能是个链表，也可能是个红黑树，比如数组下标索引为 2 的位置就是一个链表，下标索引为 9 的位置对应的就是红黑树，具体细节我们下文再说。</p>
<h5 id="1-类注释"><a href="#1-类注释" class="headerlink" title="1.类注释"></a>1.类注释</h5><p>从 HashMap 的类注释中，我们可以得到如下信息：</p>
<ul>
<li>允许 null 值，不同于 HashTable ，是线程不安全的；</li>
<li>load factor（影响因子） 默认值是 0.75， 是均衡了时间和空间损耗算出来的值，较高的值会减少空间开销（扩容减少，数组大小增长速度变慢），但增加了查找成本（hash 冲突增加，链表长度变长），不扩容的条件：数组容量 &gt; 需要的数组大小 /load factor；</li>
<li>如果有很多数据需要储存到 HashMap 中，建议 HashMap 的容量一开始就设置成足够的大小，这样可以防止在其过程中不断的扩容，影响性能；</li>
<li>HashMap 是非线程安全的，我们可以自己在外部加锁，或者通过 Collections#synchronizedMap 来实现线程安全，Collections#synchronizedMap 的实现是在每个方法上加上了 synchronized 锁；</li>
<li>在迭代过程中，如果 HashMap 的结构被修改，会快速失败。</li>
</ul>
<h5 id="2-常见属性"><a href="#2-常见属性" class="headerlink" title="2.常见属性"></a>2.常见属性</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//初始容量为 16</span>
 <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true">//最大容量</span>
 <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true">//负载因子默认值</span>
 <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true">//桶上的链表长度大于等于8时，链表转化成红黑树</span>
 <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true">//桶上的红黑树大小小于等于6时，红黑树转化成链表</span>
 <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true">//当数组容量大于 64 时，链表才会转化成红黑树</span>
 <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true">//记录迭代过程中 HashMap 结构是否发生变化，如果有变化，迭代时会 fail-fast</span>
 <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true">//HashMap 的实际大小，可能不准(因为当你拿到这个值的时候，可能又发生了变化)</span>
 <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true">//存放数据的数组</span>
 <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true">// 扩容的门槛，有两种情况</span>
 <span class="token comment" spellcheck="true">// 如果初始化时，给定数组大小的话，通过 tableSizeFor 方法计算，数组大小永远接近于 2 的幂次方，比如你给定初始化大小 19，实际上初始化大小为 32，为 2 的 5 次方。</span>
 <span class="token comment" spellcheck="true">// 如果是通过 resize 方法进行扩容，大小 = 数组容量 * 0.75</span>
 <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>

 <span class="token comment" spellcheck="true">//链表的节点</span>
 <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>

 <span class="token comment" spellcheck="true">//红黑树的节点</span>
 <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span></code></pre>
<h4 id="2-4-2-新增"><a href="#2-4-2-新增" class="headerlink" title="2.4.2-新增"></a>2.4.2-新增</h4><p>新增 key，value 大概的步骤如下：</p>
<ol>
<li>空数组有无初始化，没有的话初始化；</li>
<li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li>
<li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li>
<li>如果是链表，递归循环，把新元素追加到队尾；</li>
<li>如果是红黑树，调用红黑树新增的方法；</li>
<li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li>
<li>判断是否需要扩容，需要扩容进行扩容，结束。</li>
</ol>
<p>我们来画一张示意图来描述下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/HashMap-%E6%96%B0%E5%A2%9E%E8%BF%87%E7%A8%8B.jpeg" alt="HashMap-新增过程"></p>
<p>代码细节如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 入参 hash：通过 hash 算法计算出来的值。</span>
<span class="token comment" spellcheck="true">// 入参 onlyIfAbsent：false 表示即使 key 已经存在了，仍然会用新值覆盖原来的值，默认为 false</span>
<span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
               <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// n 表示数组的长度，i 为数组索引下标，p 为 i 下标位置的 Node 值</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//如果数组为空，使用 resize 方法初始化</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 如果当前索引位置是空的，直接生成新的节点在当前索引位置上</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 如果当前索引位置有值的处理方法，即我们常说的如何解决 hash 冲突</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// e 当前节点的临时变量</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果 key 的 hash 和值都相等，直接把当前下标位置的 Node 值赋值给临时变量</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果是红黑树，使用红黑树的方式新增</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 是个链表，把新节点放到链表的尾端</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 自旋</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// e = p.next 表示从头开始，遍历链表</span>
                <span class="token comment" spellcheck="true">// p.next == null 表明 p 是链表的尾节点</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 把新节点放到链表的尾部 </span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment" spellcheck="true">// 当链表的长度大于等于 8 时，链表转红黑树</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment" spellcheck="true">// 链表遍历过程中，发现有元素和新增的元素相等，结束循环</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//更改循环的当前元素，使 p 在遍历过程中，一直往后移动。</span>
                p <span class="token operator">=</span> e<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 说明新节点的新增位置已经找到了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 当 onlyIfAbsent 为 false 时，才会覆盖值 </span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 返回老值</span>
            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 记录 HashMap 的数据结构发生了变化</span>
    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//如果 HashMap 的实际大小大于扩容的门槛，开始扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>
        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>新增的流程上面应该已经表示很清楚了，接下来我们来看看链表和红黑树新增的细节：</p>
<h5 id="1-链表的新增"><a href="#1-链表的新增" class="headerlink" title="1.链表的新增"></a>1.链表的新增</h5><p>链表的新增比较简单，就是把当前节点追加到链表的尾部，和 LinkedList 的追加实现一样的。</p>
<p>当链表长度大于等于 8 时，此时的链表就会转化成红黑树，转化的方法是：treeifyBin，此方法有一个判断，当链表长度大于等于 8，并且整个数组大小大于 64 时，才会转成红黑树，当数组大小小于 64 时，只会触发扩容，不会转化成红黑树，转化成红黑树的过程也比较简单，具体转化的过程源码可以去 github：<a href="https://github.com/luanqiu/java8" target="_blank" rel="noopener">https://github.com/luanqiu/java8</a> 上面去查看。</p>
<p>可能面试的时候，有人问你为什么是 8，这个答案在源码中注释有说，中文翻译过来大概的意思是：</p>
<p>链表查询的时间复杂度是 O (n)，红黑树的查询复杂度是 O (log (n))。在链表数据不多的时候，使用链表进行遍历也比较快，只有当链表数据比较多的时候，才会转化成红黑树，但红黑树需要的占用空间是链表的 2 倍，考虑到转化时间和空间损耗，所以我们需要定义出转化的边界值。</p>
<p>在考虑设计 8 这个值的时候，我们参考了泊松分布概率函数，由泊松分布中得出结论，链表各个长度的命中概率为：</p>
<pre class=" language-java"><code class="language-java"><span class="token operator">*</span> <span class="token number">0</span><span class="token operator">:</span>    <span class="token number">0.60653066</span>
<span class="token operator">*</span> <span class="token number">1</span><span class="token operator">:</span>    <span class="token number">0.30326533</span>
<span class="token operator">*</span> <span class="token number">2</span><span class="token operator">:</span>    <span class="token number">0.07581633</span>
<span class="token operator">*</span> <span class="token number">3</span><span class="token operator">:</span>    <span class="token number">0.01263606</span>
<span class="token operator">*</span> <span class="token number">4</span><span class="token operator">:</span>    <span class="token number">0.00157952</span>
<span class="token operator">*</span> <span class="token number">5</span><span class="token operator">:</span>    <span class="token number">0.00015795</span>
<span class="token operator">*</span> <span class="token number">6</span><span class="token operator">:</span>    <span class="token number">0.00001316</span>
<span class="token operator">*</span> <span class="token number">7</span><span class="token operator">:</span>    <span class="token number">0.00000094</span>
<span class="token operator">*</span> <span class="token number">8</span><span class="token operator">:</span>    <span class="token number">0.00000006</span></code></pre>
<p>意思是，当链表的长度是 8 的时候，出现的概率是 0.00000006，不到千万分之一，所以说正常情况下，链表的长度不可能到达 8 ，而一旦到达 8 时，肯定是 hash 算法出了问题，所以在这种情况下，为了让 HashMap 仍然有较高的查询性能，所以让链表转化成红黑树，我们正常写代码，使用 HashMap 时，几乎不会碰到链表转化成红黑树的情况，毕竟概念只有千万分之一。</p>
<h5 id="2-红黑树新增节点过程"><a href="#2-红黑树新增节点过程" class="headerlink" title="2.红黑树新增节点过程"></a>2.红黑树新增节点过程</h5><ol>
<li><p>首先判断新增的节点在红黑树上是不是已经存在，判断手段有如下两种：</p>
<p>1.1. 如果节点没有实现 Comparable 接口，使用 equals 进行判断；</p>
<p>1.2. 如果节点自己实现了 Comparable 接口，使用 compareTo 进行判断。</p>
</li>
<li><p>新增的节点如果已经在红黑树上，直接返回；不在的话，判断新增节点是在当前节点的左边还是右边，左边值小，右边值大；</p>
</li>
<li><p>自旋递归 1 和 2 步，直到当前节点的左边或者右边的节点为空时，停止自旋，当前节点即为我们新增节点的父节点；</p>
</li>
<li><p>把新增节点放到当前节点的左边或右边为空的地方，并于当前节点建立父子节点关系；</p>
</li>
<li><p>进行着色和旋转，结束。</p>
</li>
</ol>
<p>具体源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//入参 h：key 的hash值</span>
<span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">putTreeVal</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> map<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span>
                               <span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> kc <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> searched <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//找到根节点</span>
    TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> root <span class="token operator">=</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//自旋</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> root<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> dir<span class="token punctuation">,</span> ph<span class="token punctuation">;</span> K pk<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// p hash 值大于 h，说明 p 在 h 的右边</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">></span> h<span class="token punctuation">)</span>
            dir <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// p hash 值小于 h，说明 p 在 h 的左边</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ph <span class="token operator">&lt;</span> h<span class="token punctuation">)</span>
            dir <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//要放进去key在当前树中已经存在了(equals来判断)</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> k <span class="token operator">||</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> k<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>pk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> p<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//自己实现的Comparable的话，不能用hashcode比较了，需要用compareTo</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>kc <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>
                  <span class="token comment" spellcheck="true">//得到key的Class类型，如果key没有实现Comparable就是null</span>
                  <span class="token punctuation">(</span>kc <span class="token operator">=</span> <span class="token function">comparableClassFor</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">||</span>
                  <span class="token comment" spellcheck="true">//当前节点pk和入参k不等</span>
                 <span class="token punctuation">(</span>dir <span class="token operator">=</span> <span class="token function">compareComparables</span><span class="token punctuation">(</span>kc<span class="token punctuation">,</span> k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>searched<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> q<span class="token punctuation">,</span> ch<span class="token punctuation">;</span>
                searched <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>
                     <span class="token punctuation">(</span>q <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">||</span>
                    <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>
                     <span class="token punctuation">(</span>q <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> q<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            dir <span class="token operator">=</span> <span class="token function">tieBreakOrder</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> xp <span class="token operator">=</span> p<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//找到和当前hashcode值相近的节点(当前节点的左右子节点其中一个为空即可)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>left <span class="token operator">:</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> xpn <span class="token operator">=</span> xp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//生成新的节点</span>
            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> x <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">newTreeNode</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">,</span> xpn<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//把新节点放在当前子节点为空的位置上</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                xp<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                xp<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//当前节点和新节点建立父子，前后关系</span>
            xp<span class="token punctuation">.</span>next <span class="token operator">=</span> x<span class="token punctuation">;</span>
            x<span class="token punctuation">.</span>parent <span class="token operator">=</span> x<span class="token punctuation">.</span>prev <span class="token operator">=</span> xp<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>xpn <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>xpn<span class="token punctuation">)</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> x<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//balanceInsertion 对红黑树进行着色或旋转，以达到更多的查找效率，着色或旋转的几种场景如下</span>
            <span class="token comment" spellcheck="true">//着色：新节点总是为红色；如果新节点的父亲是黑色，则不需要重新着色；如果父亲是红色，那么必须通过重新着色或者旋转的方法，再次达到红黑树的5个约束条件</span>
            <span class="token comment" spellcheck="true">//旋转： 父亲是红色，叔叔是黑色时，进行旋转</span>
            <span class="token comment" spellcheck="true">//如果当前节点是父亲的右节点，则进行左旋</span>
            <span class="token comment" spellcheck="true">//如果当前节点是父亲的左节点，则进行右旋</span>

            <span class="token comment" spellcheck="true">//moveRootToFront 方法是把算出来的root放到根节点上</span>
            <span class="token function">moveRootToFront</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token function">balanceInsertion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>红黑树的新增，要求大家对红黑树的数据结构有一定的了解。面试的时候，一般只会问到新增节点到红黑树上大概是什么样的一个过程，着色和旋转的细节不会问，因为很难说清楚，但我们要清楚着色指的是给红黑树的节点着上红色或黑色，旋转是为了让红黑树更加平衡，提高查询的效率，总的来说都是为了满足红黑树的 5 个原则：</p>
<ol>
<li>节点是红色或黑色</li>
<li>根是黑色</li>
<li>所有叶子都是黑色</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li>
<li>从每个叶子到根的所有路径上不能有两个连续的红色节点</li>
</ol>
<h4 id="2-4-3-查找"><a href="#2-4-3-查找" class="headerlink" title="2.4.3-查找"></a>2.4.3-查找</h4><p>HashMap 的查找主要分为以下三步：</p>
<ul>
<li>根据 hash 算法定位数组的索引位置，equals 判断当前节点是否是我们需要寻找的 key，是的话直接返回，不是的话往下。</li>
<li>判断当前节点有无 next 节点，有的话判断是链表类型，还是红黑树类型。</li>
<li>分别走链表和红黑树不同类型的查找方法。</li>
</ul>
<p>链表查找的关键代码是：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 采用自旋方式从链表中查找 key，e 初始为为链表的头节点</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 如果当前节点 hash 等于 key 的 hash，并且 equals 相等，当前节点就是我们要找的节点</span>
    <span class="token comment" spellcheck="true">// 当 hash 冲突时，同一个 hash 值上是一个链表的时候，我们是通过 equals 方法来比较 key 是否相等的</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> e<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 否则，把当前节点的下一个节点拿出来继续寻找</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>红黑树查找的代码很多，我们大概说下思路，实际步骤比较复杂，可以去 github 上面去查看源码：</p>
<ol>
<li>从根节点递归查找；</li>
<li>根据 hashcode，比较查找节点，左边节点，右边节点之间的大小，根本红黑树左小右大的特性进行判断；</li>
<li>判断查找节点在第 2 步有无定位节点位置，有的话返回，没有的话重复 2，3 两步；</li>
<li>一直自旋到定位到节点位置为止。</li>
</ol>
<p>如果红黑树比较平衡的话，每次查找的次数就是树的深度。</p>
<h4 id="2-4-4-总结"><a href="#2-4-4-总结" class="headerlink" title="2.4.4-总结"></a>2.4.4-总结</h4><p>HashMap 的内容虽然较多，但大多数 api 都只是对数组 + 链表 + 红黑树这种数据结构进行封装而已，本小节我们从新增和查找两个角度进行了源码的深入分析，分析了是如何对数组、链表和红黑树进行操作的。想了解更多，可以前往 github 上查看更多源码。</p>
<h3 id="2-5-TreeMap-和-LinkedHashMap-核心源码解析"><a href="#2-5-TreeMap-和-LinkedHashMap-核心源码解析" class="headerlink" title="2.5-TreeMap 和 LinkedHashMap 核心源码解析"></a>2.5-TreeMap 和 LinkedHashMap 核心源码解析</h3><p>在熟悉 HashMap 之后，本小节我们来看下 TreeMap 和 LinkedHashMap，看看 TreeMap 是如何根据 key 进行排序的，LinkedHashMap 是如何用两种策略进行访问的。</p>
<h4 id="2-5-1-知识储备"><a href="#2-5-1-知识储备" class="headerlink" title="2.5.1-知识储备"></a>2.5.1-知识储备</h4><p>在了解 TreeMap 之前，我们来看下日常工作中排序的两种方式，作为我们学习的基础储备。</p>
<p>两种方式的代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeMapDemo</span> <span class="token punctuation">{</span>

  <span class="token annotation punctuation">@Data</span>
  <span class="token comment" spellcheck="true">// DTO 为我们排序的对象</span>
  <span class="token keyword">class</span> <span class="token class-name">DTO</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>DTO<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> Integer id<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">DTO</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>DTO o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">//默认从小到大排序</span>
      <span class="token keyword">return</span> id <span class="token operator">-</span> o<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Test</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testTwoComparable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 第一种排序，从小到大排序，实现 Comparable 的 compareTo 方法进行排序</span>
    List<span class="token operator">&lt;</span>DTO<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DTO</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 第二种排序，从大到小排序，利用外部排序器 Comparator 进行排序</span>
    Comparator comparator <span class="token operator">=</span> <span class="token punctuation">(</span>Comparator<span class="token operator">&lt;</span>DTO<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">(</span>o1<span class="token punctuation">,</span> o2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> o2<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> o1<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    List<span class="token operator">&lt;</span>DTO<span class="token operator">></span> list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      list2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DTO</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span>comparator<span class="token punctuation">)</span><span class="token punctuation">;</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>第一种排序输出的结果从小到大，结果是：<code>[{“id”:1},{“id”:2},{“id”:3},{“id”:4},{“id”:5}]</code>；</p>
<p>第二种输出的结果恰好相反，结果是：<code>[{“id”:5},{“id”:4},{“id”:3},{“id”:2},{“id”:1}]</code>。</p>
<p>以上两种就是分别通过 Comparable 和 Comparator 两者进行排序的方式，而 TreeMap 利用的也是此原理，从而实现了对 key 的排序，我们一起来看下。</p>
<h4 id="2-5-2-TreeMap-整体架构"><a href="#2-5-2-TreeMap-整体架构" class="headerlink" title="2.5.2-TreeMap 整体架构"></a>2.5.2-TreeMap 整体架构</h4><p>TreeMap 底层的数据结构就是红黑树，和 HashMap 的红黑树结构一样。</p>
<p>不同的是，TreeMap 利用了红黑树左节点小，右节点大的性质，根据 key 进行排序，使每个元素能够插入到红黑树大小适当的位置，维护了 key 的大小关系，适用于 key 需要排序的场景。</p>
<p>因为底层使用的是平衡红黑树的结构，所以 containsKey、get、put、remove 等方法的时间复杂度都是 log(n)。</p>
<h5 id="1-属性"><a href="#1-属性" class="headerlink" title="1.属性"></a>1.属性</h5><p>TreeMap 常见的属性有：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//比较器，如果外部有传进来 Comparator 比较器，首先用外部的</span>
<span class="token comment" spellcheck="true">//如果外部比较器为空，则使用 key 自己实现的 Comparable#compareTo 方法</span>
<span class="token comment" spellcheck="true">//比较手段和上面日常工作中的比较 demo 是一致的</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span> comparator<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//红黑树的根节点</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> root<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//红黑树的已有元素大小</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//树结构变化的版本号，用于迭代过程中的快速失败场景</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//红黑树的节点</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>
<h5 id="2-新增节点"><a href="#2-新增节点" class="headerlink" title="2.新增节点"></a>2.新增节点</h5><p>我们来看下 TreeMap 新增节点的步骤：</p>
<ol>
<li><p>判断红黑树的节点是否为空，为空的话，新增的节点直接作为根节点，代码如下：</p>
<pre class=" language-java"><code class="language-java">Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> t <span class="token operator">=</span> root<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//红黑树根节点为空，直接新建</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// compare 方法限制了 key 不能为 null</span>
    <span class="token function">compare</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// type (and possibly null) check</span>
    <span class="token comment" spellcheck="true">// 成为根节点</span>
    root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
    size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>根据红黑树左小右大的特性，进行判断，找到应该新增节点的父节点，代码如下：</p>
<pre class=" language-java"><code class="language-java">Comparator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> K<span class="token operator">></span> cpr <span class="token operator">=</span> comparator<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>cpr <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//自旋找到 key 应该新增的位置，就是应该挂载那个节点的头上</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//一次循环结束时，parent 就是上次比过的对象</span>
        parent <span class="token operator">=</span> t<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 通过 compare 来比较 key 的大小</span>
        cmp <span class="token operator">=</span> cpr<span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> t<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//key 小于 t，把 t 左边的值赋予 t，因为红黑树左边的值比较小，循环再比</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            t <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//key 大于 t，把 t 右边的值赋予 t，因为红黑树右边的值比较大，循环再比</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
            t <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果相等的话，直接覆盖原值</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// t 为空，说明已经到叶子节点了</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
</li>
<li><p>在父节点的左边或右边插入新增节点，代码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//cmp 代表最后一次对比的大小，小于 0 ，代表 e 在上一节点的左边</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>cmp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    parent<span class="token punctuation">.</span>left <span class="token operator">=</span> e<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//cmp 代表最后一次对比的大小，大于 0 ，代表 e 在上一节点的右边，相等的情况第二步已经处理了。</span>
<span class="token keyword">else</span>
    parent<span class="token punctuation">.</span>right <span class="token operator">=</span> e<span class="token punctuation">;</span></code></pre>
</li>
<li><p>着色旋转，达到平衡，结束。</p>
</li>
</ol>
<p>从源码中，我们可以看到：</p>
<ol>
<li>新增节点时，就是利用了红黑树左小右大的特性，从根节点不断往下查找，直到找到节点是 null 为止，节点为 null 说明到达了叶子结点；</li>
<li>查找过程中，发现 key 值已经存在，直接覆盖；</li>
<li>TreeMap 是禁止 key 是 null 值的。</li>
</ol>
<p>类似的，TreeMap 查找也是类似的原理，有兴趣的同学可以去 github 上面去查看源码。</p>
<h5 id="3-小结"><a href="#3-小结" class="headerlink" title="3.小结"></a>3.小结</h5><p>TreeMap 相对来说比较简单，红黑树和 HashMap 比较类似，比较关键的是通过 compare 来比较 key 的大小，然后利用红黑树左小右大的特性，为每个 key 找到自己的位置，从而维护了 key 的大小排序顺序。</p>
<h4 id="2-5-3-LinkedHashMap-整体架构"><a href="#2-5-3-LinkedHashMap-整体架构" class="headerlink" title="2.5.3-LinkedHashMap 整体架构"></a>2.5.3-LinkedHashMap 整体架构</h4><p>HashMap 是无序的，TreeMap 可以按照 key 进行排序，那有木有 Map 是可以维护插入的顺序的呢？接下来我们一起来看下 LinkedHashMap。</p>
<p>LinkedHashMap 本身是继承 HashMap 的，所以它拥有 HashMap 的所有特性，再此基础上，还提供了两大特性：</p>
<ul>
<li>按照插入顺序进行访问；</li>
<li>实现了访问最少最先删除功能，其目的是把很久都没有访问的 key 自动删除。</li>
</ul>
<p>接着我们来看下上述两大特性。</p>
<h5 id="1-按照插入顺序访问"><a href="#1-按照插入顺序访问" class="headerlink" title="1.按照插入顺序访问"></a>1.按照插入顺序访问</h5><h6 id="1-1-LinkedHashMap-链表结构"><a href="#1-1-LinkedHashMap-链表结构" class="headerlink" title="1.1-LinkedHashMap 链表结构"></a>1.1-LinkedHashMap 链表结构</h6><p>我们看下 LinkedHashMap 新增了哪些属性，以达到了链表结构的：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 链表头</span>
<span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> head<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 链表尾</span>
<span class="token keyword">transient</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> tail<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 继承 Node，为数组的每个元素增加了 before 和 after 属性</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">HashMap<span class="token punctuation">.</span>Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>
    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> before<span class="token punctuation">,</span> after<span class="token punctuation">;</span>
    <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 控制两种访问模式的字段，默认 false</span>
<span class="token comment" spellcheck="true">// true 按照访问顺序，会把经常访问的 key 放到队尾</span>
<span class="token comment" spellcheck="true">// false 按照插入顺序提供访问</span>
<span class="token keyword">final</span> <span class="token keyword">boolean</span> accessOrder<span class="token punctuation">;</span></code></pre>
<p>从上述 Map 新增的属性可以看到，LinkedHashMap 的数据结构很像是把 LinkedList 的每个元素换成了 HashMap 的 Node，像是两者的结合体，也正是因为增加了这些结构，从而能把 Map 的元素都串联起来，形成一个链表，而链表就可以保证顺序了，就可以维护元素插入进来的顺序。</p>
<h6 id="1-2-如何按照顺序新增"><a href="#1-2-如何按照顺序新增" class="headerlink" title="1.2-如何按照顺序新增"></a>1.2-如何按照顺序新增</h6><p>LinkedHashMap 初始化时，默认 accessOrder 为 false，就是会按照插入顺序提供访问，插入方法使用的是父类 HashMap 的 put 方法，不过覆写了 put 方法执行中调用的 newNode/newTreeNode 和 afterNodeAccess 方法。</p>
<p>newNode/newTreeNode 方法，控制新增节点追加到链表的尾部，这样每次新节点都追加到尾部，即可保证插入顺序了，我们以 newNode 源码为例：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 新增节点，并追加到链表的尾部</span>
Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 新增节点</span>
    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span>
        <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 追加到链表的尾部</span>
    <span class="token function">linkNodeLast</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// link at the end of list</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">linkNodeLast</span><span class="token punctuation">(</span>LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> last <span class="token operator">=</span> tail<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 新增节点等于位节点</span>
    tail <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// last 为空，说明链表为空，首尾节点相等</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">==</span> null<span class="token punctuation">)</span>
        head <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 链表有数据，直接建立新增节点和上个尾节点之间的前后关系即可</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        p<span class="token punctuation">.</span>before <span class="token operator">=</span> last<span class="token punctuation">;</span>
        last<span class="token punctuation">.</span>after <span class="token operator">=</span> p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>LinkedHashMap 通过新增头节点、尾节点，给每个节点增加 before、after 属性，每次新增时，都把节点追加到尾节点等手段，在新增的时候，就已经维护了按照插入顺序的链表结构了。</p>
<h6 id="1-3-按照顺序访问"><a href="#1-3-按照顺序访问" class="headerlink" title="1.3-按照顺序访问"></a>1.3-按照顺序访问</h6><p>LinkedHashMap 只提供了单向访问，即按照插入的顺序从头到尾进行访问，不能像 LinkedList 那样可以双向访问。</p>
<p>我们主要通过迭代器进行访问，迭代器初始化的时候，默认从头节点开始访问，在迭代的过程中，不断访问当前节点的 after 节点即可。</p>
<p>Map 对 key、value 和 entity（节点） 都提供出了迭代的方法，假设我们需要迭代 entity，就可使用 <code>LinkedHashMap.entrySet().iterator()</code> 这种写法直接返回 LinkedHashIterator ，LinkedHashIterator 是迭代器，我们调用迭代器的 nextNode 方法就可以得到下一个节点，迭代器的源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 初始化时，默认从头节点开始访问</span>
<span class="token function">LinkedHashIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 头节点作为第一个访问的节点</span>
    next <span class="token operator">=</span> head<span class="token punctuation">;</span>
    expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
    current <span class="token operator">=</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">final</span> LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">nextNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 校验</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchElementException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    current <span class="token operator">=</span> e<span class="token punctuation">;</span>
    next <span class="token operator">=</span> e<span class="token punctuation">.</span>after<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 通过链表的 after 结构，找到下一个迭代的节点</span>
    <span class="token keyword">return</span> e<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>在新增节点时，我们就已经维护了元素之间的插入顺序了，所以迭代访问时非常简单，只需要不断的访问当前节点的下一个节点即可。</p>
<h5 id="2-访问最少删除策略"><a href="#2-访问最少删除策略" class="headerlink" title="2.访问最少删除策略"></a>2.访问最少删除策略</h5><h6 id="2-1-Demo"><a href="#2-1-Demo" class="headerlink" title="2.1-Demo"></a>2.1-Demo</h6><p>这种策略也叫做 LRU（Least recently used,最近最少使用），大概的意思就是经常访问的元素会被追加到队尾，这样不经常访问的数据自然就靠近队头，然后我们可以通过设置删除策略，比如当 Map 元素个数大于多少时，把头节点删除，我们写个 demo 方便大家理解。demo 如下，完整代码可到 github 上查看：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testAccessOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 新建 LinkedHashMap</span>
  LinkedHashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0.75f</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
      <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token comment" spellcheck="true">// 覆写了删除策略的方法，我们设定当节点个数大于 3 时，就开始删除头节点</span>
    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"初始化：{}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Assert<span class="token punctuation">.</span><span class="token function">assertNotNull</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"map.get(9)：{}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Assert<span class="token punctuation">.</span><span class="token function">assertNotNull</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"map.get(20)：{}"</span><span class="token punctuation">,</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
<p>打印出来的结果如下：</p>
<pre class=" language-java"><code class="language-java">初始化：<span class="token punctuation">{</span><span class="token number">9</span><span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span>
map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span>：<span class="token punctuation">{</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">}</span>
map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>：<span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token operator">:</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token operator">:</span><span class="token number">20</span><span class="token punctuation">}</span></code></pre>
<p>可以看到，map 初始化的时候，我们放进去四个元素，但结果只有三个元素，10 不见了，这个主要是因为我们覆写了 removeEldestEntry 方法，我们实现了如果 map 中元素个数大于 3 时，我们就把队头的元素删除，当 put(1, 1) 执行的时候，正好把队头的 10 删除，这个体现了达到我们设定的删除策略时，会自动的删除头节点。</p>
<p>当我们调用 map.get(9) 方法时，元素 9 移动到队尾，调用 map.get(20) 方法时， 元素 20 被移动到队尾，这个体现了经常被访问的节点会被移动到队尾。</p>
<p>这个例子就很好的说明了访问最少删除策略，接下来我们看下原理。</p>
<h6 id="2-2-元素被转移到队尾"><a href="#2-2-元素被转移到队尾" class="headerlink" title="2.2-元素被转移到队尾"></a>2.2-元素被转移到队尾</h6><p>我们先来看下为什么 get 时，元素会被移动到队尾：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 调用 HashMap  get 方法</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 如果设置了 LRU 策略</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessOrder<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// 这个方法把当前 key 移动到队尾</span>
        <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从上述源码中，可以看到，通过 afterNodeAccess 方法把当前访问节点移动到了队尾，其实不仅仅是 get 方法，执行 getOrDefault、compute、computeIfAbsent、computeIfPresent、merge 方法时，也会这么做，通过不断的把经常访问的节点移动到队尾，那么靠近队头的节点，自然就是很少被访问的元素了。</p>
<h6 id="2-3-删除策略"><a href="#2-3-删除策略" class="headerlink" title="2.3-删除策略"></a>2.3-删除策略</h6><p>上述 demo 我们在执行 put 方法时，发现队头元素被删除了，LinkedHashMap 本身是没有 put 方法实现的，调用的是 HashMap 的 put 方法，但 LinkedHashMap 实现了 put 方法中的调用 afterNodeInsertion 方法，这个方式实现了删除，我们看下源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 删除很少被访问的元素，被 HashMap 的 put 方法所调用</span>
<span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment" spellcheck="true">// 得到元素头节点</span>
    LinkedHashMap<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// removeEldestEntry 来控制删除策略，如果队列不为空，并且删除策略允许删除的情况下，删除头节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>evict <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>first <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        K key <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// removeNode 删除头节点</span>
        <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h5 id="3-小结-1"><a href="#3-小结-1" class="headerlink" title="3.小结"></a>3.小结</h5><p>LinkedHashMap 提供了两个很有意思的功能：按照插入顺序访问和删除最少访问元素策略，简单地通过链表的结构就实现了，设计得非常巧妙。</p>
<h4 id="2-5-4-总结"><a href="#2-5-4-总结" class="headerlink" title="2.5.4-总结"></a>2.5.4-总结</h4><p>本小节主要说了 TreeMap 和 LinkedHashMap 的的数据结构，分析了两者的核心内容源码，我们发现两者充分利用了底层数据结构的特性，TreeMap 利用了红黑树左小右大的特性进行排序，LinkedHashMap 在 HashMap 的基础上简单地加了链表结构，就形成了节点的顺序，非常巧妙，很有意思，大家可以在看源码的过程中，可以多想想设计思路，说不定会有不一样的感悟。</p>
<h3 id="2-6-Map源码会问哪些面试题"><a href="#2-6-Map源码会问哪些面试题" class="headerlink" title="2.6-Map源码会问哪些面试题"></a>2.6-Map源码会问哪些面试题</h3><p>Map 在面试中，占据了很大一部分的面试题目，其中以 HashMap 为主，这些面试题目有的可以说得清楚，有的很难说清楚，如果是面对面面试的话，建议画一画。</p>
<h4 id="2-6-1-Map-整体数据结构类问题"><a href="#2-6-1-Map-整体数据结构类问题" class="headerlink" title="2.6.1-Map 整体数据结构类问题"></a>2.6.1-Map 整体数据结构类问题</h4><h5 id="1-说一说-HashMap-底层数据结构"><a href="#1-说一说-HashMap-底层数据结构" class="headerlink" title="1.说一说 HashMap 底层数据结构"></a>1.说一说 HashMap 底层数据结构</h5><p>答：HashMap 底层是数组 + 链表 + 红黑树的数据结构，数组的主要作用是方便快速查找，时间复杂度是 O(1)，默认大小是 16，数组的下标索引是通过 key 的 hashcode 计算出来的，数组元素叫做 Node，当多个 key 的 hashcode 一致，但 key 值不同时，单个 Node 就会转化成链表，链表的查询复杂度是 O(n)，当链表的长度大于等于 8 并且数组的大小超过 64 时，链表就会转化成红黑树，红黑树的查询复杂度是 O(log(n))，简单来说，最坏的查询次数相当于红黑树的最大深度。</p>
<h5 id="2-HashMap、TreeMap、LinkedHashMap-三者有啥相同点，有啥不同点？"><a href="#2-HashMap、TreeMap、LinkedHashMap-三者有啥相同点，有啥不同点？" class="headerlink" title="2.HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点？"></a>2.HashMap、TreeMap、LinkedHashMap 三者有啥相同点，有啥不同点？</h5><p>答：相同点：</p>
<ol>
<li>三者在特定的情况下，都会使用红黑树；</li>
<li>底层的 hash 算法相同；</li>
<li>在迭代的过程中，如果 Map 的数据结构被改动，都会报 ConcurrentModificationException 的错误。</li>
</ol>
<p>不同点：</p>
<ol>
<li>HashMap 数据结构以数组为主，查询非常快，TreeMap 数据结构以红黑树为主，利用了红黑树左小右大的特点，可以实现 key 的排序，LinkedHashMap 在 HashMap 的基础上增加了链表的结构，实现了插入顺序访问和最少访问删除两种策略;</li>
<li>由于三种 Map 底层数据结构的差别，导致了三者的使用场景的不同，TreeMap 适合需要根据 key 进行排序的场景，LinkedHashMap 适合按照插入顺序访问，或需要删除最少访问元素的场景，剩余场景我们使用 HashMap 即可，我们工作中大部分场景基本都在使用 HashMap；</li>
<li>由于三种 map 的底层数据结构的不同，导致上层包装的 api 略有差别。</li>
</ol>
<h5 id="3-说一下-Map-的-hash-算法"><a href="#3-说一下-Map-的-hash-算法" class="headerlink" title="3.说一下 Map 的 hash 算法"></a>3.说一下 Map 的 hash 算法</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> h<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
key 在数组中的位置公式：tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span></code></pre>
<p>如上代码是 HashMap 的hash 算法。</p>
<p>这其实是一个数学问题，源码中就是通过以上代码来计算 hash 的，首先计算出 key 的 hashcode，因为 key 是 Object，所以会根据 key 的不同类型进行 hashcode 的计算，接着计算 h ^ (h &gt;&gt;&gt; 16) ，这么做的好处是使大多数场景下，算出来的 hash 值比较分散。</p>
<p>一般来说，hash 值算出来之后，要计算当前 key 在数组中的索引下标位置时，可以采用取模的方式，就是索引下标位置 = hash 值 % 数组大小，这样做的好处，就是可以保证计算出来的索引下标值可以均匀的分布在数组的各个索引位置上，但取模操作对于处理器的计算是比较慢的，数学上有个公式，当 b 是 2 的幂次方时，a % b = a &amp;（b-1），所以此处索引位置的计算公式我们可以更换为： (n-1) &amp; hash。</p>
<p>此问题可以延伸出三个小问题：</p>
<p>1：为什么不用 key % 数组大小，而是需要用 key 的 hash 值 % 数组大小。</p>
<p>答：如果 key 是数字，直接用 key % 数组大小是完全没有问题的，但我们的 key 还有可能是字符串，是复杂对象，这时候用 字符串或复杂对象 % 数组大小是不行的，所以需要先计算出 key 的 hash 值。</p>
<p>2：计算 hash 值时，为什么需要右移 16 位？</p>
<p>答：hash 算法是 h ^ (h &gt;&gt;&gt; 16)，为了使计算出的 hash 值更分散，所以选择先将 h 无符号右移 16 位，然后再于 h 异或时，就能达到 h 的高 16 位和低 16 位都能参与计算，减少了碰撞的可能性。</p>
<p>3：为什么把取模操作换成了 &amp; 操作？</p>
<p>答：key.hashCode() 算出来的 hash 值还不是数组的索引下标，为了随机的计算出索引的下表位置，我们还会用 hash 值和数组大小进行取模，这样子计算出来的索引下标比较均匀分布。</p>
<p>取模操作处理器计算比较慢，处理器对 &amp; 操作就比较擅长，换成了 &amp; 操作，是有数学上证明的支撑，为了提高了处理器处理的速度。</p>
<p>4：为什么提倡数组大小是 2 的幂次方？</p>
<p>答：因为只有大小是 2 的幂次方时，才能使 hash 值 % n(数组大小) == (n-1) &amp; hash 公式成立。</p>
<h5 id="4-为解决-hash-冲突，大概有哪些办法。"><a href="#4-为解决-hash-冲突，大概有哪些办法。" class="headerlink" title="4.为解决 hash 冲突，大概有哪些办法。"></a>4.为解决 hash 冲突，大概有哪些办法。</h5><p>答：1：好的 hash 算法，细问的话复述一下上题的 hash 算法;</p>
<p>2：自动扩容，当数组大小快满的时候，采取自动扩容，可以减少 hash 冲突;</p>
<p>3：hash 冲突发生时，采用链表来解决;</p>
<p>4：hash 冲突严重时，链表会自动转化成红黑树，提高遍历速度。</p>
<p>网上列举的一些其它办法，如开放定址法，尽量不要说，因为这些方法资料很少，实战用过的人更少，如果你没有深入研究的话，面试官让你深入描述一下很难说清楚，反而留下不好的印象，说 HashMap 现有的措施就足够了。</p>
<h4 id="2-6-2-HashMap-源码细节类问题"><a href="#2-6-2-HashMap-源码细节类问题" class="headerlink" title="2.6.2-HashMap 源码细节类问题"></a>2.6.2-HashMap 源码细节类问题</h4><h5 id="1-HashMap-是如何扩容的？"><a href="#1-HashMap-是如何扩容的？" class="headerlink" title="1.HashMap 是如何扩容的？"></a>1.HashMap 是如何扩容的？</h5><p>答：扩容的时机：</p>
<ol>
<li>put 时，发现数组为空，进行初始化扩容，默认扩容大小为 16;</li>
<li>put 成功后，发现现有数组大小大于扩容的门阀值时，进行扩容，扩容为老数组大小的 2 倍;</li>
</ol>
<p>扩容的门阀是 threshold，每次扩容时 threshold 都会被重新计算，门阀值等于数组的大小 * 影响因子（0.75）。</p>
<p>新数组初始化之后，需要将老数组的值拷贝到新数组上，链表和红黑树都有自己拷贝的方法。</p>
<h5 id="2-hash-冲突时怎么办？"><a href="#2-hash-冲突时怎么办？" class="headerlink" title="2.hash 冲突时怎么办？"></a>2.hash 冲突时怎么办？</h5><p>答：hash 冲突指的是 key 值的 hashcode 计算相同，但 key 值不同的情况。</p>
<p>如果桶中元素原本只有一个或已经是链表了，新增元素直接追加到链表尾部；</p>
<p>如果桶中元素已经是链表，并且链表个数大于等于 8 时，此时有两种情况：</p>
<ol>
<li>如果此时数组大小小于 64，数组再次扩容，链表不会转化成红黑树;</li>
<li>如果数组大小大于 64 时，链表就会转化成红黑树。</li>
</ol>
<p>这里不仅仅判断链表个数大于等于 8，还判断了数组大小，数组容量小于 64 没有立即转化的原因，猜测主要是因为红黑树占用的空间比链表大很多，转化也比较耗时，所以数组容量小的情况下冲突严重，我们可以先尝试扩容，看看能否通过扩容来解决冲突的问题。</p>
<h5 id="3-为什么链表个数大于等于-8-时，链表要转化成红黑树了？"><a href="#3-为什么链表个数大于等于-8-时，链表要转化成红黑树了？" class="headerlink" title="3.为什么链表个数大于等于 8 时，链表要转化成红黑树了？"></a>3.为什么链表个数大于等于 8 时，链表要转化成红黑树了？</h5><p>答：当链表个数太多了，遍历可能比较耗时，转化成红黑树，可以使遍历的时间复杂度降低，但转化成红黑树，有空间和转化耗时的成本，我们通过泊松分布公式计算，正常情况下，链表个数出现 8 的概念不到千万分之一，所以说正常情况下，链表都不会转化成红黑树，这样设计的目的，是为了防止非正常情况下，比如 hash 算法出了问题时，导致链表个数轻易大于等于 8 时，仍然能够快速遍历。</p>
<p>延伸问题：红黑树什么时候转变成链表。</p>
<p>答：当节点的个数小于等于 6 时，红黑树会自动转化成链表，主要还是考虑红黑树的空间成本问题，当节点个数小于等于 6 时，遍历链表也很快，所以红黑树会重新变成链表。</p>
<h5 id="4-HashMap-在-put-时，如果数组中已经有了这个-key，我不想把-value-覆盖怎么办？取值时，如果得到的-value-是空时，想返回默认值怎么办？"><a href="#4-HashMap-在-put-时，如果数组中已经有了这个-key，我不想把-value-覆盖怎么办？取值时，如果得到的-value-是空时，想返回默认值怎么办？" class="headerlink" title="4.HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办？"></a>4.HashMap 在 put 时，如果数组中已经有了这个 key，我不想把 value 覆盖怎么办？取值时，如果得到的 value 是空时，想返回默认值怎么办？</h5><p>答：如果数组有了 key，但不想覆盖 value ，可以选择 putIfAbsent 方法，这个方法有个内置变量 onlyIfAbsent，内置是 true ，就不会覆盖，我们平时使用的 put 方法，内置 onlyIfAbsent 为 false，是允许覆盖的。</p>
<p>取值时，如果为空，想返回默认值，可以使用 getOrDefault 方法，方法第一参数为 key，第二个参数为你想返回的默认值，如 map.getOrDefault(“2”,“0”)，当 map 中没有 key 为 2 的值时，会默认返回 0，而不是空。</p>
<h5 id="5-通过以下代码进行删除，是否可行？"><a href="#5-通过以下代码进行删除，是否可行？" class="headerlink" title="5.通过以下代码进行删除，是否可行？"></a>5.通过以下代码进行删除，是否可行？</h5><pre class=" language-java"><code class="language-java">HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String <span class="token operator">></span> map <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> s2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>答：不行，会报错误 ConcurrentModificationException，原因如下图：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/HashMap-%E5%88%A0%E9%99%A4%E6%8A%A5%E9%94%99%E5%8E%9F%E5%9B%A0.jpeg" alt="HashMap-删除报错原因"></p>
<p>建议使用迭代器的方式进行删除，原理同 ArrayList 迭代器原理，我们在《List 源码会问那些面试题》中有说到。</p>
<h5 id="6-描述一下-HashMap-get、put-的过程"><a href="#6-描述一下-HashMap-get、put-的过程" class="headerlink" title="6.描述一下 HashMap get、put 的过程"></a>6.描述一下 HashMap get、put 的过程</h5><p>答：我们在源码解析中有说，可以详细描述下源码的实现路径，说不清楚的话，可以画一画。</p>
<h4 id="2-6-3-其它-Map-面试题"><a href="#2-6-3-其它-Map-面试题" class="headerlink" title="2.6.3-其它 Map 面试题"></a>2.6.3-其它 Map 面试题</h4><h5 id="1-DTO-作为-Map-的-key-时，有无需要注意的点？"><a href="#1-DTO-作为-Map-的-key-时，有无需要注意的点？" class="headerlink" title="1.DTO 作为 Map 的 key 时，有无需要注意的点？"></a>1.DTO 作为 Map 的 key 时，有无需要注意的点？</h5><p>答：DTO 就是一个数据载体，可以看做拥有很多属性的 Java 类，我们可以对这些属性进行 get、set 操作。</p>
<p>看是什么类型的 Map，如果是 HashMap 的话，一定需要覆写 equals 和 hashCode 方法，因为在 get 和 put 的时候，需要通过 equals 方法进行相等的判断；如果是 TreeMap 的话，DTO 需要实现 Comparable 接口，因为 TreeMap 会使用 Comparable 接口进行判断 key 的大小；如果是 LinkedHashMap 的话，和 HashMap 一样的。</p>
<h5 id="2-LinkedHashMap-中的-LRU-是什么意思，是如何实现的。"><a href="#2-LinkedHashMap-中的-LRU-是什么意思，是如何实现的。" class="headerlink" title="2.LinkedHashMap 中的 LRU 是什么意思，是如何实现的。"></a>2.LinkedHashMap 中的 LRU 是什么意思，是如何实现的。</h5><p>答：LRU ，英文全称：Least recently used，中文叫做最近最少访问，在 LinkedHashMap 中，也叫做最少访问删除策略，我们可以通过 removeEldestEntry 方法设定一定的策略，使最少被访问的元素，在适当的时机被删除，原理是在 put 方法执行的最后，LinkedHashMap 会去检查这种策略，如果满足策略，就删除头节点。</p>
<p>保证头节点就是最少访问的元素的原理是：LinkedHashMap 在 get 的时候，都会把当前访问的节点，移动到链表的尾部，慢慢的，就会使头部的节点都是最少被访问的元素。</p>
<h5 id="3-为什么推荐-TreeMap-的元素最好都实现-Comparable-接口？但-key-是-String-的时候，我们却没有额外的工作呢？"><a href="#3-为什么推荐-TreeMap-的元素最好都实现-Comparable-接口？但-key-是-String-的时候，我们却没有额外的工作呢？" class="headerlink" title="3.为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？"></a>3.为什么推荐 TreeMap 的元素最好都实现 Comparable 接口？但 key 是 String 的时候，我们却没有额外的工作呢？</h5><p>答：因为 TreeMap 的底层就是通过排序来比较两个 key 的大小的，所以推荐 key 实现 Comparable 接口，是为了往你希望的排序顺序上发展， 而 String 本身已经实现了 Comparable 接口，所以使用 String 时，我们不需要额外的工作，不仅仅是 String ，其他包装类型也都实现了 Comparable 接口，如 Long、Double、Short 等等。</p>
<h4 id="2-6-4-总结"><a href="#2-6-4-总结" class="headerlink" title="2.6.4-总结"></a>2.6.4-总结</h4><p>Map 的面试题主要是 HashMap 为主，会问很多源码方面的东西，TreeMap 和 LinkedHashMap 主要以功能和场景为主，作为加分项。<br>Map 的面试题型很多，但只要弄懂原理，题目再多变化，回答起来都会比较简单。</p>
<h3 id="2-7-HashSet、TreeSet-源码解析"><a href="#2-7-HashSet、TreeSet-源码解析" class="headerlink" title="2.7-HashSet、TreeSet 源码解析"></a>2.7-HashSet、TreeSet 源码解析</h3><p>HashSet、TreeSet 两个类是在 Map 的基础上组装起来的类，我们学习的侧重点，主要在于 Set 是如何利用 Map 现有的功能，来达成自己的目标的，也就是说如何基于现有的功能进行创新，然后再看看一些改变的小细节是否值得我们学习。</p>
<h4 id="2-7-1-HashSet"><a href="#2-7-1-HashSet" class="headerlink" title="2.7.1-HashSet"></a>2.7.1-HashSet</h4><h5 id="1-类注释-1"><a href="#1-类注释-1" class="headerlink" title="1.类注释"></a>1.类注释</h5><p>看源码先看类注释上，我们可以得到的信息有：</p>
<ol>
<li>底层实现基于 HashMap，所以迭代时不能保证按照插入顺序，或者其它顺序进行迭代；</li>
<li>add、remove、contanins、size 等方法的耗时性能，是不会随着数据量的增加而增加的，这个主要跟 HashMap 底层的数组数据结构有关，不管数据量多大，不考虑 hash 冲突的情况下，时间复杂度都是 O (1)；</li>
<li>线程不安全的，如果需要安全请自行加锁，或者使用 Collections.synchronizedSet；</li>
<li>迭代过程中，如果数据结构被改变，会快速失败的，会抛出 ConcurrentModificationException 异常。</li>
</ol>
<p>我们之前也看过 List、Map 的类注释，我们发现 2、3、4 点信息在类注释中都有提到，所以如果有人问 List、Map、 Set 三者的共同点，那么就可以说 2、3、4 三点。</p>
<h5 id="2-HashSet-是如何组合-HashMap-的"><a href="#2-HashSet-是如何组合-HashMap-的" class="headerlink" title="2.HashSet 是如何组合 HashMap 的"></a>2.HashSet 是如何组合 HashMap 的</h5><p>刚才是从类注释 1 中看到，HashSet 的实现是基于 HashMap 的，在 Java 中，要基于基础类进行创新实现，有两种办法：</p>
<ul>
<li>继承基础类，覆写基础类的方法，比如说继承 HashMap , 覆写其 add 的方法；</li>
<li>组合基础类，通过调用基础类的方法，来复用基础类的能力。</li>
</ul>
<p>HashSet 使用的就是组合 HashMap，其优点如下：</p>
<ol>
<li>继承表示父子类是同一个事物，而 Set 和 Map 本来就是想表达两种事物，所以继承不妥，而且 Java 语法限制，子类只能继承一个父类，后续难以扩展。</li>
<li>组合更加灵活，可以任意的组合现有的基础类，并且可以在基础类方法的基础上进行扩展、编排等，而且方法命名可以任意命名，无需和基础类的方法名称保持一致。</li>
</ol>
<p>我们在工作中，如果碰到类似问题，我们的原则也是尽量多用组合，少用继承。</p>
<p>组合就是把 HashMap 当作自己的一个局部变量，以下是 HashSet 的组合实现：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 把 HashMap 组合进来，key 是 Hashset 的 key，value 是下面的 PRESENT</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> HashMap<span class="token operator">&lt;</span>E<span class="token punctuation">,</span>Object<span class="token operator">></span> map<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// HashMap 中的 value</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>从这两行代码中，我们可以看出两点：</p>
<ol>
<li>我们在使用 HashSet 时，比如 add 方法，只有一个入参，但组合的 Map 的 add 方法却有 key，value 两个入参，相对应上 Map 的 key 就是我们 add 的入参，value 就是第二行代码中的 PRESENT，此处设计非常巧妙，用一个默认值 PRESENT 来代替 Map 的 Value；</li>
<li>如果 HashSet 是被共享的，当多个线程访问的时候，就会有线程安全问题，因为在后续的所有操作中，并没有加锁。</li>
</ol>
<p>HashSet 在以 HashMap 为基础进行实现的时候，首先选择组合的方式，接着使用默认值来代替了 Map 中的 Value 值，设计得非常巧妙，给使用者的体验很好，使用起来简单方便，我们在工作中也可以借鉴这种思想，可以把底层复杂实现包装一下，一些默认实现可以自己吃掉，使吐出去的接口尽量简单好用。</p>
<h6 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1-初始化"></a>2.1-初始化</h6><p>HashSet 的初始化比较简单，直接 new HashMap 即可，比较有意思的是，当有原始集合数据进行初始化的情况下，会对 HashMap 的初始容量进行计算，源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对 HashMap 的容量进行了计算</span>
<span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">.</span><span class="token number">75f</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">addAll</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>上述代码中：Math.max ((int) (c.size ()/.75f) + 1, 16)，就是对 HashMap 的容量进行了计算，翻译成中文就是 取括号中两个数的最大值（期望的值 / 0.75+1，默认值 16），从计算中，我们可以看出 HashSet 的实现者对 HashMap 的底层实现是非常清楚的，主要体现在两个方面：</p>
<ol>
<li>和 16 比较大小的意思是说，如果给定 HashMap 初始容量小于 16 ，就按照 HashMap 默认的 16 初始化好了，如果大于 16，就按照给定值初始化。</li>
<li>HashMap 扩容的伐值的计算公式是：Map 的容量 * 0.75f，一旦达到阀值就会扩容，此处用 (int) (c.size ()/.75f) + 1 来表示初始化的值，这样使我们期望的大小值正好比扩容的阀值还大 1，就不会扩容，符合 HashMap 扩容的公式。</li>
</ol>
<p>从简单的构造器中，我们就可以看出要很好的组合 api 接口，并没有那么简单，我们可能需要去了解一下被组合的 api 底层的实现，这样才能用好 api。</p>
<p>同时这种写法，也提供了一种思路给我们，如果有人问你，往 HashMap 拷贝大集合时，如何给 HashMap 初始化大小时，完全可以借鉴这种写法：取最大值（期望的值 / 0.75 + 1，默认值 16）。</p>
<p>至于 HashSet 的其他方法就比较简单了，就是对 Map 的 api 进行了一些包装，如下的 add 方法实现：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 直接使用 HashMap 的 put 方法，进行一些简单的逻辑判断</span>
    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从 add 方法中，我们就可以看到组合的好处，方法的入参、名称、返回值都可以自定义，如果是继承的话就不行了。</p>
<h6 id="2-2-小结"><a href="#2-2-小结" class="headerlink" title="2.2-小结"></a>2.2-小结</h6><p>HashSet 具体实现值得我们借鉴的地方主要有如下地方，我们平时写代码的时候，完全可以参考参考：</p>
<ol>
<li>对组合还是继承的分析和把握；</li>
<li>对复杂逻辑进行一些包装，使吐出去的接口尽量简单好用；</li>
<li>组合其他 api 时，尽量多对组合的 api 多些了解，这样才能更好的使用 api；</li>
<li>HashMap 初始化大小值的模版公式：取括号内两者的最大值（期望的值 / 0.75+1，默认值 16）。</li>
</ol>
<h4 id="2-7-2-TreeSet"><a href="#2-7-2-TreeSet" class="headerlink" title="2.7.2-TreeSet"></a>2.7.2-TreeSet</h4><p>TreeSet 大致的结构和 HashSet 相似，底层组合的是 TreeMap，所以继承了 TreeMap key 能够排序的功能，迭代的时候，也可以按照 key 的排序顺序进行迭代，我们主要来看复用 TreeMap 时，复用的两种思路：</p>
<h5 id="1-复用-TreeMap-的思路一"><a href="#1-复用-TreeMap-的思路一" class="headerlink" title="1.复用 TreeMap 的思路一"></a>1.复用 TreeMap 的思路一</h5><p>场景一： TreeSet 的 add 方法，我们来看下其源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>可以看到，底层直接使用的是 HashMap 的 put 的能力，直接拿来用就好了。</p>
<h5 id="2-复用-TreeMap-的思路二"><a href="#2-复用-TreeMap-的思路二" class="headerlink" title="2.复用 TreeMap 的思路二"></a>2.复用 TreeMap 的思路二</h5><p>场景二：需要迭代 TreeSet 中的元素，那应该也是像 add 那样，直接使用 HashMap 已有的迭代能力，比如像下面这样：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 模仿思路一的方式实现</span>
<span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">descendingIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 直接使用 HashMap.keySet 的迭代能力</span>
    <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这种是思路一的实现方式，TreeSet 组合 TreeMap，直接选择 TreeMap 的底层能力进行包装，但 TreeSet 实际执行的思路却完全相反，我们看源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// NavigableSet 接口，定义了迭代的一些规范，和一些取值的特殊方法</span>
<span class="token comment" spellcheck="true">// TreeSet 实现了该方法，也就是说 TreeSet 本身已经定义了迭代的规范</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">NavigableSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">SortedSet</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    E <span class="token function">lower</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>  
<span class="token comment" spellcheck="true">// m.navigableKeySet() 是 TreeMap 写了一个子类实现了 NavigableSet</span>
<span class="token comment" spellcheck="true">// 接口，实现了 TreeSet 定义的迭代规范</span>
<span class="token keyword">public</span> Iterator<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">navigableKeySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>TreeMap 中对 NavigableSet 接口的实现源码截图如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/TreeMap-NavigableSet.jpeg" alt="TreeMap-NavigableSet"></p>
<p>从截图中（截图是在 TreeMap 中），我们可以看出 TreeMap 实现了 TreeSet 定义的各种特殊方法。</p>
<p>我们可以看到，这种思路是 TreeSet 定义了接口的规范，TreeMap 负责去实现，实现思路和思路一是相反的。</p>
<p>我们总结下 TreeSet 组合 TreeMap 实现的两种思路：</p>
<ol>
<li>TreeSet 直接使用 TreeMap 的某些功能，自己包装成新的 api。</li>
<li>TreeSet 定义自己想要的 api，自己定义接口规范，让 TreeMap 去实现。</li>
</ol>
<p>方案 1 和 2 的调用关系，都是 TreeSet 调用 TreeMap，但功能的实现关系完全相反，第一种是功能的定义和实现都在 TreeMap，TreeSet 只是简单的调用而已，第二种 TreeSet 把接口定义出来后，让 TreeMap 去实现内部逻辑，TreeSet 负责接口定义，TreeMap 负责具体实现，这样子的话因为接口是 TreeSet 定义的，所以实现一定是 TreeSet 最想要的，TreeSet 甚至都不用包装，可以直接把返回值吐出去都行。</p>
<p>我们思考下这两种复用思路的原因：</p>
<ol>
<li>像 add 这些简单的方法，我们直接使用的是思路 1，主要是 add 这些方法实现比较简单，没有复杂逻辑，所以 TreeSet 自己实现起来比较简单；</li>
<li>思路 2 主要适用于复杂场景，比如说迭代场景，TreeSet 的场景复杂，比如要能从头开始迭代，比如要能取第一个值，比如要能取最后一个值，再加上 TreeMap 底层结构比较复杂，TreeSet 可能并不清楚 TreeMap 底层的复杂逻辑，这时候让 TreeSet 来实现如此复杂的场景逻辑，TreeSet 就搞不定了，不如接口让 TreeSet 来定义，让 TreeMap 去负责实现，TreeMap 对底层的复杂结构非常清楚，实现起来既准确又简单。</li>
</ol>
<h3 id="3-小结-2"><a href="#3-小结-2" class="headerlink" title="3.小结"></a>3.小结</h3><p>TreeSet 对 TreeMap 的两种不同复用思路，很重要，在工作中经常会遇到，特别是思路二，比如说 dubbo 的泛化调用，DDD 中的依赖倒置等等，原理都是 TreeSet 第二种的复用思想。</p>
<h4 id="2-7-3-面试题"><a href="#2-7-3-面试题" class="headerlink" title="2.7.3-面试题"></a>2.7.3-面试题</h4><p>HashSet 和 TreeSet 的面试概率比不上 List 和 Map，但只要有机会，并把本文的内容表达出来，绝对是加分项，因为现在 List 和 Map 面试题太多，面试官认为你能答的出来是应该的，但只要你有机会对 HashSet 和 TreeSet 说出本文见解，并且说自己是看源码时领悟到的，绝对肯定是加分项，这些就是你超过面试官预期的惊喜，以下是一些常用的题目：</p>
<h5 id="1-TreeSet-有用过么，平时都在什么场景下使用？"><a href="#1-TreeSet-有用过么，平时都在什么场景下使用？" class="headerlink" title="1.TreeSet 有用过么，平时都在什么场景下使用？"></a>1.TreeSet 有用过么，平时都在什么场景下使用？</h5><p>答：有木有用过如实回答就好了，我们一般都是在需要把元素进行排序的时候使用 TreeSet，使用时需要我们注意元素最好实现 Comparable 接口，这样方便底层的 TreeMap 根据 key 进行排序。</p>
<h5 id="2-追问，如果我想实现根据-key-的新增顺序进行遍历怎么办？"><a href="#2-追问，如果我想实现根据-key-的新增顺序进行遍历怎么办？" class="headerlink" title="2.追问，如果我想实现根据 key 的新增顺序进行遍历怎么办？"></a>2.追问，如果我想实现根据 key 的新增顺序进行遍历怎么办？</h5><p>答：要按照 key 的新增顺序进行遍历，首先想到的应该就是 LinkedHashMap，而 LinkedHashSet 正好是基于 LinkedHashMap 实现的，所以我们可以选择使用 LinkedHashSet。</p>
<h5 id="3-追问，如果我想对-key-进行去重，有什么好的办法么？"><a href="#3-追问，如果我想对-key-进行去重，有什么好的办法么？" class="headerlink" title="3.追问，如果我想对 key 进行去重，有什么好的办法么？"></a>3.追问，如果我想对 key 进行去重，有什么好的办法么？</h5><p>答：我们首先想到的是 TreeSet，TreeSet 底层使用的是 TreeMap，TreeMap 在 put 的时候，如果发现 key 是相同的，会把 value 值进行覆盖，所有不会产生重复的 key ，利用这一特性，使用 TreeSet 正好可以去重。</p>
<h5 id="4-说说-TreeSet-和-HashSet-两个-Set-的内部实现结构和原理？"><a href="#4-说说-TreeSet-和-HashSet-两个-Set-的内部实现结构和原理？" class="headerlink" title="4.说说 TreeSet 和 HashSet 两个 Set 的内部实现结构和原理？"></a>4.说说 TreeSet 和 HashSet 两个 Set 的内部实现结构和原理？</h5><p>答： HashSet 底层对 HashMap 的能力进行封装，比如说 add 方法，是直接使用 HashMap 的 put 方法，比较简单，但在初始化的时候，我看源码有一些感悟：说一下 HashSet 小结的四小点。</p>
<p>TreeSet 主要是对 TreeMap 底层能力进行封装复用，我发现了两种非常有意思的复用思路，重复 TreeSet 两种复用思路。</p>
<h4 id="2-7-4-总结"><a href="#2-7-4-总结" class="headerlink" title="2.7.4-总结"></a>2.7.4-总结</h4><p>本小节主要说了 Set 源码中两处亮点：</p>
<ol>
<li>HashSet 对组合的 HashMap 类扩容的门阀值的深入了解和设计，值得我们借鉴；</li>
<li>TreeSet 对 TreeMap 两种复用思路，值得我们学习，特别是第二种复用思路。</li>
</ol>
<p>HashSet 和 TreeSet 不会是面试的重点，但通过以上两点，可以让我们给面试官一种精益求精的感觉，成为加分项。</p>
<h3 id="2-8-彰显细节：看集合源码对我们实际工作的帮助和应用"><a href="#2-8-彰显细节：看集合源码对我们实际工作的帮助和应用" class="headerlink" title="2.8-彰显细节：看集合源码对我们实际工作的帮助和应用"></a>2.8-彰显细节：看集合源码对我们实际工作的帮助和应用</h3><p>本节中，我们先跳出源码的视角，来看看集合类的类图，看看在设计层面上，是否有可疑借鉴之处，接着通过源码来找找工作中的集合坑，提前扫雷。</p>
<h4 id="2-8-1-集合类图"><a href="#2-8-1-集合类图" class="headerlink" title="2.8.1-集合类图"></a>2.8.1-集合类图</h4><p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E9%9B%86%E5%90%88%E7%B1%BB%E5%9B%BE.jpeg" alt="集合类图"></p>
<p>上图是目前我们已学的集合类图，大概可以看出以下几点：</p>
<ol>
<li>每个接口做的事情非常明确，比如 Serializable，只负责序列化，Cloneable 只负责拷贝，Map 只负责定义 Map 的接口，整个图看起来虽然接口众多，但职责都很清晰；</li>
<li>复杂功能通过接口的继承来实现，比如 ArrayList 通过实现了 Serializable、Cloneable、RandomAccess、AbstractList、List 等接口，从而拥有了序列化、拷贝、对数组各种操作定义等各种功能；</li>
<li>上述类图只能看见继承的关系，组合的关系还看不出来，比如说 Set 组合封装 Map 的底层能力等。</li>
</ol>
<p>上述设计的最大好处是，每个接口能力职责单一，众多的接口变成了接口能力的积累，假设我们想再实现一个数据结构类，我们就可以从这些已有的能力接口中，挑选出能满足需求的能力接口，进行一些简单的组装，从而加快开发速度。</p>
<p>这种思想在平时的工作中也经常被使用，我们会把一些通用的代码块抽象出来，沉淀成代码块池，碰到不同的场景的时候，我们就从代码块池中，把我们需要的代码块提取出来，进行简单的编排和组装，从而实现我们需要的场景功能。</p>
<h4 id="2-8-2-集合工作中一些注意事项"><a href="#2-8-2-集合工作中一些注意事项" class="headerlink" title="2.8.2-集合工作中一些注意事项"></a>2.8.2-集合工作中一些注意事项</h4><h5 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1.线程安全"></a>1.线程安全</h5><p>我们说集合都是非线程安全的，这里说的非线程安全指的是集合类作为共享变量，被多线程读写的时候，才是不安全的，如果要实现线程安全的集合，在类注释中，JDK 统一推荐我们使用 Collections.synchronized* 类， Collections 帮我们实现了 List、Set、Map 对应的线程安全的方法， 如下图：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Collections-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%96%B9%E6%B3%95.jpeg" alt="Collections-线程安全方法"></p>
<p>图中实现了各种集合类型的线程安全的方法，我们以 synchronizedList 为例，从源码上来看下，Collections 是如何实现线程安全的：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// mutex 就是我们需要锁住的对象</span>
<span class="token keyword">final</span> Object mutex<span class="token punctuation">;</span>  
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SynchronizedList</span><span class="token operator">&lt;</span>E<span class="token operator">></span>
        <span class="token keyword">extends</span> <span class="token class-name">SynchronizedCollection</span><span class="token operator">&lt;</span>E<span class="token operator">></span>
        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token operator">-</span>7754090372962971524L<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 这个 List 就是我们需要保证线程安全的类</span>
        <span class="token keyword">final</span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> list<span class="token punctuation">;</span>
        <span class="token function">SynchronizedList</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>E<span class="token operator">></span> list<span class="token punctuation">,</span> Object mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>list <span class="token operator">=</span> list<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
                <span class="token comment" spellcheck="true">// 我们可以看到，List 的所有操作都使用了 synchronized 关键字，来进行加锁</span>
                <span class="token comment" spellcheck="true">// synchronized 是一种悲观锁，能够保证同一时刻，只能有一个线程能够获得锁</span>
        <span class="token keyword">public</span> E <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> E <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> E element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token punctuation">{</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
…………
<span class="token punctuation">}</span>      </code></pre>
<p>从源码中我们可以看到 Collections 是通过 synchronized 关键字给 List 操作数组的方法加上锁，来实现线程安全的。</p>
<h5 id="2-集合性能"><a href="#2-集合性能" class="headerlink" title="2.集合性能"></a>2.集合性能</h5><p>集合的单个操作，一般都没有性能问题，性能问题主要出现的批量操作上。</p>
<h6 id="2-1-批量新增"><a href="#2-1-批量新增" class="headerlink" title="2.1-批量新增"></a>2.1-批量新增</h6><p>在 List 和 Map 大量数据新增的时候，我们不要使用 for 循环 + add/put 方法新增，这样子会有很大的扩容成本，我们应该尽量使用 addAll 和 putAll 方法进行新增，以 ArrayList 为例写了一个 demo 如下，演示了两种方案的性能对比：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testBatchInsert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 准备拷贝数据</span>
  ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">3000000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// for 循环 + add</span>
  ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">long</span> start1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    list2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"单个 for 循环新增 300 w 个，耗时{}"</span><span class="token punctuation">,</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start1<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 批量新增</span>
  ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">long</span> start2 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  list3<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"批量新增 300 w 个，耗时{}"</span><span class="token punctuation">,</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>最后打印出来的日志为：</p>
<p>16:52:59.865 [main] INFO demo.one.ArrayListDemo - 单个 for 循环新增 300 w 个，耗时1518<br>16:52:59.880 [main] INFO demo.one.ArrayListDemo - 批量新增 300 w 个，耗时8</p>
<p>可以看到，批量新增方法性能是单个新增方法性能的 189 倍，主要原因在于批量新增，只会扩容一次，大大缩短了运行时间，而单个新增，每次到达扩容阀值时，都会进行扩容，在整个过程中就会不断的扩容，浪费了很多时间，我们来看下批量新增的源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 确保容量充足，整个过程只会扩容一次</span>
  <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token comment" spellcheck="true">// 进行数组的拷贝</span>
  System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>
  size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>
  <span class="token keyword">return</span> numNew <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>以上是 ArrayList 批量新增的演示，我们可以看到，整个批量新增的过程中，只扩容了一次，HashMap 的 putAll 方法也是如此，整个新增过程只会扩容一次，大大缩短了批量新增的时间，提高了性能。</p>
<p>所以如果有人问你当碰到集合批量拷贝，批量新增场景，如何提高新增性能的时候 ，就可以从目标集合初始化方面应答。</p>
<p>这里也提醒了我们，在容器初始化的时候，最好能给容器赋上初始值，这样可以防止在 put 的过程中不断的扩容，从而缩短时间，上章 HashSet 的源码给我们演示了，给 HashMap 赋初始值的公式为：取括号内两者的最大值（期望的值/0.75+1，默认值 16）。</p>
<h6 id="2-2-批量删除"><a href="#2-2-批量删除" class="headerlink" title="2.2-批量删除"></a>2.2-批量删除</h6><p>批量删除 ArrayList 提供了 removeAll 的方法，HashMap 没有提供批量删除的方法，我们一起来看下 removeAll 的源码实现，是如何提高性能的：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 批量删除，removeAll 方法底层调用的是 batchRemove 方法</span>
<span class="token comment" spellcheck="true">// complement 参数默认是 false,false 的意思是数组中不包含 c 中数据的节点往头移动</span>
<span class="token comment" spellcheck="true">// true 意思是数组中包含 c 中数据的节点往头移动，这个是根据你要删除数据和原数组大小的比例来决定的</span>
<span class="token comment" spellcheck="true">// 如果你要删除的数据很多，选择 false 性能更好，当然 removeAll 方法默认就是 false。</span>
<span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">batchRemove</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">,</span> <span class="token keyword">boolean</span> complement<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// r 表示当前循环的位置、w 位置之前都是不需要被删除的数据，w 位置之后都是需要被删除的数据</span>
  <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> w <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">boolean</span> modified <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 从 0 位置开始判断，当前数组中元素是不是要被删除的元素，不是的话移到数组头</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> r<span class="token operator">++</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> complement<span class="token punctuation">)</span>
        elementData<span class="token punctuation">[</span>w<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> elementData<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// r 和 size 不等，说明在 try 过程中发生了异常，在 r 处断开</span>
    <span class="token comment" spellcheck="true">// 把 r 位置之后的数组移动到 w 位置之后(r 位置之后的数组数据都是没有判断过的数据，这样不会影响没有判断的数据，判断过的数据可以被删除)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">!=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> r<span class="token punctuation">,</span>
                       elementData<span class="token punctuation">,</span> w<span class="token punctuation">,</span>
                       size <span class="token operator">-</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
      w <span class="token operator">+=</span> size <span class="token operator">-</span> r<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// w != size 说明数组中是有数据需要被删除的</span>
    <span class="token comment" spellcheck="true">// 如果 w、size 相等，说明没有数据需要被删除</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>w <span class="token operator">!=</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// w 之后都是需要删除的数据，赋值为空，帮助 gc。</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> w<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
      modCount <span class="token operator">+=</span> size <span class="token operator">-</span> w<span class="token punctuation">;</span>
      size <span class="token operator">=</span> w<span class="token punctuation">;</span>
      modified <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> modified<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>我们看到 ArrayList 在批量删除时，如果程序执行正常，只有一次 for 循环，如果程序执行异常，才会加一次拷贝，而单个 remove 方法，每次执行的时候都会进行数组的拷贝（当删除的元素正好是数组最后一个元素时除外），当数组越大，需要删除的数据越多时，批量删除的性能会越差，所以在 ArrayList 批量删除时，强烈建议使用 removeAll 方法进行删除。</p>
<h5 id="3-集合的一些坑"><a href="#3-集合的一些坑" class="headerlink" title="3.集合的一些坑"></a>3.集合的一些坑</h5><ol>
<li>当集合的元素是自定义类时，自定义类强制实现 equals 和 hashCode 方法，并且两个都要实现。</li>
</ol>
<p>在集合中，除了 TreeMap 和 TreeSet 是通过比较器比较元素大小外，其余的集合类在判断索引位置和相等时，都会使用到 equals 和 hashCode 方法，这个在之前的源码解析中，我们有说到，所以当集合的元素是自定义类时，我们强烈建议覆写 equals 和 hashCode 方法，我们可以直接使用 IDEA 工具覆写这两个方法，非常方便；</p>
<ol>
<li>所有集合类，在 for 循环进行删除时，如果直接使用集合类的 remove 方法进行删除，都会快速失败，报 ConcurrentModificationException 的错误，所以在任意循环删除的场景下，都建议使用迭代器进行删除；</li>
<li>我们把数组转化成集合时，常使用 Arrays.asList(array)，这个方法有两个坑，代码演示坑为：</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testArrayToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 坑1：修改数组的值，会直接影响原 list</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"数组被修改之前，集合第一个元素为：{}"</span><span class="token punctuation">,</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"数组被修改之前，集合第一个元素为：{}"</span><span class="token punctuation">,</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">// 坑2：使用 add、remove 等操作 list 的方法时，</span>
  <span class="token comment" spellcheck="true">// 会报 UnsupportedOperationException 异常</span>
  list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
坑 <span class="token number">1</span>：数组被修改后，会直接影响到新 List 的值。
坑 <span class="token number">2</span>：不能对新 List 进行 add、remove 等操作，否则运行时会报 UnsupportedOperationException 错误。</code></pre>
<p>我们来看下 Arrays.asList 的源码实现，就能知道问题所在了，源码如下图：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Arrays-asList.jpeg" alt="Arrays-asList"></p>
<p>从上图中，我们可以发现，Arrays.asList 方法返回的 List 并不是 java.util.ArrayList，而是自己内部的一个静态类，该静态类直接持有数组的引用，并且没有实现 add、remove 等方法，这些就是坑 1 和 2 的原因。</p>
<ol>
<li>集合 List 转化成数组，我们通常使用 toArray 这个方法，这个方法很危险，稍微不注意，就踩进大坑，我们示例代码如下：</li>
</ol>
<pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testListToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
      <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 下面这行被注释的代码这么写是无法转化成数组的，无参 toArray 返回的是 Object[],</span>
    <span class="token comment" spellcheck="true">// 无法向下转化成 List&lt;Integer>，编译都无法通过</span>
    <span class="token comment" spellcheck="true">// List&lt;Integer> list2 = list.toArray();</span>

    <span class="token comment" spellcheck="true">// 演示有参 toArray 方法，数组大小不够时，得到数组为 null 情况</span>
    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> array0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"toArray 数组大小不够，array0 数组[0] 值是{},数组[1] 值是{},"</span><span class="token punctuation">,</span>array0<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>array0<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 演示数组初始化大小正好，正好转化成数组</span>
    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> array1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"toArray 数组大小正好，array1 数组[3] 值是{}"</span><span class="token punctuation">,</span>array1<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 演示数组初始化大小大于实际所需大小，也可以转化成数组</span>
    Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> array2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"toArray 数组大小多了，array2 数组[3] 值是{}，数组[4] 值是{}"</span><span class="token punctuation">,</span>array2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>array2<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token number">19</span><span class="token operator">:</span><span class="token number">33</span><span class="token operator">:</span><span class="token number">07.687</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO demo<span class="token punctuation">.</span>one<span class="token punctuation">.</span>ArrayListDemo <span class="token operator">-</span> toArray 数组大小不够，array0 数组<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> 值是null<span class="token punctuation">,</span>数组<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> 值是null<span class="token punctuation">,</span>
<span class="token number">19</span><span class="token operator">:</span><span class="token number">33</span><span class="token operator">:</span><span class="token number">07.697</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO demo<span class="token punctuation">.</span>one<span class="token punctuation">.</span>ArrayListDemo <span class="token operator">-</span> toArray 数组大小正好，array1 数组<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> 值是<span class="token number">4</span>
<span class="token number">19</span><span class="token operator">:</span><span class="token number">33</span><span class="token operator">:</span><span class="token number">07.697</span> <span class="token punctuation">[</span>main<span class="token punctuation">]</span> INFO demo<span class="token punctuation">.</span>one<span class="token punctuation">.</span>ArrayListDemo <span class="token operator">-</span> toArray 数组大小多了，array2 数组<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> 值是<span class="token number">4</span>，数组<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> 值是null</code></pre>
<p>toArray 的无参方法，无法强转成具体类型，这个编译的时候，就会有提醒，我们一般都会去使用带有参数的 toArray 方法，这时就有一个坑，如果参数数组的大小不够，这时候返回的数组值竟然是空，上述代码中的 array0 的返回值就体现了这点，但我们去看 toArray 源码，发现源码中返回的是 4 个大小值的数据，返回的并不是空，源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// List 转化成数组</span>
<span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 如果数组长度不够，按照 List 的大小进行拷贝，return 的时候返回的都是正确的数组</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true">// Make a new array of a's runtime type, but my contents:</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 数组长度大于 List 大小的，赋值为 null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">></span> size<span class="token punctuation">)</span>
    a<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
  <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码中，我们丝毫看不出为什么 array0 的元素值为什么是 null，最后我们去看方法的注释，发现是这样子描述的：</p>
<pre class=" language-java"><code class="language-java">If the list fits in the specified array<span class="token punctuation">,</span> it is returned therein<span class="token punctuation">.</span>  Otherwise<span class="token punctuation">,</span> a <span class="token keyword">new</span> <span class="token class-name">array</span> is
 allocated with the runtime type of the specified array and the size of <span class="token keyword">this</span> list。</code></pre>
<p>翻译过来的意思就是说：如果返回的数组大小和申明的数组大小一致，那么就会正常返回，否则，一个新数组就会被分配返回。</p>
<p>所以我们在使用有参 toArray 方法时，申明的数组大小一定要大于等于 List 的大小，如果小于的话，你会得到一个空数组。</p>
<h4 id="2-8-3-总结"><a href="#2-8-3-总结" class="headerlink" title="2.8.3-总结"></a>2.8.3-总结</h4><p>本小节，我们详细描述了集合的线程安全、性能优化和日常工作中一些坑，这些问题我们在工作中经常会碰到，稍不留神就会引发线上故障，面试的时候也经常会通过这些问题，来考察大家的工作经验，所以阅读本章时，建议大家自己动手试一试，加深印象。</p>
<h3 id="2-9-差异对比：集合在-Java-7-和-8-有何不同和改进"><a href="#2-9-差异对比：集合在-Java-7-和-8-有何不同和改进" class="headerlink" title="2.9-差异对比：集合在 Java 7 和 8 有何不同和改进"></a>2.9-差异对比：集合在 Java 7 和 8 有何不同和改进</h3><p>Java 8 在 Java 7 的基础上，做了一些改进和优化，但我们在平时工作中，或者直接升级到 Java 8 的过程中，我们好像无需做任何兼容逻辑，那么 Java 8 底层是如何处理的呢，在改进的同时，是如何优雅兼容 Java 老版本，让使用者无需感知，接下来我们通过对比 Java 7 和 8 的差异，来展示 Java 8 是如何优雅升级的。</p>
<h4 id="2-9-1-通用区别"><a href="#2-9-1-通用区别" class="headerlink" title="2.9.1-通用区别"></a>2.9.1-通用区别</h4><h5 id="1-所有集合都新增了forEach-方法"><a href="#1-所有集合都新增了forEach-方法" class="headerlink" title="1.所有集合都新增了forEach 方法"></a>1.所有集合都新增了forEach 方法</h5><p>List、Set、Map 在 Java 8 版本中都增加了 forEach 的方法，方法的入参是 Consumer，Consumer 是一个函数式接口，可以简单理解成允许一个入参，但没有返回值的函数式接口，我们以 ArrayList 的 forEach 的源码为例，来看下方法是如何实现的 ：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">forEach</span><span class="token punctuation">(</span>Consumer<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 判断非空</span>
  Objects<span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// modCount的原始值被拷贝</span>
  <span class="token keyword">final</span> <span class="token keyword">int</span> expectedModCount <span class="token operator">=</span> modCount<span class="token punctuation">;</span>
  <span class="token keyword">final</span> E<span class="token punctuation">[</span><span class="token punctuation">]</span> elementData <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>elementData<span class="token punctuation">;</span>
  <span class="token keyword">final</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// 每次循环都会判断数组有没有被修改，一旦被修改，停止循环</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> modCount <span class="token operator">==</span> expectedModCount <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 执行循环内容，action 代表我们要干的事情</span>
    action<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 数组如果被修改了，抛异常</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>modCount <span class="token operator">!=</span> expectedModCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentModificationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>从这段源码中，很容易产生两个问题：</p>
<p>1、action.accept 到底是个啥？</p>
<p>action.accept 就是你在 for 循环中要干的事情，你可以进行任何事情，比如我们打印一句话，如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testForEach</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// value 是每次循环的入参，就是 list 中的每个元素</span>
  list<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span> value<span class="token operator">-</span><span class="token operator">></span>log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"当前值为：{}"</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
输出为：
当前值为：<span class="token number">1</span>
当前值为：<span class="token number">3</span>
当前值为：<span class="token number">2</span>
当前值为：<span class="token number">4</span></code></pre>
<p>log.info(“当前值为：{}”,value) 就是我们要干的事情，就是 action。</p>
<p>2.、forEach 方法上打了 @Override 注解，说明该方法是被继承实现的，该方法是被定义在 Iterable 接口上的，Java 7 和 8 的 ArrayList 都实现了该接口，但我们在 Java 7 的 ArrayList 并没有发现有实现该方法，编译器也木有报错，这个主要是因为 Iterable 接口的 forEach 方法被加上了 default 关键字，这个关键字只会出现在接口类中，被该关键字修饰的方法无需强制要求子类继承，但需要自己实现默认实现，我们看下源码：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/Iterable.jpeg" alt="Iterable"></p>
<p>不仅仅是 forEach 这一个方法是这么干的，List、Set、Map 接口中很多新增的方法都是这么干的，通过 default 关键字，可以让 Java 7 的集合子类无需实现 Java 8 中新增的方法。</p>
<p>如果想在接口中新增一个方法，但又不想子类强制实现该方法时，可以给该方法加上 default 关键字，这个在实际工作中，也经常使用到，算是重构的小技巧吧。</p>
<h4 id="2-9-2-List区别"><a href="#2-9-2-List区别" class="headerlink" title="2.9.2-List区别"></a>2.9.2-List区别</h4><h5 id="1-ArrayList"><a href="#1-ArrayList" class="headerlink" title="1.ArrayList"></a>1.ArrayList</h5><p>ArrayList 无参初始化时，Java 7 是直接初始化 10 的大小，Java 8 去掉了这个逻辑，初始化时是空数组，在第一次 add 时才开始按照 10 进行扩容，下图是源码的差异对比图：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayList-78%E5%AF%B9%E6%AF%94.jpeg" alt="ArrayList-78对比"></p>
<p>List 其它方面 java7 和 8 并没有改动。</p>
<h4 id="2-9-3-Map区别"><a href="#2-9-3-Map区别" class="headerlink" title="2.9.3-Map区别"></a>2.9.3-Map区别</h4><h5 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1.HashMap"></a>1.HashMap</h5><ol>
<li>和 ArrayList 一样，Java 8 中 HashMap 在无参构造器中，丢弃了 Java 7 中直接把数组初始化 16 的做法，而是采用在第一次新增的时候，才开始扩容数组大小；</li>
<li>hash 算法计算公式不同，Java 8 的 hash 算法更加简单，代码更加简洁；</li>
<li>Java 8 的 HashMap 增加了红黑树的数据结构，这个是 Java 7 中没有的，Java 7 只有数组 + 链表的结构，Java 8 中提出了数组 + 链表 + 红黑树的结构，一般 key 是 Java 的 API 时，比如说 String 这些 hashcode 实现很好的 API，很少出现链表转化成红黑树的情况，因为 String 这些 API 的 hash 算法够好了，只有当 key 是我们自定义的类，而且我们覆写的 hashcode 算法非常糟糕时，才会真正使用到红黑树，提高我们的检索速度。</li>
</ol>
<p>也是因为 Java 8 新增了红黑树，所以几乎所有操作数组的方法的实现，都发生了变动，比如说 put、remove 等操作，可以说 Java 8 的 HashMap 几乎重写了一遍，所以 Java 7 的很多问题都被 Java 8 解决了，比如扩容时极小概率死锁，丢失数据等等。</p>
<ol>
<li>新增了一些好用的方法，比如 getOrDefault，我们看下源码，非常简单：</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果 key 对应的值不存在，返回期望的默认值 defaultValue</span>
<span class="token keyword">public</span> V <span class="token function">getOrDefault</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> V defaultValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> defaultValue <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>还有 putIfAbsent(K key, V value) 方法，意思是，如果 map 中存在 key 了，那么 value 就不会覆盖，如果不存在 key ，新增成功。</p>
<p>还有 compute 方法，意思是允许我们把 key 和 value 的值进行计算后，再 put 到 map 中，为防止 key 值不存在造成未知错误，map 还提供了 computeIfPresent 方法，表示只有在 key 存在的时候，才执行计算，demo 如下：</p>
<pre class=" language-java"><code class="language-java">  <span class="token annotation punctuation">@Test</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">compute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"compute 之前值为：{}"</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> key <span class="token operator">*</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"compute 之后值为：{}"</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 还原测试值</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 如果为 11 的 key 不存在的话，需要注意 value 为空的情况，下面这行代码就会报空指针</span>
    <span class="token comment" spellcheck="true">//  map.compute(11,(key,value) -> key * value);</span>

    <span class="token comment" spellcheck="true">// 为了防止 key 不存在时导致的未知异常，我们一般有两种办法</span>
    <span class="token comment" spellcheck="true">// 1：自己判断空指针</span>
    map<span class="token punctuation">.</span><span class="token function">compute</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> null <span class="token operator">==</span> value <span class="token operator">?</span> null <span class="token operator">:</span> key <span class="token operator">*</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 2：computeIfPresent 方法里面判断</span>
    map<span class="token punctuation">.</span><span class="token function">computeIfPresent</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> key <span class="token operator">*</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"computeIfPresent 之后值为：{}"</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
结果是：
compute 之前值为：<span class="token number">10</span>
compute 之后值为：<span class="token number">100</span>
computeIfPresent 之后值为：null（这个结果中，可以看出，使用 computeIfPresent 避免了空指针）</code></pre>
<p>上述 Java 8 新增的几种方法非常好用，在实际工作中，可以大大减少我们的代码量，computeIfPresent 的源码就不贴了，有兴趣可以去 github 上面查看，主要的实现原理如下：</p>
<ul>
<li>找到 key 对应的老值，会分别从数组、链表、红黑树中找；</li>
<li>根据 key 和老值进行计算，得到新值；</li>
<li>用新值替换掉老值，可能是普通替换、链表替换或红黑树替换。</li>
</ul>
<h5 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2.LinkedHashMap"></a>2.LinkedHashMap</h5><p>由于 Java 8 的底层数据有变动，导致 HashMap 操作数据的方法几乎重写，也使 LinkedHashMap 的实现名称上有所差异，原理上都相同，我们看下面的图，左边是 Java 7，右边是 Java 8。</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/LinkedHashMap-78%E5%8C%BA%E5%88%AB.jpeg" alt="LinkedHashMap-78区别"></p>
<p>从图中，我们发现 LinkedHashMap 的方法名有所修改，底层的实现逻辑其实都差不多的。</p>
<h4 id="2-9-4-其他区别"><a href="#2-9-4-其他区别" class="headerlink" title="2.9.4-其他区别"></a>2.9.4-其他区别</h4><h5 id="1-Arrays-提供了很多-parallel-开头的方法。"><a href="#1-Arrays-提供了很多-parallel-开头的方法。" class="headerlink" title="1.Arrays 提供了很多 parallel 开头的方法。"></a>1.Arrays 提供了很多 parallel 开头的方法。</h5><p>Java 8 的 Arrays 提供了一些 parallel 开头的方法，这些方法支持并行的计算，在数据量大的时候，会充分利用 CPU ，提高计算效率，比如说 parallelSort 方法，方法底层有判断，只有数据量大于 8192 时，才会真正走并行的实现，在实际的实验中，并行计算的确能够快速的提高计算速度。</p>
<h4 id="2-9-5-面试题"><a href="#2-9-5-面试题" class="headerlink" title="2.9.5-面试题"></a>2.9.5-面试题</h4><h5 id="1-Java-8-在-List、Map-接口上新增了很多方法，为什么-Java-7-中这些接口的实现者不需要强制实现这些方法呢？"><a href="#1-Java-8-在-List、Map-接口上新增了很多方法，为什么-Java-7-中这些接口的实现者不需要强制实现这些方法呢？" class="headerlink" title="1.Java 8 在 List、Map 接口上新增了很多方法，为什么 Java 7 中这些接口的实现者不需要强制实现这些方法呢？"></a>1.Java 8 在 List、Map 接口上新增了很多方法，为什么 Java 7 中这些接口的实现者不需要强制实现这些方法呢？</h5><p>答：主要是因为这些新增的方法被 default 关键字修饰了，default 一旦修饰接口上的方法，我们需要在接口的方法中写默认实现，并且子类无需强制实现这些方法，所以 Java 7 接口的实现者无需感知。</p>
<h5 id="2-Java-8-中有新增很多实用的方法，你在平时工作中有使用过么？"><a href="#2-Java-8-中有新增很多实用的方法，你在平时工作中有使用过么？" class="headerlink" title="2.Java 8 中有新增很多实用的方法，你在平时工作中有使用过么？"></a>2.Java 8 中有新增很多实用的方法，你在平时工作中有使用过么？</h5><p>答：有的，比如说 getOrDefault、putIfAbsent、computeIfPresent 方法等等，具体使用细节参考上文。</p>
<h5 id="3-说说-computeIfPresent-方法的使用姿势？"><a href="#3-说说-computeIfPresent-方法的使用姿势？" class="headerlink" title="3.说说 computeIfPresent 方法的使用姿势？"></a>3.说说 computeIfPresent 方法的使用姿势？</h5><p>答：computeIfPresent 是可以对 key 和 value 进行计算后，把计算的结果重新赋值给 key，并且如果 key 不存在时，不会报空指针，会返回 null 值。</p>
<h5 id="4-Java-8-集合新增了-forEach-方法，和普通的-for-循环有啥不同？"><a href="#4-Java-8-集合新增了-forEach-方法，和普通的-for-循环有啥不同？" class="headerlink" title="4.Java 8 集合新增了 forEach 方法，和普通的 for 循环有啥不同？"></a>4.Java 8 集合新增了 forEach 方法，和普通的 for 循环有啥不同？</h5><p>答：新增的 forEach 方法的入参是函数式的接口，比如说 Consumer 和 BiConsumer，这样子做的好处就是封装了 for 循环的代码，让使用者只需关注实现每次循环的业务逻辑，简化了重复的 for 循环代码，使代码更加简洁，普通的 for 循环，每次都需要写重复的 for 循环代码，forEach 把这种重复的计算逻辑吃掉了，使用起来更加方便。</p>
<h5 id="5-HashMap-8-和-7-有啥区别？"><a href="#5-HashMap-8-和-7-有啥区别？" class="headerlink" title="5.HashMap 8 和 7 有啥区别？"></a>5.HashMap 8 和 7 有啥区别？</h5><p>答：HashMap 8 和 7 的差别太大了，新增了红黑树，修改了底层数据逻辑，修改了 hash 算法，几乎所有底层数组变动的方法都重写了一遍，可以说 Java 8 的 HashMap 几乎重新了一遍。</p>
<h4 id="2-9-6-总结"><a href="#2-9-6-总结" class="headerlink" title="2.9.6-总结"></a>2.9.6-总结</h4><p>总体来说，List 方面是小改动，HashMap 几乎重写了一套，所有的集合都新增了函数式的方法，比如说 forEach，也新增了很多好用的函数，比如说 getOrDefault，这些函数可以大大减少我们的代码量，让我们把关注点聚焦在业务逻辑的实现上，这其实是一种思想，把繁琐重复的计算逻辑抽取出来，从计算逻辑中扩展出业务逻辑的口子，让使用者只专心关注业务逻辑的实现即可。</p>
<p>想要了解更多差异，也可直接前往 JDK 8 新特性查看，地址为：<a href="http://openjdk.java.net/projects/jdk8/features#103。" target="_blank" rel="noopener">http://openjdk.java.net/projects/jdk8/features#103。</a></p>
<h3 id="2-10-简化工作：Guava-Lists-Maps-实际工作运用和源码"><a href="#2-10-简化工作：Guava-Lists-Maps-实际工作运用和源码" class="headerlink" title="2.10-简化工作：Guava Lists Maps 实际工作运用和源码"></a>2.10-简化工作：Guava Lists Maps 实际工作运用和源码</h3><p>在日常工作中，我们经常会使用一些三方的 API 来简化我们的工作，Guava 就是其中一种，Guava 是 Google 开源的技术框架，使用率高，社区活跃度也很高。</p>
<p>本小节我们从工作中对 Guava 集合的使用入手，然后深入的看下其底层的实现，最后总结其设计思想，感兴趣的同学也可以下载源码学习，GitHub 地址：<a href="https://github.com/google/guava，源码中" target="_blank" rel="noopener">https://github.com/google/guava，源码中</a> guava 的文件夹为其源码。</p>
<h4 id="2-10-1-运用工厂模式进行初始化"><a href="#2-10-1-运用工厂模式进行初始化" class="headerlink" title="2.10.1-运用工厂模式进行初始化"></a>2.10.1-运用工厂模式进行初始化</h4><p>在集合类初始化方面，Guava 比 Java 原生的 API 更加好用，还发明了很多新的功能，比如说在 JDK 7 之前，我们新建集合类时，声明和初始化都必须写上泛型说明，像这样：<code>List&lt;泛型&gt; list = new ArrayList&lt;泛型&gt;();</code> ， JDK 7 之后有所改变，我们只需要在声明处写上泛型说明，像这样：<code>List&lt;泛型&gt; list = new ArrayList&lt;&gt;();</code>。</p>
<p>Guava 提供了更加方便的使用姿势，采用了工厂模式，把集合创建的逻辑交给了工厂，开发者无需关注工厂底层是如何创建的，只需要关心，工厂能产生什么，代码于是变成了这样：<code>List&lt;泛型&gt; list = Lists.newArrayList();</code>，Lists 就是 Guava 提供出来的，方便操作 List 的工具类。</p>
<p>这种写法其实就是一种简单的工厂模式，只需要定义好工厂的入参和出参，就能对外隐藏其内部的创建逻辑，提供更加方便的使用体验。</p>
<p>当然除了 Lists，Guava 还提供了很多其他实用工具，如 Maps、Sets，接下来我们分别来看下这些常用工具的使用和原理。</p>
<h4 id="2-10-2-Lists"><a href="#2-10-2-Lists" class="headerlink" title="2.10.2-Lists"></a>2.10.2-Lists</h4><h5 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h5><p>Lists 最大的功能是能帮助我们进行 List 的初始化，比如我们刚说的 newArrayList 这种：</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> ArrayList<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 这种底层是帮助我们写好了泛型，E 代表泛型，表示当前返回的泛型类型和声明的一致即可，在编译的时候，会把泛型 E 转化成我们声明的 String。</span></code></pre>
<p>如果你清楚 List 的大小，我们也可以这样做：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 可以预估 list 的大小为 20</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayListWithCapacity</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 不太肯定 list 大小是多少，但期望是大小是 20 上下。</span>
List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayListWithExpectedSize</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>newArrayListWithCapacity(20) 方法内部实现是：<code>new ArrayList&lt;&gt;(20);</code>，而 newArrayListWithExpectedSize 方法内部实现是对 List 大小有一个计算公式的，计算公式为：<code>5L + arraySize + (arraySize / 10)</code> ，arraySize 表示传进来的值，公式简化下就是 5 + 11/10 * arraySize，因为这个方法表示期望的大小，所以这里取的约是期望值的十分之十一，比传进来的值约大十分之一，所以根据 20 最终计算出来的值是 27。</p>
<p>Lists 在初始化的时候，还支持传迭代器的入参（只适合小数据量的迭代器的入参），源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> ArrayList<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">newArrayList</span><span class="token punctuation">(</span>Iterator<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> elements<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ArrayList<span class="token operator">&lt;</span>E<span class="token operator">></span> list <span class="token operator">=</span> <span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// addAll 方法底层其实通过迭代器进行 for 循环添加</span>
  Iterators<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> elements<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> list<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从 Lists 对 List 初始化进行包装的底层源码来看，底层源码非常简单的，但我们还是愿意使用这种方式的包装，主要是因为这种工厂模式的包装，使我们的使用姿势更加优雅，使用起来更加方便。</p>
<h5 id="2-分组和反转排序"><a href="#2-分组和反转排序" class="headerlink" title="2.分组和反转排序"></a>2.分组和反转排序</h5><p>除了初始化之外，Lists 还提供了两个比较实用的功能，分组和反转排序功能，我们分别来演示一下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 演示反转排序</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"30"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"40"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"反转之前："</span><span class="token operator">+</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"反转之后："</span><span class="token operator">+</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 打印出来的结果为：</span>
反转之前：<span class="token punctuation">[</span><span class="token string">"10"</span><span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">,</span><span class="token string">"30"</span><span class="token punctuation">,</span><span class="token string">"40"</span><span class="token punctuation">]</span>
反转之后：<span class="token punctuation">[</span><span class="token string">"40"</span><span class="token punctuation">,</span><span class="token string">"30"</span><span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">,</span><span class="token string">"10"</span><span class="token punctuation">]</span></code></pre>
<p>reverse 方法底层实现非常巧妙，底层覆写了 List 原生的 get(index) 方法，会把传进来的 index 进行 (size - 1) - index 的计算，使计算得到的索引位置和 index 位置正好相反，这样当我们 get 时，数组索引位置的 index 已经是相反的位置了，达到了反转排序的效果，其实底层并没有进行反转排序，只是在计算相反的索引位置，通过计算相反的索引位置这样简单的设计，得到了反转排序的效果，很精妙。</p>
<p>在工作中，有时候我们需要把一个大的 list 进行切分，然后再把每份丢给线程池去运行，最后将每份运行的结果汇总，Lists 工具类就提供了一个对 list 进行切分分组的方法，演示 demo 如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 分组</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testPartition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"20"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"30"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"40"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"分组之前："</span><span class="token operator">+</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> list2 <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"分组之后："</span><span class="token operator">+</span>JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
输出结果为：
分组之前：<span class="token punctuation">[</span><span class="token string">"10"</span><span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">,</span><span class="token string">"30"</span><span class="token punctuation">,</span><span class="token string">"40"</span><span class="token punctuation">]</span>
分组之后：<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"10"</span><span class="token punctuation">,</span><span class="token string">"20"</span><span class="token punctuation">,</span><span class="token string">"30"</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"40"</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre>
<p>partition 方法的第二个参数的意思，你想让分组后的 List 包含几个元素，这个方法的底层实现其实就是 subList 方法。</p>
<p>有一点需要我们注意的是这两个方法返回的 List 并不是 ArrayList，是自定义的 List，所以对于 ArrayList 的有些功能可能并不支持，使用的时候最好能看下源码，看看底层有无支持。</p>
<h5 id="3-小结-3"><a href="#3-小结-3" class="headerlink" title="3.小结"></a>3.小结</h5><p>Lists 上述的方法大大的方便了我们进行开发，简化了使用姿势，但其内部实现却非常简单巧妙，比如说 reverse 方法可以输出相反排序的 List，但底层并没有实现排序，只是计算了索引位置的相反值而已，这点值得我们学习。</p>
<h4 id="2-10-3-Maps"><a href="#2-10-3-Maps" class="headerlink" title="2.10.3-Maps"></a>2.10.3-Maps</h4><h5 id="1-初始化-1"><a href="#1-初始化-1" class="headerlink" title="1.初始化"></a>1.初始化</h5><p>Maps 也是有着各种初始化 Map 的各种方法，原理不说了，和 Lists 类似，我们演示下如何使用：</p>
<pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> hashMap <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> linkedHashMap <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newLinkedHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 这里 Map 的初始化大小公式和 HashSet 初始化公式类似，还记得 HashSet 初始化 HashMap 时，经典的计算初始大小的公式么：取最大值（期望的值 / 0.75 + 1，默认值 16），newHashMapWithExpectedSize 方法底层也是这么算的初始化大小的</span>
Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> withExpectedSizeHashMap <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMapWithExpectedSize</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h5 id="2-difference"><a href="#2-difference" class="headerlink" title="2.difference"></a>2.difference</h5><p>Maps 提供了一个特别有趣也很实用的方法：difference，此方法的目的是比较两个 Map 的差异，入参就是两个 Map，比较之后能够返回四种差异：</p>
<ol>
<li>左边 Map 独有 key。</li>
<li>右边 Map 独有 key。</li>
<li>左右边 Map 都有 key，并且 value 相等。</li>
<li>左右边 Map 都有 key，但是 value 不等。</li>
</ol>
<p>我们用代码来演示一下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ImmutableMap.of 也是 Guava 提供初始化 Map 的方法，入参格式为 k1,v1,k2,v2,k3,v3……</span>
Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> leftMap <span class="token operator">=</span> ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> rightMap <span class="token operator">=</span> ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"2"</span><span class="token punctuation">,</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"30"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
MapDifference difference <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">difference</span><span class="token punctuation">(</span>leftMap<span class="token punctuation">,</span> rightMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"左边 map 独有 key：{}"</span><span class="token punctuation">,</span>difference<span class="token punctuation">.</span><span class="token function">entriesOnlyOnLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"右边 map 独有 key：{}"</span><span class="token punctuation">,</span>difference<span class="token punctuation">.</span><span class="token function">entriesOnlyOnRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"左右边 map 都有 key，并且 value 相等：{}"</span><span class="token punctuation">,</span>difference<span class="token punctuation">.</span><span class="token function">entriesInCommon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"左右边 map 都有 key，但 value 不等：{}"</span><span class="token punctuation">,</span>difference<span class="token punctuation">.</span><span class="token function">entriesDiffering</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
最后打印结果为：
左边 map 独有 key：<span class="token punctuation">{</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">}</span>
右边 map 独有 key：<span class="token punctuation">{</span><span class="token number">4</span><span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">}</span>
左右边 map 都有 key，并且 value 相等：<span class="token punctuation">{</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">}</span>
左右边 map 都有 key，但 value 不等：<span class="token punctuation">{</span><span class="token number">3</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre>
<p>从这个 demo 我们可以看到此方法的强大威力，我们在工作中经常遇到 Map 或者 List 间比较差异的任务，我们就可以直接使用该方法进行对比，List 可以先转化成 Map。</p>
<p>而且 difference 底层的实现也算是最优的实现了，只需要循环一遍，就可得到上述四种差异结果，源码解析如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对比两个 map 的差异</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">doDifference</span><span class="token punctuation">(</span>
    Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> left<span class="token punctuation">,</span>
    Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> right<span class="token punctuation">,</span>
    Equivalence<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> V<span class="token operator">></span> valueEquivalence<span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// key 只在左边 map 出现</span>
    Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> onlyOnLeft<span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// key 只在右边 map 出现，调用 doDifference 方法前已经包含了全部右边的值</span>
    Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> onlyOnRight<span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// key 在左右 map 中都出现过，并且 value 都相等</span>
    Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> onBoth<span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// key 在左右 map 中都出现过，但 value 不等</span>
    Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> MapDifference<span class="token punctuation">.</span>ValueDifference<span class="token operator">&lt;</span>V<span class="token operator">>></span> differences<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">// 以左边 map 为基准进行循环</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> entry <span class="token operator">:</span> left<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    K leftKey <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    V leftValue <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 右边 map 包含左边的 key</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// onlyOnRight 已经包含全部右边的值 所以需要删除当前 key</span>
      V rightValue <span class="token operator">=</span> onlyOnRight<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// key 相等，并且 value 值也相等</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>valueEquivalence<span class="token punctuation">.</span><span class="token function">equivalent</span><span class="token punctuation">(</span>leftValue<span class="token punctuation">,</span> rightValue<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        onBoth<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">,</span> leftValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// key 相等，但 value 值不等</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        differences<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">,</span> ValueDifferenceImpl<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>leftValue<span class="token punctuation">,</span> rightValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 右边 map 不包含左边的 key，就是左边 map 独有的 key</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      onlyOnLeft<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>leftKey<span class="token punctuation">,</span> leftValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这是一种比较优秀的，快速比对的算法，可以好好看下上面的源码，然后把这种算法背下来，或者自己再次实现一次。</p>
<p>Sets 的使用方式和 Lists 和 Maps 很类似，没有太大的亮点，我们就不说了。</p>
<h4 id="2-10-4-总结"><a href="#2-10-4-总结" class="headerlink" title="2.10.4-总结"></a>2.10.4-总结</h4><p>这一小节主要都是实战内容，在实际工作中可以用起来。</p>
<p>在 Guava 对集合的设计中，有两个大点是非常值得我们学习的：</p>
<ol>
<li>Lists、Maps 的出现给我们提供了更方便的使用姿势和方法，我们在实际工作中，如果碰到特别繁琐，或者特别难用的 API，我们也可以进行一些包装，使更好用，这个是属于在解决目前的痛点的问题上进行创新，是非常值得提倡的一件事情，往往可以帮助你拿到更好的绩效。</li>
<li>如果有人问你，List 或者 Map 高效的差异排序算法，完全可以参考 Maps.difference 的内部实现，该方法只使用了一次循环，就可得到所有的相同或不同结果，这种算法在我们工作中也经常被使用。</li>
</ol>
<p>了解更多，可以直接前往 Guava 的代码库查看：<a href="https://github.com/google/guava" target="_blank" rel="noopener">https://github.com/google/guava</a></p>
<h2 id="3-并发集合类"><a href="#3-并发集合类" class="headerlink" title="3-并发集合类"></a>3-并发集合类</h2><h3 id="3-1-CopyOnWriteArrayList-源码解析和设计思路"><a href="#3-1-CopyOnWriteArrayList-源码解析和设计思路" class="headerlink" title="3.1-CopyOnWriteArrayList 源码解析和设计思路"></a>3.1-CopyOnWriteArrayList 源码解析和设计思路</h3><p>在 ArrayList 的类注释上，JDK 就提醒了我们，如果要把 ArrayList 作为共享变量的话，是线程不安全的，推荐我们自己加锁或者使用 Collections.synchronizedList 方法，其实 JDK 还提供了另外一种线程安全的 List，叫做 CopyOnWriteArrayList，这个 List 具有以下特征：</p>
<ol>
<li>线程安全的，多线程环境下可以直接使用，无需加锁；</li>
<li>通过锁 + 数组拷贝 + volatile 关键字保证了线程安全；</li>
<li>每次数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作成功之后再赋值回去。</li>
</ol>
<h4 id="3-1-1-整体架构"><a href="#3-1-1-整体架构" class="headerlink" title="3.1.1-整体架构"></a>3.1.1-整体架构</h4><p>从整体架构上来说，CopyOnWriteArrayList 数据结构和 ArrayList 是一致的，底层是个数组，只不过 CopyOnWriteArrayList 在对数组进行操作的时候，基本会分四步走：</p>
<ol>
<li>加锁；</li>
<li>从原数组中拷贝出新数组；</li>
<li>在新数组上进行操作，并把新数组赋值给数组容器；</li>
<li>解锁。</li>
</ol>
<p>除了加锁之外，CopyOnWriteArrayList 的底层数组还被 volatile 关键字修饰，意思是一旦数组被修改，其它线程立马能够感知到，代码如下：</p>
<p><code>private transient volatile Object[] array;</code></p>
<p>整体上来说，CopyOnWriteArrayList 就是利用锁 + 数组拷贝 + volatile 关键字保证了 List 的线程安全。</p>
<h5 id="1-类注释-2"><a href="#1-类注释-2" class="headerlink" title="1.类注释"></a>1.类注释</h5><p>我们看看从 CopyOnWriteArrayList 的类注释上能得到哪些信息：</p>
<ol>
<li>所有的操作都是线程安全的，因为操作都是在新拷贝数组上进行的；</li>
<li>数组的拷贝虽然有一定的成本，但往往比一般的替代方案效率高；</li>
<li>迭代过程中，不会影响到原来的数组，也不会抛出 ConcurrentModificationException 异常。</li>
</ol>
<p>接着我们来看下 CopyOnWriteArrayList 的核心方法源码。</p>
<h4 id="3-1-2-新增"><a href="#3-1-2-新增" class="headerlink" title="3.1.2-新增"></a>3.1.2-新增</h4><p>新增有很多种情况，比如说：新增到数组尾部、新增到数组某一个索引位置、批量新增等等，操作的思路还是我们开头说的四步，我们拿新增到数组尾部的方法举例，来看看底层源码的实现：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 添加元素到数组尾部</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 加锁</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 得到所有的原数组</span>
        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 拷贝到新数组里面，新数组的长度是 + 1 的，因为新增会多一个元素</span>
        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 在新数组中进行赋值，新元素直接放在数组的尾部</span>
        newElements<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 替换掉原来的数组</span>
        <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// finally 里面释放锁，保证即使 try 发生了异常，仍然能够释放锁   </span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码中，我们发现整个 add 过程都是在持有锁的状态下进行的，通过加锁，来保证同一时刻只能有一个线程能够对同一个数组进行 add 操作。</p>
<p>除了加锁之外，还会从老数组中创建出一个新数组，然后把老数组的值拷贝到新数组上，这时候就有一个问题：都已经加锁了，为什么需要拷贝数组，而不是在原来数组上面进行操作呢，原因主要为：</p>
<ol>
<li>volatile 关键字修饰的是数组，如果我们简单的在原来数组上修改其中某几个元素的值，是无法触发可见性的，我们必须通过修改数组的内存地址才行，也就说要对数组进行重新赋值才行。</li>
<li>在新的数组上进行拷贝，对老数组没有任何影响，只有新数组完全拷贝完成之后，外部才能访问到，降低了在赋值过程中，老数组数据变动的影响。</li>
</ol>
<p>简单 add 操作是直接添加到数组的尾部，接着我们来看下指定位置添加元素的关键源码（部分源码）：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// len：数组的长度、index：插入的位置</span>
<span class="token keyword">int</span> numMoved <span class="token operator">=</span> len <span class="token operator">-</span> index<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 如果要插入的位置正好等于数组的末尾，直接拷贝数组即可</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    newElements <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token comment" spellcheck="true">// 如果要插入的位置在数组的中间，就需要拷贝 2 次</span>
<span class="token comment" spellcheck="true">// 第一次从 0 拷贝到 index。</span>
<span class="token comment" spellcheck="true">// 第二次从 index+1 拷贝到末尾。</span>
    newElements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index<span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// index 索引位置的值是空的，直接赋值即可。</span>
newElements<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 把新数组的值赋值给数组的容器中</span>
<span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>从源码中可以看到，当插入的位置正好处于末尾时，只需要拷贝一次，当插入的位置处于中间时，此时我们会把原数组一分为二，进行两次拷贝操作。</p>
<p>最后还有个批量新增操作，源码我们就不贴了，底层也是拷贝数组的操作。</p>
<h5 id="1-小结"><a href="#1-小结" class="headerlink" title="1.小结"></a>1.小结</h5><p>从 add 系列方法可以看出，CopyOnWriteArrayList 通过加锁 + 数组拷贝+ volatile 来保证了线程安全，每一个要素都有着其独特的含义：</p>
<ol>
<li>加锁：保证同一时刻数组只能被一个线程操作；</li>
<li>数组拷贝：保证数组的内存地址被修改，修改后触发 volatile 的可见性，其它线程可以立马知道数组已经被修改；</li>
<li>volatile：值被修改后，其它线程能够立马感知最新值。</li>
</ol>
<p>3 个要素缺一不可，比如说我们只使用 1 和 3 ，去掉 2，这样当我们修改数组中某个值时，并不会触发 volatile 的可见特性的，只有当数组内存地址被修改后，才能触发把最新值通知给其他线程的特性。</p>
<h4 id="3-1-3-删除"><a href="#3-1-3-删除" class="headerlink" title="3.1.3-删除"></a>3.1.3-删除</h4><p>接着我们来看下指定数组索引位置删除的源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 删除某个索引位置的数据</span>
<span class="token keyword">public</span> E <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 加锁</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 先得到老值</span>
        E oldValue <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> len <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果要删除的数据正好是数组的尾部，直接删除</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">setArray</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 如果删除的数据在数组的中间，分三步走</span>
            <span class="token comment" spellcheck="true">// 1. 设置新数组的长度减一，因为是减少一个元素</span>
            <span class="token comment" spellcheck="true">// 2. 从 0 拷贝到数组新位置</span>
            <span class="token comment" spellcheck="true">// 3. 从新位置拷贝到数组尾部</span>
            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> newElements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elements<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> newElements<span class="token punctuation">,</span> index<span class="token punctuation">,</span>
                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">setArray</span><span class="token punctuation">(</span>newElements<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>步骤分为三步：</p>
<ol>
<li>加锁；</li>
<li>判断删除索引的位置，从而进行不同策略的拷贝；</li>
<li>解锁。</li>
</ol>
<p>代码整体的结构风格也比较统一：锁 + try finally +数组拷贝，锁被 final 修饰的，保证了在加锁过程中，锁的内存地址肯定不会被修改，finally 保证锁一定能够被释放，数组拷贝是为了删除其中某个位置的元素。</p>
<h4 id="3-1-4-批量删除"><a href="#3-1-4-批量删除" class="headerlink" title="3.1.4-批量删除"></a>3.1.4-批量删除</h4><p>数组的批量删除很有意思，接下来我们来看下 CopyOnWriteArrayList 的批量删除的实现过程：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 批量删除包含在 c 中的元素</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements <span class="token operator">=</span> <span class="token function">getArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> len <span class="token operator">=</span> elements<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 说明数组有值，数组无值直接返回 false</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// newlen 表示新数组的索引位置，新数组中存在不包含在 c 中的元素</span>
            <span class="token keyword">int</span> newlen <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            Object<span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 循环，把不包含在 c 里面的元素，放到新数组中</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                Object element <span class="token operator">=</span> elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 不包含在 c 中的元素，从 0 开始放到新数组中</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>c<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">)</span>
                    temp<span class="token punctuation">[</span>newlen<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 拷贝新数组，变相的删除了不包含在 c 中的元素</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>newlen <span class="token operator">!=</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">setArray</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> newlen<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码中，我们可以看到，我们并不会直接对数组中的元素进行挨个删除，而是先对数组中的值进行循环判断，把我们不需要删除的数据放到临时数组中，最后临时数组中的数据就是我们不需要删除的数据。</p>
<p>不知道大家有木有似曾相识的感觉，ArrayList 的批量删除的思想也是和这个类似的，所以我们在需要删除多个元素的时候，最好都使用这种批量删除的思想，而不是采用在 for 循环中使用单个删除的方法，单个删除的话，在每次删除的时候都会进行一次数组拷贝(删除最后一个元素时不会拷贝)，很消耗性能，也耗时，会导致加锁时间太长，并发大的情况下，会造成大量请求在等待锁，这也会占用一定的内存。</p>
<h4 id="3-1-5-其他方法"><a href="#3-1-5-其他方法" class="headerlink" title="3.1.5-其他方法"></a>3.1.5-其他方法</h4><h5 id="1-indexOf"><a href="#1-indexOf" class="headerlink" title="1.indexOf"></a>1.indexOf</h5><p>indexOf 方法的主要用处是查找元素在数组中的下标位置，如果元素存在就返回元素的下标位置，元素不存在的话返回 -1，不但支持 null 值的搜索，还支持正向和反向的查找，我们以正向查找为例，通过源码来说明一下其底层的实现方式：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// o：我们需要搜索的元素</span>
<span class="token comment" spellcheck="true">// elements：我们搜索的目标数组</span>
<span class="token comment" spellcheck="true">// index：搜索的开始位置</span>
<span class="token comment" spellcheck="true">// fence：搜索的结束位置</span>
<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">,</span>
                           <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> fence<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 支持对 null 的搜索</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fence<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// 找到第一个 null 值，返回下标索引的位置</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 通过 equals 方法来判断元素是否相等</span>
        <span class="token comment" spellcheck="true">// 如果相等，返回元素的下标位置</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fence<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elements<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>indexOf 方法在 CopyOnWriteArrayList 内部使用也比较广泛，比如在判断元素是否存在时（contains），在删除元素方法中校验元素是否存在时，都会使用到 indexOf 方法，indexOf 方法通过一次 for 循环来查找元素，我们在调用此方法时，需要注意如果找不到元素时，返回的是 -1，所以有可能我们会对这个特殊值进行判断。</p>
<h5 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2.迭代"></a>2.迭代</h5><p>在 CopyOnWriteArrayList 类注释中，明确说明了，在其迭代过程中，即使数组的原值被改变，也不会抛出 ConcurrentModificationException 异常，其根源在于数组的每次变动，都会生成新的数组，不会影响老数组，这样的话，迭代过程中，根本就不会发生迭代数组的变动，我们截几个图说明一下：</p>
<ol>
<li><p>迭代是直接持有原有数组的引用，也就是说迭代过程中，一旦原有数组的值内存地址发生变化，必然会影响到迭代过程，下图源码演示的是 CopyOnWriteArrayList 的迭代方法，我们可以看到迭代器是直接持有原数组的引用：</p>
<p>![CopyOnWriteArrayList 的迭代方法](CopyOnWriteArrayList 的迭代方法.jpeg)</p>
</li>
<li><p>我们写了一个 demo，在 CopyOnWriteArrayList 迭代之后，往 CopyOnWriteArrayList 里面新增值，从下图中可以看到在 CopyOnWriteArrayList 迭代之前，数组的内存地址是 962，请记住这个数字：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/testIterator.jpeg" alt="testIterator"></p>
</li>
<li><p>CopyOnWriteArrayList 迭代之后，我们使用 add(“50”) 代码给数组新增一个数据后，数组内存地址发生了变化，内存地址从原来的 962 变成了 968，这是因为 CopyOnWriteArrayList 的 add 操作，会生成新的数组，所以数组的内存地址发生了变化：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/testIterator2.jpeg" alt="testIterator2"></p>
</li>
<li><p>迭代继续进行时，我们发现迭代器中的地址仍然是迭代之前引用的地址，是 962，而不是新的数组的内存地址：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/testIterator3.jpeg" alt="testIterator3"></p>
</li>
</ol>
<p>从上面 4 张截图，我们可以得到迭代过程中，即使 CopyOnWriteArrayList 的结构发生变动了，也不会抛出 ConcurrentModificationException 异常的原因：CopyOnWriteArrayList 迭代持有的是老数组的引用，而 CopyOnWriteArrayList 每次的数据变动，都会产生新的数组，对老数组的值不会产生影响，所以迭代也可以正常进行。</p>
<h4 id="3-1-6-总结"><a href="#3-1-6-总结" class="headerlink" title="3.1.6-总结"></a>3.1.6-总结</h4><p>当我们需要在线程不安全场景下使用 List 时，建议使用 CopyOnWriteArrayList，CopyOnWriteArrayList 通过锁 + 数组拷贝 + volatile 之间的相互配合，实现了 List 的线程安全，我们抛弃 Java 的这种实现，如果让我们自己实现，你又将如何实现呢？</p>
<h3 id="3-2-ConcurrentHashMap-源码解析和设计思路"><a href="#3-2-ConcurrentHashMap-源码解析和设计思路" class="headerlink" title="3.2-ConcurrentHashMap 源码解析和设计思路"></a>3.2-ConcurrentHashMap 源码解析和设计思路</h3><p>当我们碰到线程不安全场景下，需要使用 Map 的时候，我们第一个想到的 API 估计就是 ConcurrentHashMap，ConcurrentHashMap 内部封装了锁和各种数据结构来保证访问 Map 是线程安全的，接下来我们一一来看下，和 HashMap 相比，多了哪些数据结构，又是如何保证线程安全的。</p>
<h4 id="3-2-1-类注释"><a href="#3-2-1-类注释" class="headerlink" title="3.2.1-类注释"></a>3.2.1-类注释</h4><p>我们从类注释上大概可以得到如下信息：</p>
<ol>
<li>所有的操作都是线程安全的，我们在使用时，无需再加锁；</li>
<li>多个线程同时进行 put、remove 等操作时并不会阻塞，可以同时进行，和 HashTable 不同，HashTable 在操作时，会锁住整个 Map；</li>
<li>迭代过程中，即使 Map 结构被修改，也不会抛 ConcurrentModificationException 异常；</li>
<li>除了数组 + 链表 + 红黑树的基本结构外，新增了转移节点，是为了保证扩容时的线程安全的节点；</li>
<li>提供了很多 Stream 流式方法，比如说：forEach、search、reduce 等等。</li>
</ol>
<p>从类注释中，我们可以看出 ConcurrentHashMap 和 HashMap 相比，新增了转移节点的数据结构，至于底层如何实现线程安全，转移节点的具体细节，暂且看不出来，接下来我们细看源码。</p>
<h4 id="3-2-2-结构"><a href="#3-2-2-结构" class="headerlink" title="3.2.2-结构"></a>3.2.2-结构</h4><p>虽然 ConcurrentHashMap 的底层数据结构，和方法的实现细节和 HashMap 大体一致，但两者在类结构上却没有任何关联，我们看下 ConcurrentHashMap 的类图：</p>
<p>![ConcurrentHashMap 的类图](ConcurrentHashMap 的类图.jpeg)</p>
<p>看 ConcurrentHashMap 源码，我们会发现很多方法和代码和 HashMap 很相似，有的同学可能会问，为什么不继承 HashMap 呢？继承的确是个好办法，但尴尬的是，ConcurrentHashMap 都是在方法中间进行一些加锁操作，也就是说加锁把方法切割了，继承就很难解决这个问题。</p>
<p>ConcurrentHashMap 和 HashMap 两者的相同之处：</p>
<ol>
<li>数组、链表结构几乎相同，所以底层对数据结构的操作思路是相同的（只是思路相同，底层实现不同）；</li>
<li>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以大多数的方法也都是相同的，HashMap 有的方法，ConcurrentHashMap 几乎都有，所以当我们需要从 HashMap 切换到 ConcurrentHashMap 时，无需关心两者之间的兼容问题。</li>
</ol>
<p>不同之处：</p>
<ol>
<li>红黑树结构略有不同，HashMap 的红黑树中的节点叫做 TreeNode，TreeNode 不仅仅有属性，还维护着红黑树的结构，比如说查找，新增等等；ConcurrentHashMap 中红黑树被拆分成两块，TreeNode 仅仅维护的属性和查找功能，新增了 TreeBin，来维护红黑树结构，并负责根节点的加锁和解锁；</li>
<li>新增 ForwardingNode （转移）节点，扩容的时候会使用到，通过使用该节点，来保证扩容时的线程安全。</li>
</ol>
<h4 id="3-2-3-put"><a href="#3-2-3-put" class="headerlink" title="3.2.3-put"></a>3.2.3-put</h4><p>ConcurrentHashMap 在 put 方法上的整体思路和 HashMap 相同，但在线程安全方面写了很多保障的代码，我们先来看下大体思路：</p>
<ol>
<li>如果数组为空，初始化，初始化完成之后，走 2；</li>
<li>计算当前槽点有没有值，没有值的话，cas 创建，失败继续自旋（for 死循环），直到成功，槽点有值的话，走 3；</li>
<li>如果槽点是转移节点(正在扩容)，就会一直自旋等待扩容完成之后再新增，不是转移节点走 4；</li>
<li>槽点有值的，先锁定当前槽点，保证其余线程不能操作，如果是链表，新增值到链表的尾部，如果是红黑树，使用红黑树新增的方法新增；</li>
<li>新增完成之后 check 需不需要扩容，需要的话去扩容。</li>
</ol>
<p>具体源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">||</span> value <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//计算hash</span>
    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fh<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//table是空的，进行初始化</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            tab <span class="token operator">=</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果当前索引位置没有值，直接创建</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//cas 在 i 位置创建新的元素，当 i 位置是空时，即能创建成功，结束for自循，否则继续自旋</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span>
                         <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// no lock when adding to empty bin</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//如果当前槽点是转移节点，表示该槽点正在扩容，就会一直等待扩容完成</span>
        <span class="token comment" spellcheck="true">//转移节点的 hash 值是固定的，都是 MOVED</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>
            tab <span class="token operator">=</span> <span class="token function">helpTransfer</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//槽点上有值的</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            V oldVal <span class="token operator">=</span> null<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//锁定当前槽点，其余线程不能操作，保证了安全</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//这里再次判断 i 索引位置的数据没有被修改</span>
                <span class="token comment" spellcheck="true">//binCount 被赋值的话，说明走到了修改表的过程里面</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">//链表</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            K ek<span class="token punctuation">;</span>
                            <span class="token comment" spellcheck="true">//值有的话，直接返回</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
                                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>
                                 <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                                    e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>
                            <span class="token comment" spellcheck="true">//把新增的元素赋值到链表的最后，退出自旋</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>
                                                          value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                                <span class="token keyword">break</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment" spellcheck="true">//红黑树，这里没有使用 TreeNode,使用的是 TreeBin，TreeNode 只是红黑树的一个节点</span>
                    <span class="token comment" spellcheck="true">//TreeBin 持有红黑树的引用，并且会对其加锁，保证其操作的线程安全</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span>
                        binCount <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                        <span class="token comment" spellcheck="true">//满足if的话，把老的值给oldVal</span>
                        <span class="token comment" spellcheck="true">//在putTreeVal方法里面，在给红黑树重新着色旋转的时候</span>
                        <span class="token comment" spellcheck="true">//会锁住红黑树的根节点</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeBin<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span>
                                                       value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            oldVal <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
                                p<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//binCount不为空，并且 oldVal 有值的情况，说明已经新增成功了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 链表是否需要转化成红黑树</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD<span class="token punctuation">)</span>
                    <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVal <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                    <span class="token keyword">return</span> oldVal<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">//这一步几乎走不到。槽点已经上锁，只有在红黑树或者链表新增失败的时候</span>
                <span class="token comment" spellcheck="true">//才会走到这里，这两者新增都是自旋的，几乎不会失败</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">//check 容器是否需要扩容，如果需要去扩容，调用 transfer 方法去扩容</span>
    <span class="token comment" spellcheck="true">//如果已经在扩容中了，check有无完成</span>
    <span class="token function">addCount</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> binCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>源码中都有非常详细的注释，就不解释了，我们重点说一下，ConcurrentHashMap 在 put 过程中，采用了哪些手段来保证线程安全。</p>
<h5 id="1-数组初始化时的线程安全"><a href="#1-数组初始化时的线程安全" class="headerlink" title="1.数组初始化时的线程安全"></a>1.数组初始化时的线程安全</h5><p>数组初始化时，首先通过自旋来保证一定可以初始化成功，然后通过 CAS 设置 SIZECTL 变量的值，来保证同一时刻只能有一个线程对数组进行初始化，CAS 成功之后，还会再次判断当前数组是否已经初始化完成，如果已经初始化完成，就不会再次初始化，通过自旋 + CAS + 双重 check 等手段保证了数组初始化时的线程安全，源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//初始化 table，通过对 sizeCtl 的变量赋值来保证数组只能被初始化一次</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//通过自旋保证初始化成功</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 小于 0 代表有线程正在初始化，释放当前 CPU 的调度权，重新发起锁的竞争</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// lost initialization race; just spin</span>
        <span class="token comment" spellcheck="true">// CAS 赋值保证当前只有一个线程在初始化，-1 代表当前只有一个线程能初始化</span>
        <span class="token comment" spellcheck="true">// 保证了数组的初始化的安全性</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 很有可能执行到这里的时候，table 已经不为空了，这里是双重 check</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> tab<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 进行初始化</span>
                    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token punctuation">(</span>sc <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> sc <span class="token operator">:</span> DEFAULT_CAPACITY<span class="token punctuation">;</span>
                    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    table <span class="token operator">=</span> tab <span class="token operator">=</span> nt<span class="token punctuation">;</span>
                    sc <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                sizeCtl <span class="token operator">=</span> sc<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> tab<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h5 id="2-新增槽点值时的线程安全"><a href="#2-新增槽点值时的线程安全" class="headerlink" title="2.新增槽点值时的线程安全"></a>2.新增槽点值时的线程安全</h5><p>此时为了保证线程安全，做了四处优化：</p>
<ol>
<li>通过自旋死循环保证一定可以新增成功。</li>
</ol>
<p>在新增之前，通过 <code>for (Node[] tab = table;;)</code> 这样的死循环来保证新增一定可以成功，一旦新增成功，就可以退出当前死循环，新增失败的话，会重复新增的步骤，直到新增成功为止。</p>
<ol start="2">
<li>当前槽点为空时，通过 CAS 新增。</li>
</ol>
<p>Java 这里的写法非常严谨，没有在判断槽点为空的情况下直接赋值，因为在判断槽点为空和赋值的瞬间，很有可能槽点已经被其他线程赋值了，所以我们采用 CAS 算法，能够保证槽点为空的情况下赋值成功，如果恰好槽点已经被其他线程赋值，当前 CAS 操作失败，会再次执行 for 自旋，再走槽点有值的 put 流程，这里就是自旋 + CAS 的结合。</p>
<ol start="3">
<li>当前槽点有值，锁住当前槽点。</li>
</ol>
<p>put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树，我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改，截图如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ConcurrentHashMap-hash%E5%86%B2%E7%AA%81.jpeg" alt="ConcurrentHashMap-hash冲突"></p>
<ol start="4">
<li><p>红黑树旋转时，锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转。</p>
<p>代码截图如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ConcurrentHashMap-%E9%94%81%E4%BD%8F%E7%BA%A2%E9%BB%91%E6%A0%91.jpeg" alt="ConcurrentHashMap-锁住红黑树"></p>
</li>
</ol>
<p>通过以上 4 点，保证了在各种情况下的新增（不考虑扩容的情况下），都是线程安全的，通过自旋 + CAS + 锁三大姿势，实现的很巧妙，值得我们借鉴。</p>
<h5 id="3-扩容时的线程安全"><a href="#3-扩容时的线程安全" class="headerlink" title="3.扩容时的线程安全"></a>3.扩容时的线程安全</h5><p>ConcurrentHashMap 的扩容时机和 HashMap 相同，都是在 put 方法的最后一步检查是否需要扩容，如果需要则进行扩容，但两者扩容的过程完全不同，ConcurrentHashMap 扩容的方法叫做 transfer，从 put 方法的 addCount 方法进去，就能找到 transfer 方法，transfer 方法的主要思路是：</p>
<ol>
<li>首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝；</li>
<li>拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时，把原数组槽点赋值为转移节点；</li>
<li>这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在扩容完成之前，该槽点对应的数据是不会发生变化的；</li>
<li>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点；</li>
<li>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。</li>
</ol>
<p>关键源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 扩容主要分 2 步，第一新建新的空数组，第二移动拷贝每个元素到新数组中去</span>
<span class="token comment" spellcheck="true">// tab：原数组，nextTab：新数组</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nextTab<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 老数组的长度</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">,</span> stride<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>stride <span class="token operator">=</span> <span class="token punctuation">(</span>NCPU <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> NCPU <span class="token operator">:</span> n<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TRANSFER_STRIDE<span class="token punctuation">)</span>
        stride <span class="token operator">=</span> MIN_TRANSFER_STRIDE<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// subdivide range</span>
    <span class="token comment" spellcheck="true">// 如果新数组为空，初始化，大小为原数组的两倍，n &lt;&lt; 1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nextTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// initiating</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> nt <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            nextTab <span class="token operator">=</span> nt<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// try to cope with OOME</span>
            sizeCtl <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        nextTable <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>
        transferIndex <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 新数组的长度</span>
    <span class="token keyword">int</span> nextn <span class="token operator">=</span> nextTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 代表转移节点，如果原数组上是转移节点，说明该节点正在被扩容</span>
    ForwardingNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> fwd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForwardingNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>nextTab<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> finishing <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// to ensure sweep before committing nextTab</span>
    <span class="token comment" spellcheck="true">// 无限自旋，i 的值会从原数组的最大值开始，慢慢递减到 0</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bound <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> f<span class="token punctuation">;</span> <span class="token keyword">int</span> fh<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>advance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> nextIndex<span class="token punctuation">,</span> nextBound<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 结束循环的标志</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>i <span class="token operator">>=</span> bound <span class="token operator">||</span> finishing<span class="token punctuation">)</span>
                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 已经拷贝完成</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nextIndex <span class="token operator">=</span> transferIndex<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                i <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 每次减少 i 的值</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span>
                     <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> TRANSFERINDEX<span class="token punctuation">,</span> nextIndex<span class="token punctuation">,</span>
                      nextBound <span class="token operator">=</span> <span class="token punctuation">(</span>nextIndex <span class="token operator">></span> stride <span class="token operator">?</span>
                                   nextIndex <span class="token operator">-</span> stride <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                bound <span class="token operator">=</span> nextBound<span class="token punctuation">;</span>
                i <span class="token operator">=</span> nextIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                advance <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// if 任意条件满足说明拷贝结束了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> n <span class="token operator">||</span> i <span class="token operator">+</span> n <span class="token operator">>=</span> nextn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> sc<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 拷贝结束，直接赋值，因为每次拷贝完一个节点，都在原数组上放转移节点，所以拷贝完成的节点的数据一定不会再发生变化。</span>
            <span class="token comment" spellcheck="true">// 原数组发现是转移节点，是不会操作的，会一直等待转移节点消失之后在进行操作。</span>
            <span class="token comment" spellcheck="true">// 也就是说数组节点一旦被标记为转移节点，是不会再发生任何变动的，所以不会有任何线程安全的问题</span>
            <span class="token comment" spellcheck="true">// 所以此处直接赋值，没有任何问题。</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>finishing<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                nextTable <span class="token operator">=</span> null<span class="token punctuation">;</span>
                table <span class="token operator">=</span> nextTab<span class="token punctuation">;</span>
                sizeCtl <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>n <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>U<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> SIZECTL<span class="token punctuation">,</span> sc <span class="token operator">=</span> sizeCtl<span class="token punctuation">,</span> sc <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>sc <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">resizeStamp</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> RESIZE_STAMP_SHIFT<span class="token punctuation">)</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                finishing <span class="token operator">=</span> advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                i <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// recheck before commit</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
            advance <span class="token operator">=</span> <span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> null<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fh <span class="token operator">=</span> f<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> MOVED<span class="token punctuation">)</span>
            advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// already processed</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 进行节点的拷贝</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token operator">==</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> ln<span class="token punctuation">,</span> hn<span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token keyword">int</span> runBit <span class="token operator">=</span> fh <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>
                        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> lastRun <span class="token operator">=</span> f<span class="token punctuation">;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">.</span>next<span class="token punctuation">;</span> p <span class="token operator">!=</span> null<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">int</span> b <span class="token operator">=</span> p<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> n<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">!=</span> runBit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                                runBit <span class="token operator">=</span> b<span class="token punctuation">;</span>
                                lastRun <span class="token operator">=</span> p<span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>runBit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            ln <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>
                            hn <span class="token operator">=</span> null<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">else</span> <span class="token punctuation">{</span>
                            hn <span class="token operator">=</span> lastRun<span class="token punctuation">;</span>
                            ln <span class="token operator">=</span> null<span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token comment" spellcheck="true">// 如果节点只有单个数据，直接拷贝，如果是链表，循环多次组成链表拷贝</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p <span class="token operator">=</span> f<span class="token punctuation">;</span> p <span class="token operator">!=</span> lastRun<span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                            <span class="token keyword">int</span> ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">;</span> K pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">;</span> V pv <span class="token operator">=</span> p<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">&amp;</span> n<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                                ln <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                            <span class="token keyword">else</span>
                                hn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> pk<span class="token punctuation">,</span> pv<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token comment" spellcheck="true">// 在新数组位置上放置拷贝的值</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>nextTab<span class="token punctuation">,</span> i <span class="token operator">+</span> n<span class="token punctuation">,</span> hn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token comment" spellcheck="true">// 在老数组位置上放上 ForwardingNode 节点</span>
                        <span class="token comment" spellcheck="true">// put 时，发现是 ForwardingNode 节点，就不会再动这个节点的数据了</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token comment" spellcheck="true">// 红黑树的拷贝</span>
                    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token keyword">instanceof</span> <span class="token class-name">TreeBin</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token comment" spellcheck="true">// 红黑树的拷贝工作，同 HashMap 的内容，代码忽略</span>
                        …………
                        <span class="token comment" spellcheck="true">// 在老数组位置上放上 ForwardingNode 节点</span>
                        <span class="token function">setTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> fwd<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        advance <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>扩容中的关键点，就是如何保证是线程安全的，小结有如下几点：</p>
<ol>
<li>拷贝槽点时，会把原数组的槽点锁住；</li>
<li>拷贝成功之后，会把原数组的槽点设置成转移节点，这样如果有数据需要 put 到该节点时，发现该槽点是转移节点，会一直等待，直到扩容成功之后，才能继续 put，可以参考 put 方法中的 helpTransfer 方法；</li>
<li>从尾到头进行拷贝，拷贝成功就把原数组的槽点设置成转移节点。</li>
<li>等扩容拷贝都完成之后，直接把新数组的值赋值给数组容器，之前等待 put 的数据才能继续 put。</li>
</ol>
<p>扩容方法还是很有意思的，通过在原数组上设置转移节点，put 时碰到转移节点时会等待扩容成功之后才能 put 的策略，来保证了整个扩容过程中肯定是线程安全的，因为数组的槽点一旦被设置成转移节点，在没有扩容完成之前，是无法进行操作的。</p>
<h4 id="3-2-4-get"><a href="#3-2-4-get" class="headerlink" title="3.2.4-get"></a>3.2.4-get</h4><p>ConcurrentHashMap 读的话，就比较简单，先获取数组的下标，然后通过判断数组下标的 key 是否和我们的 key 相等，相等的话直接返回，如果下标的槽点是链表或红黑树的话，分别调用相应的查找数据的方法，整体思路和 HashMap 很像，源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">,</span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> eh<span class="token punctuation">;</span> K ek<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//计算hashcode</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token function">spread</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//不是空的数组 &amp;&amp; 并且当前索引的槽点数据不是空的</span>
    <span class="token comment" spellcheck="true">//否则该key对应的值不存在，返回null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//槽点第一个值和key相等，直接返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eh <span class="token operator">=</span> e<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//如果是红黑树或者转移节点，使用对应的find方法</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>eh <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span> p<span class="token punctuation">.</span>val <span class="token operator">:</span> null<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//如果是链表，遍历查找</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span>
                <span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>ek <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="3-2-5-总结"><a href="#3-2-5-总结" class="headerlink" title="3.2.5-总结"></a>3.2.5-总结</h4><p>本文摘取 ConcurrentHashMap 两个核心的方法讲解了一下，特别是 put 方法，采取了很多手段来保证了线程安全，是平时面试时的重中之重，大家可以尝试 debug 来调试一下源码，其他方法感兴趣的话，可以尝试去 GitHub 上去查看源码。</p>
<h3 id="3-3-并发-List、Map源码面试题"><a href="#3-3-并发-List、Map源码面试题" class="headerlink" title="3.3-并发 List、Map源码面试题"></a>3.3-并发 List、Map源码面试题</h3><p>并发 List 和 Map 是技术面时常问的问题，问的问题也都比较深入，有很多问题都是面试官自创的，市面上找不到，所以说通过背题的方式，这一关大部分是过不了的，只有我们真正理解了 API 内部的实现，阅读过源码，才能自如应对各种类型的面试题，接着我们来看一下并发 List、Map 源码相关的面试题集。</p>
<h4 id="3-3-1-CopyOnWriteArrayList-相关"><a href="#3-3-1-CopyOnWriteArrayList-相关" class="headerlink" title="3.3.1-CopyOnWriteArrayList 相关"></a>3.3.1-CopyOnWriteArrayList 相关</h4><h5 id="1-CopyOnWriteArrayList-和-ArrayList-相比有哪些相同点和不同点？"><a href="#1-CopyOnWriteArrayList-和-ArrayList-相比有哪些相同点和不同点？" class="headerlink" title="1.CopyOnWriteArrayList 和 ArrayList 相比有哪些相同点和不同点？"></a>1.CopyOnWriteArrayList 和 ArrayList 相比有哪些相同点和不同点？</h5><p>答：相同点：底层的数据结构是相同的，都是数组的数据结构，提供出来的 API 都是对数组结构进行操作，让我们更好的使用。</p>
<p>不同点：后者是线程安全的，在多线程环境下使用，无需加锁，可直接使用。</p>
<h5 id="2-CopyOnWriteArrayList-通过哪些手段实现了线程安全？"><a href="#2-CopyOnWriteArrayList-通过哪些手段实现了线程安全？" class="headerlink" title="2.CopyOnWriteArrayList 通过哪些手段实现了线程安全？"></a>2.CopyOnWriteArrayList 通过哪些手段实现了线程安全？</h5><p>答：主要有：1. 数组容器被 volatile 关键字修饰，保证了数组内存地址被任意线程修改后，都会通知到其他线程；</p>
<ol>
<li>对数组的所有修改操作，都进行了加锁，保证了同一时刻，只能有一个线程对数组进行修改，比如我在 add 时，就无法 remove；</li>
<li>修改过程中对原数组进行了复制，是在新数组上进行修改的，修改过程中，不会对原数组产生任何影响。</li>
</ol>
<p>通过以上三点保证了线程安全。</p>
<h5 id="3-在-add-方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？"><a href="#3-在-add-方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？" class="headerlink" title="3.在 add 方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？"></a>3.在 add 方法中，对数组进行加锁后，不是已经是线程安全了么，为什么还需要对老数组进行拷贝？</h5><p>答：的确，对数组进行加锁后，能够保证同一时刻，只有一个线程能对数组进行 add，在同单核 CPU 下的多线程环境下肯定没有问题，但我们现在的机器都是多核 CPU，如果我们不通过复制拷贝新建数组，修改原数组容器的内存地址的话，是无法触发 volatile 可见性效果的，那么其他 CPU 下的线程就无法感知数组原来已经被修改了，就会引发多核 CPU 下的线程安全问题。</p>
<p>假设我们不复制拷贝，而是在原来数组上直接修改值，数组的内存地址就不会变，而数组被 volatile 修饰时，必须当数组的内存地址变更时，才能及时的通知到其他线程，内存地址不变，仅仅是数组元素值发生变化时，是无法把数组元素值发生变动的事实，通知到其它线程的。</p>
<h5 id="4-对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？"><a href="#4-对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？" class="headerlink" title="4.对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？"></a>4.对老数组进行拷贝，会有性能损耗，我们平时使用需要注意什么么？</h5><p>答：主要有：</p>
<ol>
<li>在批量操作时，尽量使用 addAll、removeAll 方法，而不要在循环里面使用 add、remove 方法，主要是因为 for 循环里面使用 add 、remove 的方式，在每次操作时，都会进行一次数组的拷贝(甚至多次)，非常耗性能，而 addAll、removeAll 方法底层做了优化，整个操作只会进行一次数组拷贝，由此可见，当批量操作的数据越多时，批量方法的高性能体现的越明显。</li>
</ol>
<h5 id="5-为什么-CopyOnWriteArrayList-迭代过程中，数组结构变动，不会抛出ConcurrentModificationException-了"><a href="#5-为什么-CopyOnWriteArrayList-迭代过程中，数组结构变动，不会抛出ConcurrentModificationException-了" class="headerlink" title="5.为什么 CopyOnWriteArrayList 迭代过程中，数组结构变动，不会抛出ConcurrentModificationException 了"></a>5.为什么 CopyOnWriteArrayList 迭代过程中，数组结构变动，不会抛出ConcurrentModificationException 了</h5><p>答：主要是因为 CopyOnWriteArrayList 每次操作时，都会产生新的数组，而迭代时，持有的仍然是老数组的引用，所以我们说的数组结构变动，是用新数组替换了老数组，老数组的结构并没有发生变化，所以不会抛出异常了。</p>
<h5 id="6-插入的数据正好在-List-的中间，请问两种-List-分别拷贝数组几次？为什么？"><a href="#6-插入的数据正好在-List-的中间，请问两种-List-分别拷贝数组几次？为什么？" class="headerlink" title="6.插入的数据正好在 List 的中间，请问两种 List 分别拷贝数组几次？为什么？"></a>6.插入的数据正好在 List 的中间，请问两种 List 分别拷贝数组几次？为什么？</h5><p>答：ArrayList 只需拷贝一次，假设插入的位置是 2，只需要把位置 2 （包含 2）后面的数据都往后移动一位即可，所以拷贝一次。</p>
<p>CopyOnWriteArrayList 拷贝两次，因为 CopyOnWriteArrayList 多了把老数组的数据拷贝到新数组上这一步，可能有的同学会想到这种方式：先把老数组拷贝到新数组，再把 2 后面的数据往后移动一位，这的确是一种拷贝的方式，但 CopyOnWriteArrayList 底层实现更加灵活，而是：把老数组 0 到 2 的数据拷贝到新数组上，预留出新数组 2 的位置，再把老数组 3～ 最后的数据拷贝到新数组上，这种拷贝方式可以减少我们拷贝的数据，虽然是两次拷贝，但拷贝的数据却仍然是老数组的大小，设计的非常巧妙。</p>
<h4 id="3-3-2-ConcurrentHashMap-相关"><a href="#3-3-2-ConcurrentHashMap-相关" class="headerlink" title="3.3.2-ConcurrentHashMap 相关"></a>3.3.2-ConcurrentHashMap 相关</h4><h5 id="1-ConcurrentHashMap-和-HashMap-的相同点和不同点"><a href="#1-ConcurrentHashMap-和-HashMap-的相同点和不同点" class="headerlink" title="1.ConcurrentHashMap 和 HashMap 的相同点和不同点"></a>1.ConcurrentHashMap 和 HashMap 的相同点和不同点</h5><p>答：</p>
<p>相同点：</p>
<ul>
<li>都是数组 + 链表 +红黑树的数据结构，所以基本操作的思想相同；</li>
<li>都实现了 Map 接口，继承了 AbstractMap 抽象类，所以两者的方法大多都是相似的，可以互相切换。</li>
</ul>
<p>不同点：</p>
<ul>
<li>ConcurrentHashMap 是线程安全的，在多线程环境下，无需加锁，可直接使用；</li>
<li>数据结构上，ConcurrentHashMap 多了转移节点，主要用于保证扩容时的线程安全。</li>
</ul>
<h5 id="2-ConcurrentHashMap-通过哪些手段保证了线程安全。"><a href="#2-ConcurrentHashMap-通过哪些手段保证了线程安全。" class="headerlink" title="2.ConcurrentHashMap 通过哪些手段保证了线程安全。"></a>2.ConcurrentHashMap 通过哪些手段保证了线程安全。</h5><p>答：主要有以下几点：</p>
<ol>
<li>储存 Map 数据的数组被 volatile 关键字修饰，一旦被修改，立马就能通知其他线程，因为是数组，所以需要改变其内存值，才能真正的发挥出 volatile 的可见特性；</li>
<li>put 时，如果计算出来的数组下标索引没有值的话，采用无限 for 循环 + CAS 算法，来保证一定可以新增成功，又不会覆盖其他线程 put 进去的值；</li>
<li>如果 put 的节点正好在扩容，会等待扩容完成之后，再进行 put ，保证了在扩容时，老数组的值不会发生变化；</li>
<li>对数组的槽点进行操作时，会先锁住槽点，保证只有当前线程才能对槽点上的链表或红黑树进行操作；</li>
<li>红黑树旋转时，会锁住根节点，保证旋转时的线程安全。</li>
</ol>
<h5 id="3-描述一下-CAS-算法在-ConcurrentHashMap-中的应用？"><a href="#3-描述一下-CAS-算法在-ConcurrentHashMap-中的应用？" class="headerlink" title="3.描述一下 CAS 算法在 ConcurrentHashMap 中的应用？"></a>3.描述一下 CAS 算法在 ConcurrentHashMap 中的应用？</h5><p>答：CAS 其实是一种乐观锁，一般有三个值，分别为：赋值对象，原值，新值，在执行的时候，会先判断内存中的值是否和原值相等，相等的话把新值赋值给对象，否则赋值失败，整个过程都是原子性操作，没有线程安全问题。</p>
<p>ConcurrentHashMap 的 put 方法中，有使用到 CAS ，是结合无限 for 循环一起使用的，步骤如下：</p>
<ol>
<li>计算出数组索引下标，拿出下标对应的原值；</li>
<li>CAS 覆盖当前下标的值，赋值时，如果发现内存值和 1 拿出来的原值相等，执行赋值，退出循环，否则不赋值，转到 3；</li>
<li>进行下一次 for 循环，重复执行 1，2，直到成功为止。</li>
</ol>
<p>可以看到这样做的好处，第一是不会盲目的覆盖原值，第二是一定可以赋值成功。</p>
<h5 id="4-ConcurrentHashMap-是如何发现当前槽点正在扩容的。"><a href="#4-ConcurrentHashMap-是如何发现当前槽点正在扩容的。" class="headerlink" title="4.ConcurrentHashMap 是如何发现当前槽点正在扩容的。"></a>4.ConcurrentHashMap 是如何发现当前槽点正在扩容的。</h5><p>答：ConcurrentHashMap 新增了一个节点类型，叫做转移节点，当我们发现当前槽点是转移节点时（转移节点的 hash 值是 -1），即表示 Map 正在进行扩容。</p>
<h5 id="5-发现槽点正在扩容时，put-操作会怎么办？"><a href="#5-发现槽点正在扩容时，put-操作会怎么办？" class="headerlink" title="5.发现槽点正在扩容时，put 操作会怎么办？"></a>5.发现槽点正在扩容时，put 操作会怎么办？</h5><p>答：无限 for 循环，或者走到扩容方法中去，帮助扩容，一直等待扩容完成之后，再执行 put 操作。</p>
<h5 id="6-两种-Map-扩容时，有啥区别？"><a href="#6-两种-Map-扩容时，有啥区别？" class="headerlink" title="6.两种 Map 扩容时，有啥区别？"></a>6.两种 Map 扩容时，有啥区别？</h5><p>答：区别很大，HashMap 是直接在老数据上面进行扩容，多线程环境下，会有线程安全的问题，而 ConcurrentHashMap 就不太一样，扩容过程是这样的：</p>
<ol>
<li>从数组的队尾开始拷贝；</li>
<li>拷贝数组的槽点时，先把原数组槽点锁住，拷贝成功到新数组时，把原数组槽点赋值为转移节点；</li>
<li>从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组的槽点设置成转移节点；</li>
<li>直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成。</li>
</ol>
<p>简单来说，通过扩容时给槽点加锁，和发现槽点正在扩容就等待的策略，保证了 ConcurrentHashMap 可以慢慢一个一个槽点的转移，保证了扩容时的线程安全，转移节点比较重要，平时问的人也比较多。</p>
<h5 id="7-ConcurrentHashMap-在-Java-7-和-8-中关于线程安全的做法有啥不同？"><a href="#7-ConcurrentHashMap-在-Java-7-和-8-中关于线程安全的做法有啥不同？" class="headerlink" title="7.ConcurrentHashMap 在 Java 7 和 8 中关于线程安全的做法有啥不同？"></a>7.ConcurrentHashMap 在 Java 7 和 8 中关于线程安全的做法有啥不同？</h5><p>答：非常不一样，拿 put 方法为例，Java 7 的做法是：</p>
<ol>
<li>把数组进行分段，找到当前 key 对应的是那一段；</li>
<li>将当前段锁住，然后再根据 hash 寻找对应的值，进行赋值操作。</li>
</ol>
<p>Java 7 的做法比较简单，缺点也很明显，就是当我们需要 put 数据时，我们会锁住改该数据对应的某一段，这一段数据可能会有很多，比如我只想 put 一个值，锁住的却是一段数据，导致这一段的其他数据都不能进行写入操作，大大的降低了并发性的效率。Java 8 解决了这个问题，从锁住某一段，修改成锁住某一个槽点，提高了并发效率。</p>
<p>不仅仅是 put，删除也是，仅仅是锁住当前槽点，缩小了锁的范围，增大了效率。</p>
<h4 id="3-3-3-总结"><a href="#3-3-3-总结" class="headerlink" title="3.3.3-总结"></a>3.3.3-总结</h4><p>因为目前大多数公司都已经在使用 Java 8 了，所以大部分面试内容还是以 Java 8 的 API 为主，特别是 CopyOnWriteArrayList 和 ConcurrentHashMap 两个 API，文章毕竟篇幅有限，建议大家多多阅读剩余源码。</p>
<h3 id="3-4-场景集合：并发-List、Map的应用场景"><a href="#3-4-场景集合：并发-List、Map的应用场景" class="headerlink" title="3.4-场景集合：并发 List、Map的应用场景"></a>3.4-场景集合：并发 List、Map的应用场景</h3><p>并发 List、Map 使用最多的就是 CopyOnWriteArrayList 和 ConcurrentHashMap，在考虑 API 时，我们也无需迟疑，这两个并发类在安全和性能方面都很好，我们都可以直接使用。</p>
<p>并发的场景很多，但归根结底其实就是共享变量被多个线程同时访问，也就是说 CopyOnWriteArrayList 或 ConcurrentHashMap 会被作为共享变量，本节我们会以流程引擎为案例，现身说法，增加一下大家的工作经验积累。</p>
<p>流程引擎在实际工作中经常被使用，其主要功能就是对我们需要完成的事情，进行编排和组装，比如在淘宝下单流程中，我们一共会执行 20 个 Spring Bean，流程引擎就可以帮助我们调起 20 个 Spring Bean，并帮助我们去执行，本文介绍的重点在于如何使用 Map + List 来设计流程引擎的数据结构，以及其中需要注意到的线程安全的问题。</p>
<h4 id="3-4-1-嵌套-Map，简单流程引擎"><a href="#3-4-1-嵌套-Map，简单流程引擎" class="headerlink" title="3.4.1-嵌套 Map，简单流程引擎"></a>3.4.1-嵌套 Map，简单流程引擎</h4><p>市面上有很多流程引擎，比如说 Activiti、Flowable、Camunda 等等，功能非常齐全，但我们本小节只实现一种最最简单的流程引擎，只要能对我们需要完成的事情进行编排，并能依次的调用就行。</p>
<h5 id="1-流程引擎设计思路"><a href="#1-流程引擎设计思路" class="headerlink" title="1.流程引擎设计思路"></a>1.流程引擎设计思路</h5><p>我们认为每个流程都会做 4 个阶段的事情，阶段主要是指在整个流程中，大概可以分为几个大的步骤，每个阶段可以等同为大的步骤，分别如下：</p>
<ol>
<li>参数校验，主要是对流程的入参数进行校验；</li>
<li>业务校验，主要是对当前流程中的业务进行逻辑校验；</li>
<li>事务中落库，主要把数据落库，控制事务；</li>
<li>事务后事件，我们在数据落库，事务提交之后，可能会做一些其他事情，比如说发消息出来等等。</li>
</ol>
<p>以上每个大的阶段，都会做一些粒度较细的事情，比如说业务校验，我们可能会对两个业务对象进行校验，那么此时业务校验阶段就会做两件事情，每件具体的事情，我们叫做领域行为，在实际项目中，一个领域行为一般都是一个 Spring Bean。</p>
<p>综上所述，流程引擎嵌套数据结构就是：流程 -&gt; 阶段 -&gt; 领域行为，前者对应后者，都是一对一或者一对多的关系。</p>
<p>我们以在淘宝上买东西时，下单为例，下单指的是我们在淘宝选择好了商品和优惠券后，点击购买按钮时触发的动作。</p>
<p>为了方便举例，我们假设在淘宝上买电视和电影票，在后端，会分别对应着两个下单流程，我们画图示意一下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E6%B7%98%E5%AE%9D%E4%B8%8B%E5%8D%95%E6%B5%81%E7%A8%8B.jpeg" alt="淘宝下单流程"></p>
<p>上图中，左右两个黑色长方形大框代表着两个流程，流程下面有多个阶段，阶段用蓝色表示，每个阶段下面有多个领域行为，用红色表示。</p>
<p>可以看到两个流程中，都包含有四个阶段，阶段都是相同的，但每个阶段中的领域行为，有的相同，有的却是特有的。</p>
<p>三个概念，每个概念层层嵌套，整体组装起来，用来表示一个流程，那么这个数据结构，我们应该如何表示呢？</p>
<p>使用 Map + List 即可！</p>
<h5 id="2-数据结构的定义"><a href="#2-数据结构的定义" class="headerlink" title="2.数据结构的定义"></a>2.数据结构的定义</h5><p>流程的数据结构定义分成两步：</p>
<ol>
<li>定义出阶段、领域行为基础概念；</li>
<li>把阶段、领域行为、流程概念组合起来，定义出流程的数据结构。</li>
</ol>
<p>首先给阶段定义一个枚举，如下 StageEnum 代表流程中的阶段或步骤：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> StageEnum <span class="token punctuation">{</span>
  <span class="token function">PARAM_VALID</span><span class="token punctuation">(</span><span class="token string">"PARAM_VALID"</span><span class="token punctuation">,</span> <span class="token string">"参数校验"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

  <span class="token function">BUSINESS_VALID</span><span class="token punctuation">(</span><span class="token string">"BUSINESS_VALID"</span><span class="token punctuation">,</span> <span class="token string">"业务校验"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

  <span class="token function">IN_TRANSACTION</span><span class="token punctuation">(</span><span class="token string">"IN_TRANSACTION"</span><span class="token punctuation">,</span> <span class="token string">"事务中落库"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

  <span class="token function">AFTER_TRANSACTION</span><span class="token punctuation">(</span><span class="token string">"AFTER_TRANSACTION"</span><span class="token punctuation">,</span> <span class="token string">"事务后事件"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">;</span>

  <span class="token keyword">private</span> String code<span class="token punctuation">;</span>
  <span class="token keyword">private</span> String desc<span class="token punctuation">;</span>

  <span class="token function">StageEnum</span><span class="token punctuation">(</span>String code<span class="token punctuation">,</span> String desc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>code <span class="token operator">=</span> code<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>desc <span class="token operator">=</span> desc<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>领域行为我们无需定义，目前通用的技术框架都是 Spring Boot，领域行为都是 Spring Bean，为了简单起见，我们给领域行为定义了一个接口，每个领域行为都要实现这个接口，方便我们编排，接口如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 领域行为
 * author  wenhe
 * date 2019/8/11
 */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DomainAbilityBean</span> <span class="token punctuation">{</span>

  <span class="token comment" spellcheck="true">/**
   * 领域行为的方法入口
   */</span>
  FlowContent <span class="token function">invoke</span><span class="token punctuation">(</span>FlowContent content<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
<p>接着我们使用 Map + List 来定义流程，定义如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 第一个 key 是流程的名字
 * 第二个 map 的 key 是阶段，为 StageEnum 枚举，值为多个领域行为的集合
 */</span>
Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Map<span class="token operator">&lt;</span>StageEnum<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>DomainAbilityBean<span class="token operator">>>></span> flowMap</code></pre>
<p>至此，我们定义出了，简单流程引擎的数据结构，流程引擎看着很复杂，利用 Map + List 的组合，就巧妙的定义好了。</p>
<h4 id="3-4-2-容器初始化时，本地缓存使用"><a href="#3-4-2-容器初始化时，本地缓存使用" class="headerlink" title="3.4.2-容器初始化时，本地缓存使用"></a>3.4.2-容器初始化时，本地缓存使用</h4><p>我们定义好 Map 后，我们就需要去使用他，我们使用的大体步骤为：</p>
<ol>
<li>项目启动时，把所有的流程信息初始化到 flowMap(刚刚定义的流程的数据结构叫做 flowMap) 中去，可能是从数据库中加载，也可能是从 xml 文件中加载；</li>
<li>查找流程时，直接从 flowMap 中获取即可。</li>
</ol>
<h5 id="1-初始化-2"><a href="#1-初始化-2" class="headerlink" title="1.初始化"></a>1.初始化</h5><p>以上两步最为关键的点就是 flowMap 必须是可以随时访问到的，所有我们会把 flowMap 作为共享变量使用，也就是会被 static final 关键字所修饰，我们首先来 mock 一下把所有信息初始化到 flowMap 中去的代码，如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowCenter</span> <span class="token punctuation">{</span>

  <span class="token comment" spellcheck="true">/**
   * flowMap 是共享变量，方便访问，并且是 ConcurrentHashMap
   */</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>StageEnum<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>DomainAbilityBean<span class="token operator">>>></span> flowMap
      <span class="token operator">=</span> Maps<span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment" spellcheck="true">/**
   * PostConstruct 注解的意思就是
   * 在容器启动成功之后，执行 init 方法，初始化 flowMap
   */</span>
  <span class="token annotation punctuation">@PostConstruct</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 初始化 flowMap，可能是从数据库，或者 xml 文件中加载 map</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>以上代码，关键地方在于三点：</p>
<ol>
<li>flowMap 被 static final 修饰，是个共享变量，方便访问；</li>
<li>flowMap 是 ConcurrentHashMap，所以我们所有的操作都无需加锁，比如我们在 init 方法中，对 flowMap 进行初始化，就无需加锁，因为 ConcurrentHashMap 本身已经保证了线程安全；</li>
<li>这里我们初始化的时机是在容器启动的时候，在实际的工作中，我们经常在容器启动的时候，把不会经常发生变动的数据，放到类似 List、Map 这样的共享变量中，这样当我们频繁要使用的时候，直接从内存中读取即可。</li>
</ol>
<h5 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h5><p>那我们实际使用的时候，只需要告诉 flowMap 当前是那个流程的那个阶段，就可以返回该流程该阶段下面的所有领域行为了，我们写了一个流程引擎使用的工具类入口，如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 流程引擎对外的 API</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlowStart</span> <span class="token punctuation">{</span>

  <span class="token comment" spellcheck="true">/**
   * 流程引擎开始
   *
   * @param flowName 流程的名字
   */</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">invokeParamValid</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">invokeBusinessValid</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">invokeInTramsactionValid</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">invokeAfterTramsactionValid</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 执行参数校验</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeParamValid</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">stageInvoke</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> StageEnum<span class="token punctuation">.</span>PARAM_VALID<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 执行业务校验</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeBusinessValid</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">stageInvoke</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> StageEnum<span class="token punctuation">.</span>BUSINESS_VALID<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 执行事务中</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeInTramsactionValid</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">stageInvoke</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> StageEnum<span class="token punctuation">.</span>IN_TRANSACTION<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment" spellcheck="true">// 执行事务后</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeAfterTramsactionValid</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">stageInvoke</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> StageEnum<span class="token punctuation">.</span>AFTER_TRANSACTION<span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment" spellcheck="true">// 批量执行 Spring Bean</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">stageInvoke</span><span class="token punctuation">(</span>String flowName<span class="token punctuation">,</span> StageEnum stage<span class="token punctuation">,</span> FlowContent content<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    List<span class="token operator">&lt;</span>DomainAbilityBean<span class="token operator">></span>
        domainAbilitys <span class="token operator">=</span>
        FlowCenter<span class="token punctuation">.</span>flowMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>flowName<span class="token punctuation">,</span> Maps<span class="token punctuation">.</span><span class="token function">newHashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>stage<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>CollectionUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>domainAbilitys<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"找不到该流程对应的领域行为"</span> <span class="token operator">+</span> flowName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>DomainAbilityBean domainAbility <span class="token operator">:</span> domainAbilitys<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      domainAbility<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
<p>从代码中可以看到，我们在流程引擎的入口，只要根据参数校验、业务校验、事务中、事务后四个阶段，从 flowMap 中得到领域行为的集合，然后对领域行为进行顺序执行即可。</p>
<p>我们在使用时，直接使用上述类的 start 方法即可。</p>
<p>当然以上演示的流程引擎只是一个大的框架，还有很多地方需要改进的地方，比如如何找到 flowName，如何初始化 flowMap，但这些都不是本节重点，本节主要想通过流程引擎案例来说明几点：</p>
<ol>
<li>把 List 和 Map 作为共享变量非常常见，就像咱们这种项目启动时，从数据库中把数据捞出来，然后封装成 List 或 Map 的结构，这样做的优点就是节约资源，不用每次用的时候都去查数据库，直接从内存中获取即可；</li>
<li>并发场景下，我们可以放心的使用 CopyOnWriteArrayList 和 ConcurrentHashMap 两个并发类，首先用 static final 对两者进行修饰，使其成为共享变量，接着在写入或者查询的时候，无需加锁，两个 API 内部已经实现了加锁的功能了；</li>
<li>有一点需要澄清一下，就是 CopyOnWriteArrayList 和 ConcurrentHashMap 只能作为单机的共享变量，如果是分布式系统，多台机器的情况下，这样做不行了，需要使用分布式缓存了。</li>
</ol>
<h4 id="3-4-3-总结"><a href="#3-4-3-总结" class="headerlink" title="3.4.3-总结"></a>3.4.3-总结</h4><p>本节内容，以流程引擎为例，说明了如何使用 Map + List 的嵌套结构设计流程引擎，以及在并发情况下，如何安全的使用 List 和 Map。</p>
<p>本案列是高并发项目的真实案例，感兴趣的同学可以在此流程引擎框架基础上进行细节补充，实现可运行的流程引擎。</p>
<h2 id="4-队列"><a href="#4-队列" class="headerlink" title="4-队列"></a>4-队列</h2><h3 id="4-1-LinkedBlockingQueue-源码解析"><a href="#4-1-LinkedBlockingQueue-源码解析" class="headerlink" title="4.1-LinkedBlockingQueue 源码解析"></a>4.1-LinkedBlockingQueue 源码解析</h3><p>说到队列，大家的反应可能是我从来都没有用过，应该是不重要的 API 吧。如果这么想，那就大错特错了，我们平时使用到的线程池、读写锁、消息队列等等技术和框架，底层原理都是队列，所以我们万万不可轻视队列，队列是很多高级 API 的基础，学好队列，对自己深入 Java 学习非常重要。</p>
<p>本文主要以 LinkedBlockingQueue 队列为例，详细描述一下底层具体的实现。</p>
<h4 id="4-1-1-整体架构"><a href="#4-1-1-整体架构" class="headerlink" title="4.1.1-整体架构"></a>4.1.1-整体架构</h4><p>LinkedBlockingQueue 中文叫做链表阻塞队列，这个命名很好，从命名上就知道其底层数据结构是链表，并且队列是可阻塞的。接下来，我们就从整体结构上看看 LinkedBlockingQueue。</p>
<h5 id="1-类图"><a href="#1-类图" class="headerlink" title="1.类图"></a>1.类图</h5><p>首先我们来看下 LinkedBlockingQueue 类图，如下：</p>
<p>![LinkedBlockingQueue 类图](LinkedBlockingQueue 类图.jpeg)</p>
<p>从类图中，我们大概可以看出两条路径：</p>
<ol>
<li>AbstractQueue -&gt; AbstractCollection -&gt; Collection -&gt;Iterable 这条路径依赖，主要是想复用 Collection 和 迭代器的一些操作，这些我们在说集合的时候，都知道这些类是干什么，能干什么，就不细说了；</li>
<li>BlockingQueue -&gt; Queue -&gt; Collection，BlockingQueue 和 Queue 是新出来的两个接口，我们重点说一下。</li>
</ol>
<p>Queue 是最基础的接口，几乎所有的队列实现类都会实现这个接口，该接口定义出了队列的三大类操作：</p>
<p>新增操作：</p>
<ol>
<li>add 队列满的时候抛出异常；</li>
<li>offer 队列满的时候返回 false。</li>
</ol>
<p>查看并删除操作：</p>
<ol>
<li>remove 队列空的时候抛异常；</li>
<li>poll 队列空的时候返回 null。</li>
</ol>
<p>只查看不删除操作：</p>
<ol>
<li>element 队列空的时候抛异常；</li>
<li>peek 队列空的时候返回 null。</li>
</ol>
<p>一共 6 种方法，除了以上分类方法，也可以分成两类：</p>
<ol>
<li>遇到队列满或空的时候，抛异常，如 add、remove、element；</li>
<li>遇到队列满或空的时候，返回特殊值，如 offer、poll、peek。</li>
</ol>
<p>实际上，这些都比较难记忆。每次需要使用的时候，我都会看会源码，才能想起这个方法是抛异常还是返回特殊值。</p>
<p>BlockingQueue 在 Queue 的基础上加上了阻塞的概念，比如一直阻塞，还是阻塞一段时间。为了方便记忆，我们画一个表格，如下：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">抛异常</th>
<th align="left">特殊值</th>
<th align="left">一直阻塞</th>
<th align="left">阻塞一段时间</th>
</tr>
</thead>
<tbody><tr>
<td align="left">新增操作–队列满</td>
<td align="left">add</td>
<td align="left">offer 返回 false</td>
<td align="left">put</td>
<td align="left">offer 过超时时间返回 false</td>
</tr>
<tr>
<td align="left">查看并删除操作–队列空</td>
<td align="left">remove</td>
<td align="left">poll 返回 null</td>
<td align="left">take</td>
<td align="left">poll 过超时时间返回 null</td>
</tr>
<tr>
<td align="left">只查看不删除操作–队列空</td>
<td align="left">element</td>
<td align="left">peek 返回 null</td>
<td align="left">暂无</td>
<td align="left">暂无</td>
</tr>
</tbody></table>
<p>PS: remove 方法，BlockingQueue 类注释中定义的是抛异常，但 LinkedBlockingQueue 中 remove 方法实际是返回 false。<br>从表格中可以看到，在新增和查看并删除两大类操作上，BlockingQueue 增加了阻塞的功能，而且可以选择一直阻塞，或者阻塞一段时间后，返回特殊值。</p>
<h5 id="2-类注释"><a href="#2-类注释" class="headerlink" title="2.类注释"></a>2.类注释</h5><p>我们看看从 LinkedBlockingQueue 的类注释中能得到那些信息：</p>
<ol>
<li>基于链表的阻塞队列，其底层的数据结构是链表；</li>
<li>链表维护先入先出队列，新元素被放在队尾，获取元素从队头部拿；</li>
<li>链表大小在初始化的时候可以设置，默认是 Integer 的最大值；</li>
<li>可以使用 Collection 和 Iterator 两个接口的所有操作，因为实现了两者的接口。</li>
</ol>
<h5 id="3-内部构成"><a href="#3-内部构成" class="headerlink" title="3.内部构成"></a>3.内部构成</h5><p>LinkedBlockingQueue 内部构成简单来说，分成三个部分：链表存储 + 锁 + 迭代器，我们来看下源码。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 链表结构 begin</span>
<span class="token comment" spellcheck="true">//链表的元素</span>
<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    E item<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//当前元素的下一个，为空表示当前节点是最后一个</span>
    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> next<span class="token punctuation">;</span>

    <span class="token function">Node</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span> item <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//链表的容量，默认 Integer.MAX_VALUE</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//链表已有元素大小，使用 AtomicInteger，所以是线程安全的</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//链表头</span>
<span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> head<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//链表尾</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>E<span class="token operator">></span> last<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 链表结构 end</span>

<span class="token comment" spellcheck="true">// 锁 begin</span>
<span class="token comment" spellcheck="true">//take 时的锁</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// take 的条件队列，condition 可以简单理解为基于 ASQ 同步机制建立的条件队列</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty <span class="token operator">=</span> takeLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// put 时的锁，设计两把锁的目的，主要为了 take 和 put 可以同时进行</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// put 的条件队列</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull <span class="token operator">=</span> putLock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 锁 end</span>

<span class="token comment" spellcheck="true">// 迭代器 </span>
<span class="token comment" spellcheck="true">// 实现了自己的迭代器</span>
<span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Itr</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
………………
<span class="token punctuation">}</span></code></pre>
<p>从代码上来看，结构是非常清晰的，三种结构各司其职：</p>
<ol>
<li>链表的作用是为了保存当前节点，节点中的数据可以是任意东西，是一个泛型，比如说队列被应用到线程池时，节点就是线程，比如队列被应用到消息队列中，节点就是消息，节点的含义主要看队列被使用的场景；</li>
<li>锁有 take 锁和 put 锁，是为了保证队列操作时的线程安全，设计两种锁，是为了 take 和 put 两种操作可以同时进行，互不影响。</li>
</ol>
<h5 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4.初始化"></a>4.初始化</h5><p>初始化有三种方式：</p>
<ol>
<li>指定链表容量大小；</li>
<li>不指定链表容量大小，默认是 Integer 的最大值；</li>
<li>对已有集合数据进行初始化。</li>
</ol>
<p>源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 不指定容量，默认 Integer 的最大值</span>
<span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 指定链表容量大小，链表头尾相等，节点值（item）都是 null</span>
<span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
    last <span class="token operator">=</span> head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 已有集合数据进行初始化</span>
<span class="token keyword">public</span> <span class="token function">LinkedBlockingQueue</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token operator">></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>
    putLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Never contended, but necessary for visibility</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>E e <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 集合内的元素不能为空</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// capacity 代表链表的大小，在这里是 Integer 的最大值</span>
            <span class="token comment" spellcheck="true">// 如果集合类的大小大于 Integer 的最大值，就会报错</span>
            <span class="token comment" spellcheck="true">// 其实这个判断完全可以放在 for 循环外面，这样可以减少 Integer 的最大值次循环(最坏情况)</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> capacity<span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"Queue full"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>n<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        count<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>对于初始化源码，我们说明两点：</p>
<ol>
<li>初始化时，容量大小是不会影响性能的，只影响在后面的使用，因为初始化队列太小，容易导致没有放多少就会报队列已满的错误；</li>
<li>在对给定集合数据进行初始化时，源码给了一个不优雅的示范，我们不反对在每次 for 循环的时候，都去检查当前链表的大小是否超过容量，但我们希望在 for 循环开始之前就做一步这样的工作。举个列子，给定集合大小是 1 w，链表大小是 9k，按照现在代码实现，只能在 for 循环 9k 次时才能发现，原来给定集合的大小已经大于链表大小了，导致 9k 次循环都是在浪费资源，还不如在 for 循环之前就 check 一次，如果 1w &gt; 9k，直接报错即可。</li>
</ol>
<h4 id="4-1-2-阻塞新增"><a href="#4-1-2-阻塞新增" class="headerlink" title="4.1.2-阻塞新增"></a>4.1.2-阻塞新增</h4><p>新增有多种方法，如：add、put、offer，三者的区别上文有说。我们拿 put 方法为例，put 方法在碰到队列满的时候，会一直阻塞下去，直到队列不满时，并且自己被唤醒时，才会继续去执行，源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 把e新增到队列的尾部。</span>
<span class="token comment" spellcheck="true">// 如果有可以新增的空间的话，直接新增成功，否则当前线程陷入等待</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// e 为空，抛出异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 预先设置 c 为 -1，约定负数为新增失败</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> ReentrantLock putLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putLock<span class="token punctuation">;</span>
    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 设置可中断锁</span>
    putLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 队列满了</span>
        <span class="token comment" spellcheck="true">// 当前线程阻塞，等待其他线程的唤醒(其他线程 take 成功后就会唤醒此处被阻塞的线程)</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// await 无限等待</span>
            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 队列没有满，直接新增到队列的尾部</span>
        <span class="token function">enqueue</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 新增计数赋值,注意这里 getAndIncrement 返回的是旧值</span>
        <span class="token comment" spellcheck="true">// 这里的 c 是比真实的 count 小 1 的</span>
        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 如果链表现在的大小 小于链表的容量，说明队列未满</span>
        <span class="token comment" spellcheck="true">// 可以尝试唤醒一个 put 的等待线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> capacity<span class="token punctuation">)</span>
            notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 释放锁</span>
        putLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// c==0，代表队列里面有一个元素</span>
    <span class="token comment" spellcheck="true">// 会尝试唤醒一个take的等待线程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">signalNotEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 入队，把新元素放到队尾</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>E<span class="token operator">></span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    last <span class="token operator">=</span> last<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码中我们可以总结以下几点：</p>
<ol>
<li>往队列新增数据，第一步是上锁，所以新增数据是线程安全的；</li>
<li>队列新增数据，简单的追加到链表的尾部即可；</li>
<li>新增时，如果队列满了，当前线程是会被阻塞的，阻塞的底层使用是锁的能力，底层实现其它也和队列相关，原理我们在锁章节会说到；</li>
<li>新增数据成功后，在适当时机，会唤起 put 的等待线程（队列不满时），或者 take 的等待线程（队列不为空时），这样保证队列一旦满足 put 或者 take 条件时，立马就能唤起阻塞线程，继续运行，保证了唤起的时机不被浪费。</li>
</ol>
<p>以上就是 put 方法的原理，至于 offer 方法阻塞超过一端时间后，仍未成功，就会直接返回默认值的实现，和 put 方法相比只修改了几行代码，如下截图：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/LinkedBlockingQueue-put%E5%92%8Coffer.jpeg" alt="LinkedBlockingQueue-put和offer"></p>
<h4 id="4-1-3-阻塞删除"><a href="#4-1-3-阻塞删除" class="headerlink" title="4.1.3-阻塞删除"></a>4.1.3-阻塞删除</h4><p>删除的方法也很多，我们主要看两个关键问题：</p>
<ol>
<li>删除的原理是怎样的；</li>
<li>查看并删除和只查看不删除两种的区别是如何实现的。</li>
</ol>
<p>首先我们来看第一个问题，我们以 take 方法为例，说明一下查看并删除的底层源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 阻塞拿数据</span>
<span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    E x<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 默认负数，代表失败</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// count 代表当前链表数据的真实大小</span>
    <span class="token keyword">final</span> AtomicInteger count <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>
    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>
    takeLock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 空队列时，阻塞，等待其他线程唤醒</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 非空队列，从队列的头部拿一个出来</span>
        x <span class="token operator">=</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 减一计算，注意 getAndDecrement 返回的值是旧值</span>
        <span class="token comment" spellcheck="true">// c 比真实的 count 大1</span>
        c <span class="token operator">=</span> count<span class="token punctuation">.</span><span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 如果队列里面有值，从 take 的等待线程里面唤醒一个。</span>
        <span class="token comment" spellcheck="true">// 意思是队列里面有值啦,唤醒之前被阻塞的线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 释放锁</span>
        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 如果队列空闲还剩下一个，尝试从 put 的等待线程中唤醒一个</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> capacity<span class="token punctuation">)</span>
        <span class="token function">signalNotFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 队头中取数据</span>
<span class="token keyword">private</span> E <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
    Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    h<span class="token punctuation">.</span>next <span class="token operator">=</span> h<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// help GC</span>
    head <span class="token operator">=</span> first<span class="token punctuation">;</span>
    E x <span class="token operator">=</span> first<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
    first<span class="token punctuation">.</span>item <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 头节点指向 null，删除</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>整体流程和 put 很相似，都是先上锁，然后从队列的头部拿出数据，如果队列为空，会一直阻塞到队列有值为止。</p>
<p>而查看不删除元素更加简单，直接把队列头的数据拿出来即可，我们以 peek 为例，源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 查看并不删除元素，如果队列为空，返回 null</span>
<span class="token keyword">public</span> E <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// count 代表队列实际大小，队列为空，直接返回 null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token keyword">final</span> ReentrantLock takeLock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>takeLock<span class="token punctuation">;</span>
    takeLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 拿到队列头</span>
        Node<span class="token operator">&lt;</span>E<span class="token operator">></span> first <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 判断队列头是否为空，并返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> null<span class="token punctuation">)</span>
            <span class="token keyword">return</span> null<span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token keyword">return</span> first<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        takeLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>可以看出，查看并删除，和查看不删除两者从队头拿数据的逻辑不太一致，从而导致一个会删除，一个不会删除队头数据。</p>
<h4 id="4-1-4-总结"><a href="#4-1-4-总结" class="headerlink" title="4.1.4-总结"></a>4.1.4-总结</h4><p>本文通过 LinkedBlockingQueue 的源码，来介绍了下链表队列，当队列满和空的场景下，新增和删除数据时，队列有啥变化。</p>
<p>队列本身就是一个阻塞工具，我们可以把这个工具应用到各种阻塞场景中，比如说队列应用到线程池，当线程池跑满时，我们把新的请求都放到阻塞队列中等待；队列应用到消息队列，当消费者处理能力有限时，我们可以把消息放到队列中等待，让消费者慢慢消费；每应用到一个新的场景中，都是一个新的技术工具，所以学好队列，用处很大。</p>
<h3 id="4-2-SynchronousQueue-源码解析"><a href="#4-2-SynchronousQueue-源码解析" class="headerlink" title="4.2-SynchronousQueue 源码解析"></a>4.2-SynchronousQueue 源码解析</h3><p>SynchronousQueue 是比较独特的队列，其本身是没有容量大小，比如我放一个数据到队列中，我是不能够立马返回的，我必须等待别人把我放进去的数据消费掉了，才能够返回。SynchronousQueue 在消息队列技术中间件中被大量使用，本文就来从底层实现来看下 SynchronousQueue 到底是如何做到的。</p>
<h4 id="4-2-1-整体架构"><a href="#4-2-1-整体架构" class="headerlink" title="4.2.1-整体架构"></a>4.2.1-整体架构</h4><p>SynchronousQueue 的整体设计比较抽象，在内部抽象出了两种算法实现，一种是先入先出的队列，一种是后入先出的堆栈，两种算法被两个内部类实现，而直接对外的 put，take 方法的实现就非常简单，都是直接调用两个内部类的 transfer 方法进行实现，整体的调用关系如下图所示：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/SynchronousQueue-put%E5%92%8Ctake.jpeg" alt="SynchronousQueue-put和take"></p>
<h5 id="1-类注释-3"><a href="#1-类注释-3" class="headerlink" title="1.类注释"></a>1.类注释</h5><p>源码的类注释往往能给我带来很多疑问和有用的信息，我们来看下类注释都说了什么：</p>
<ol>
<li>队列不存储数据，所以没有大小，也无法迭代；</li>
<li>插入操作的返回必须等待另一个线程完成对应数据的删除操作，反之亦然；</li>
<li>队列由两种数据结构组成，分别是后入先出的堆栈和先入先出的队列，堆栈是非公平的，队列是公平的。</li>
</ol>
<p>看到类注释，大家是不是有一些疑问，比如第二点是如何做到的？堆栈又是如何实现的呢？接下来我们一点一点揭晓。</p>
<h5 id="2-类图"><a href="#2-类图" class="headerlink" title="2.类图"></a>2.类图</h5><p>SynchronousQueue 整体类图和 LinkedBlockingQueue 相似，都是实现了 BlockingQueue 接口，但因为其不储存数据结构，有一些方法是没有实现的，比如说 isEmpty、size、contains、remove 和迭代等方法，这些方法都是默认实现，如下截图：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/SynchronousQueue%E7%9A%84%E6%96%B9%E6%B3%95.jpeg" alt="SynchronousQueue的方法"></p>
<h5 id="3-结构细节"><a href="#3-结构细节" class="headerlink" title="3.结构细节"></a>3.结构细节</h5><p>SynchronousQueue 底层结构和其它队列完全不同，有着独特的两种数据结构：队列和堆栈，我们一起来看下数据结构：</p>
<pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 堆栈和队列共同的接口</span>
    <span class="token comment" spellcheck="true">// 负责执行 put or take</span>
    <span class="token keyword">abstract</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Transferer</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// e 为空的，会直接返回特殊值，不为空会传递给消费者</span>
        <span class="token comment" spellcheck="true">// timed 为 true，说明会有超时时间</span>
        <span class="token keyword">abstract</span> E <span class="token function">transfer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 堆栈 后入先出 非公平</span>
    <span class="token comment" spellcheck="true">// Scherer-Scott 算法</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TransferStack</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Transferer</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 队列 先入先出 公平</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TransferQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Transferer</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> Transferer<span class="token operator">&lt;</span>E<span class="token operator">></span> transferer<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 无参构造器默认为非公平的</span>
    <span class="token keyword">public</span> <span class="token function">SynchronousQueue</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        transferer <span class="token operator">=</span> fair <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">TransferQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">TransferStack</span><span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>从源码中我们可以得到几点：</p>
<ol>
<li>堆栈和队列都有一个共同的接口，叫做 Transferer，该接口有个方法：transfer，该方法很神奇，会承担 take 和 put 的双重功能；</li>
<li>在我们初始化的时候，是可以选择是使用堆栈还是队列的，如果你不选择，默认的就是堆栈，类注释中也说明了这一点，堆栈的效率比队列更高。</li>
</ol>
<p>接下来我们来看下堆栈和队列的具体实现。</p>
<h4 id="4-2-2-非公平的堆栈"><a href="#4-2-2-非公平的堆栈" class="headerlink" title="4.2.2-非公平的堆栈"></a>4.2.2-非公平的堆栈</h4><h5 id="1-堆栈的结构"><a href="#1-堆栈的结构" class="headerlink" title="1.堆栈的结构"></a>1.堆栈的结构</h5><p>首先我们来介绍下堆栈的整体结构，如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E5%A0%86%E6%A0%88%E7%9A%84%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.jpeg" alt="堆栈的整体结构"></p>
<p>从上图中我们可以看到，我们有一个大的堆栈池，池的开口叫做堆栈头，put 的时候，就往堆栈池中放数据。take 的时候，就从堆栈池中拿数据，两者操作都是在堆栈头上操作数据，从图中可以看到，越靠近堆栈头，数据越新，所以每次 take 的时候，都会拿到堆栈头的最新数据，这就是我们说的后入先出，也就是非公平的。</p>
<p>图中 SNode 就是源码中栈元素的表示，我们看下源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SNode</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 栈的下一个，就是被当前栈压在下面的栈元素</span>
    <span class="token keyword">volatile</span> SNode next<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 节点匹配，用来判断阻塞栈元素能被唤醒的时机</span>
    <span class="token comment" spellcheck="true">// 比如我们先执行 take，此时队列中没有数据，take 被阻塞了，栈元素为 SNode1</span>
    <span class="token comment" spellcheck="true">// 当有 put 操作时，会把当前 put 的栈元素赋值给 SNode1 的 match 属性，并唤醒 take 操作</span>
    <span class="token comment" spellcheck="true">// 当 take 被唤醒，发现 SNode1 的 match 属性有值时，就能拿到 put 进来的数据，从而返回</span>
    <span class="token keyword">volatile</span> SNode match<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 栈元素的阻塞是通过线程阻塞来实现的，waiter 为阻塞的线程</span>
    <span class="token keyword">volatile</span> Thread waiter<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 未投递的消息，或者未消费的消息</span>
    Object item<span class="token punctuation">;</span>             
<span class="token punctuation">}</span> </code></pre>
<h5 id="2-入栈和出栈"><a href="#2-入栈和出栈" class="headerlink" title="2.入栈和出栈"></a>2.入栈和出栈</h5><p>入栈指的是使用 put 等方法，把数据放到堆栈池中，出栈指的使用 take 等方法，把数据从堆栈池中拿出来，操作的对象都是堆栈头，虽然两者的一个是从堆栈头拿数据，一个是放数据，但底层实现的方法却是同一个，源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// transfer 方法思路比较复杂，因为 take 和 put 两个方法都揉在了一起</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>
E <span class="token function">transfer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    SNode s <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// constructed/reused as needed</span>
    <span class="token comment" spellcheck="true">// e 为空，说明是 take 方法，不为空是 put 方法</span>
    <span class="token keyword">int</span> mode <span class="token operator">=</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> REQUEST <span class="token operator">:</span> DATA<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 自旋</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 拿出头节点，有几种情况</span>
        <span class="token comment" spellcheck="true">// 1：头节点为空，说明队列中还没有数据</span>
        <span class="token comment" spellcheck="true">// 2：头节点不为空，并且是 take 类型的，说明头节点线程正等着拿数据。</span>
        <span class="token comment" spellcheck="true">// 3：头节点不为空，并且是 put 类型的，说明头节点线程正等着放数据。</span>
        SNode h <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 栈头为空，说明队列中还没有数据。</span>
        <span class="token comment" spellcheck="true">// 栈头不为空，并且栈头的类型和本次操作一致，比如都是 put，那么就把</span>
        <span class="token comment" spellcheck="true">// 本次 put 操作放到该栈头的前面即可，让本次 put 能够先执行</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> null <span class="token operator">||</span> h<span class="token punctuation">.</span>mode <span class="token operator">==</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// empty or same-mode</span>
            <span class="token comment" spellcheck="true">// 设置了超时时间，并且 e 进栈或者出栈要超时了，</span>
            <span class="token comment" spellcheck="true">// 就会丢弃本次操作，返回 null 值。</span>
            <span class="token comment" spellcheck="true">// 如果栈头此时被取消了，丢弃栈头，取下一个节点继续消费</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// can't wait</span>
                <span class="token comment" spellcheck="true">// 栈头操作被取消</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span><span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token comment" spellcheck="true">// 丢弃栈头，把栈头后一个元素作为栈头</span>
                    <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// pop cancelled node</span>
                <span class="token comment" spellcheck="true">//栈头是空的，直接返回 null</span>
                <span class="token keyword">else</span>
                    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 没有超时，直接把 e 作为新的栈头</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token function">snode</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e<span class="token punctuation">,</span> h<span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// e 等待出栈，一种是空队列 take，一种是 put</span>
                SNode m <span class="token operator">=</span> <span class="token function">awaitFulfill</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> timed<span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment" spellcheck="true">// wait was cancelled</span>
                    <span class="token function">clean</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> null<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token comment" spellcheck="true">// 本来 s 是栈头的，现在 s 不是栈头了，s 后面又来了一个数，把新的数据作为栈头</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>next <span class="token operator">==</span> s<span class="token punctuation">)</span>
                    <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> s<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// help s's fulfiller</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">==</span> REQUEST<span class="token punctuation">)</span> <span class="token operator">?</span> m<span class="token punctuation">.</span>item <span class="token operator">:</span> s<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 栈头正在等待其他线程 put 或 take</span>
        <span class="token comment" spellcheck="true">// 比如栈头正在阻塞，并且是 put 类型，而此次操作正好是 take 类型，走此处</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isFulfilling</span><span class="token punctuation">(</span>h<span class="token punctuation">.</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// try to fulfill</span>
            <span class="token comment" spellcheck="true">// 栈头已经被取消，把下一个元素作为栈头</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>h<span class="token punctuation">.</span><span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// already cancelled</span>
                <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> h<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// pop and retry</span>
            <span class="token comment" spellcheck="true">// snode 方法第三个参数 h 代表栈头，赋值给 s 的 next 属性</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token function">snode</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e<span class="token punctuation">,</span> h<span class="token punctuation">,</span> FULFILLING<span class="token operator">|</span>mode<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// loop until matched or waiters disappear</span>
                    <span class="token comment" spellcheck="true">// m 就是栈头，通过上面 snode 方法刚刚赋值</span>
                    SNode m <span class="token operator">=</span> s<span class="token punctuation">.</span>next<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// m is s's match</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// all waiters are gone</span>
                        <span class="token function">casHead</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// pop fulfill node</span>
                        s <span class="token operator">=</span> null<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// use new node next time</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// restart main loop</span>
                    <span class="token punctuation">}</span>
                    SNode mn <span class="token operator">=</span> m<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                     <span class="token comment" spellcheck="true">// tryMatch 非常重要的方法，两个作用：</span>
                     <span class="token comment" spellcheck="true">// 1 唤醒被阻塞的栈头 m，2 把当前节点 s 赋值给 m 的 match 属性</span>
                     <span class="token comment" spellcheck="true">// 这样栈头 m 被唤醒时，就能从 m.match 中得到本次操作 s</span>
                     <span class="token comment" spellcheck="true">// 其中 s.item 记录着本次的操作节点，也就是记录本次操作的数据</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">tryMatch</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        <span class="token function">casHead</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// pop both s and m</span>
                        <span class="token keyword">return</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mode <span class="token operator">==</span> REQUEST<span class="token punctuation">)</span> <span class="token operator">?</span> m<span class="token punctuation">.</span>item <span class="token operator">:</span> s<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">else</span>                  <span class="token comment" spellcheck="true">// lost match</span>
                        s<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// help unlink</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// help a fulfiller</span>
            SNode m <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// m is h's match</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">==</span> null<span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true">// waiter is gone</span>
                <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// pop fulfilling node</span>
            <span class="token keyword">else</span> <span class="token punctuation">{</span>
                SNode mn <span class="token operator">=</span> m<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">tryMatch</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">// help match</span>
                    <span class="token function">casHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// pop both h and m</span>
                <span class="token keyword">else</span>                        <span class="token comment" spellcheck="true">// lost match</span>
                    h<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> mn<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// help unlink</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码中密密麻麻的注释，我们就可以看出来此方法比较复杂，我们总结一下大概的操作思路：</p>
<ol>
<li>判断是 put 方法还是 take 方法；</li>
<li>判断栈头数据是否为空，如果为空或者栈头的操作和本次操作一致，是的话走 3，否则走 5；</li>
<li>判断操作有无设置超时时间，如果设置了超时时间并且已经超时，返回 null，否则走 4；</li>
<li>如果栈头为空，把当前操作设置成栈头，或者栈头不为空，但栈头的操作和本次操作相同，也把当前操作设置成栈头，并看看其它线程能否满足自己，不能满足则阻塞自己。比如当前操作是 take，但队列中没有数据，则阻塞自己；</li>
<li>如果栈头已经是阻塞住的，需要别人唤醒的，判断当前操作能否唤醒栈头，可以唤醒走 6，否则走 4；</li>
<li>把自己当作一个节点，赋值到栈头的 match 属性上，并唤醒栈头节点；</li>
<li>栈头被唤醒后，拿到 match 属性，就是把自己唤醒的节点的信息，返回。</li>
</ol>
<p>在整个过程中，有一个节点阻塞的方法，实现原理如下：</p>
<pre class=" language-java"><code class="language-java">SNode <span class="token function">awaitFulfill</span><span class="token punctuation">(</span>SNode s<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// deadline 死亡时间，如果设置了超时时间的话，死亡时间等于当前时间 + 超时时间，否则就是 0</span>
    <span class="token keyword">final</span> <span class="token keyword">long</span> deadline <span class="token operator">=</span> timed <span class="token operator">?</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> nanos <span class="token operator">:</span> 0L<span class="token punctuation">;</span>
    Thread w <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 自旋的次数，如果设置了超时时间，会自旋 32 次，否则自旋 512 次。</span>
    <span class="token comment" spellcheck="true">// 比如本次操作是 take 操作，自选次数后，仍没有其他线程 put 数据进来</span>
    <span class="token comment" spellcheck="true">// 就会阻塞，有超时时间的，会阻塞固定的时间，否则一致阻塞下去</span>
    <span class="token keyword">int</span> spins <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">shouldSpin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">?</span>
                 <span class="token punctuation">(</span>timed <span class="token operator">?</span> maxTimedSpins <span class="token operator">:</span> maxUntimedSpins<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 当前线程有无被打断，如果过了超时时间，当前线程就会被打断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            s<span class="token punctuation">.</span><span class="token function">tryCancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        SNode m <span class="token operator">=</span> s<span class="token punctuation">.</span>match<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> null<span class="token punctuation">)</span>
            <span class="token keyword">return</span> m<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>timed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            nanos <span class="token operator">=</span> deadline <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 超时了，取消当前线程的等待操作</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&lt;=</span> 0L<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                s<span class="token punctuation">.</span><span class="token function">tryCancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 自选次数减少 1</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>spins <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
            spins <span class="token operator">=</span> <span class="token function">shouldSpin</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>spins<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 把当前线程设置成 waiter，主要是通过线程来完成阻塞和唤醒</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>waiter <span class="token operator">==</span> null<span class="token punctuation">)</span>
            s<span class="token punctuation">.</span>waiter <span class="token operator">=</span> w<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// establish waiter so can park next iter</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span>
            <span class="token comment" spellcheck="true">// 通过 park 进行阻塞，这个我们在锁章节中会说明</span>
            LockSupport<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">></span> spinForTimeoutThreshold<span class="token punctuation">)</span>
            LockSupport<span class="token punctuation">.</span><span class="token function">parkNanos</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>从节点阻塞代码中，我们可以发现，其阻塞的策略，并不是一上来就阻塞住，而是在自旋一定次数后，仍然没有其它线程来满足自己的要求时，才会真正的阻塞住。</p>
<h4 id="4-2-3-公平的队列"><a href="#4-2-3-公平的队列" class="headerlink" title="4.2.3-公平的队列"></a>4.2.3-公平的队列</h4><p>首先我们来看一下队列中的每个元素的组成：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 队列头 */</span>
<span class="token keyword">transient</span> <span class="token keyword">volatile</span> QNode head<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">/** 队列尾 */</span>
<span class="token keyword">transient</span> <span class="token keyword">volatile</span> QNode tail<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 队列的元素</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">QNode</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 当前元素的下一个元素</span>
    <span class="token keyword">volatile</span> QNode next<span class="token punctuation">;</span>         
    <span class="token comment" spellcheck="true">// 当前元素的值，如果当前元素被阻塞住了，等其他线程来唤醒自己时，其他线程</span>
    <span class="token comment" spellcheck="true">// 会把自己 set 到 item 里面</span>
    <span class="token keyword">volatile</span> Object item<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// CAS'ed to or from null</span>
    <span class="token comment" spellcheck="true">// 可以阻塞住的当前线程</span>
    <span class="token keyword">volatile</span> Thread waiter<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// to control park/unpark</span>
    <span class="token comment" spellcheck="true">// true 是 put，false 是 take</span>
    <span class="token keyword">final</span> <span class="token keyword">boolean</span> isData<span class="token punctuation">;</span>
<span class="token punctuation">}</span>  </code></pre>
<p>公平的队列主要使用的是 TransferQueue 内部类的 transfer 方法，我们一起来看下源码：</p>
<pre class=" language-java"><code class="language-java">E <span class="token function">transfer</span><span class="token punctuation">(</span>E e<span class="token punctuation">,</span> <span class="token keyword">boolean</span> timed<span class="token punctuation">,</span> <span class="token keyword">long</span> nanos<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    QNode s <span class="token operator">=</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// constructed/reused as needed</span>
    <span class="token comment" spellcheck="true">// true 是 put，false 是 get</span>
    <span class="token keyword">boolean</span> isData <span class="token operator">=</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 队列头和尾的临时变量,队列是空的时候，t=h</span>
        QNode t <span class="token operator">=</span> tail<span class="token punctuation">;</span>
        QNode h <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// tail 和 head 没有初始化时，无限循环</span>
        <span class="token comment" spellcheck="true">// 虽然这种 continue 非常耗cpu，但感觉不会碰到这种情况</span>
        <span class="token comment" spellcheck="true">// 因为 tail 和 head 在 TransferQueue 初始化的时候，就已经被赋值空节点了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> null <span class="token operator">||</span> h <span class="token operator">==</span> null<span class="token punctuation">)</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 首尾节点相同，说明是空队列</span>
        <span class="token comment" spellcheck="true">// 或者尾节点的操作和当前节点操作一致</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> t <span class="token operator">||</span> t<span class="token punctuation">.</span>isData <span class="token operator">==</span> isData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            QNode tn <span class="token operator">=</span> t<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 当 t 不是 tail 时，说明 tail 已经被修改过了</span>
            <span class="token comment" spellcheck="true">// 因为 tail 没有被修改的情况下，t 和 tail 必然相等</span>
            <span class="token comment" spellcheck="true">// 因为前面刚刚执行赋值操作： t = tail</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> tail<span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 队尾后面的值还不为空，t 还不是队尾，直接把 tn 赋值给 t，这是一步加强校验。</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>tn <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">advanceTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> tn<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">//超时直接返回 null</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>timed <span class="token operator">&amp;&amp;</span> nanos <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// can't wait</span>
                <span class="token keyword">return</span> null<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//构造node节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null<span class="token punctuation">)</span>
                s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> isData<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//如果把 e 放到队尾失败，继续递归放进去</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span><span class="token function">casNext</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// failed to link in</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>

            <span class="token function">advanceTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// swing tail and wait</span>
            <span class="token comment" spellcheck="true">// 阻塞住自己</span>
            Object x <span class="token operator">=</span> <span class="token function">awaitFulfill</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> e<span class="token punctuation">,</span> timed<span class="token punctuation">,</span> nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">// wait was cancelled</span>
                <span class="token function">clean</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> null<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">isOffList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment" spellcheck="true">// not already unlinked</span>
                <span class="token function">advanceHead</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// unlink if head</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null<span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">// and forget fields</span>
                    s<span class="token punctuation">.</span>item <span class="token operator">=</span> s<span class="token punctuation">;</span>
                s<span class="token punctuation">.</span>waiter <span class="token operator">=</span> null<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span>x <span class="token operator">:</span> e<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 队列不为空，并且当前操作和队尾不一致</span>
        <span class="token comment" spellcheck="true">// 也就是说当前操作是队尾是对应的操作</span>
        <span class="token comment" spellcheck="true">// 比如说队尾是因为 take 被阻塞的，那么当前操作必然是 put</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// complementary-mode</span>
            <span class="token comment" spellcheck="true">// 如果是第一次执行，此处的 m 代表就是 tail</span>
            <span class="token comment" spellcheck="true">// 也就是这行代码体现出队列的公平，每次操作时，从头开始按照顺序进行操作</span>
            QNode m <span class="token operator">=</span> h<span class="token punctuation">.</span>next<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">// node to fulfill</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">!=</span> tail <span class="token operator">||</span> m <span class="token operator">==</span> null <span class="token operator">||</span> h <span class="token operator">!=</span> head<span class="token punctuation">)</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// inconsistent read</span>

            Object x <span class="token operator">=</span> m<span class="token punctuation">.</span>item<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>isData <span class="token operator">==</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">||</span>    <span class="token comment" spellcheck="true">// m already fulfilled</span>
                x <span class="token operator">==</span> m <span class="token operator">||</span>                   <span class="token comment" spellcheck="true">// m cancelled</span>
                <span class="token comment" spellcheck="true">// m 代表栈头</span>
                <span class="token comment" spellcheck="true">// 这里把当前的操作值赋值给阻塞住的 m 的 item 属性</span>
                <span class="token comment" spellcheck="true">// 这样 m 被释放时，就可得到此次操作的值</span>
                <span class="token operator">!</span>m<span class="token punctuation">.</span><span class="token function">casItem</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">// lost CAS</span>
                <span class="token function">advanceHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// dequeue and retry</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment" spellcheck="true">// 当前操作放到队头</span>
            <span class="token function">advanceHead</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// successfully fulfilled</span>
            <span class="token comment" spellcheck="true">// 释放队头阻塞节点</span>
            LockSupport<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>waiter<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span>x <span class="token operator">:</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>源码比较复杂，我们需要搞清楚的是，线程被阻塞住后，当前线程是如何把自己的数据传给阻塞线程的。为了方便说明，我们假设线程 1 往队列中 take 数据 ，被阻塞住了，变成阻塞线程 A ，然后线程 2 开始往队列中 put 数据 B，大致的流程是这样的：</p>
<ol>
<li>线程 1 从队列中拿数据，发现队列中没有数据，于是被阻塞，成为 A ；</li>
<li>线程 2 往队尾 put 数据，会从队尾往前找到第一个被阻塞的节点，假设此时能找到的就是节点 A，然后线程 B 把将 put 的数据放到节点 A 的 item 属性里面，并唤醒线程 1；</li>
<li>线程 1 被唤醒后，就能从 A.item 里面拿到线程 2 put 的数据了，线程 1 成功返回。</li>
</ol>
<p>从这个过程中，我们能看出公平主要体现在，每次 put 数据的时候，都 put 到队尾上，而每次拿数据时，并不是直接从堆头拿数据，而是从队尾往前寻找第一个被阻塞的线程，这样就会按照顺序释放被阻塞的线程。</p>
<h4 id="4-2-4-总结"><a href="#4-2-4-总结" class="headerlink" title="4.2.4-总结"></a>4.2.4-总结</h4><p>SynchronousQueue 源码比较复杂，建议大家进行源码的 debug 来学习源码，为大家准备了调试类：SynchronousQueueDemo，大家可以下载源码自己调试一下，这样学起来应该会更加轻松一点。</p>
<h3 id="4-3-DelayQueue-源码解析"><a href="#4-3-DelayQueue-源码解析" class="headerlink" title="4.3-DelayQueue 源码解析"></a>4.3-DelayQueue 源码解析</h3><p>之前我们说的阻塞队列，都是资源足够时立马执行。本章我们说的队列比较特殊，是一种延迟队列，意思是延迟执行，并且可以设置延迟多久之后执行，比如设置过 5 秒钟之后再执行，在一些延迟执行的场景被大量使用，比如说延迟对账等等。</p>
<h4 id="4-3-1-整体架构"><a href="#4-3-1-整体架构" class="headerlink" title="4.3.1-整体架构"></a>4.3.1-整体架构</h4><p>DelayQueue 延迟队列底层使用的是锁的能力，比如说要在当前时间往后延迟 5 秒执行，那么当前线程就会沉睡 5 秒，等 5 秒后线程被唤醒时，如果能获取到资源的话，线程即可立马执行。原理上似乎很简单，但内部实现却很复杂，有很多难点，比如当运行资源不够，多个线程同时被唤醒时，如何排队等待？比如说在何时阻塞？何时开始执行等等？接下来我们从源码角度来看下是如何实现的。</p>
<h5 id="1-类注释-4"><a href="#1-类注释-4" class="headerlink" title="1.类注释"></a>1.类注释</h5><p>类注释上比较简单，只说了三个概念：</p>
<ol>
<li>队列中元素将在过期时被执行，越靠近队头，越早过期；</li>
<li>未过期的元素不能够被 take；</li>
<li>不允许空元素。</li>
</ol>
<p>这三个概念，其实就是三个问题，下文我们会一一看下这三点是如何实现的。</p>
<h5 id="2-类图-1"><a href="#2-类图-1" class="headerlink" title="2.类图"></a>2.类图</h5><p>DelayQueue 的类图和之前的队列一样，不多说，关键是 DelayQueue 类上是有泛型的，如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayQueue</span><span class="token operator">&lt;</span>E <span class="token keyword">extends</span> <span class="token class-name">Delayed</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span>
    <span class="token keyword">implements</span> <span class="token class-name">BlockingQueue</span><span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token punctuation">{</span></code></pre>
<p>从泛型中可以看出，DelayQueue 中的元素必须是 Delayed 的子类，Delayed 是表达延迟能力的关键接口，其继承了 Comparable 接口，并定义了还剩多久过期的方法，如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Delayed</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>Delayed<span class="token operator">></span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> <span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>也就是说 DelayQueue 队列中的元素必须是实现 Delayed 接口和 Comparable 接口的，并覆写了 getDelay 方法和 compareTo 的方法才行，不然在编译时，编译器就会提醒我们元素必须强制实现 Delayed 接口。</p>
<p>除此之外 DelayQueue 还大量使用了 PriorityQueue 队列的大量功能，这个和 SynchronousQueue 队列很像，大量复用了其它基础类的逻辑，代码示例如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/DelayQueue-poll.jpeg" alt="DelayQueue-poll"></p>
<p>PriorityQueue 中文叫做优先级队列，在此处的作用就是可以根据过期时间做优先级排序，让先过期的可以先执行，用来实现类注释中的第一点。</p>
<p>这里的复用的思想还是蛮重要的，我们在源码中经常会遇到这种思想，比如说 LinkedHashMap 复用 HashMap 的能力，Set 复用 Map 的能力，还有此处的 DelayQueue 复用 PriorityQueue 的能力。小结一下，如果想要复用需要做到哪些：</p>
<ol>
<li>需要把能遇见可复用的功能尽量抽象，并开放出可扩展的地方，比如说 HashMap 在操作数组的方法中，都给 LinkedHashMap 开放出很多 after 开头的方法，便于 LinkedHashMap 进行排序、删除等等；</li>
<li>采用组合或继承两种手段进行复用，比如 LinkedHashMap 采用的继承、 Set 和 DelayQueue 采用的组合，组合的意思就是把可复用的类给依赖进来。</li>
</ol>
<h5 id><a href="#" class="headerlink" title></a></h5><h4 id="4-3-2-演示"><a href="#4-3-2-演示" class="headerlink" title="4.3.2-演示"></a>4.3.2-演示</h4><p>为了方便大家理解，写了一个演示的 demo，演示了一下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DelayQueueDemo</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 队列消息的生产者</span>
  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue queue<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">Product</span><span class="token punctuation">(</span>BlockingQueue queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"begin put"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> beginTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DelayedDTO</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> 2000L<span class="token punctuation">,</span>beginTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延迟 2 秒执行</span>
        queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DelayedDTO</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> 5000L<span class="token punctuation">,</span>beginTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延迟 5 秒执行</span>
        queue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DelayedDTO</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> 1000L <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">,</span>beginTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//延迟 10 秒执行</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"end put"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// 队列的消费者</span>
  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue queue<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">Consumer</span><span class="token punctuation">(</span>BlockingQueue queue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>queue <span class="token operator">=</span> queue<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Consumer begin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>DelayedDTO<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>DelayedDTO<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">(</span><span class="token punctuation">(</span>DelayedDTO<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Consumer end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token annotation punctuation">@Data</span>
  <span class="token comment" spellcheck="true">// 队列元素，实现了 Delayed 接口</span>
  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DelayedDTO</span> <span class="token keyword">implements</span> <span class="token class-name">Delayed</span> <span class="token punctuation">{</span>
    Long s<span class="token punctuation">;</span>
    Long beginTime<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token function">DelayedDTO</span><span class="token punctuation">(</span>Long s<span class="token punctuation">,</span>Long beginTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>s <span class="token operator">=</span> s<span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>beginTime <span class="token operator">=</span>beginTime<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> unit<span class="token punctuation">.</span><span class="token function">convert</span><span class="token punctuation">(</span>s <span class="token operator">-</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span>Delayed o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span> <span class="token operator">-</span> o<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"现在已经过了{}秒钟"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> beginTime<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// demo 运行入口</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    BlockingQueue q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelayQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    DelayQueueDemo<span class="token punctuation">.</span>Product p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelayQueueDemo<span class="token punctuation">.</span>Product</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    DelayQueueDemo<span class="token punctuation">.</span>Consumer c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DelayQueueDemo<span class="token punctuation">.</span>Consumer</span><span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
打印出来的结果如下：
<span class="token number">06</span><span class="token operator">:</span><span class="token number">57</span><span class="token operator">:</span><span class="token number">50.544</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">]</span> Consumer begin
<span class="token number">06</span><span class="token operator">:</span><span class="token number">57</span><span class="token operator">:</span><span class="token number">50.544</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> begin put
<span class="token number">06</span><span class="token operator">:</span><span class="token number">57</span><span class="token operator">:</span><span class="token number">50.551</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> end put
<span class="token number">06</span><span class="token operator">:</span><span class="token number">57</span><span class="token operator">:</span><span class="token number">52.554</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">]</span> 延迟了<span class="token number">2</span>秒钟才执行
<span class="token number">06</span><span class="token operator">:</span><span class="token number">57</span><span class="token operator">:</span><span class="token number">55.555</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">]</span> 延迟了<span class="token number">5</span>秒钟才执行
<span class="token number">06</span><span class="token operator">:</span><span class="token number">58</span><span class="token operator">:</span><span class="token number">00.555</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">]</span> 延迟了<span class="token number">10</span>秒钟才执行
<span class="token number">06</span><span class="token operator">:</span><span class="token number">58</span><span class="token operator">:</span><span class="token number">00.556</span> <span class="token punctuation">[</span>Thread<span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">]</span> Consumer end</code></pre>
<p>写这个代码的目的主要想演示一下延迟执行的例子，我们大概的思路是：</p>
<ol>
<li>新建队列的元素，如 DelayedDTO，必须实现 Delayed 接口，我们在 getDelay 方法中实现了现在离过期时间还剩多久的方法。</li>
<li>定义队列元素的生产者，和消费者，对应着代码中的 Product 和 Consumer。</li>
<li>对生产者和消费者就行初始化和管理，对应着我们的 main 方法。</li>
</ol>
<p>虽然这只是一个简单的 demo，但实际工作中，我们使用 DelayQueue 基本上就是这种思想，只不过写代码的时候会更加通用和周全，接下来我们来看下 DelayQueue 是如何实现 put 和 take 的。</p>
<h4 id="4-3-3-放数据"><a href="#4-3-3-放数据" class="headerlink" title="4.3.3-放数据"></a>4.3.3-放数据</h4><p>我们以 put 为例，put 调用的是 offer 的方法，offer 的源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 上锁</span>
    lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 使用 PriorityQueue 的扩容，排序等能力</span>
        q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果恰好刚放进去的元素正好在队列头</span>
        <span class="token comment" spellcheck="true">// 立马唤醒 take 的阻塞线程，执行 take 操作</span>
        <span class="token comment" spellcheck="true">// 如果元素需要延迟执行的话，可以使其更快的沉睡计时</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            leader <span class="token operator">=</span> null<span class="token punctuation">;</span>
            available<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 释放锁</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>可以看到其实底层使用到的是 PriorityQueue 的 offer 方法，我们来看下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 新增元素</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">offer</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 如果是空元素的话，抛异常</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> null<span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    modCount<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 队列实际大小大于容量时，进行扩容</span>
    <span class="token comment" spellcheck="true">// 扩容策略是：如果老容量小于 64，2 倍扩容，如果大于 64，50 % 扩容</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        <span class="token function">grow</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    size <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 如果队列为空，当前元素正好处于队头</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token comment" spellcheck="true">// 如果队列不为空，需要根据优先级进行排序</span>
        <span class="token function">siftUp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 按照从小到大的顺序排列</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">siftUpComparable</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span> key <span class="token operator">=</span> <span class="token punctuation">(</span>Comparable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> E<span class="token operator">></span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// k 是当前队列实际大小的位置</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 对 k 进行减倍</span>
            <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>>></span> <span class="token number">1</span><span class="token punctuation">;</span>
            Object e <span class="token operator">=</span> queue<span class="token punctuation">[</span>parent<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 如果 x 比 e 大，退出，把 x 放在 k 位置上</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token punctuation">(</span>E<span class="token punctuation">)</span> e<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// x 比 e 小，继续循环，直到找到 x 比队列中元素大的位置</span>
            queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
            k <span class="token operator">=</span> parent<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        queue<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>可以看到，PriorityQueue 的 offer 方法主要做了三件事情：</p>
<ol>
<li>对新增元素进行判空；</li>
<li>对队列进行扩容，扩容策略和集合的扩容策略很相近；</li>
<li>根据元素的 compareTo 方法进行排序，我们希望最终排序的结果是从小到大的，因为我们想让队头的都是过期的数据，我们需要在 compareTo 方法里面实现：通过每个元素的过期时间进行排序，如下：</li>
</ol>
<pre class=" language-java"><code class="language-java"><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span> <span class="token operator">-</span> o<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这样便可实现越快过期的元素越能排到队头。</p>
<p>可以看到，新增数据时，只是使用到了 compareTo 方法，来对队列中的元素进行排序，接下来我们看下，取数据时，是如何操作的。</p>
<h4 id="4-3-4-取数据"><a href="#4-3-4-取数据" class="headerlink" title="4.3.4-取数据"></a>4.3.4-取数据</h4><p>取数据时，如果发现有元素的过期时间到了，就能拿出数据来，如果没有过期元素，那么线程就会一直阻塞，我们以 take 为例子，来看一下核心源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 从队头中拿数据出来</span>
    E first <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 如果为空，说明队列中，没有数据，阻塞住</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> null<span class="token punctuation">)</span>
        available<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 获取队头数据的过期时间</span>
        <span class="token keyword">long</span> delay <span class="token operator">=</span> first<span class="token punctuation">.</span><span class="token function">getDelay</span><span class="token punctuation">(</span>NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 如果过期了，直接返回队头数据</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 引用置为 null ，便于 gc，这样可以让线程等待时，回收 first 变量</span>
        first <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// leader 不为空的话，表示当前队列元素之前已经被设置过阻塞时间了</span>
        <span class="token comment" spellcheck="true">// 直接阻塞当前线程等待。</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">!=</span> null<span class="token punctuation">)</span>
            available<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">// 之前没有设置过阻塞时间，按照一定的时间进行阻塞</span>
            Thread thisThread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            leader <span class="token operator">=</span> thisThread<span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 进行阻塞</span>
                available<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>leader <span class="token operator">==</span> thisThread<span class="token punctuation">)</span>
                    leader <span class="token operator">=</span> null<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>可以看到阻塞等待的功能底层使用的是锁的能力，这个我们在后面章节中会说到。</p>
<p>以上演示的 take 方法是会无限阻塞，直到队头的过期时间到了才会返回，如果不想无限阻塞，可以尝试 poll 方法，设置超时时间，在超时时间内，队头元素还没有过期的话，就会返回 null。</p>
<h5 id="4-3-5-总结"><a href="#4-3-5-总结" class="headerlink" title="4.3.5-总结"></a>4.3.5-总结</h5><p>DelayQueue 是非常有意思的队列，底层使用了排序和超时阻塞实现了延迟队列，排序使用的是 PriorityQueue 排序能力，超时阻塞使用得是锁的等待能力，可以看出 DelayQueue 其实就是为了满足延迟执行的场景，在已有 API 的基础上进行了封装，我们在工作中，可以学习这种思想，对已有的功能能复用的尽量复用，减少开发的工作量。</p>
<h3 id="4-4-ArrayBlockingQueue-源码解析"><a href="#4-4-ArrayBlockingQueue-源码解析" class="headerlink" title="4.4-ArrayBlockingQueue 源码解析"></a>4.4-ArrayBlockingQueue 源码解析</h3><p>本小节我们来介绍本章最后一个队列：ArrayBlockingQueue。按照字面翻译，中文叫做数组阻塞队列，从名称上看，我们就比较清楚此阻塞队列底层使用的是数组。一说到数组，大家可能会想到 ArrayList 和 HashMap，举新增场景来说 ArrayList 通过 size ++ 找到新增的数组下标位置，HashMap 通过 hash 算法计算出下标位置，那么 ArrayBlockingQueue 是不是也是这两种方法呢？都不是，ArrayBlockingQueue 使用的是一种非常奇妙的方式，我们一起拭目以待。</p>
<p>全文为了方便说明，队头的说法就是数组头，队尾的说法就是数组尾。</p>
<h4 id="4-4-1-整体架构"><a href="#4-4-1-整体架构" class="headerlink" title="4.4.1-整体架构"></a>4.4.1-整体架构</h4><p>我们从类注释上可以得到一些有用的信息：</p>
<h5 id="1-类注释-5"><a href="#1-类注释-5" class="headerlink" title="1.类注释"></a>1.类注释</h5><ol>
<li>有界的阻塞数组，容量一旦创建，后续大小无法修改；</li>
<li>元素是有顺序的，按照先入先出进行排序，从队尾插入数据数据，从队头拿数据；</li>
<li>队列满时，往队列中 put 数据会被阻塞，队列空时，往队列中拿数据也会被阻塞。</li>
</ol>
<p>从类注释上可以看出 ArrayBlockingQueue 和一般的数组结构的类不太一样，是不能够动态扩容的，如果队列满了或者空时，take 和 put 都会被阻塞。</p>
<h5 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 队列存放在 object 的数组里面</span>
<span class="token comment" spellcheck="true">// 数组大小必须在初始化的时候手动设置，没有默认大小</span>
<span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 下次拿数据的时候的索引位置</span>
<span class="token keyword">int</span> takeIndex<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 下次放数据的索引位置</span>
<span class="token keyword">int</span> putIndex<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 当前已有元素的大小</span>
<span class="token keyword">int</span> count<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 可重入的锁</span>
<span class="token keyword">final</span> ReentrantLock lock<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// take的队列</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> Condition notEmpty<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// put的队列</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> Condition notFull<span class="token punctuation">;</span></code></pre>
<p>以上代码有两个关键的字段，takeIndex 和 putIndex，分别表示下次拿数据和放数据的索引位置。所以说在新增数据和拿数据时，都无需计算，就能知道应该新增到什么位置，应该从什么位置拿数据。</p>
<h4 id="4-4-2-初始化"><a href="#4-4-2-初始化" class="headerlink" title="4.4.2-初始化"></a>4.4.2-初始化</h4><p>初始化时，有两个重要的参数：数组的大小、是否是公平，源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">ArrayBlockingQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">,</span> <span class="token keyword">boolean</span> fair<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>capacity <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span>fair<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 队列不为空 Condition，在 put 成功时使用</span>
    notEmpty <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 队列不满 Condition，在 take 成功时使用</span>
    notFull <span class="token operator">=</span>  lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码中我们可以看出，第二个参数是否公平，主要用于读写锁是否公平，如果是公平锁，那么在锁竞争时，就会按照先来先到的顺序，如果是非公平锁，锁竞争时随机的。</p>
<p>对于锁公平和非公平，我们举个例子：比如说现在队列是满的，还有很多线程执行 put 操作，必然会有很多线程阻塞等待，当有其它线程执行 take 时，会唤醒等待的线程，如果是公平锁，会按照阻塞等待的先后顺序，依次唤醒阻塞的线程，如果是非公平锁，会随机唤醒沉睡的线程。</p>
<p>所以说队列满很多线程执行 put 操作时，如果是公平锁，数组元素新增的顺序就是阻塞线程被释放的先后顺序，是有顺序的，而非公平锁，由于阻塞线程被释放的顺序是随机的，所以元素插入到数组的顺序也就不会按照插入的顺序了。</p>
<p>队列空时，也是一样的道理。</p>
<p>ArrayBlockingQueue 通过锁的公平和非公平，轻松实现了数组元素的插入顺序的问题。如果要实现这个功能，你会怎么做呢？会想到利用锁的功能么？其实这种思想我们在文中多次提到，当我们需要完成一件事情时，首先看看已有的 API 能不能满足，如果可以的话，通过继承和组合的方式来实现，ArrayBlockingQueue 就是组合了锁的功能。</p>
<p>初始化时，如果给定了原始数据的话，一定要注意原始数据的大小一定要小于队列的容量，否则会抛异常，如下图所示：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayBlockingQueue%E6%8A%9B%E5%BC%82%E5%B8%B8.jpeg" alt="ArrayBlockingQueue抛异常"></p>
<p>我们写了一个 demo，报错如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E6%B5%8B%E8%AF%95ArrayBlockingQueue%E6%8A%9B%E5%BC%82%E5%B8%B8.jpeg" alt="测试ArrayBlockingQueue抛异常"></p>
<h4 id="4-4-3-新增数据"><a href="#4-4-3-新增数据" class="headerlink" title="4.4.3-新增数据"></a>4.4.3-新增数据</h4><p>数据新增都会按照 putIndex 的位置进行新增，源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 新增，如果队列满，无限阻塞</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 元素不能为空</span>
    <span class="token function">checkNotNull</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 队列如果是满的，就无限等待</span>
        <span class="token comment" spellcheck="true">// 一直等待队列中有数据被拿走时，自己被唤醒</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
            notFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">enqueue</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">enqueue</span><span class="token punctuation">(</span>E x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// assert lock.getHoldCount() == 1; 同一时刻只能一个线程进行操作此方法</span>
    <span class="token comment" spellcheck="true">// assert items[putIndex] == null;</span>
    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// putIndex 为本次插入的位置</span>
    items<span class="token punctuation">[</span>putIndex<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ++ putIndex 计算下次插入的位置</span>
    <span class="token comment" spellcheck="true">// 如果下次插入的位置，正好等于队尾，下次插入就从 0 开始</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>putIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        putIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 唤醒因为队列空导致的等待线程</span>
    notEmpty<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码中，我们可以看出，其实新增就两种情况：</p>
<ol>
<li><p>本次新增的位置居中，直接新增，下图演示的是 putIndex 在数组下标为 5 的位置，还不到队尾，那么可以直接新增，计算下次新增的位置应该是 6；</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayBlockingQueue-%E6%96%B0%E5%A2%9E1.jpeg" alt="ArrayBlockingQueue-新增1"></p>
</li>
<li><p>新增的位置到队尾了，那么下次新增时就要从头开始了，示意图如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayBlockingQueue-%E6%96%B0%E5%A2%9E2.jpeg" alt="ArrayBlockingQueue-新增2"></p>
</li>
</ol>
<p>上面这张图演示的就是这行代码：<code>if (++putIndex == items.length) putIndex = 0;</code></p>
<p>可以看到当新增到队尾时，下次新增会重新从队头重新开始。</p>
<h4 id="4-4-4-取数据"><a href="#4-4-4-取数据" class="headerlink" title="4.4.4-取数据"></a>4.4.4-取数据</h4><p>拿数据都是从队头开始拿数据，源码如下：</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> E <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
    <span class="token keyword">final</span> ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>
    lock<span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果队列为空，无限等待</span>
        <span class="token comment" spellcheck="true">// 直到队列中有数据被 put 后，自己被唤醒</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            notEmpty<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 从队列中拿数据</span>
        <span class="token keyword">return</span> <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> E <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// takeIndex 代表本次拿数据的位置，是上一次拿数据时计算好的</span>
    E x <span class="token operator">=</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 帮助 gc</span>
    items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// ++ takeIndex 计算下次拿数据的位置</span>
    <span class="token comment" spellcheck="true">// 如果正好等于队尾的话，下次就从 0 开始拿数据</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
        takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 队列实际大小减 1</span>
    count<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> null<span class="token punctuation">)</span>
        itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 唤醒被队列满所阻塞的线程</span>
    notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>从源码中可以看出，每次拿数据的位置就是 takeIndex 的位置，在找到本次该拿的数据之后，会把 takeIndex 加 1，计算下次拿数据时的索引位置，有个特殊情况是，如果本次拿数据的位置已经是队尾了，那么下次拿数据的位置就要从头开始，就是从 0 开始了。</p>
<h4 id="4-4-5-删除数据"><a href="#4-4-5-删除数据" class="headerlink" title="4.4.5-删除数据"></a>4.4.5-删除数据</h4><p>删除数据很有意思，我们一起来看下核心源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 一共有两种情况：</span>
<span class="token comment" spellcheck="true">// 1：删除位置和 takeIndex 的关系：删除位置和 takeIndex 一样，比如 takeIndex 是 2， 而要删除的位置正好也是 2，那么就把位置 2 的数据置为 null ,并重新计算 takeIndex 为 3。</span>
<span class="token comment" spellcheck="true">// 2：找到要删除元素的下一个，计算删除元素和 putIndex 的关系</span>
<span class="token comment" spellcheck="true">// 如果下一个元素不是 putIndex，就把下一个元素往前移动一位</span>
<span class="token comment" spellcheck="true">// 如果下一个元素是 putIndex，把 putIndex 的值修改成删除的位置</span>
<span class="token keyword">void</span> <span class="token function">removeAt</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> removeIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> items <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 情况1 如果删除位置正好等于下次要拿数据的位置</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>removeIndex <span class="token operator">==</span> takeIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 下次要拿数据的位置直接置空</span>
        items<span class="token punctuation">[</span>takeIndex<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 要拿数据的位置往后移动一位</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>takeIndex <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
            takeIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 当前数组的大小减一</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> null<span class="token punctuation">)</span>
            itrs<span class="token punctuation">.</span><span class="token function">elementDequeued</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 情况 2</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token keyword">int</span> putIndex <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>putIndex<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> removeIndex<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 找到要删除元素的下一个</span>
            <span class="token keyword">int</span> next <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">==</span> items<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
                next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 下一个元素不是 putIndex</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">!=</span> putIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 下一个元素往前移动一位</span>
                items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>next<span class="token punctuation">]</span><span class="token punctuation">;</span>
                i <span class="token operator">=</span> next<span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 下一个元素是 putIndex</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 删除元素</span>
                items<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// 下次放元素时，应该从本次删除的元素放</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>putIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>itrs <span class="token operator">!=</span> null<span class="token punctuation">)</span>
            itrs<span class="token punctuation">.</span><span class="token function">removedAt</span><span class="token punctuation">(</span>removeIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    notFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>删除数据的情况比较复杂，一共有两种情况，第一种情况是 <code>takeIndex == removeIndex</code>，我们画个示意图来看下处理方式：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayBlockingQueue-%E5%88%A0%E9%99%A41.jpeg" alt="ArrayBlockingQueue-删除1"></p>
<p>第二种情况又分两种：</p>
<ol>
<li><p>如果 removeIndex + 1 != putIndex 的话，就把下一个元素往前移动一位，示意图如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayBlockingQueue-%E5%88%A0%E9%99%A42.jpeg" alt="ArrayBlockingQueue-删除2"></p>
</li>
<li><p>如果 removeIndex + 1 == putIndex 的话，就把 putIndex 的值修改成删除的位置，示意图如下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/ArrayBlockingQueue-%E5%88%A0%E9%99%A43.jpeg" alt="ArrayBlockingQueue-删除3"></p>
</li>
</ol>
<p>ArrayBlockingQueue 的删除方法其实还蛮复杂的，需要考虑到很多特殊的场景。</p>
<h4 id="4-4-6-总结"><a href="#4-4-6-总结" class="headerlink" title="4.4.6-总结"></a>4.4.6-总结</h4><p>ArrayBlockingQueue 底层是有界的数组，整体来说，和其它队列差别不多，需要注意的是，当 takeIndex、putIndex 到队尾的时候，都会重新从 0 开始循环，这点是比较特殊的，在我们学习源码时，需要特别注意。</p>
<h3 id="4-5-队列在源码方面的面试题"><a href="#4-5-队列在源码方面的面试题" class="headerlink" title="4.5-队列在源码方面的面试题"></a>4.5-队列在源码方面的面试题</h3><p>队列在源码方面的面试题，一般面试官会从锁，线程池等知识点作为问题入口，慢慢的问到队列，由于锁、线程池咱们还没有学习到，所以本章就直奔主题，从队列入手，看看队列都有哪些面试题（队列种类很多，本文在说队列的通用特征时，都是在说其大部分队列的通用特征，如有某种队列特征不符，不在一一说明）。</p>
<h4 id="4-5-1-面试题"><a href="#4-5-1-面试题" class="headerlink" title="4.5.1-面试题"></a>4.5.1-面试题</h4><h5 id="1-说说你对队列的理解，队列和集合的区别。"><a href="#1-说说你对队列的理解，队列和集合的区别。" class="headerlink" title="1.说说你对队列的理解，队列和集合的区别。"></a>1.说说你对队列的理解，队列和集合的区别。</h5><p>答：对队列的理解：</p>
<ol>
<li>首先队列本身也是个容器，底层也会有不同的数据结构，比如 LinkedBlockingQueue 是底层是链表结构，所以可以维持先入先出的顺序，比如 DelayQueue 底层可以是队列或堆栈，所以可以保证先入先出，或者先入后出的顺序等等，底层的数据结构不同，也造成了操作实现不同；</li>
<li>部分队列（比如 LinkedBlockingQueue ）提供了暂时存储的功能，我们可以往队列里面放数据，同时也可以从队列里面拿数据，两者可以同时进行；</li>
<li>队列把生产数据的一方和消费数据的一方进行解耦，生产者只管生产，消费者只管消费，两者之间没有必然联系，队列就像生产者和消费者之间的数据通道一样，如 LinkedBlockingQueue；</li>
<li>队列还可以对消费者和生产者进行管理，比如队列满了，有生产者还在不停投递数据时，队列可以使生产者阻塞住，让其不再能投递，比如队列空时，有消费者过来拿数据时，队列可以让消费者 hodler 住，等有数据时，唤醒消费者，让消费者拿数据返回，如 ArrayBlockingQueue；</li>
<li>队列还提供阻塞的功能，比如我们从队列拿数据，但队列中没有数据时，线程会一直阻塞到队列有数据可拿时才返回。</li>
</ol>
<p>队列和集合的区别：</p>
<ol>
<li>和集合的相同点，队列（部分例外）和集合都提供了数据存储的功能，底层的储存数据结构是有些相似的，比如说 LinkedBlockingQueue 和 LinkedHashMap 底层都使用的是链表，ArrayBlockingQueue 和 ArrayList 底层使用的都是数组。</li>
<li>和集合的区别：<ul>
<li>部分队列和部分集合底层的存储结构很相似的，但两者为了完成不同的事情，提供的 API 和其底层的操作实现是不同的。</li>
<li>队列提供了阻塞的功能，能对消费者和生产者进行简单的管理，队列空时，会阻塞消费者，有其他线程进行 put 操作后，会唤醒阻塞的消费者，让消费者拿数据进行消费，队列满时亦然。</li>
<li>解耦了生产者和消费者，队列就像是生产者和消费者之间的管道一样，生产者只管往里面丢，消费者只管不断消费，两者之间互不关心。</li>
</ul>
</li>
</ol>
<h5 id="2-哪些队列具有阻塞的功能，大概是如何阻塞的？"><a href="#2-哪些队列具有阻塞的功能，大概是如何阻塞的？" class="headerlink" title="2.哪些队列具有阻塞的功能，大概是如何阻塞的？"></a>2.哪些队列具有阻塞的功能，大概是如何阻塞的？</h5><p>答：队列主要提供了两种阻塞功能，如下：</p>
<ol>
<li>LinkedBlockingQueue 链表阻塞队列和 ArrayBlockingQueue 数组阻塞队列是一类，前者容量是 Integer 的最大值，后者数组大小固定，两个阻塞队列都可以指定容量大小，当队列满时，如果有线程 put 数据，线程会阻塞住，直到有其他线程进行消费数据后，才会唤醒阻塞线程继续 put，当队列空时，如果有线程 take 数据，线程会阻塞到队列不空时，继续 take。</li>
<li>SynchronousQueue 同步队列，当线程 put 时，必须有对应线程把数据消费掉，put 线程才能返回，当线程 take 时，需要有对应线程进行 put 数据时，take 才能返回，反之则阻塞，举个例子，线程 A put 数据 A1 到队列中了，此时并没有任何的消费者，线程 A 就无法返回，会阻塞住，直到有线程消费掉数据 A1 时，线程 A 才能返回。</li>
</ol>
<h5 id="3-底层是如何实现阻塞的？"><a href="#3-底层是如何实现阻塞的？" class="headerlink" title="3.底层是如何实现阻塞的？"></a>3.底层是如何实现阻塞的？</h5><p>答：队列本身并没有实现阻塞的功能，而是利用 Condition 的等待唤醒机制，阻塞底层实现就是更改线程的状态为沉睡，细节我们在锁小节会说到。</p>
<h5 id="4-LinkedBlockingQueue-和-ArrayBlockingQueue-有啥区别。"><a href="#4-LinkedBlockingQueue-和-ArrayBlockingQueue-有啥区别。" class="headerlink" title="4.LinkedBlockingQueue 和 ArrayBlockingQueue 有啥区别。"></a>4.LinkedBlockingQueue 和 ArrayBlockingQueue 有啥区别。</h5><p>答：相同点：</p>
<ol>
<li>两者的阻塞机制大体相同，比如在队列满、空时，线程都会阻塞住。</li>
</ol>
<p>不同点：</p>
<ol>
<li>LinkedBlockingQueue 底层是链表结构，容量默认是 Interge 的最大值，ArrayBlockingQueue 底层是数组，容量必须在初始化时指定。</li>
<li>两者的底层结构不同，所以 take、put、remove 的底层实现也就不同。</li>
</ol>
<h5 id="5-往队列里面-put-数据是线程安全的么？为什么？"><a href="#5-往队列里面-put-数据是线程安全的么？为什么？" class="headerlink" title="5.往队列里面 put 数据是线程安全的么？为什么？"></a>5.往队列里面 put 数据是线程安全的么？为什么？</h5><p>答：是线程安全的，在 put 之前，队列会自动加锁，put 完成之后，锁会自动释放，保证了同一时刻只会有一个线程能操作队列的数据，以 LinkedBlockingQueue 为例子，put 时，会加 put 锁，并只对队尾 tail 进行操作，take 时，会加 take 锁，并只对队头 head 进行操作，remove 时，会同时加 put 和 take 锁，所以各种操作都是线程安全的，我们工作中可以放心使用。</p>
<h5 id="6-take-的时候也会加锁么？既然-put-和-take-都会加锁，是不是同一时间只能运行其中一个方法。"><a href="#6-take-的时候也会加锁么？既然-put-和-take-都会加锁，是不是同一时间只能运行其中一个方法。" class="headerlink" title="6.take 的时候也会加锁么？既然 put 和 take 都会加锁，是不是同一时间只能运行其中一个方法。"></a>6.take 的时候也会加锁么？既然 put 和 take 都会加锁，是不是同一时间只能运行其中一个方法。</h5><p>答：</p>
<ol>
<li><p>是的，take 时也会加锁的，像 LinkedBlockingQueue 在执行 take 方法时，在拿数据的同时，会把当前数据删除掉，就改变了链表的数据结构，所以需要加锁来保证线程安全。</p>
</li>
<li><p>这个需要看情况而言，对于 LinkedBlockingQueue 来说，队列的 put 和 take 都会加锁，但两者的锁是不一样的，所以两者互不影响，可以同时进行的，对于 ArrayBlockingQueue 而言，put 和 take 是同一个锁，所以同一时刻只能运行一个方法。</p>
</li>
</ol>
<h5 id="7-工作中经常使用队列的-put、take-方法有什么危害，如何避免。"><a href="#7-工作中经常使用队列的-put、take-方法有什么危害，如何避免。" class="headerlink" title="7.工作中经常使用队列的 put、take 方法有什么危害，如何避免。"></a>7.工作中经常使用队列的 put、take 方法有什么危害，如何避免。</h5><p>答：当队列满时，使用 put 方法，会一直阻塞到队列不满为止。</p>
<p>当队列空时，使用 take 方法，会一直阻塞到队列有数据为止。</p>
<p>两个方法都是无限（永远、没有超时时间的意思）阻塞的方法，容易使得线程全部都阻塞住，大流量时，导致机器无线程可用，所以建议在流量大时，使用 offer 和 poll 方法来代替两者，我们只需要设置好超时阻塞时间，这两个方法如果在超时时间外，还没有得到数据的话，就会返回默认值（LinkedBlockingQueue 为例），这样就不会导致流量大时，所有的线程都阻塞住了。</p>
<p>这个也是生产事故常常发生的原因之一，尝试用 put 和 take 方法，在平时自测中根本无法发现，对源码不熟悉的同学也不会意识到会有问题，当线上大流量打进来时，很有可能会发生故障，所以我们平时工作中使用队列时，需要谨慎再谨慎。</p>
<h5 id="8-把数据放入队列中后，有木有办法让队列过一会儿再执行？"><a href="#8-把数据放入队列中后，有木有办法让队列过一会儿再执行？" class="headerlink" title="8.把数据放入队列中后，有木有办法让队列过一会儿再执行？"></a>8.把数据放入队列中后，有木有办法让队列过一会儿再执行？</h5><p>答：可以的，DelayQueue 提供了这种机制，可以设置一段时间之后再执行，该队列有个唯一的缺点，就是数据保存在内存中，在重启和断电的时候，数据容易丢失，所以定时的时间我们都不会设置很久，一般都是几秒内，如果定时的时间需要设置很久的话，可以考虑采取延迟队列中间件（这种中间件对数据会进行持久化，不怕断电的发生）进行实现。</p>
<h5 id="9-DelayQueue-对元素有什么要求么，我把-String-放到队列中去可以么？"><a href="#9-DelayQueue-对元素有什么要求么，我把-String-放到队列中去可以么？" class="headerlink" title="9.DelayQueue 对元素有什么要求么，我把 String 放到队列中去可以么？"></a>9.DelayQueue 对元素有什么要求么，我把 String 放到队列中去可以么？</h5><p>答：DelayQueue 要求元素必须实现 Delayed 接口，Delayed 本身又实现了 Comparable 接口，Delayed 接口的作用是定义还剩下多久就会超时，给使用者定制超时时间的，Comparable 接口主要用于对元素之间的超时时间进行排序的，两者结合，就可以让越快过期的元素能够排在前面。</p>
<p>所以把 String 放到 DelayQueue 中是不行的，编译都无法通过，DelayQueue 类在定义的时候，是有泛型定义的，泛型类型必须是 Delayed 接口的子类才行。</p>
<h5 id="10-DelayQueue-如何让快过期的元素先执行的？"><a href="#10-DelayQueue-如何让快过期的元素先执行的？" class="headerlink" title="10.DelayQueue 如何让快过期的元素先执行的？"></a>10.DelayQueue 如何让快过期的元素先执行的？</h5><p>答：DelayQueue 中的元素都实现 Delayed 和 Comparable 接口的，其内部会使用 Comparable 的 compareTo 方法进行排序，我们可以利用这个功能，在 compareTo 方法中实现过期时间和当前时间的差，这样越快过期的元素，计算出来的差值就会越小，就会越先被执行。</p>
<h5 id="11-如何查看-SynchronousQueue-队列的大小？"><a href="#11-如何查看-SynchronousQueue-队列的大小？" class="headerlink" title="11.如何查看 SynchronousQueue 队列的大小？"></a>11.如何查看 SynchronousQueue 队列的大小？</h5><p>答：此题是个陷进题，题目首先设定了 SynchronousQueue 是可以查看大小的，实际上 SynchronousQueue 本身是没有容量的，所以也无法查看其容量的大小，其内部的 size 方法都是写死的返回 0。</p>
<h5 id="12-SynchronousQueue-底层有几种数据结构，两者有何不同？"><a href="#12-SynchronousQueue-底层有几种数据结构，两者有何不同？" class="headerlink" title="12.SynchronousQueue 底层有几种数据结构，两者有何不同？"></a>12.SynchronousQueue 底层有几种数据结构，两者有何不同？</h5><p>答：底层有两种数据结构，分别是队列和堆栈。</p>
<p>两者不同点：</p>
<ol>
<li>队列维护了先入先出的顺序，所以最先进去队列的元素会最先被消费，我们称为公平的，而堆栈则是先入后出的顺序，最先进入堆栈中的数据可能会最后才会被消费，我们称为不公平的。</li>
<li>两者的数据结构不同，导致其 take 和 put 方法有所差别，具体的可以看 《 SynchronousQueue 源码解析 》章节。</li>
</ol>
<h5 id="13-假设-SynchronousQueue-底层使用的是堆栈，线程-1-执行-take-操作阻塞住了，然后有线程-2-执行-put-操作，问此时线程-2-是如何把-put-的数据传递给-take-的？"><a href="#13-假设-SynchronousQueue-底层使用的是堆栈，线程-1-执行-take-操作阻塞住了，然后有线程-2-执行-put-操作，问此时线程-2-是如何把-put-的数据传递给-take-的？" class="headerlink" title="13.假设 SynchronousQueue 底层使用的是堆栈，线程 1 执行 take 操作阻塞住了，然后有线程 2 执行 put 操作，问此时线程 2 是如何把 put 的数据传递给 take 的？"></a>13.假设 SynchronousQueue 底层使用的是堆栈，线程 1 执行 take 操作阻塞住了，然后有线程 2 执行 put 操作，问此时线程 2 是如何把 put 的数据传递给 take 的？</h5><p>答：这是一个好问题，也是理解 SynchronousQueue 的核心问题。</p>
<p>首先线程 1 被阻塞住，此时堆栈头就是线程 1 了，此时线程 2 执行 put 操作，会把 put 的数据赋值给堆栈头的 match 属性，并唤醒线程 1，线程 1 被唤醒后，拿到堆栈头中的 match 属性，就能够拿到 put 的数据了。</p>
<p>严格上说并不是 put 操作直接把数据传递给了 take，而是 put 操作改变了堆栈头的数据，从而 take 可以从堆栈头上直接拿到数据，堆栈头是 take 和 put 操作之间的沟通媒介。</p>
<h5 id="14-如果想使用固定大小的队列，有几种队列可以选择，有何不同？"><a href="#14-如果想使用固定大小的队列，有几种队列可以选择，有何不同？" class="headerlink" title="14.如果想使用固定大小的队列，有几种队列可以选择，有何不同？"></a>14.如果想使用固定大小的队列，有几种队列可以选择，有何不同？</h5><p>答：可以使用 LinkedBlockingQueue 和 ArrayBlockingQueue 两种队列。</p>
<p>前者是链表，后者是数组，链表新增时，只要建立起新增数据和链尾数据之间的关联即可，数组新增时，需要考虑到索引的位置（takeIndex 和 putIndex 分别记录着下次拿数据、放数据的索引位置），如果增加到了数组最后一个位置，下次就要重头开始新增。</p>
<h5 id="15-ArrayBlockingQueue-可以动态扩容么？用到数组最后一个位置时怎么办？"><a href="#15-ArrayBlockingQueue-可以动态扩容么？用到数组最后一个位置时怎么办？" class="headerlink" title="15.ArrayBlockingQueue 可以动态扩容么？用到数组最后一个位置时怎么办？"></a>15.ArrayBlockingQueue 可以动态扩容么？用到数组最后一个位置时怎么办？</h5><p>答：不可以的，虽然 ArrayBlockingQueue 底层是数组，但不能够动态扩容的。</p>
<p>假设 put 操作用到了数组的最后一个位置，那么下次 put 就需要从数组 0 的位置重新开始了。</p>
<p>假设 take 操作用到数组的最后一个位置，那么下次 take 的时候也会从数组 0 的位置重新开始。</p>
<h5 id="16-ArrayBlockingQueue-take-和-put-都是怎么找到索引位置的？是利用-hash-算法计算得到的么？"><a href="#16-ArrayBlockingQueue-take-和-put-都是怎么找到索引位置的？是利用-hash-算法计算得到的么？" class="headerlink" title="16.ArrayBlockingQueue take 和 put 都是怎么找到索引位置的？是利用 hash 算法计算得到的么？"></a>16.ArrayBlockingQueue take 和 put 都是怎么找到索引位置的？是利用 hash 算法计算得到的么？</h5><p>答：ArrayBlockingQueue 有两个属性，为 takeIndex 和 putIndex，分别标识下次 take 和 put 的位置，每次 take 和 put 完成之后，都会往后加一，虽然底层是数组，但和 HashMap 不同，并不是通过 hash 算法计算得到的。</p>
<h4 id="4-5-2-总结"><a href="#4-5-2-总结" class="headerlink" title="4.5.2-总结"></a>4.5.2-总结</h4><p>队列是锁、线程池等复杂 API 的基础，很多面试官都会在问这些 API 时冷不防的问你队列的知识，如果你回答不好，面试官可能会认为你仅仅是用过锁和线程池，但却对其底层的原理和实现了解的不够全面，所以说队列还是蛮重要的，但队列的源码比较复杂，建议大家可以尝试 debug 的方式来理解源码。</p>
<h3 id="4-6-举一反三：队列在-Java-其它源码中的应用"><a href="#4-6-举一反三：队列在-Java-其它源码中的应用" class="headerlink" title="4.6-举一反三：队列在 Java 其它源码中的应用"></a>4.6-举一反三：队列在 Java 其它源码中的应用</h3><p>队列除了提供 API 供开发者使用外，自身也和 Java 中其他 API 紧密结合，比如线程池和锁，线程池直接使用了队列的 API，锁借鉴了队列的思想，重新实现了队列，线程池和锁都是我们工作中经常使用的 API，也是面试官常问的 API，队列在两者的实现上发挥着至关重要的作用，接下来我们一起来看下。</p>
<h4 id="4-6-1-队列和线程池的结合"><a href="#4-6-1-队列和线程池的结合" class="headerlink" title="4.6.1-队列和线程池的结合"></a>4.6.1-队列和线程池的结合</h4><h5 id="1-队列在线程池中的作用"><a href="#1-队列在线程池中的作用" class="headerlink" title="1.队列在线程池中的作用"></a>1.队列在线程池中的作用</h5><p>线程池大家应该都使用过，比如我们想新建一个固定大小的线程池，并让运行的线程打印一句话出来，我们会这么写代码：</p>
<pre class=" language-java"><code class="language-java">ExecutorService executorService <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// submit 是提交任务的意思</span>
<span class="token comment" spellcheck="true">// Thread.currentThread() 得到当前线程</span>
executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" is run"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 打印结果(我们打印出了当前线程的名字)：</span>
pool<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>thread<span class="token operator">-</span><span class="token number">1</span> is run</code></pre>
<p>代码中的 Executors 是并发的工具类，主要是为了帮助我们更方便的构造线程池的，其中 newFixedThreadPool 方法表示会构造出固定大小的线程池，我们给的入参是 10，代表线程池最大可以构造 10 个线程出来。</p>
<p>在实际的工作中，我们对流量的大小是无法控制的，这里我们设定的最大是 10 个线程，但如果一下子来了 100 个请求，这时候 10 个线程肯定是忙不过来了，那么剩余的 90 个请求怎么办呢？</p>
<p>这时候就需要队列出马了，我们会把线程无法消化的数据放到队列中去，让数据在队列中排队，等线程有能力消费了，再从队列中拿出来慢慢去消费。</p>
<p>我们画一个图释义一下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97.jpeg" alt="线程池中的队列"></p>
<p>上图右边表示 10 个线程正在全力消费请求，左边表示剩余请求正在队列中排队，等待消费。</p>
<p>由此可见，队列在线程池中占有很重要的地位，当线程池中的线程忙不过来的时候，请求都可以在队列中等待，从而慢慢地消费。</p>
<p>接下来我们来看下，线程池到底用到了那几种队列类型，分别起的什么作用。</p>
<h5 id="2-线程池中使用到的队列的类型"><a href="#2-线程池中使用到的队列的类型" class="headerlink" title="2.线程池中使用到的队列的类型"></a>2.线程池中使用到的队列的类型</h5><ul>
<li><h4 id="LinkedBlockingQueue-队列的使用"><a href="#LinkedBlockingQueue-队列的使用" class="headerlink" title="LinkedBlockingQueue 队列的使用"></a>LinkedBlockingQueue 队列的使用</h4><p>刚刚我们说的 newFixedThreadPool 是一种固定大小的线程池，意思是当线程池初始化好后，线程池里面的线程大小是不会变的了（线程池默认设置是不会回收核心线程数的），我们来看下 newFixedThreadPool 的源码：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ThreadPoolExecutor 初始化时，第一个参数表示 coreSize，第二个参数是 maxSize，coreSize == maxSize,</span>
<span class="token comment" spellcheck="true">// 表示线程池初始化时，线程大小已固定，所以叫做固定(Fixed)线程池。 </span>
<span class="token keyword">public</span> <span class="token keyword">static</span> ExecutorService <span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>nThreads<span class="token punctuation">,</span> nThreads<span class="token punctuation">,</span>
                                  0L<span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MILLISECONDS<span class="token punctuation">,</span>
                                  <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span>Runnable<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>源码中可以看到初始化了 ThreadPoolExecutor，ThreadPoolExecutor 是线程池的 API，我们在线程池章节会细说，它的第五个构造参数就是队列，线程池根据场景会选择不同的队列，此处使用的是 LinkedBlockingQueue，并且是默认参数的 Queue，这说明此阻塞队列的最大容量是 Integer 的最大值，也就是说当线程池的处理能力有限时，阻塞队列中最大可以存放 Integer 最大值个任务。</p>
<p>但我们在实际工作中，常常不建议直接使用 newFixedThreadPool，主要是因为其使用的是 LinkedBlockingQueue 的默认构造器，队列容量太大了，在要求实时响应的请求中，队列容量太大往往危害也很大。</p>
<p>比如说我们用上述的线程池，线程 10 个，队列是 Integer 的最大值，当并发流量很大时，比如来了 1w/qps 请求，这时候 10 个线程根本消费不完，就会有很多请求被阻塞在队列中，虽然 10 个线程仍然在不断地消费，但需要消费完队列中的所有数据是需要时间的，假设需要 3 秒才能全部消费完，而这些实时请求都是有超时时间的，默认超时时间是 2 秒，当时间到达 2 秒时，请求已经超时了，返回报错，可这时候队列中的任务还有很多都在等待消费呢，即使后来消费完成，也无法返回给调用方了。</p>
<p>以上情况就会造成，调用方看到接口是超时报错返回的，但服务端的任务其实还在排队执行，过了 3 秒后，服务端的任务可能都会执行成功，但调用方已经无法感知了，调用方再次调用时，就会发现其实这笔请求已经成功了。</p>
<p>如果调用方是从页面发起的，那么体验就会更差，页面上第一次调用页面报错，用户重新刷新页面时，页面显示上次的请求已经成功了，这个就是很不好的体验了。</p>
<p>所以我们希望队列的大小不要设置成那么大，可以根据实际的消费情况来设置队列的大小，这样就可以保证在接口超时前，队列中排队的请求可以执行完。</p>
<p>场景比较复杂，为了方便理解，我们画了一个图，把整个流程释义一下：</p>
<p><img src="/2020/02/02/jdk-yuan-ma-xiang-jie/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%BD%BF%E7%94%A8LinkedBlockingQueue.jpeg" alt="线程池中使用LinkedBlockingQueue"></p>
</li>
</ul>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://fangpeng12.github.io" rel="external nofollow noreferrer">fangpeng</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://fangpeng12.github.io/2020/02/02/jdk-yuan-ma-xiang-jie/">https://fangpeng12.github.io/2020/02/02/jdk-yuan-ma-xiang-jie/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://fangpeng12.github.io" target="_blank">fangpeng</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JDK-%E6%BA%90%E7%A0%81/">
                                    <span class="chip bg-color">JDK 源码</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2020/02/02/jdk-yuan-ma-xiang-jie/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/17.jpg" class="responsive-img" alt="JDK源码详解">
                        
                        <span class="card-title">JDK源码详解</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            JDK1.8源码阅读解析和常见面试题
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-02-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java%E6%BA%90%E7%A0%81/" class="post-category">
                                    Java源码
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JDK-%E6%BA%90%E7%A0%81/">
                        <span class="chip bg-color">JDK 源码</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/01/18/css-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="CSS学习笔记">
                        
                        <span class="card-title">CSS学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            CSS入门学习笔记
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-01-18
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF/">
                        <span class="chip bg-color">前端</span>
                    </a>
                    
                    <a href="/tags/css/">
                        <span class="chip bg-color">css</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">年份</span>
            <a href="https://fangpeng12.github.io" target="_blank">fangpeng</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">180.8k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    window.setTimeout("siteTime()", 1000);
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "12";
                    var startDate = "21";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/fangpeng12" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>















    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
