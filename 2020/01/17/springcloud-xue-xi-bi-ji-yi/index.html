<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="SpringCloud学习笔记1, 空白格的博客">
    <meta name="description" content="SpringCloud学习笔记1-架构演进和分布式系统基础1.1-单体应用
把所有的功能集中在同一系统中实现，应用程序的全部功能被一起打包作为单个单元或应用程序
这个单元可以是JAR、WAR、EAR,或其他一些归档格式，运行在同一个 tom">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>SpringCloud学习笔记1 | 空白格的博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="空白格的博客" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">空白格的博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">空白格的博客</div>
        <div class="logo-desc">
            
            个人技术博客：主要是一些技术杂谈和学习笔记的分享
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/fangpeng12" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #36b3ec;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/fangpeng12" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/13.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        SpringCloud学习笔记1
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E7%AC%94%E8%AE%B0/">
                                <span class="chip bg-color">笔记</span>
                            </a>
                        
                            <a href="/tags/Spring/">
                                <span class="chip bg-color">Spring</span>
                            </a>
                        
                            <a href="/tags/SpringBoot/">
                                <span class="chip bg-color">SpringBoot</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/SpringCloud%E7%AC%94%E8%AE%B0/" class="post-category">
                                SpringCloud笔记
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-01-17
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    15.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    57 分
                </div>
                
				
                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="SpringCloud学习笔记"><a href="#SpringCloud学习笔记" class="headerlink" title="SpringCloud学习笔记"></a>SpringCloud学习笔记</h1><h2 id="1-架构演进和分布式系统基础"><a href="#1-架构演进和分布式系统基础" class="headerlink" title="1-架构演进和分布式系统基础"></a>1-架构演进和分布式系统基础</h2><h3 id="1-1-单体应用"><a href="#1-1-单体应用" class="headerlink" title="1.1-单体应用"></a>1.1-单体应用</h3><ol>
<li>把所有的功能集中在同一系统中实现，应用程序的全部功能被一起打包作为单个单元或应用程序</li>
<li>这个单元可以是JAR、WAR、EAR,或其他一些归档格式，运行在同一个 tomcat 进程中</li>
<li>其全部集成在一个单一的单元.</li>
<li><strong>优点：</strong><ul>
<li>方便调试，代码都在一起</li>
<li>易于部署，所有服务都在本地容器内</li>
<li>中小型项目可以快速迭代，不需要太多资源</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>可复用性差：服务被打包在应用中，功能不易复用</li>
<li>系统启动慢：一个进程包含了所有的业务逻辑，涉及到的启动模块过多，导致系统的启动、重启时间周期过长 </li>
<li>线上问题修复周期长：任何一个线上问题修复需要对整个应用系统进行全面升级。</li>
<li>系统扩展性比较差：增加新东西的时候不能针对单个点增加，全局性的增加.牵一发而动全身。</li>
<li>技术债务逐渐上升：随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务，并且越积越多。</li>
<li>阻碍技术创新：单体应用往往使用统一的技术平台或方案解决所有问题，团队的每个成员都必须使用相同的开发语言和架构，想要引入新的框架或技术平台非常困难。</li>
</ul>
</li>
</ol>
<h3 id="1-2-微服务应用"><a href="#1-2-微服务应用" class="headerlink" title="1.2-微服务应用"></a>1.2-微服务应用</h3><ol>
<li>微服务架构风格是一种将一个单一应用程序开发为一组小型服务的方法</li>
<li>每个小型服务都运行在自己的进程中，并经常采用HTTP资源API轻量的机制来相互通信</li>
<li>这些服务围绕业务功能进行构建，并能通过全自动的部署机制来进行独立部署</li>
<li>一个微服务只关注某个特定的功能</li>
<li><strong>优点：</strong><ul>
<li>易于开发和维护：一个微服务只会关注一个特定的业务功能，所以业务清晰、代码量较少。开发和维护单个微服务相对简单，每个服务为独立的业务开发，一个微服务只关注某个特定的功能，如订单管理、用户管理等</li>
<li>单个微服务启动较快，每个微服务可独立运行在自己的进程里</li>
<li>局部修改容易部署：单体应用只要有修改，就得重新部署整个应用。一般来说，对某个微服务进行修改，只需要重新部署这个服务即可</li>
<li>技术栈不受限制：在微服务架构中，可以结合项目业务及团队的特点，合理的选择技术栈</li>
<li>按需伸缩：可根据需求，实现细粒度的扩展</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>运维要求高：更多的服务意味着要投入更多的运维</li>
<li>分布式固有的复杂性：使用微服务构建的是分布式系统。对于一个分布式系统，系统容错、网络延迟、分布式事务等都会带来巨大的问题。</li>
<li>接口调整成本高：微服务之间通过接口进行通信。如果修改某一个微服务的API，可能所有用到这个接口的微服务都需要进行调整</li>
</ul>
</li>
</ol>
<h3 id="1-3-集群、分布式和微服务的区别"><a href="#1-3-集群、分布式和微服务的区别" class="headerlink" title="1.3-集群、分布式和微服务的区别"></a>1.3-集群、分布式和微服务的区别</h3><ol>
<li>分布式：<ul>
<li>一个业务分拆多个子业务，部署在不同的服务器上</li>
<li>分布式中的每一个节点，都可以做集群</li>
<li>分布式需要做好事务管理</li>
<li>区别分布式的方式是根据不同机器不同业务。</li>
</ul>
</li>
<li>微服务：<ul>
<li>微服务是一种架构风格，一个大型复杂软件应用由一个或多个微服务组成</li>
<li>系统中的各个微服务可被独立部署，各个微服务之间是松耦合的</li>
<li>每个微服务仅关注于完成一件任务并很好地完成该任务</li>
</ul>
</li>
<li>集群：<ul>
<li>同一个业务，部署在多个服务器上        </li>
<li>区别集群的方式是根据部署多台服务器业务是否相同</li>
<li>集群模式需要做好session共享，确保在不同服务器切换的过程中不会因为没有获取到session而中止退出服务</li>
<li>一般配置Nginx的负载容器实现：静态资源缓存、Session共享可以附带实现，Nginx支持5000个并发量</li>
</ul>
</li>
<li>分布式是否属于微服务<ul>
<li>不一定，如果一个很大应用，拆分成三个应用，但还是很庞大，虽然分布式了，但不是微服务。微服务核心要素是微小</li>
<li>微服务的设计是为了不因为某个模块的升级和BUG影响现有的系统业务</li>
<li>微服务的应用不一定是分散在多个服务器上，也可以是同一个服务器     </li>
<li>微服务架构是分布式服务架构的子集</li>
<li>分布式：分散压力。微服务：分散能力</li>
</ul>
</li>
<li>单应用与集群<ul>
<li>整个项目所有的服务都由这台服务器提供。这就是单机结构</li>
<li>单机复制几份，这样就构成了一个“集群”</li>
<li>集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群</li>
<li>每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍</li>
</ul>
</li>
</ol>
<h2 id="2-微服务核心基础"><a href="#2-微服务核心基础" class="headerlink" title="2-微服务核心基础"></a>2-微服务核心基础</h2><h3 id="2-1-微服务架构"><a href="#2-1-微服务架构" class="headerlink" title="2.1-微服务架构"></a>2.1-微服务架构</h3><p>微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务于服务间采用轻量级的通信机制互相沟通（通常是基于 HTTP 的 RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建。</p>
<ul>
<li>分布式：不同的功能模块部署在不同的服务器上，减轻网站高并发带来的压力。</li>
<li>集群：多台服务器上部署相同应用构成一个集群，通过负载均衡共同向外提供服务。</li>
<li>微服务：微服务架构模式就是将web应用拆分为一系列小的服务模块，这些模块可以独立地编译、部署，并通过各自暴露的API接口通讯，共同组成一个web应用。</li>
<li>SpringCloud是基于SpringBoot的一整套微服务框架，提供了一系列可配置的组件，如<strong>配置管理</strong>、<strong>服务发现</strong>、<strong>负载均衡</strong>、<strong>熔断器</strong>、<strong>断路器</strong>、<strong>智能路由</strong>、<strong>微代理</strong>、<strong>控制总线</strong>、<strong>全局锁</strong>、<strong>决策竞选</strong>、<strong>分布式会话</strong>和<strong>集群状态管理</strong>等。</li>
</ul>
<h3 id="2-2-什么是SpringCloud？"><a href="#2-2-什么是SpringCloud？" class="headerlink" title="2.2-什么是SpringCloud？"></a>2.2-什么是SpringCloud？</h3><p>Spring Cloud是一个基于Spring Boot实现的服务工具治理包，专注于全局的服务治理框架。</p>
<p>Spring Cloud 是一系列框架的有序集合。<br> 它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。<br> Spring 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/SpringCloud%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84.png" alt="SpringCloud组件架构"></p>
<ul>
<li>所有请求都通过API网关来访问内部服务；</li>
<li>网关接受请求后，从注册中心获取可用服务模块；</li>
<li>由Ribbon进行负载均衡后，分发到后台的具体实例；</li>
<li>各个服务模块之间通过Feign进行通信处理业务；</li>
<li>Hystrix负责处理服务超时熔断；</li>
<li>Turbine监控服务间的调用和熔断相关指标。</li>
</ul>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/SpringCloud%E6%B5%81%E7%A8%8B.png" alt="SpringCloud流程"></p>
<h2 id="2-3-微服务技术"><a href="#2-3-微服务技术" class="headerlink" title="2.3-微服务技术"></a>2.3-微服务技术</h2><ul>
<li><p>Spring Cloud Config ：服务配置中心，将所有的服务的配置文件放到本地仓库或者远程仓库，配置中心负责读取仓库的配置文件，其他服务向配置中心读取配置。SpringCloud Config 使得服务的配置统一管理 并可以在不人为重启服务的情况下进行配置文件的刷新。</p>
</li>
<li><p>Spring Cloud Netflix ：它是通过包装了 Netflix 公司的微服务组件实现的，也是SpringCloud 核心的核心组件，包括 Eureka Hystrix Zuul Archaius 等。</p>
</li>
<li><p>Eureka ：服务注册和发现组件，可以细分为eureka server（服务注册中心）和eureka client（服务注册客户端，所有其他需注册到服务注册中心的微服务组件都可以看做是服务注册客户端）</p>
<ul>
<li>Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。</li>
<li>Eureka Client是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除（默认90秒）Eureka Server之间将会通过复制的方式完成数据的同步。Eureka还提供了客户端缓存的机制，即使所有的Eureka Server都挂掉了，客户端依然可以利用缓存中的信息消费其它服务的API。综上，Eureka通过心跳检测、健康检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性。</li>
</ul>
</li>
<li><p>Hystrix ：熔断器组件 Hystrix 通过控制服务的 API 接口的熔断来转移故障，防止微服务系统发生雪崩效应。另外， Hystrix 能够起到服务限流和服务降级的作用。使用Hystrix Dashboard 组件监控单个服务的熔断器的状态，使用 Turbine 组件可以聚合多，现了断路器的模式。“断路器” 本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
</li>
<li><p>Zuul ：（路由转发+过滤器）能路由网关组 Netflix Zuul能够起到智能路由和请求过滤的作用，是服务接口统一暴露 关键模块，也是安全验证、权限控制的一道门；Zuul路由是微服务架构的不可或缺的一部分，提供动态路由、监控、弹性、安全等的边缘服务，Zuul 是 Netflix 出品的一个基于 JVM 路由和服务端的负载均衡器。</p>
</li>
<li><p>Feign 声明式远程调度组件，Feign 是一个声明式的 Web Service 客户端，它的目的就是让 Web Service 调用更加简单。它整合了 Ribbon 和 Hystrix，从而让我们不再需要显式地使用这两个组件。Feign 还提供了 HTTP 请求的模板，通过编写简单的接口和插入注解，我们就可以定义好 HTTP 请求的参数、格式、地址等信息。接下来，Feign 会完全代理 HTTP 的请求，我们只需要像调用方法一样调用它就可以完成服务请求。</p>
<p>Feign 具有如下特性：</p>
<ul>
<li>可插拔的注解支持，包括 Feign 注解和 JAX-RS 注解</li>
<li>支持可插拔的 HTTP 编码器和解码器</li>
<li>支持 Hystrix 和它的 Fallback</li>
<li>支持 Ribbon 的负载均衡</li>
<li>支持 HTTP 请求和响应的压缩</li>
</ul>
</li>
<li><p>Ribbon 负载均衡组件，为REST客户端实现负载均衡。</p>
</li>
<li><p>Archaius ：配置管理 API 的组件， 一个基于 Java 的配置管理库主要用于多配置的动态获取。Spring Cloud Bus 消息总线组件，常和 Spring Cloud Config 配合使用，用于动态新服务的配置。</p>
</li>
<li><p>Spring Cloud Sleuth ：服务链路追踪组件，封装了 Dapper Zipkin, Kibina 等组件，可以实时监控服务的链路调用情况。</p>
</li>
<li><p>Spring Cloud Data Flow ：大数据操作组件，Spring Cloud Data Flow SpringXD替代品，也是 个混合计算的模型，可以通过命令行的方式操作数据流</p>
</li>
<li><p>Spring Cloud Security 安全模块组件，是对 Spring Security 封装，通常配合 0Auth2使用来保护微服务系统的安全。</p>
</li>
<li><p>Spring Cloud Consule ：该组件是 Spring Cloud Consul 的封装，和 ureka 类似，它是一个服务注册和发现组件</p>
</li>
<li><p>Spring Cloud Zookeeper 该组件是 Spring Cloud Zookeeper 封装，和 Eureka Consul相似，用于服务的注册和发现</p>
</li>
<li><p>Spring Cloud Stream ：数据流操作组件，可以封装 Redis RabbitMQ Kafka 等组件实现发送和接收消息等。</p>
</li>
<li><p>Spring Cloud CLI ：该组件是 Spring Cloud Spring Boot CLI 的封装，可以让用户以命令行方式快速运行和搭建容器</p>
</li>
<li><p>Spring Cloud Task 该组件基于 Spring Task ，提供了任务调度和任务管理的功能。　</p>
</li>
<li><p>Spring Cloud Connectors 用于 Paas 云平台连接到后端。</p>
</li>
</ul>
<h2 id="3-Dubbo和SpringCloud"><a href="#3-Dubbo和SpringCloud" class="headerlink" title="3-Dubbo和SpringCloud"></a>3-Dubbo和SpringCloud</h2><ol>
<li><p><strong>dubbo:</strong> zookeeper + dubbo + springmvc/springboot<br>官方地址：<a href="http://dubbo.apache.org/#!/?lang=zh-cn" target="_blank" rel="noopener">http://dubbo.apache.org/#!/?lang=zh-cn</a><br>配套：</p>
<p>​    通信方式：rpc<br>​    注册中心：zookeper/redis<br>​    配置中心：diamond</p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/Dubbo%E7%BB%84%E4%BB%B6.png" alt="Dubbo"></p>
</li>
<li><p>Dubbo核心组件</p>
<ul>
<li><strong>Provider：</strong>暴露服务的提供方，可以通过 jar 或者容器的方式启动服务。</li>
<li><strong>Consumer：</strong>调用远程服务的服务消费方。</li>
<li><strong>Registry：</strong>服务注册中心和发现中心。</li>
<li><strong>Monitor：</strong>统计服务和调用次数，调用时间监控中心。（Dubbo 的控制台页面中可以显示，目前只有一个简单版本。）</li>
<li><strong>Container：</strong>服务运行的容器。</li>
</ul>
</li>
<li><p>Spring Cloud</p>
<p>springcloud: 全家桶+轻松嵌入第三方组件<br>官网：<a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">http://projects.spring.io/spring-cloud/</a><br>配套</p>
<p>​        通信方式：http restful<br>​        注册中心：eruka/consul<br>​        配置中心：config<br>​        断路器：hystrix<br>​        网关：zuul<br>​        分布式追踪系统：sleuth+zipkin</p>
</li>
<li><p>SpringCloud和Dubbo区别</p>
<table>
<thead>
<tr>
<th></th>
<th>Dubbo</th>
<th>Spring Cloud</th>
</tr>
</thead>
<tbody><tr>
<td>服务注册中心</td>
<td>Zookeeper</td>
<td>Spring Cloud Netflix Eureka</td>
</tr>
<tr>
<td>服务调用方式</td>
<td>RPC</td>
<td>REST API</td>
</tr>
<tr>
<td>服务监控</td>
<td>无</td>
<td>Spring Boot Admin</td>
</tr>
<tr>
<td>断路器</td>
<td>不完善</td>
<td>Spring Cloud Netflix Hystrix</td>
</tr>
<tr>
<td>服务网关</td>
<td>无</td>
<td>Spring Cloud Netflix Zuul</td>
</tr>
<tr>
<td>分布式配置</td>
<td>无</td>
<td>Spring Cloud Config</td>
</tr>
<tr>
<td>服务跟踪</td>
<td>无</td>
<td>Spring Cloud Sleuth</td>
</tr>
<tr>
<td>消息总线</td>
<td>无</td>
<td>Spring Cloud Bus</td>
</tr>
<tr>
<td>数据流</td>
<td>无</td>
<td>Spring Cloud Stream</td>
</tr>
<tr>
<td>批量任务</td>
<td>无</td>
<td>Spring Cloud Task</td>
</tr>
</tbody></table>
</li>
<li><p>Spring Cloud 抛弃了 Dubbo 的 RPC 通信，采用的是基于 HTTP 的 REST 方式。严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生 RPC 带来的问题。而且 REST 相比 RPC 更为灵活，服务提供方和调用方，不存在代码级别的强依赖，这在强调快速演化的微服务环境下显得更加合适。</p>
<p>很明显，Spring Cloud 的功能比 Dubbo 更加强大，涵盖面更广，而且作为 Spring 的拳头项目，它也能够与 Spring Framework、Spring Boot、Spring Data、Spring Batch 等其他 Spring 项目完美融合，这些对于微服务而言是至关重要的。</p>
</li>
<li><p>微服务下电商项目模块设计</p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E7%94%B5%E5%95%86%E5%BE%AE%E6%9C%8D%E5%8A%A1.png" alt="电商微服务"></p>
<ul>
<li>用户服务<ul>
<li>用户信息接口</li>
<li>登录接口</li>
</ul>
</li>
<li>商品服务<ul>
<li>商品列表</li>
<li>商品详情</li>
</ul>
</li>
<li>订单服务 <ul>
<li>我的订单</li>
<li>下单接口</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="4-SpringCloud核心组件注册中心"><a href="#4-SpringCloud核心组件注册中心" class="headerlink" title="4-SpringCloud核心组件注册中心"></a>4-SpringCloud核心组件注册中心</h2><h3 id="4-1-什么是微服务的注册中心？"><a href="#4-1-什么是微服务的注册中心？" class="headerlink" title="4.1-什么是微服务的注册中心？"></a>4.1-什么是微服务的注册中心？</h3><p>在微服务架构下，主要有三种角色：<strong>服务提供者（RPC Server）</strong>、<strong>服务消费者（RPC Client）</strong>和<strong>服务注册中心（Registry）</strong>，三者的交互关系如下面这张图：</p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="微服务注册中心"></p>
<p>RPC Server 提供服务，在启动时，根据服务发布文件 server.xml 中的配置的信息，向 Registry 注册自身服务，并向 Registry 定期发送心跳汇报存活状态。</p>
<p>RPC Client 调用服务，在启动时，根据服务引用文件 client.xml 中配置的信息，向 Registry 订阅服务，把 Registry 返回的服务节点列表缓存在本地内存中，并与 RPC Sever 建立连接。</p>
<p>当 RPC Server 节点发生变更时，Registry 会同步变更，RPC Client 感知后会刷新本地内存中缓存的服务节点列表。</p>
<p>RPC Client 从本地缓存的服务节点列表中，基于负载均衡算法选择一台 RPC Sever 发起调用。</p>
<p>注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。</p>
<ul>
<li><p><strong>数据模型</strong></p>
<p>注册中心的核心数据是服务的名字和它对应的网络地址，当服务注册了多个实例时，我们需要对不健康的实例进行过滤或者针对实例的一些特征进行流量的分配，那么就需要在实例上存储一些例如健康状态、权重等属性。随着服务规模的扩大，渐渐的又需要在整个服务级别设定一些权限规则、以及对所有实例都生效的一些开关，于是在服务级别又会设立一些属性。再往后，我们又发现单个服务的实例又会有划分为多个子集的需求，例如一个服务是多机房部署的，那么可能需要对每个机房的实例做不同的配置，这样又需要在服务和实例之间再设定一个数据级别。</p>
</li>
<li><p><strong>数据一致性</strong></p>
<p>数据一致性是分布式系统永恒的话题，Paxos协议的艰深更让数据一致性成为程序员大牛们吹水的常见话题。不过从协议层面上看，一致性的选型已经很长时间没有新的成员加入了。目前来看基本可以归为两家：一种是基于Leader的非对等部署的单点写一致性，一种是对等部署的多写一致性。当我们选用服务注册中心的时候，并没有一种协议能够覆盖所有场景，例如当注册的服务节点不会定时发送心跳到注册中心时，强一致协议看起来是唯一的选择，因为无法通过心跳来进行数据的补偿注册，第一次注册就必须保证数据不会丢失。而当客户端会定时发送心跳来汇报健康状态时，第一次的注册的成功率并不是非常关键（当然也很关键，只是相对来说我们容忍数据的少量写失败），因为后续还可以通过心跳再把数据补偿上来，此时Paxos协议的单点瓶颈就会不太划算了，这也是Eureka为什么不采用Paxos协议而采用自定义的Renew机制的原因。</p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7.png" alt="数据一致性"></p>
</li>
<li><p><strong>负载均衡</strong></p>
<p>负载均衡严格的来说，并不算是传统注册中心的功能。一般来说服务发现的完整流程应该是先从注册中心获取到服务的实例列表，然后再根据自身的需求，来选择其中的部分实例或者按照一定的流量分配机制来访问不同的服务提供者，因此注册中心本身一般不限定服务消费者的访问策略。<code>Eureka</code>、<code>Zookeeper</code>包括<code>Consul</code>，本身都没有去实现可配置及可扩展的负载均衡机制，Eureka的负载均衡是由ribbon来完成的，而Consul则是由Fabio做负载均衡。</p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="客户端负载均衡"></p>
<p>服务端的负载均衡，给服务提供者更强的流量控制权，但是无法满足不同的消费者希望使用不同负载均衡策略的需求。而不同负载均衡策略的场景，确实是存在的。而客户端的负载均衡则提供了这种灵活性，并对用户扩展提供更加友好的支持。但是客户端负载均衡策略如果配置不当，可能会导致服务提供者出现热点，或者压根就拿不到任何服务提供者。</p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="服务端负载均衡"></p>
</li>
<li><p><strong>健康检查</strong></p>
<p>Zookeeper和Eureka都实现了一种TTL的机制，就是如果客户端在一定时间内没有向注册中心发送心跳，则会将这个客户端摘除。Eureka做的更好的一点在于它允许在注册服务的时候，自定义检查自身状态的健康检查方法。这在服务实例能够保持心跳上报的场景下，是一种比较好的体验，在Dubbo和SpringCloud这两大体系内，也被培养成用户心智上的默认行为。Nacos也支持这种TTL机制，不过这与ConfigServer在阿里巴巴内部的机制又有一些区别。Nacos目前支持临时实例使用心跳上报方式维持活性，发送心跳的周期默认是5秒，Nacos服务端会在15秒没收到心跳后将实例设置为不健康，在30秒没收到心跳时将这个临时实例摘除。</p>
<p>客户端健康检查和服务端健康检查有一些不同的关注点。客户端健康检查主要关注客户端上报心跳的方式、服务端摘除不健康客户端的机制。而服务端健康检查，则关注探测客户端的方式、灵敏度及设置客户端健康状态的机制。从实现复杂性来说，服务端探测肯定是要更加复杂的，因为需要服务端根据注册服务配置的健康检查方式，去执行相应的接口，判断相应的返回结果，并做好重试机制和线程池的管理。这与客户端探测，只需要等待心跳，然后刷新TTL是不一样的。同时服务端健康检查无法摘除不健康实例，这意味着只要注册过的服务实例，如果不调用接口主动注销，这些服务实例都需要去维持健康检查的探测任务，而客户端则可以随时摘除不健康实例，减轻服务端的压力。</p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/Nacos%E7%9A%84%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5.png" alt="Nacos的健康检查"></p>
</li>
<li><p>性能与容量</p>
<p>虽然大部分用户用到的性能不高，但是他们仍然希望选用的产品的性能越高越好。影响读写性能的因素很多：一致性协议、机器的配置、集群的规模、存量数据的规模、数据结构及读写逻辑的设计等等。在服务发现的场景中，我们认为读写性能都是非常关键的，但是并非性能越高就越好，因为追求性能往往需要其他方面做出牺牲。Zookeeper在写性能上似乎能达到上万的TPS，这得益于Zookeeper精巧的设计，不过这显然是因为有一系列的前提存在。首先Zookeeper的写逻辑就是进行K-V的写入，内部没有聚合；其次Zookeeper舍弃了服务发现的基本功能如健康检查、友好的查询接口，它在支持这些功能的时候，显然需要增加一些逻辑，甚至弃用现有的数据结构；最后，Paxos协议本身就限制了Zookeeper集群的规模，3、5个节点是不能应对大规模的服务订阅和查询的。</p>
</li>
<li><p>易用性</p>
<p>易用性也是用户比较关注的一块内容。产品虽然可以在功能特性或者性能上做到非常先进，但是如果用户的使用成本极高，也会让用户望而却步。易用性包括多方面的工作，例如API和客户端的接入是否简单，文档是否齐全易懂，控制台界面是否完善等。对于开源产品来说，还有一块是社区是否活跃。在比较Nacos、Eureka和Zookeeper在易用性上的表现时，我们诚邀社区的用户进行全方位的反馈，因为毕竟在阿里巴巴集团内部，我们对Eureka、Zookeeper的使用场景是有限的。从我们使用的经验和调研来看，Zookeeper的易用性是比较差的，Zookeeper的客户端使用比较复杂，没有针对服务发现的模型设计以及相应的API封装，需要依赖方自己处理。对多语言的支持也不太好，同时没有比较好用的控制台进行运维管理。</p>
</li>
<li><p>集群扩展性</p>
<p>集群扩展性和集群容量以及读写性能关系紧密。当使用一个比较小的集群规模就可以支撑远高于现有数量的服务注册及访问时，集群的扩展能力暂时就不会那么重要。从协议的层面上来说，Zookeeper使用的ZAB协议，由于是单点写，在集群扩展性上不具备优势。Eureka在协议上来说理论上可以扩展到很大规模，因为都是点对点的数据同步，但是从我们对Eureka的运维经验来看，Eureka集群在扩容之后，性能上有很大问题。</p>
</li>
</ul>
<p><strong>几大服务注册中心的对比：</strong></p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94.png" alt="注册中心对比"></p>
<h3 id="4-2-SpringCloud微服务核心组件Eureka"><a href="#4-2-SpringCloud微服务核心组件Eureka" class="headerlink" title="4.2-SpringCloud微服务核心组件Eureka"></a>4.2-SpringCloud微服务核心组件Eureka</h3><p>Eureka是Netflix开源的服务发现组件，本身是一个基于REST的服务，包含Server和Client两部分，并且服务端与客户端均采用java编写，所以Eureka主要适用于通过java实现的分布式系统，或是JVM兼容语言构建的系统，Spring Cloud将它集成在子项目Spring Cloud Netflix中。在微服务系统中，我们需要单独创建一个Eureka Server作为注册中心，其他的微服务就相当于客户端，注册到我们的注册中心中。</p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/Eureka.png" alt="Eureka"></p>
<pre class=" language-properties"><code class="language-properties">Register(服务注册)：把自己的IP和端口注册给Eureka。
Renew(服务续约)：发送心跳包，每30秒发送一次。告诉Eureka自己还活着。
Cancel(服务下线)：当provider关闭时会向Eureka发送消息，把自己从服务列表中删除。防止consumer调用到不存在的服务。
<span class="token attr-name">Get</span> <span class="token attr-value">Registry(获取服务注册列表)：获取其他服务列表。</span>
Replicate(集群中数据同步)：eureka集群中的数据复制与同步。
<span class="token attr-name">Make</span> <span class="token attr-value">Remote Call(远程调用)：完成服务的远程调用。</span></code></pre>
<p><strong>流程：</strong></p>
<p>各个微服务启动时，会通过 Eureka Client 向 Eureka Server 注册自己，Eureka Server 会存储该服务的信息</p>
<p>也就是说，每个微服务的客户端和服务端，都会注册到 Eureka Server，这就衍生出了微服务相互识别的话题</p>
<ul>
<li><p>同步：每个 Eureka Server 同时也是 Eureka Client（逻辑上的）<br>　　　多个 Eureka Server 之间通过复制的方式完成服务注册表的同步，形成 Eureka 的高可用</p>
</li>
<li><p>识别：Eureka Client 会缓存 Eureka Server 中的信息<br>　　　即使所有 Eureka Server 节点都宕掉，服务消费者仍可使用缓存中的信息找到服务提供者<strong>（笔者已亲测）</strong></p>
</li>
<li><p>续约：微服务会周期性（默认30s）地向 Eureka Server 发送心跳以Renew（续约）信息（类似于heartbeat）</p>
</li>
<li><p>续期：Eureka Server 会定期（默认60s）执行一次失效服务检测功能<br>　　　它会检查超过一定时间（默认90s）没有Renew的微服务，发现则会注销该微服务节点</p>
</li>
<li><p><strong>Eureka服务端</strong></p>
<p>提供服务注册和发现的能力（通常就是微服务中的注册中心），各个节点启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在前端界面中直观的看到。</p>
<p>即服务注册中心。它同其他服务注册中心一样，支持高可用配置。依托于强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景。</p>
<p>Eureka服务端支持集群模式部署，当集群中有分片发生故障的时候，Eureka会自动转入自我保护模式。它允许在分片发生故障的时候继续提供服务的发现和注册，当故障分配恢复时，集群中的其他分片会把他们的状态再次同步回来。集群中的的不同服务注册中心通过异步模式互相复制各自的状态，这也意味着在给定的时间点每个实例关于所有服务的状态可能存在不一致的现象。</p>
</li>
<li><p><strong>Eureka客户端</strong></p>
<p>一个Java客户端，用于简化与 Eureka Server 的交互，<strong>客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后</strong>，将会向Eureka Server发送心跳,<strong>默认周期为30秒</strong>，如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个<strong>服务节点移除(默认90秒)</strong>。。</p>
<p>Eureka客户端，主要处理服务的注册和发现。客户端服务通过注册和参数配置的方式，嵌入在客户端应用程序的代码中。在应用程序启动时，Eureka客户端向服务注册中心注册自身提供的服务，并周期性的发送心跳来更新它的服务租约。同时，他也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期行的刷新服务状态。</p>
</li>
<li><p><strong>心跳检测</strong></p>
<p>在应用启动后，客户端将会向Eureka Server发送心跳（默认为30秒，我们项目配置的是30秒）。Eureka Serber如果在多个心跳周期内没有收到某个微服务节点的心跳，将会剔除该节点（默认90秒，我们项目配置的是90秒）。</p>
</li>
<li><p><strong>集群数据同步</strong></p>
<p>Eureka Server之间通过复制的方式来进行数据同步。</p>
</li>
<li><p><strong>客户端缓存功能</strong></p>
<p>Eureka Client具有缓存功能，即使所有的Eureka Server都挂掉，客户端依然可以利用缓存中的信息消费其他服务的API。</p>
</li>
<li><p><strong>清理失效节点</strong></p>
</li>
<li><p><strong>自我保护模式</strong></p>
<p>自我保护模式是指在网络出现异常的情况下，由于Eureka Server无法收到客户端的心跳续约，Eureka Server会判断该节点不可用，但其实该节点可能是正常的，可用的。为了避免误删，Eureka Server引入了自我保护模式。一旦Eureka Server发现当前收到的心跳总次数小于心跳阈值的85%（默认值），就会进入自我保护模式，此时Eureka Server不会清理任何节点。直到Eureka Server收到的心跳总次数大于等于心跳阈值的85%。</p>
<p>自我保护模式的设计哲学是：在不确定节点是否可用的情况下，尽可能保留节点。</p>
</li>
</ul>
<p><strong>Eureka工作流程：</strong></p>
<ol>
<li>Eureka Server 启动成功，等待服务端注册。在启动过程中如果配置了集群，集群之间定时通过 Replicate 同步注册表，每个 Eureka Server 都存在独立完整的服务注册表信息</li>
<li>Eureka Client 启动时根据配置的 Eureka Server 地址去注册中心注册服务</li>
<li>Eureka Client 会每 30s 向 Eureka Server 发送一次心跳请求，证明客户端服务正常</li>
<li>当 Eureka Server 90s 内没有收到 Eureka Client 的心跳，注册中心则认为该节点失效，会注销该实例</li>
<li>单位时间内 Eureka Server 统计到有大量的 Eureka Client 没有上送心跳，则认为可能为网络异常，进入自我保护机制，不再剔除没有上送心跳的客户端</li>
<li>当 Eureka Client 心跳请求恢复正常之后，Eureka Server 自动退出自我保护模式</li>
<li>Eureka Client 定时全量或者增量从注册中心获取服务注册表，并且将获取到的信息缓存到本地</li>
<li>服务调用时，Eureka Client 会先从本地缓存找寻调取的服务。如果获取不到，先从注册中心刷新注册表，再同步到本地缓存</li>
<li>Eureka Client 获取到目标服务器信息，发起服务调用</li>
<li>Eureka Client 程序关闭时向 Eureka Server 发送取消请求，Eureka Server 将实例从注册表中删除</li>
</ol>
<h3 id="4-3-Eureka-Server搭建实战"><a href="#4-3-Eureka-Server搭建实战" class="headerlink" title="4.3-Eureka Server搭建实战"></a>4.3-Eureka Server搭建实战</h3><ol>
<li><p>创建eureka-server工程</p>
</li>
<li><p>添加依赖</p>
<p><strong>父工程添加：</strong></p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>Greenwich.SR1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">></span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
<p><strong>Eureka Server工程添加：</strong></p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
</li>
<li><p>添加配置</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8761</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> eureka<span class="token punctuation">-</span>server
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">instance</span><span class="token punctuation">:</span>
    <span class="token key atrule">hostname</span><span class="token punctuation">:</span> 127.0.0.1
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//$<span class="token punctuation">{</span>eureka.instance.hostname<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">:</span>$<span class="token punctuation">{</span>server.port<span class="token punctuation">}</span>/eureka/
    <span class="token comment" spellcheck="true">#声明自己是个服务端</span>
    <span class="token key atrule">register-with-eureka</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
    <span class="token key atrule">fetch-registry</span><span class="token punctuation">:</span> <span class="token boolean important">false</span></code></pre>
</li>
<li><p>启动类配置：<br>启动Eureka Server注册中心，和普通的SpringBoot应用的启动没有太大的区别。只需要在启动类上增加<code>@EnableEurekaServe</code>r注解，来开启Eureka Server服务即可。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@EnableEurekaServer</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaServerApplication</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>SpringcloudEurekaServerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
</li>
<li><p>访问注册中心</p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E8%AE%BF%E9%97%AE%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt="访问注册中心"></p>
</li>
</ol>
<h3 id="4-4-Eureka-Client搭建商品服务实战"><a href="#4-4-Eureka-Client搭建商品服务实战" class="headerlink" title="4.4-Eureka Client搭建商品服务实战"></a>4.4-Eureka Client搭建商品服务实战</h3><ol>
<li><p>创建实体类</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@NoArgsConstructor</span>
<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//商品名称</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//商品价格</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> price<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">//库存</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> store<span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
</li>
<li><p>创建Service</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProductService</span> <span class="token punctuation">{</span>

    List<span class="token operator">&lt;</span>Product<span class="token operator">></span> <span class="token function">getProducts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    Product <span class="token function">findById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">ProductService</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Product<span class="token operator">></span> daoMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        Product p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"iphonex"</span><span class="token punctuation">,</span><span class="token number">9999</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Product p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"冰箱"</span><span class="token punctuation">,</span><span class="token number">5342</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Product p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"洗衣机"</span><span class="token punctuation">,</span><span class="token number">523</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Product p4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">"电话"</span><span class="token punctuation">,</span><span class="token number">64345</span><span class="token punctuation">,</span> <span class="token number">150</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Product p5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">"汽车"</span><span class="token punctuation">,</span><span class="token number">2345</span><span class="token punctuation">,</span> <span class="token number">140</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Product p6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token string">"椅子"</span><span class="token punctuation">,</span><span class="token number">253</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Product p7 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">"java编程思想"</span><span class="token punctuation">,</span><span class="token number">2341</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p3<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p4<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p4<span class="token punctuation">)</span><span class="token punctuation">;</span>
        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p5<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p5<span class="token punctuation">)</span><span class="token punctuation">;</span>
        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p6<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p6<span class="token punctuation">)</span><span class="token punctuation">;</span>
        daoMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>p7<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p7<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Product<span class="token operator">></span> <span class="token function">getProducts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Collection<span class="token operator">&lt;</span>Product<span class="token operator">></span> collection <span class="token operator">=</span> daoMap<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token operator">&lt;</span>Product<span class="token operator">></span> productList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> productList<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Product <span class="token function">findById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> daoMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</li>
<li><p>Controller</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/api/v1/product"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> ProductService productService<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * 获取所有商品列表
     * @return
     */</span>
    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"list"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> Object <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> productService<span class="token punctuation">.</span><span class="token function">getProducts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 根据id查找商品详情
     * @param id
     * @return
     */</span>
    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"find"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> Object <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> productService<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
</li>
<li><p>启动类</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token comment" spellcheck="true">//By having spring-cloud-starter-netflix-eureka-client on the classpath, your application automatically registers with the Eureka Server. Configuration is required to locate the Eureka server, as shown in the following example:</span>
<span class="token annotation punctuation">@EnableEurekaClient</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductServiceApplication</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>ProductServiceApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
</li>
<li><p>配置文件</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8081</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> product<span class="token punctuation">-</span>service
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>8761/eureka
  <span class="token key atrule">instance</span><span class="token punctuation">:</span>
    <span class="token key atrule">prefer-ip-address</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true"># 当其它服务获取地址时提供ip而不是hostname</span>
    <span class="token key atrule">ip-address</span><span class="token punctuation">:</span> 127.0.0.1 <span class="token comment" spellcheck="true"># 指定自己的ip信息，不指定的话会自己寻找</span></code></pre>
</li>
<li><p>访问注册中心可以看到我们的商品服务</p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E6%B3%A8%E5%86%8C%E5%95%86%E5%93%81%E6%9C%8D%E5%8A%A1.png" alt="注册商品服务"></p>
<p>eureka管理后台出现一串红色字体：是警告，说明有服务上线率低</p>
<pre><code>EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&#39;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE.</code></pre><p>关闭检查方法：eureka服务端配置文件加入</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
    <span class="token key atrule">enable-self-preservation</span><span class="token punctuation">:</span> <span class="token boolean important">false</span></code></pre>
<p>注意：自我保护模式禁止关闭，默认是开启状态true</p>
</li>
</ol>
<h2 id="5-服务消费者Ribbon和Feign"><a href="#5-服务消费者Ribbon和Feign" class="headerlink" title="5-服务消费者Ribbon和Feign"></a>5-服务消费者Ribbon和Feign</h2><h3 id="5-1-常用的服务间调用方式"><a href="#5-1-常用的服务间调用方式" class="headerlink" title="5.1-常用的服务间调用方式"></a>5.1-常用的服务间调用方式</h3><ul>
<li><p><strong>RPC</strong></p>
<p>RPC 即远程过程调用（Remote Procedure Call Protocol，简称RPC），像调用本地服务(方法)一样调用服务器的服务(方法)。通常的实现有 XML-RPC , JSON-RPC , 通信方式基本相同, 所不同的只是传输数据的格式.</p>
<p>客户端和服务器之间建立TCP连接（长连接），可以一次建立一个，也可以多个调用复用一次链接。</p>
<p>RPC是分布式架构的核心，按响应方式分如下两种：</p>
<p>同步调用：客户端调用服务方方法，等待直到服务方返回结果或者超时，再继续自己的操作</p>
<p>异步调用：客户端把消息发送给中间件，不再等待服务端返回，直接继续自己的操作。</p>
<p>同步调用的实现方式有WebService和RMI。Web Service提供的服务是基于web容器的，底层使用http协议，因而适合不同语言异构系统间的调用。RMI实际上是Java语言的RPC实现，允许方法返回 Java 对象以及基本数据类型，适合用于JAVA语言构建的不同系统间的调用。</p>
<p>异步调用的JAVA实现版就是JMS(Java Message Service)，目前开源的的JMS中间件有Apache社区的ActiveMQ、Kafka消息中间件，另外有阿里的RocketMQ。</p>
<p><strong>RPC架构里包含如下4个组件:</strong></p>
<ol>
<li>客户端(Client)：服务调用方</li>
<li>客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数打包成网络消息，再通过网络发送给服务方</li>
<li>服务端存根(Server Stub)：接受客户端发送过来的消息并解包，再调用本地服务</li>
<li>服务端(Server)：真正的服务提供者。 </li>
</ol>
</li>
</ul>
<p>  RPC主要是用在大型企业里面，因为大型企业里面系统繁多，业务线复杂，而且效率优势非常重要的一块，这个时候RPC的优势就比较明显了。实际的开发当中是这么做的，项目一般使用maven来管理。比如我们有一个处理订单的系统服务，先声明它的所有的接口（这里就是具体指Java中的<code>interface</code>），然后将整个项目打包为一个<code>jar</code>包，服务端这边引入这个二方库，然后实现相应的功能，客户端这边也只需要引入这个二方库即可调用了。为什么这么做？主要是为了减少客户端这边的<code>jar</code>包大小，RPC数据包较小，因为每一次打包发布的时候，<code>jar</code>包太多总是会影响效率。另外也是将客户端和服务端解耦，提高代码的可移植性。</p>
<p>  <strong>同步调用与异步调用</strong>:</p>
<ol>
<li>同步调用就是客户端等待调用执行完成并返回结果。</li>
<li>异步调用就是客户端不等待调用执行完成返回结果，不过依然可以通过回调函数等接收到返回结果的通知。如果客户端并不关心结果，则可以变成一个单向的调用。这个过程有点类似于Java中的callable和runnable接口，我们进行异步执行的时候，如果需要知道执行的结果，就可以使用callable接口，并且可以通过Future类获取到异步执行的结果信息。如果不关心执行的结果，直接使用runnable接口就可以了，因为它不返回结果，当然callable也是可以的，我们不去获取Future就可以了。</li>
</ol>
<p>  <strong>流行的RPC框架</strong>：<br>  目前流行的开源RPC框架还是比较多的。下面重点介绍三种：</p>
<ul>
<li>gRPC是Google的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言。 我们知道HTTP2.0是基于二进制的HTTP协议升级版本，目前各大浏览器都在快马加鞭的加以支持。 这个RPC框架是基于HTTP协议实现的，底层使用到了Netty框架的支持。</li>
<li>Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的IDL定义文件自动生成服务代码框架。用户只要在其之前进行二次开发就行，对于底层的RPC通讯等都是透明的。不过这个对于用户来说的话需要学习特定领域语言这个特性，还是有一定成本的。</li>
<li>Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。同样 的远程接口是基于Java Interface，并且依托于spring框架方便开发。可以方便的打包成单一文件，独立进程运行，和现在的微服务概念一致。</li>
</ul>
<p>  <strong>RPC框架要做到的最基本的三件事：</strong></p>
<p>  1、服务端如何确定客户端要调用的函数；</p>
<p>  在远程调用中，客户端和服务端分别维护一个【ID-&gt;函数】的对应表， ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，附上这个ID，服务端通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p>
<p>  2、如何进行序列化和反序列化；</p>
<p>  客户端和服务端交互时将参数或结果转化为字节流在网络中传输，那么数据转化为字节流的或者将字节流转换成能读取的固定格式时就需要进行序列化和反序列化，序列化和反序列化的速度也会影响远程调用的效率。</p>
<p>  3、如何进行网络传输（选择何种网络协议）；</p>
<p>  多数RPC框架选择TCP作为传输协议，也有部分选择HTTP。如gRPC使用HTTP2。不同的协议各有利弊。TCP更加高效，而HTTP在实际应用中更加的灵活。</p>
<ul>
<li><p><strong>REST</strong></p>
<p>REST即表述性状态传递（Representational State Transfer，简称REST），是一种软件架构风格。REST通过HTTP协议定义的通用动词方法(GET、PUT、DELETE、POST) ，以URI对网络资源进行唯一标识，响应端根据请求端的不同需求，通过无状态通信，对其请求的资源进行表述。</p>
<p><strong>Rest架构的主要原则：</strong></p>
<ol>
<li><p>网络上的所有事物都被抽象为资源</p>
</li>
<li><p>每个资源都有一个唯一的资源标识符</p>
</li>
<li><p>同一个资源具有多种表现形式(xml,json等)</p>
</li>
<li><p>对资源的各种操作不会改变资源标识符</p>
</li>
<li><p>所有的操作都是无状态的</p>
</li>
</ol>
<p>其中表述性状态，是指(在某个瞬间状态的)资源数据的快照，包括资源数据的内容、表述格式(XML、JSON)等信息。</p>
<p>其中无状态通信，是指服务端(响应端)不保存任何与特定HTTP请求相关的资源，应用状态必须由请求方在请求过程中提供。要求在网络通信过程中，任意一个Web请求必须与其他请求隔离，当请求端提出请求时，请求本身包含了响应端为响应这一请求所需的全部信息。</p>
<p>REST使用HTTP+URI+XML /JSON 的技术来实现其API要求的架构风格：HTTP协议和URI用于统一接口和定位资源，文本、二进制流、XML、JSON等格式用来作为资源的表述。</p>
<p><code>满足REST约束条件和原则的架构，就被称为是RESTful架构。就像URL都是URI(统一资源标识)的表现形式一样，RESTful是符合REST原则的表现形式。</code></p>
</li>
<li><p><strong>RPC和REST比较</strong></p>
<ol>
<li><p>RPC优缺点</p>
<ul>
<li><p>原理：socket+动态代理</p>
</li>
<li><p>优点：</p>
<ol>
<li><p>调用简单，清晰，透明，不用像 rest 一样复杂，就像调用本地方法一样简单</p>
</li>
<li><p>高效低延迟，性能高</p>
</li>
<li><p>自定义协议（让传输报文提及更小），数据包较小</p>
</li>
<li><p>性能消耗低，高效的序列化协议可以支持高效的二进制传输</p>
</li>
<li><p>自带负载均衡</p>
</li>
</ol>
</li>
<li><p>缺点：</p>
<ol>
<li><p>耦合性强</p>
<p>他人总结：</p>
<pre><code>我们为每个微服务定义了各自的 service 抽象接口，并通过持续集成发布到私有仓库中，调用方应用对微服务提供的抽象接口存在强依赖关系，因此不论开发、测试、集成环境都需要严格的管理版本依赖，才不会出现服务方与调用方的不一致导致应用无法编译成功等一系列问题，以及这也会直接影响本地开发的环境要求，往往一个依赖很多服务的上层应用，每天都要更新很多代码并 install 之后才能进行后续的开发。若没有严格的版本管理制度或开发一些自动化工具，这样的依赖关系会成为开发团队的一大噩梦。
而 REST 接口相比 RPC 更为轻量化，服务提供方和调用方的依赖只是依靠一纸契约，不存在代码级别的强依赖，当然 REST 接口也有痛点，因为接口定义过轻，很容易导致定义文档与实际实现不一致导致服务集成时的问题，但是该问题很好解决，只需要通过每个服务整合swagger，让每个服务的代码与文档一体化，就能解决。所以在分布式环境下，REST 方式的服务依赖要比 RPC 方式的依赖更为灵活。</code></pre></li>
<li><p>无法跨语言，平台敏感</p>
<p>Java 写的 RPC 微服务无法给 Python 调用，需要再实现一层 REST 来对外提供服务。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>REST</p>
<ul>
<li>原理：HTTP调用</li>
<li>优点：<ol>
<li>耦合性低，兼容性好，提高开发效率</li>
<li>不用关心接口实现细节，相对更规范，更标准，更通用，跨语言支持</li>
</ol>
</li>
<li>缺点：<ol>
<li>性能不如 RPC 高</li>
<li>HTTP数据包较大</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>应用场景选择</strong></p>
<p>RPC 适用于内网服务调用，对外提供服务请走 REST。</p>
<p>IO 密集的服务调用用 RPC，低频服务用 REST。</p>
<p>服务调用过于密集与复杂，RPC 就比较适用。</p>
<p><strong>REST和RPC都常用于微服务架构中。</strong></p>
<ol>
<li>HTTP相对更规范，更标准，更通用，无论哪种语言都支持http协议。如果你是对外开放API，例如开放平台，外部的编程语言多种多样，你无法拒绝对每种语言的支持，现在开源中间件，基本最先支持的几个协议都包含RESTful。</li>
<li>RPC 框架作为架构微服务化的基础组件，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节。让调用方感觉就像调用本地函数一样调用远端函数、让服务提供方感觉就像实现一个本地函数一样来实现服务。</li>
</ol>
</li>
</ul>
<h3 id="5-2-Ribbon"><a href="#5-2-Ribbon" class="headerlink" title="5.2-Ribbon"></a>5.2-Ribbon</h3><ol>
<li><p>什么是负载均衡？</p>
<p>负载均衡是微服务架构中必须使用的技术，通过负载均衡来实现系统的高可用、集群扩容等功能。负载均衡可通过硬件设备及软件来实现，硬件比如：F5、Array等，软件比如：LVS、Nginx等。</p>
<p><img src="/2020/01/17/springcloud-xue-xi-bi-ji-yi/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="微服务负载均衡"></p>
<p>用户请求先到达负载均衡器（也相当于一个服务），负载均衡器根据负载均衡算法将请求转发到微服务。负载均衡算法有：轮训、随机、加权轮训、加权随机、地址哈希等方法，负载均衡器维护一份服务列表，根据负载均衡算法将请求转发到相应的微服务上，所以负载均衡可以为微服务集群分担请求，降低系统的压力。</p>
</li>
<li><p>什么是客户端负载均衡？</p>
<p>上图是服务端负载均衡，客户端负载均衡与服务端负载均衡的区别在于客户端要维护一份服务列表，Ribbon从Eureka Server获取服务列表，Ribbon根据负载均衡算法直接请求到具体的微服务，然后进行访问，这是客户端负载均衡。</p>
<p>当我们将Ribbon和Eureka一起使用时，Ribbon会从Eureka注册中心去获取服务端列表，然后进行轮询访问以到达负载均衡的作用，客户端负载均衡中也需要心跳机制去维护服务端清单的有效性，当然这个过程需要配合服务注册中心一起完成。</p>
</li>
<li><p>什么是服务端负载均衡？</p>
<p>负载均衡是我们处理高并发、缓解网络压力和进行服务端扩容的重要手段之一，但是一般情况下我们所说的负载均衡通常都是指服务端负载均衡，服务端负载均衡又分为两种，一种是硬件负载均衡，还有一种是软件负载均衡。</p>
<ul>
<li><p>硬件负载均衡主要通过在服务器节点之间安装专门用于负载均衡的设备，常见的如F5。</p>
</li>
<li><p>软件负载均衡则主要是在服务器上安装一些具有负载均衡功能的软件来完成请求分发进而实现负载均衡，常见的就是Nginx。</p>
<p>无论是硬件负载均衡还是软件负载均衡都会维护一个可用的服务端清单，然后通过心跳机制来删除故障的服务端节点以保证清单中都是可以正常访问的服务端节点，此时当客户端的请求到达负载均衡服务器时，负载均衡服务器按照某种配置好的规则从可用服务端清单中选出一台服务器去处理客户端的请求。这就是服务端负载均衡。</p>
</li>
</ul>
</li>
<li><p>Ribbon是什么？</p>
<p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将Netflix的中间层服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出Load Balancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。</p>
<p>Load Balance负载均衡是用于解决一台机器(一个进程)无法解决所有请求而产生的一种算法。像nginx可以使用负载均衡分配流量，ribbon为客户端提供负载均衡，dubbo服务调用里的负载均衡等等，很多地方都使用到了负载均衡。</p>
<p><strong>使用负载均衡带来的好处很明显(系统高可用、网络压力缓解、处理能力扩容)：</strong></p>
<p>当集群里的1台或者多台服务器down的时候，剩余的没有down的服务器可以保证服务的继续使用<br>使用了更多的机器保证了机器的良性使用，不会由于某一高峰时刻导致系统cpu急剧上升<br><strong>负载均衡有好几种实现策略，常见的有：</strong></p>
<ul>
<li>随机 (Random)</li>
<li>轮询 (RoundRobin)</li>
<li>一致性哈希 (ConsistentHash)</li>
<li>哈希 (Hash)</li>
<li>加权（Weighted）(默认会启动一个每隔30秒的定时任务来为每个服务实例计算权重.)</li>
</ul>
<p>服务发现的任务由Eureka完成，而服务消费的任务由Ribbon完成,它是一个基于Http和TCP的客户端负载均衡器，可以通过在客户端中配置的ribbonServerList服务端列表去轮询访问以达到均衡负载的作用(对于服务提供方，同一服务的实例通常会有多个来保证服务的高可用性).</p>
</li>
<li><p>Ribbon实战</p>
<ol>
<li><p>添加依赖</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-ribbon<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre>
</li>
<li><p>在application.yml中添加配置</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
  <span class="token key atrule">MaxAutoRetries</span><span class="token punctuation">:</span> <span class="token number">2 </span><span class="token comment" spellcheck="true">#最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试</span>
  <span class="token key atrule">MaxAutoRetriesNextServer</span><span class="token punctuation">:</span> <span class="token number">3 </span><span class="token comment" spellcheck="true">#切换实例的重试次数</span>
  <span class="token key atrule">OkToRetryOnAllOperations</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true">#对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false</span>
  <span class="token key atrule">ConnectTimeout</span><span class="token punctuation">:</span> <span class="token number">5000  </span><span class="token comment" spellcheck="true">#请求连接的超时时间</span>
  <span class="token key atrule">ReadTimeout</span><span class="token punctuation">:</span> <span class="token number">6000 </span><span class="token comment" spellcheck="true">#请求处理的超时时间</span></code></pre>
</li>
<li><p>在订单服务启动类中添加如下代码：</p>
<pre class=" language-java"><code class="language-java">        <span class="token annotation punctuation">@Bean</span>
    <span class="token annotation punctuation">@LoadBalanced</span>
    <span class="token keyword">public</span> RestTemplate <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
</li>
<li><p>修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用：</p>
<pre class=" language-java"><code class="language-java">        <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> ProductOrder <span class="token function">save</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">,</span> <span class="token keyword">int</span> productId<span class="token punctuation">)</span> <span class="token punctuation">{</span>

        Object obj <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span><span class="token string">"http://product-service/api/v1/product/find?id="</span><span class="token operator">+</span>productId<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

        ProductOrder productOrder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProductOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        productOrder<span class="token punctuation">.</span><span class="token function">setCreateTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        productOrder<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        productOrder<span class="token punctuation">.</span><span class="token function">setTradeNo</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> productOrder<span class="token punctuation">;</span>
    <span class="token punctuation">}</span></code></pre>
<p>控制台输出如下：</p>
<pre><code>2020-01-18 22:32:24.792  INFO 28215 --- [nio-8081-exec-1] c.n.l.DynamicServerListLoadBalancer      : DynamicServerListLoadBalancer for client product-service initialized: DynamicServerListLoadBalancer:{NFLoadBalancer:name=product-service,current list of Servers=[127.0.0.1:8082],Load balancer stats=Zone stats: {defaultzone=[Zone:defaultzone;    Instance count:1;    Active connections count: 0;    Circuit breaker tripped count: 0;    Active connections per server: 0.0;]
},Server stats: [[Server:127.0.0.1:8082;    Zone:defaultZone;    Total Requests:0;    Successive connection failure:0;    Total blackout seconds:0;    Last connection made:Thu Jan 01 08:00:00 CST 1970;    First connection made: Thu Jan 01 08:00:00 CST 1970;    Active Connections:0;    total failure count in last (1000) msecs:0;    average resp time:0.0;    90 percentile resp time:0.0;    95 percentile resp time:0.0;    min resp time:0.0;    max resp time:0.0;    stddev resp time:0.0]
]}ServerList:org.springframework.cloud.netflix.ribbon.eureka.DomainExtractingServerList@56d1dd2a
{id=6, name=椅子, price=253, store=20}</code></pre><p><code>将商品服务多节点启动，会看到订单服务会通过Ribbon的负载均衡来调用商品服务。</code></p>
</li>
</ol>
</li>
<li><p>Ribbon修改负载均衡策略</p>
<p>在application.yml配置文件中加入：</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#自定义负载均衡策略</span>
    <span class="token key atrule">product-service</span><span class="token punctuation">:</span>
      <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
        <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule</code></pre>
<p><strong>策略选择：</strong></p>
<ol>
<li>如果每个机器配置一样，则建议不修改策略 (推荐)</li>
<li>如果部分机器配置强，则可以改为 WeightedResponseTimeRule</li>
</ol>
</li>
</ol>
<h3 id="5-3-微服务调用方式之Feign"><a href="#5-3-微服务调用方式之Feign" class="headerlink" title="5.3-微服务调用方式之Feign"></a>5.3-微服务调用方式之Feign</h3><ol>
<li><p>Feign是什么？</p>
<p><strong>Feign是Netflix开发的声明式、模板化的HTTP客户端， Feign可以帮助我们更快捷、优雅地调用HTTP API。</strong></p>
<p>Feign是一个声明式WebService客户端，使用Feign能让编写WebService客户端更加简单，它的使用方法是定义一个接口，然后在上面添加注解,同时也支持JAX-RS标准的注解。Feign也支持可拔插式的编码器和解码器，Spring Cloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters.Feign可以与Eureka和Ribbon组合使用以支持负载均衡。</p>
<p><strong>只需要你创建一个接口，然后在上面添加注解即可。</strong></p>
<p>Feign 是一种声明式、模板化的 HTTP 客户端。在 Spring Cloud 中使用 Feign，可以做到使用 HTTP 请求访问远程服务，就像调用本地方法一样的，开发者完全感知不到这是在调用远程方法，更感知不到在访问 HTTP 请求。接下来介绍一下 Feign 的特性，具体如下：</p>
<ul>
<li>可插拔的注解支持，包括 Feign 注解和AX-RS注解。</li>
<li>支持可插拔的 HTTP 编码器和解码器。</li>
<li>支持 Hystrix 和它的 Fallback。</li>
<li>支持 Ribbon 的负载均衡。</li>
<li>支持 HTTP 请求和响应的压缩。Feign 是一个声明式的 WebService 客户端，它的目的就是让 Web Service 调用更加简单。它整合了 Ribbon 和 Hystrix，从而不需要开发者针对 Feign 对其进行整合。Feign 还提供了 HTTP 请求的模板，通过编写简单的接口和注解，就可以定义好 HTTP 请求的参数、格式、地址等信息。Feign 会完全代理 HTTP 的请求，在使用过程中我们只需要依赖注入 Bean，然后调用对应的方法传递参数即可。</li>
</ul>
</li>
<li><p>Feign能干什么？</p>
<p>Feign旨在使编写Java Htpp客户端变得更容易。</p>
<p>使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理,形成了一套模板化的调用方法.但是在实际开发中,由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用,所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用.所以，Feign在此基础上做了进一步封装,由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它(以前是Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可),即可完成对服务提供方的接口绑定，简化了使用Spring cloud Ribbon时，自动封装服务调用客户端的开发量。</p>
</li>
<li><p>添加Feign依赖</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
# 注意：新旧版本依赖名称不同</code></pre>
</li>
<li><p>添加配置</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#feign的配置，连接超时及读取超时配置</span>
<span class="token key atrule">feign</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">config</span><span class="token punctuation">:</span>
      <span class="token key atrule">default</span><span class="token punctuation">:</span>
        <span class="token key atrule">connectTimeout</span><span class="token punctuation">:</span> <span class="token number">5000</span>
        <span class="token key atrule">readTimeout</span><span class="token punctuation">:</span> <span class="token number">5000</span>
        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> basic</code></pre>
</li>
<li><p>启动类增加注解<code>@EnableFeignClients</code>（开启 Feign 扫描支持）</p>
</li>
<li><p>Feign接口编写</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"product-service"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ProductFeignClient</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"api/v1//product/find"</span><span class="token punctuation">)</span>
    String <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span></code></pre>
</li>
<li><p>Controller</p>
<pre class=" language-java"><code class="language-java">RestController
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProductController</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> ProductFeignClient productFeignClient<span class="token punctuation">;</span>

   <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span>"api<span class="token operator">/</span>v1<span class="token comment" spellcheck="true">//product)</span>
    String <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> productFeignClient<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span></code></pre>
</li>
<li><p>Feign工作原理</p>
<ul>
<li>在开发微服务应用时，我们会在主程序入口添加 @EnableFeignClients 注解开启对 Feign Client 扫描加载处理。根据 Feign Client 的开发规范，定义接口并加 @FeignClients 注解。</li>
<li>当程序启动时，会进行包扫描，扫描所有 @FeignClients 的注解的类，并将这些信息注入 Spring IOC 容器中。当定义的 Feign 接口中的方法被调用时，通过JDK的代理的方式，来生成具体的 RequestTemplate。当生成代理时，Feign 会为每个接口方法创建一个 RequetTemplate 对象，该对象封装了 HTTP 请求需要的全部信息，如请求参数名、请求方法等信息都是在这个过程中确定的。</li>
<li>然后由 RequestTemplate 生成 Request，然后把 Request 交给 Client 去处理，这里指的 Client 可以是 JDK 原生的 URLConnection、Apache 的 Http Client 也可以是 Okhttp。最后 Client 被封装到 LoadBalanceclient 类，这个类结合 Ribbon 负载均衡发起服务之间的调用。</li>
</ul>
</li>
<li><p>@FeignClient 注解</p>
<ul>
<li>name：指定 Feign Client 的名称，如果项目使用了 Ribbon，name 属性会作为微服务的名称，用于服务发现。</li>
<li>url：url 一般用于调试，可以手动指定 @FeignClient 调用的地址。</li>
<li>decode404：当发生404错误时，如果该字段为 true，会调用 decoder 进行解码，否则抛出 FeignException。</li>
<li>configuration：Feign 配置类，可以自定义 Feign 的 Encoder、Decoder、LogLevel、Contract。</li>
<li>fallback：定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback 指定的类必须实现 @FeignClient 标记的接口。</li>
<li>fallbackFactory：工厂类，用于生成 fallback 类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码。</li>
<li>path：定义当前 FeignClient 的统一前缀。</li>
</ul>
</li>
<li><p>超市时间配置</p>
<p>如果在一个微服务当中对同一个接口同时配置了Hystrix与ribbon两个超时时间，则在接口调用的时候，两个计时器会同时读秒。</p>
<p>比如，访问一个接口需要2秒，你的ribbon配置的超时时间是3秒，Hystrix配置的超时时间是1秒。</p>
<p>在这种情况下，程序会回调进入到Hystrix的fallback方法，因为在访问接口的时候，Hystrix与ribbon的两个计时器同时计时，而在Hystrix计时器结束的时候自动停止了访问进行回调，进入fallback方法。</p>
<p><strong>如果没有配置Hystrix的话，访问一个接口需要2秒，你的ribbon配置的超时时间是3秒，Hystrix配置的超时时间是1秒，不会有异常。</strong></p>
<p>在这个地方建议配置Hystrix的超时时间要大于ribbon的超时时间，否则会在接口调用还未完成的时候直接进入回调方法。</p>
<p><strong>Hystrix与ribbon的默认请求超时时间都是1秒</strong></p>
<p>配置如下：</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">8200</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> testFeign
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>8100/eureka/
    <span class="token key atrule">register-with-eureka</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">fetch-registry</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token comment" spellcheck="true">###设置feign客户端超时时间</span>
<span class="token comment" spellcheck="true">###SpringCloud feign 默认开启支持ribbon</span>
<span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
  <span class="token comment" spellcheck="true">###指的是建立连接所用的时间，适用于网络状况正常的情况下，两端连接所用的时间。</span>
  <span class="token key atrule">ReadTimeout</span><span class="token punctuation">:</span> <span class="token number">5000</span>
  <span class="token comment" spellcheck="true">###指的是建立连接后从服务器读取到可用资源所用的时间。</span>
  <span class="token key atrule">ConnectTimeout</span><span class="token punctuation">:</span> <span class="token number">5000</span>
<span class="token comment" spellcheck="true">###配置请求超时时间</span>
<span class="token key atrule">hystrix</span><span class="token punctuation">:</span>
  <span class="token key atrule">command</span><span class="token punctuation">:</span>
    <span class="token key atrule">default</span><span class="token punctuation">:</span>
      <span class="token key atrule">execution</span><span class="token punctuation">:</span>
        <span class="token key atrule">isolation</span><span class="token punctuation">:</span>
          <span class="token key atrule">thread</span><span class="token punctuation">:</span>
            <span class="token key atrule">timeoutInMilliseconds</span><span class="token punctuation">:</span> <span class="token number">7000</span>
<span class="token comment" spellcheck="true">###配置具体方法超时时间    </span>
    <span class="token key atrule">serverMethod</span><span class="token punctuation">:</span>
      <span class="token key atrule">execution</span><span class="token punctuation">:</span>
        <span class="token key atrule">isolation</span><span class="token punctuation">:</span>
          <span class="token key atrule">thread</span><span class="token punctuation">:</span>
            <span class="token key atrule">timeoutInMilliseconds</span><span class="token punctuation">:</span> <span class="token number">3000</span>
<span class="token comment" spellcheck="true">###开启Hystrix断路器</span>
<span class="token key atrule">feign</span><span class="token punctuation">:</span>
  <span class="token key atrule">hystrix</span><span class="token punctuation">:</span>
    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre>
<p>一般情况下 都是 <code>ribbon 的超时时间（&lt;）hystrix的超时时间</code>（因为涉及到ribbon的重试机制） 因为ribbon的重试机制和Feign的重试机制有冲突，所以源码中默认关闭Feign的重试机制。</p>
</li>
<li><p><strong>Feign和Ribbon的区别：</strong></p>
<ul>
<li>启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的是@EnableFeignClients。</li>
<li>服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。</li>
<li>调用方式不同，<strong>Ribbon</strong>需要自己构建http请求，是一个基于 HTTP 和 TCP 客户端 的负载均衡的工具。它可以在客户端配置 <code>RibbonServerList</code>（服务端列表），使用 HttpClient 或 RestTemplate http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。<strong>Feign</strong>则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可，不需要自己构建http请求。然后就像是调用自身工程的方法调用，而感觉不到是调用远程方法，使得编写 客户端变得非常容易。要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。</li>
</ul>
</li>
</ol>

            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://fangpeng12.github.io" rel="external nofollow noreferrer">fangpeng</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://fangpeng12.github.io/2020/01/17/springcloud-xue-xi-bi-ji-yi/">https://fangpeng12.github.io/2020/01/17/springcloud-xue-xi-bi-ji-yi/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://fangpeng12.github.io" target="_blank">fangpeng</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E7%AC%94%E8%AE%B0/">
                                    <span class="chip bg-color">笔记</span>
                                </a>
                            
                                <a href="/tags/Spring/">
                                    <span class="chip bg-color">Spring</span>
                                </a>
                            
                                <a href="/tags/SpringBoot/">
                                    <span class="chip bg-color">SpringBoot</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/01/18/html-xue-xi-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="HTML学习笔记">
                        
                        <span class="card-title">HTML学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            HTML入门学习笔记
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-01-18
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%89%8D%E7%AB%AF/" class="post-category">
                                    前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%89%8D%E7%AB%AF/">
                        <span class="chip bg-color">前端</span>
                    </a>
                    
                    <a href="/tags/html/">
                        <span class="chip bg-color">html</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2020/01/16/wei-fu-wu-jia-gou-ji-chu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="微服务架构基础">
                        
                        <span class="card-title">微服务架构基础</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            微服务架构基础知识梳理和学习
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-01-16
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" class="post-category">
                                    微服务
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9E%B6%E6%9E%84/">
                        <span class="chip bg-color">架构</span>
                    </a>
                    
                    <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">
                        <span class="chip bg-color">微服务</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">年份</span>
            <a href="https://fangpeng12.github.io" target="_blank">fangpeng</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">113.6k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    window.setTimeout("siteTime()", 1000);
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "12";
                    var startDate = "21";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/fangpeng12" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>















    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
